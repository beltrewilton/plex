(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a2, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a2, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a2, prop, b[prop]);
      }
    return a2;
  };
  var __spreadProps = (a2, b) => __defProps(a2, __getOwnPropDescs(b));
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to2, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to2, key) && key !== except)
          __defProp(to2, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to2;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // vendor/topbar.js
  var require_topbar = __commonJS({
    "vendor/topbar.js"(exports, module) {
      (function(window2, document2) {
        "use strict";
        (function() {
          var lastTime = 0;
          var vendors = ["ms", "moz", "webkit", "o"];
          for (var x = 0; x < vendors.length && !window2.requestAnimationFrame; ++x) {
            window2.requestAnimationFrame = window2[vendors[x] + "RequestAnimationFrame"];
            window2.cancelAnimationFrame = window2[vendors[x] + "CancelAnimationFrame"] || window2[vendors[x] + "CancelRequestAnimationFrame"];
          }
          if (!window2.requestAnimationFrame)
            window2.requestAnimationFrame = function(callback2, element) {
              var currTime = (/* @__PURE__ */ new Date()).getTime();
              var timeToCall = Math.max(0, 16 - (currTime - lastTime));
              var id = window2.setTimeout(function() {
                callback2(currTime + timeToCall);
              }, timeToCall);
              lastTime = currTime + timeToCall;
              return id;
            };
          if (!window2.cancelAnimationFrame)
            window2.cancelAnimationFrame = function(id) {
              clearTimeout(id);
            };
        })();
        var canvas, currentProgress, showing, progressTimerId = null, fadeTimerId = null, delayTimerId = null, addEvent = function(elem, type, handler) {
          if (elem.addEventListener)
            elem.addEventListener(type, handler, false);
          else if (elem.attachEvent)
            elem.attachEvent("on" + type, handler);
          else
            elem["on" + type] = handler;
        }, options = {
          autoRun: true,
          barThickness: 3,
          barColors: {
            0: "rgba(26,  188, 156, .9)",
            ".25": "rgba(52,  152, 219, .9)",
            ".50": "rgba(241, 196, 15,  .9)",
            ".75": "rgba(230, 126, 34,  .9)",
            "1.0": "rgba(211, 84,  0,   .9)"
          },
          shadowBlur: 10,
          shadowColor: "rgba(0,   0,   0,   .6)",
          className: null
        }, repaint = function() {
          canvas.width = window2.innerWidth;
          canvas.height = options.barThickness * 5;
          var ctx = canvas.getContext("2d");
          ctx.shadowBlur = options.shadowBlur;
          ctx.shadowColor = options.shadowColor;
          var lineGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
          for (var stop in options.barColors)
            lineGradient.addColorStop(stop, options.barColors[stop]);
          ctx.lineWidth = options.barThickness;
          ctx.beginPath();
          ctx.moveTo(0, options.barThickness / 2);
          ctx.lineTo(
            Math.ceil(currentProgress * canvas.width),
            options.barThickness / 2
          );
          ctx.strokeStyle = lineGradient;
          ctx.stroke();
        }, createCanvas = function() {
          canvas = document2.createElement("canvas");
          var style = canvas.style;
          style.position = "fixed";
          style.top = style.left = style.right = style.margin = style.padding = 0;
          style.zIndex = 100001;
          style.display = "none";
          if (options.className)
            canvas.classList.add(options.className);
          document2.body.appendChild(canvas);
          addEvent(window2, "resize", repaint);
        }, topbar2 = {
          config: function(opts) {
            for (var key in opts)
              if (options.hasOwnProperty(key))
                options[key] = opts[key];
          },
          show: function(delay) {
            if (showing)
              return;
            if (delay) {
              if (delayTimerId)
                return;
              delayTimerId = setTimeout(() => topbar2.show(), delay);
            } else {
              showing = true;
              if (fadeTimerId !== null)
                window2.cancelAnimationFrame(fadeTimerId);
              if (!canvas)
                createCanvas();
              canvas.style.opacity = 1;
              canvas.style.display = "block";
              topbar2.progress(0);
              if (options.autoRun) {
                (function loop() {
                  progressTimerId = window2.requestAnimationFrame(loop);
                  topbar2.progress(
                    "+" + 0.05 * Math.pow(1 - Math.sqrt(currentProgress), 2)
                  );
                })();
              }
            }
          },
          progress: function(to2) {
            if (typeof to2 === "undefined")
              return currentProgress;
            if (typeof to2 === "string") {
              to2 = (to2.indexOf("+") >= 0 || to2.indexOf("-") >= 0 ? currentProgress : 0) + parseFloat(to2);
            }
            currentProgress = to2 > 1 ? 1 : to2;
            repaint();
            return currentProgress;
          },
          hide: function() {
            clearTimeout(delayTimerId);
            delayTimerId = null;
            if (!showing)
              return;
            showing = false;
            if (progressTimerId != null) {
              window2.cancelAnimationFrame(progressTimerId);
              progressTimerId = null;
            }
            (function loop() {
              if (topbar2.progress("+.1") >= 1) {
                canvas.style.opacity -= 0.05;
                if (canvas.style.opacity <= 0.05) {
                  canvas.style.display = "none";
                  fadeTimerId = null;
                  return;
                }
              }
              fadeTimerId = window2.requestAnimationFrame(loop);
            })();
          }
        };
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = topbar2;
        } else if (typeof define === "function" && define.amd) {
          define(function() {
            return topbar2;
          });
        } else {
          this.topbar = topbar2;
        }
      }).call(exports, window, document);
    }
  });

  // ../../../deps/phoenix_html/priv/static/phoenix_html.js
  (function() {
    var PolyfillEvent = eventConstructor();
    function eventConstructor() {
      if (typeof window.CustomEvent === "function")
        return window.CustomEvent;
      function CustomEvent2(event, params) {
        params = params || { bubbles: false, cancelable: false, detail: void 0 };
        var evt = document.createEvent("CustomEvent");
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
      }
      CustomEvent2.prototype = window.Event.prototype;
      return CustomEvent2;
    }
    function buildHiddenInput(name, value) {
      var input = document.createElement("input");
      input.type = "hidden";
      input.name = name;
      input.value = value;
      return input;
    }
    function handleClick(element, targetModifierKey) {
      var to2 = element.getAttribute("data-to"), method = buildHiddenInput("_method", element.getAttribute("data-method")), csrf = buildHiddenInput("_csrf_token", element.getAttribute("data-csrf")), form = document.createElement("form"), submit = document.createElement("input"), target = element.getAttribute("target");
      form.method = element.getAttribute("data-method") === "get" ? "get" : "post";
      form.action = to2;
      form.style.display = "none";
      if (target)
        form.target = target;
      else if (targetModifierKey)
        form.target = "_blank";
      form.appendChild(csrf);
      form.appendChild(method);
      document.body.appendChild(form);
      submit.type = "submit";
      form.appendChild(submit);
      submit.click();
    }
    window.addEventListener("click", function(e2) {
      var element = e2.target;
      if (e2.defaultPrevented)
        return;
      while (element && element.getAttribute) {
        var phoenixLinkEvent = new PolyfillEvent("phoenix.link.click", {
          "bubbles": true,
          "cancelable": true
        });
        if (!element.dispatchEvent(phoenixLinkEvent)) {
          e2.preventDefault();
          e2.stopImmediatePropagation();
          return false;
        }
        if (element.getAttribute("data-method") && element.getAttribute("data-to")) {
          handleClick(element, e2.metaKey || e2.shiftKey);
          e2.preventDefault();
          return false;
        } else {
          element = element.parentNode;
        }
      }
    }, false);
    window.addEventListener("phoenix.link.click", function(e2) {
      var message = e2.target.getAttribute("data-confirm");
      if (message && !window.confirm(message)) {
        e2.preventDefault();
      }
    }, false);
  })();

  // ../../../deps/phoenix/priv/static/phoenix.mjs
  var closure = (value) => {
    if (typeof value === "function") {
      return value;
    } else {
      let closure22 = function() {
        return value;
      };
      return closure22;
    }
  };
  var globalSelf = typeof self !== "undefined" ? self : null;
  var phxWindow = typeof window !== "undefined" ? window : null;
  var global = globalSelf || phxWindow || global;
  var DEFAULT_VSN = "2.0.0";
  var SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };
  var DEFAULT_TIMEOUT = 1e4;
  var WS_CLOSE_NORMAL = 1e3;
  var CHANNEL_STATES = {
    closed: "closed",
    errored: "errored",
    joined: "joined",
    joining: "joining",
    leaving: "leaving"
  };
  var CHANNEL_EVENTS = {
    close: "phx_close",
    error: "phx_error",
    join: "phx_join",
    reply: "phx_reply",
    leave: "phx_leave"
  };
  var TRANSPORTS = {
    longpoll: "longpoll",
    websocket: "websocket"
  };
  var XHR_STATES = {
    complete: 4
  };
  var Push = class {
    constructor(channel, event, payload, timeout) {
      this.channel = channel;
      this.event = event;
      this.payload = payload || function() {
        return {};
      };
      this.receivedResp = null;
      this.timeout = timeout;
      this.timeoutTimer = null;
      this.recHooks = [];
      this.sent = false;
    }
    /**
     *
     * @param {number} timeout
     */
    resend(timeout) {
      this.timeout = timeout;
      this.reset();
      this.send();
    }
    /**
     *
     */
    send() {
      if (this.hasReceived("timeout")) {
        return;
      }
      this.startTimeout();
      this.sent = true;
      this.channel.socket.push({
        topic: this.channel.topic,
        event: this.event,
        payload: this.payload(),
        ref: this.ref,
        join_ref: this.channel.joinRef()
      });
    }
    /**
     *
     * @param {*} status
     * @param {*} callback
     */
    receive(status, callback2) {
      if (this.hasReceived(status)) {
        callback2(this.receivedResp.response);
      }
      this.recHooks.push({ status, callback: callback2 });
      return this;
    }
    /**
     * @private
     */
    reset() {
      this.cancelRefEvent();
      this.ref = null;
      this.refEvent = null;
      this.receivedResp = null;
      this.sent = false;
    }
    /**
     * @private
     */
    matchReceive({ status, response, _ref }) {
      this.recHooks.filter((h3) => h3.status === status).forEach((h3) => h3.callback(response));
    }
    /**
     * @private
     */
    cancelRefEvent() {
      if (!this.refEvent) {
        return;
      }
      this.channel.off(this.refEvent);
    }
    /**
     * @private
     */
    cancelTimeout() {
      clearTimeout(this.timeoutTimer);
      this.timeoutTimer = null;
    }
    /**
     * @private
     */
    startTimeout() {
      if (this.timeoutTimer) {
        this.cancelTimeout();
      }
      this.ref = this.channel.socket.makeRef();
      this.refEvent = this.channel.replyEventName(this.ref);
      this.channel.on(this.refEvent, (payload) => {
        this.cancelRefEvent();
        this.cancelTimeout();
        this.receivedResp = payload;
        this.matchReceive(payload);
      });
      this.timeoutTimer = setTimeout(() => {
        this.trigger("timeout", {});
      }, this.timeout);
    }
    /**
     * @private
     */
    hasReceived(status) {
      return this.receivedResp && this.receivedResp.status === status;
    }
    /**
     * @private
     */
    trigger(status, response) {
      this.channel.trigger(this.refEvent, { status, response });
    }
  };
  var Timer = class {
    constructor(callback2, timerCalc) {
      this.callback = callback2;
      this.timerCalc = timerCalc;
      this.timer = null;
      this.tries = 0;
    }
    reset() {
      this.tries = 0;
      clearTimeout(this.timer);
    }
    /**
     * Cancels any previous scheduleTimeout and schedules callback
     */
    scheduleTimeout() {
      clearTimeout(this.timer);
      this.timer = setTimeout(() => {
        this.tries = this.tries + 1;
        this.callback();
      }, this.timerCalc(this.tries + 1));
    }
  };
  var Channel = class {
    constructor(topic, params, socket) {
      this.state = CHANNEL_STATES.closed;
      this.topic = topic;
      this.params = closure(params || {});
      this.socket = socket;
      this.bindings = [];
      this.bindingRef = 0;
      this.timeout = this.socket.timeout;
      this.joinedOnce = false;
      this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
      this.pushBuffer = [];
      this.stateChangeRefs = [];
      this.rejoinTimer = new Timer(() => {
        if (this.socket.isConnected()) {
          this.rejoin();
        }
      }, this.socket.rejoinAfterMs);
      this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));
      this.stateChangeRefs.push(
        this.socket.onOpen(() => {
          this.rejoinTimer.reset();
          if (this.isErrored()) {
            this.rejoin();
          }
        })
      );
      this.joinPush.receive("ok", () => {
        this.state = CHANNEL_STATES.joined;
        this.rejoinTimer.reset();
        this.pushBuffer.forEach((pushEvent) => pushEvent.send());
        this.pushBuffer = [];
      });
      this.joinPush.receive("error", () => {
        this.state = CHANNEL_STATES.errored;
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.onClose(() => {
        this.rejoinTimer.reset();
        if (this.socket.hasLogger())
          this.socket.log("channel", `close ${this.topic} ${this.joinRef()}`);
        this.state = CHANNEL_STATES.closed;
        this.socket.remove(this);
      });
      this.onError((reason) => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `error ${this.topic}`, reason);
        if (this.isJoining()) {
          this.joinPush.reset();
        }
        this.state = CHANNEL_STATES.errored;
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.joinPush.receive("timeout", () => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);
        let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);
        leavePush.send();
        this.state = CHANNEL_STATES.errored;
        this.joinPush.reset();
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.on(CHANNEL_EVENTS.reply, (payload, ref) => {
        this.trigger(this.replyEventName(ref), payload);
      });
    }
    /**
     * Join the channel
     * @param {integer} timeout
     * @returns {Push}
     */
    join(timeout = this.timeout) {
      if (this.joinedOnce) {
        throw new Error("tried to join multiple times. 'join' can only be called a single time per channel instance");
      } else {
        this.timeout = timeout;
        this.joinedOnce = true;
        this.rejoin();
        return this.joinPush;
      }
    }
    /**
     * Hook into channel close
     * @param {Function} callback
     */
    onClose(callback2) {
      this.on(CHANNEL_EVENTS.close, callback2);
    }
    /**
     * Hook into channel errors
     * @param {Function} callback
     */
    onError(callback2) {
      return this.on(CHANNEL_EVENTS.error, (reason) => callback2(reason));
    }
    /**
     * Subscribes on channel events
     *
     * Subscription returns a ref counter, which can be used later to
     * unsubscribe the exact event listener
     *
     * @example
     * const ref1 = channel.on("event", do_stuff)
     * const ref2 = channel.on("event", do_other_stuff)
     * channel.off("event", ref1)
     * // Since unsubscription, do_stuff won't fire,
     * // while do_other_stuff will keep firing on the "event"
     *
     * @param {string} event
     * @param {Function} callback
     * @returns {integer} ref
     */
    on(event, callback2) {
      let ref = this.bindingRef++;
      this.bindings.push({ event, ref, callback: callback2 });
      return ref;
    }
    /**
     * Unsubscribes off of channel events
     *
     * Use the ref returned from a channel.on() to unsubscribe one
     * handler, or pass nothing for the ref to unsubscribe all
     * handlers for the given event.
     *
     * @example
     * // Unsubscribe the do_stuff handler
     * const ref1 = channel.on("event", do_stuff)
     * channel.off("event", ref1)
     *
     * // Unsubscribe all handlers from event
     * channel.off("event")
     *
     * @param {string} event
     * @param {integer} ref
     */
    off(event, ref) {
      this.bindings = this.bindings.filter((bind) => {
        return !(bind.event === event && (typeof ref === "undefined" || ref === bind.ref));
      });
    }
    /**
     * @private
     */
    canPush() {
      return this.socket.isConnected() && this.isJoined();
    }
    /**
     * Sends a message `event` to phoenix with the payload `payload`.
     * Phoenix receives this in the `handle_in(event, payload, socket)`
     * function. if phoenix replies or it times out (default 10000ms),
     * then optionally the reply can be received.
     *
     * @example
     * channel.push("event")
     *   .receive("ok", payload => console.log("phoenix replied:", payload))
     *   .receive("error", err => console.log("phoenix errored", err))
     *   .receive("timeout", () => console.log("timed out pushing"))
     * @param {string} event
     * @param {Object} payload
     * @param {number} [timeout]
     * @returns {Push}
     */
    push(event, payload, timeout = this.timeout) {
      payload = payload || {};
      if (!this.joinedOnce) {
        throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`);
      }
      let pushEvent = new Push(this, event, function() {
        return payload;
      }, timeout);
      if (this.canPush()) {
        pushEvent.send();
      } else {
        pushEvent.startTimeout();
        this.pushBuffer.push(pushEvent);
      }
      return pushEvent;
    }
    /** Leaves the channel
     *
     * Unsubscribes from server events, and
     * instructs channel to terminate on server
     *
     * Triggers onClose() hooks
     *
     * To receive leave acknowledgements, use the `receive`
     * hook to bind to the server ack, ie:
     *
     * @example
     * channel.leave().receive("ok", () => alert("left!") )
     *
     * @param {integer} timeout
     * @returns {Push}
     */
    leave(timeout = this.timeout) {
      this.rejoinTimer.reset();
      this.joinPush.cancelTimeout();
      this.state = CHANNEL_STATES.leaving;
      let onClose = () => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `leave ${this.topic}`);
        this.trigger(CHANNEL_EVENTS.close, "leave");
      };
      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);
      leavePush.receive("ok", () => onClose()).receive("timeout", () => onClose());
      leavePush.send();
      if (!this.canPush()) {
        leavePush.trigger("ok", {});
      }
      return leavePush;
    }
    /**
     * Overridable message hook
     *
     * Receives all events for specialized message handling
     * before dispatching to the channel callbacks.
     *
     * Must return the payload, modified or unmodified
     * @param {string} event
     * @param {Object} payload
     * @param {integer} ref
     * @returns {Object}
     */
    onMessage(_event, payload, _ref) {
      return payload;
    }
    /**
     * @private
     */
    isMember(topic, event, payload, joinRef) {
      if (this.topic !== topic) {
        return false;
      }
      if (joinRef && joinRef !== this.joinRef()) {
        if (this.socket.hasLogger())
          this.socket.log("channel", "dropping outdated message", { topic, event, payload, joinRef });
        return false;
      } else {
        return true;
      }
    }
    /**
     * @private
     */
    joinRef() {
      return this.joinPush.ref;
    }
    /**
     * @private
     */
    rejoin(timeout = this.timeout) {
      if (this.isLeaving()) {
        return;
      }
      this.socket.leaveOpenTopic(this.topic);
      this.state = CHANNEL_STATES.joining;
      this.joinPush.resend(timeout);
    }
    /**
     * @private
     */
    trigger(event, payload, ref, joinRef) {
      let handledPayload = this.onMessage(event, payload, ref, joinRef);
      if (payload && !handledPayload) {
        throw new Error("channel onMessage callbacks must return the payload, modified or unmodified");
      }
      let eventBindings = this.bindings.filter((bind) => bind.event === event);
      for (let i2 = 0; i2 < eventBindings.length; i2++) {
        let bind = eventBindings[i2];
        bind.callback(handledPayload, ref, joinRef || this.joinRef());
      }
    }
    /**
     * @private
     */
    replyEventName(ref) {
      return `chan_reply_${ref}`;
    }
    /**
     * @private
     */
    isClosed() {
      return this.state === CHANNEL_STATES.closed;
    }
    /**
     * @private
     */
    isErrored() {
      return this.state === CHANNEL_STATES.errored;
    }
    /**
     * @private
     */
    isJoined() {
      return this.state === CHANNEL_STATES.joined;
    }
    /**
     * @private
     */
    isJoining() {
      return this.state === CHANNEL_STATES.joining;
    }
    /**
     * @private
     */
    isLeaving() {
      return this.state === CHANNEL_STATES.leaving;
    }
  };
  var Ajax = class {
    static request(method, endPoint, accept, body, timeout, ontimeout, callback2) {
      if (global.XDomainRequest) {
        let req = new global.XDomainRequest();
        return this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback2);
      } else {
        let req = new global.XMLHttpRequest();
        return this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback2);
      }
    }
    static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback2) {
      req.timeout = timeout;
      req.open(method, endPoint);
      req.onload = () => {
        let response = this.parseJSON(req.responseText);
        callback2 && callback2(response);
      };
      if (ontimeout) {
        req.ontimeout = ontimeout;
      }
      req.onprogress = () => {
      };
      req.send(body);
      return req;
    }
    static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback2) {
      req.open(method, endPoint, true);
      req.timeout = timeout;
      req.setRequestHeader("Content-Type", accept);
      req.onerror = () => callback2 && callback2(null);
      req.onreadystatechange = () => {
        if (req.readyState === XHR_STATES.complete && callback2) {
          let response = this.parseJSON(req.responseText);
          callback2(response);
        }
      };
      if (ontimeout) {
        req.ontimeout = ontimeout;
      }
      req.send(body);
      return req;
    }
    static parseJSON(resp) {
      if (!resp || resp === "") {
        return null;
      }
      try {
        return JSON.parse(resp);
      } catch (e2) {
        console && console.log("failed to parse JSON response", resp);
        return null;
      }
    }
    static serialize(obj, parentKey) {
      let queryStr = [];
      for (var key in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, key)) {
          continue;
        }
        let paramKey = parentKey ? `${parentKey}[${key}]` : key;
        let paramVal = obj[key];
        if (typeof paramVal === "object") {
          queryStr.push(this.serialize(paramVal, paramKey));
        } else {
          queryStr.push(encodeURIComponent(paramKey) + "=" + encodeURIComponent(paramVal));
        }
      }
      return queryStr.join("&");
    }
    static appendParams(url, params) {
      if (Object.keys(params).length === 0) {
        return url;
      }
      let prefix = url.match(/\?/) ? "&" : "?";
      return `${url}${prefix}${this.serialize(params)}`;
    }
  };
  var arrayBufferToBase64 = (buffer) => {
    let binary = "";
    let bytes = new Uint8Array(buffer);
    let len = bytes.byteLength;
    for (let i2 = 0; i2 < len; i2++) {
      binary += String.fromCharCode(bytes[i2]);
    }
    return btoa(binary);
  };
  var LongPoll = class {
    constructor(endPoint) {
      this.endPoint = null;
      this.token = null;
      this.skipHeartbeat = true;
      this.reqs = /* @__PURE__ */ new Set();
      this.awaitingBatchAck = false;
      this.currentBatch = null;
      this.currentBatchTimer = null;
      this.batchBuffer = [];
      this.onopen = function() {
      };
      this.onerror = function() {
      };
      this.onmessage = function() {
      };
      this.onclose = function() {
      };
      this.pollEndpoint = this.normalizeEndpoint(endPoint);
      this.readyState = SOCKET_STATES.connecting;
      setTimeout(() => this.poll(), 0);
    }
    normalizeEndpoint(endPoint) {
      return endPoint.replace("ws://", "http://").replace("wss://", "https://").replace(new RegExp("(.*)/" + TRANSPORTS.websocket), "$1/" + TRANSPORTS.longpoll);
    }
    endpointURL() {
      return Ajax.appendParams(this.pollEndpoint, { token: this.token });
    }
    closeAndRetry(code, reason, wasClean) {
      this.close(code, reason, wasClean);
      this.readyState = SOCKET_STATES.connecting;
    }
    ontimeout() {
      this.onerror("timeout");
      this.closeAndRetry(1005, "timeout", false);
    }
    isActive() {
      return this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting;
    }
    poll() {
      this.ajax("GET", "application/json", null, () => this.ontimeout(), (resp) => {
        if (resp) {
          var { status, token, messages } = resp;
          this.token = token;
        } else {
          status = 0;
        }
        switch (status) {
          case 200:
            messages.forEach((msg) => {
              setTimeout(() => this.onmessage({ data: msg }), 0);
            });
            this.poll();
            break;
          case 204:
            this.poll();
            break;
          case 410:
            this.readyState = SOCKET_STATES.open;
            this.onopen({});
            this.poll();
            break;
          case 403:
            this.onerror(403);
            this.close(1008, "forbidden", false);
            break;
          case 0:
          case 500:
            this.onerror(500);
            this.closeAndRetry(1011, "internal server error", 500);
            break;
          default:
            throw new Error(`unhandled poll status ${status}`);
        }
      });
    }
    // we collect all pushes within the current event loop by
    // setTimeout 0, which optimizes back-to-back procedural
    // pushes against an empty buffer
    send(body) {
      if (typeof body !== "string") {
        body = arrayBufferToBase64(body);
      }
      if (this.currentBatch) {
        this.currentBatch.push(body);
      } else if (this.awaitingBatchAck) {
        this.batchBuffer.push(body);
      } else {
        this.currentBatch = [body];
        this.currentBatchTimer = setTimeout(() => {
          this.batchSend(this.currentBatch);
          this.currentBatch = null;
        }, 0);
      }
    }
    batchSend(messages) {
      this.awaitingBatchAck = true;
      this.ajax("POST", "application/x-ndjson", messages.join("\n"), () => this.onerror("timeout"), (resp) => {
        this.awaitingBatchAck = false;
        if (!resp || resp.status !== 200) {
          this.onerror(resp && resp.status);
          this.closeAndRetry(1011, "internal server error", false);
        } else if (this.batchBuffer.length > 0) {
          this.batchSend(this.batchBuffer);
          this.batchBuffer = [];
        }
      });
    }
    close(code, reason, wasClean) {
      for (let req of this.reqs) {
        req.abort();
      }
      this.readyState = SOCKET_STATES.closed;
      let opts = Object.assign({ code: 1e3, reason: void 0, wasClean: true }, { code, reason, wasClean });
      this.batchBuffer = [];
      clearTimeout(this.currentBatchTimer);
      this.currentBatchTimer = null;
      if (typeof CloseEvent !== "undefined") {
        this.onclose(new CloseEvent("close", opts));
      } else {
        this.onclose(opts);
      }
    }
    ajax(method, contentType, body, onCallerTimeout, callback2) {
      let req;
      let ontimeout = () => {
        this.reqs.delete(req);
        onCallerTimeout();
      };
      req = Ajax.request(method, this.endpointURL(), contentType, body, this.timeout, ontimeout, (resp) => {
        this.reqs.delete(req);
        if (this.isActive()) {
          callback2(resp);
        }
      });
      this.reqs.add(req);
    }
  };
  var serializer_default = {
    HEADER_LENGTH: 1,
    META_LENGTH: 4,
    KINDS: { push: 0, reply: 1, broadcast: 2 },
    encode(msg, callback2) {
      if (msg.payload.constructor === ArrayBuffer) {
        return callback2(this.binaryEncode(msg));
      } else {
        let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];
        return callback2(JSON.stringify(payload));
      }
    },
    decode(rawPayload, callback2) {
      if (rawPayload.constructor === ArrayBuffer) {
        return callback2(this.binaryDecode(rawPayload));
      } else {
        let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload);
        return callback2({ join_ref, ref, topic, event, payload });
      }
    },
    // private
    binaryEncode(message) {
      let { join_ref, ref, event, topic, payload } = message;
      let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;
      let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);
      let view = new DataView(header);
      let offset = 0;
      view.setUint8(offset++, this.KINDS.push);
      view.setUint8(offset++, join_ref.length);
      view.setUint8(offset++, ref.length);
      view.setUint8(offset++, topic.length);
      view.setUint8(offset++, event.length);
      Array.from(join_ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(event, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      var combined = new Uint8Array(header.byteLength + payload.byteLength);
      combined.set(new Uint8Array(header), 0);
      combined.set(new Uint8Array(payload), header.byteLength);
      return combined.buffer;
    },
    binaryDecode(buffer) {
      let view = new DataView(buffer);
      let kind = view.getUint8(0);
      let decoder = new TextDecoder();
      switch (kind) {
        case this.KINDS.push:
          return this.decodePush(buffer, view, decoder);
        case this.KINDS.reply:
          return this.decodeReply(buffer, view, decoder);
        case this.KINDS.broadcast:
          return this.decodeBroadcast(buffer, view, decoder);
      }
    },
    decodePush(buffer, view, decoder) {
      let joinRefSize = view.getUint8(1);
      let topicSize = view.getUint8(2);
      let eventSize = view.getUint8(3);
      let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;
      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
      offset = offset + joinRefSize;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data = buffer.slice(offset, buffer.byteLength);
      return { join_ref: joinRef, ref: null, topic, event, payload: data };
    },
    decodeReply(buffer, view, decoder) {
      let joinRefSize = view.getUint8(1);
      let refSize = view.getUint8(2);
      let topicSize = view.getUint8(3);
      let eventSize = view.getUint8(4);
      let offset = this.HEADER_LENGTH + this.META_LENGTH;
      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
      offset = offset + joinRefSize;
      let ref = decoder.decode(buffer.slice(offset, offset + refSize));
      offset = offset + refSize;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data = buffer.slice(offset, buffer.byteLength);
      let payload = { status: event, response: data };
      return { join_ref: joinRef, ref, topic, event: CHANNEL_EVENTS.reply, payload };
    },
    decodeBroadcast(buffer, view, decoder) {
      let topicSize = view.getUint8(1);
      let eventSize = view.getUint8(2);
      let offset = this.HEADER_LENGTH + 2;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data = buffer.slice(offset, buffer.byteLength);
      return { join_ref: null, ref: null, topic, event, payload: data };
    }
  };
  var Socket = class {
    constructor(endPoint, opts = {}) {
      this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };
      this.channels = [];
      this.sendBuffer = [];
      this.ref = 0;
      this.timeout = opts.timeout || DEFAULT_TIMEOUT;
      this.transport = opts.transport || global.WebSocket || LongPoll;
      this.primaryPassedHealthCheck = false;
      this.longPollFallbackMs = opts.longPollFallbackMs;
      this.fallbackTimer = null;
      this.sessionStore = opts.sessionStorage || global && global.sessionStorage;
      this.establishedConnections = 0;
      this.defaultEncoder = serializer_default.encode.bind(serializer_default);
      this.defaultDecoder = serializer_default.decode.bind(serializer_default);
      this.closeWasClean = false;
      this.binaryType = opts.binaryType || "arraybuffer";
      this.connectClock = 1;
      if (this.transport !== LongPoll) {
        this.encode = opts.encode || this.defaultEncoder;
        this.decode = opts.decode || this.defaultDecoder;
      } else {
        this.encode = this.defaultEncoder;
        this.decode = this.defaultDecoder;
      }
      let awaitingConnectionOnPageShow = null;
      if (phxWindow && phxWindow.addEventListener) {
        phxWindow.addEventListener("pagehide", (_e) => {
          if (this.conn) {
            this.disconnect();
            awaitingConnectionOnPageShow = this.connectClock;
          }
        });
        phxWindow.addEventListener("pageshow", (_e) => {
          if (awaitingConnectionOnPageShow === this.connectClock) {
            awaitingConnectionOnPageShow = null;
            this.connect();
          }
        });
      }
      this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;
      this.rejoinAfterMs = (tries) => {
        if (opts.rejoinAfterMs) {
          return opts.rejoinAfterMs(tries);
        } else {
          return [1e3, 2e3, 5e3][tries - 1] || 1e4;
        }
      };
      this.reconnectAfterMs = (tries) => {
        if (opts.reconnectAfterMs) {
          return opts.reconnectAfterMs(tries);
        } else {
          return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;
        }
      };
      this.logger = opts.logger || null;
      if (!this.logger && opts.debug) {
        this.logger = (kind, msg, data) => {
          console.log(`${kind}: ${msg}`, data);
        };
      }
      this.longpollerTimeout = opts.longpollerTimeout || 2e4;
      this.params = closure(opts.params || {});
      this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
      this.vsn = opts.vsn || DEFAULT_VSN;
      this.heartbeatTimeoutTimer = null;
      this.heartbeatTimer = null;
      this.pendingHeartbeatRef = null;
      this.reconnectTimer = new Timer(() => {
        this.teardown(() => this.connect());
      }, this.reconnectAfterMs);
    }
    /**
     * Returns the LongPoll transport reference
     */
    getLongPollTransport() {
      return LongPoll;
    }
    /**
     * Disconnects and replaces the active transport
     *
     * @param {Function} newTransport - The new transport class to instantiate
     *
     */
    replaceTransport(newTransport) {
      this.connectClock++;
      this.closeWasClean = true;
      clearTimeout(this.fallbackTimer);
      this.reconnectTimer.reset();
      if (this.conn) {
        this.conn.close();
        this.conn = null;
      }
      this.transport = newTransport;
    }
    /**
     * Returns the socket protocol
     *
     * @returns {string}
     */
    protocol() {
      return location.protocol.match(/^https/) ? "wss" : "ws";
    }
    /**
     * The fully qualified socket url
     *
     * @returns {string}
     */
    endPointURL() {
      let uri = Ajax.appendParams(
        Ajax.appendParams(this.endPoint, this.params()),
        { vsn: this.vsn }
      );
      if (uri.charAt(0) !== "/") {
        return uri;
      }
      if (uri.charAt(1) === "/") {
        return `${this.protocol()}:${uri}`;
      }
      return `${this.protocol()}://${location.host}${uri}`;
    }
    /**
     * Disconnects the socket
     *
     * See https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes for valid status codes.
     *
     * @param {Function} callback - Optional callback which is called after socket is disconnected.
     * @param {integer} code - A status code for disconnection (Optional).
     * @param {string} reason - A textual description of the reason to disconnect. (Optional)
     */
    disconnect(callback2, code, reason) {
      this.connectClock++;
      this.closeWasClean = true;
      clearTimeout(this.fallbackTimer);
      this.reconnectTimer.reset();
      this.teardown(callback2, code, reason);
    }
    /**
     *
     * @param {Object} params - The params to send when connecting, for example `{user_id: userToken}`
     *
     * Passing params to connect is deprecated; pass them in the Socket constructor instead:
     * `new Socket("/socket", {params: {user_id: userToken}})`.
     */
    connect(params) {
      if (params) {
        console && console.log("passing params to connect is deprecated. Instead pass :params to the Socket constructor");
        this.params = closure(params);
      }
      if (this.conn) {
        return;
      }
      if (this.longPollFallbackMs && this.transport !== LongPoll) {
        this.connectWithFallback(LongPoll, this.longPollFallbackMs);
      } else {
        this.transportConnect();
      }
    }
    /**
     * Logs the message. Override `this.logger` for specialized logging. noops by default
     * @param {string} kind
     * @param {string} msg
     * @param {Object} data
     */
    log(kind, msg, data) {
      this.logger && this.logger(kind, msg, data);
    }
    /**
     * Returns true if a logger has been set on this socket.
     */
    hasLogger() {
      return this.logger !== null;
    }
    /**
     * Registers callbacks for connection open events
     *
     * @example socket.onOpen(function(){ console.info("the socket was opened") })
     *
     * @param {Function} callback
     */
    onOpen(callback2) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.open.push([ref, callback2]);
      return ref;
    }
    /**
     * Registers callbacks for connection close events
     * @param {Function} callback
     */
    onClose(callback2) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.close.push([ref, callback2]);
      return ref;
    }
    /**
     * Registers callbacks for connection error events
     *
     * @example socket.onError(function(error){ alert("An error occurred") })
     *
     * @param {Function} callback
     */
    onError(callback2) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.error.push([ref, callback2]);
      return ref;
    }
    /**
     * Registers callbacks for connection message events
     * @param {Function} callback
     */
    onMessage(callback2) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.message.push([ref, callback2]);
      return ref;
    }
    /**
     * Pings the server and invokes the callback with the RTT in milliseconds
     * @param {Function} callback
     *
     * Returns true if the ping was pushed or false if unable to be pushed.
     */
    ping(callback2) {
      if (!this.isConnected()) {
        return false;
      }
      let ref = this.makeRef();
      let startTime = Date.now();
      this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref });
      let onMsgRef = this.onMessage((msg) => {
        if (msg.ref === ref) {
          this.off([onMsgRef]);
          callback2(Date.now() - startTime);
        }
      });
      return true;
    }
    /**
     * @private
     */
    transportConnect() {
      this.connectClock++;
      this.closeWasClean = false;
      this.conn = new this.transport(this.endPointURL());
      this.conn.binaryType = this.binaryType;
      this.conn.timeout = this.longpollerTimeout;
      this.conn.onopen = () => this.onConnOpen();
      this.conn.onerror = (error) => this.onConnError(error);
      this.conn.onmessage = (event) => this.onConnMessage(event);
      this.conn.onclose = (event) => this.onConnClose(event);
    }
    getSession(key) {
      return this.sessionStore && this.sessionStore.getItem(key);
    }
    storeSession(key, val) {
      this.sessionStore && this.sessionStore.setItem(key, val);
    }
    connectWithFallback(fallbackTransport, fallbackThreshold = 2500) {
      clearTimeout(this.fallbackTimer);
      let established = false;
      let primaryTransport = true;
      let openRef, errorRef;
      let fallback = (reason) => {
        this.log("transport", `falling back to ${fallbackTransport.name}...`, reason);
        this.off([openRef, errorRef]);
        primaryTransport = false;
        this.replaceTransport(fallbackTransport);
        this.transportConnect();
      };
      if (this.getSession(`phx:fallback:${fallbackTransport.name}`)) {
        return fallback("memorized");
      }
      this.fallbackTimer = setTimeout(fallback, fallbackThreshold);
      errorRef = this.onError((reason) => {
        this.log("transport", "error", reason);
        if (primaryTransport && !established) {
          clearTimeout(this.fallbackTimer);
          fallback(reason);
        }
      });
      this.onOpen(() => {
        established = true;
        if (!primaryTransport) {
          if (!this.primaryPassedHealthCheck) {
            this.storeSession(`phx:fallback:${fallbackTransport.name}`, "true");
          }
          return this.log("transport", `established ${fallbackTransport.name} fallback`);
        }
        clearTimeout(this.fallbackTimer);
        this.fallbackTimer = setTimeout(fallback, fallbackThreshold);
        this.ping((rtt) => {
          this.log("transport", "connected to primary after", rtt);
          this.primaryPassedHealthCheck = true;
          clearTimeout(this.fallbackTimer);
        });
      });
      this.transportConnect();
    }
    clearHeartbeats() {
      clearTimeout(this.heartbeatTimer);
      clearTimeout(this.heartbeatTimeoutTimer);
    }
    onConnOpen() {
      if (this.hasLogger())
        this.log("transport", `${this.transport.name} connected to ${this.endPointURL()}`);
      this.closeWasClean = false;
      this.establishedConnections++;
      this.flushSendBuffer();
      this.reconnectTimer.reset();
      this.resetHeartbeat();
      this.stateChangeCallbacks.open.forEach(([, callback2]) => callback2());
    }
    /**
     * @private
     */
    heartbeatTimeout() {
      if (this.pendingHeartbeatRef) {
        this.pendingHeartbeatRef = null;
        if (this.hasLogger()) {
          this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
        }
        this.triggerChanError();
        this.closeWasClean = false;
        this.teardown(() => this.reconnectTimer.scheduleTimeout(), WS_CLOSE_NORMAL, "heartbeat timeout");
      }
    }
    resetHeartbeat() {
      if (this.conn && this.conn.skipHeartbeat) {
        return;
      }
      this.pendingHeartbeatRef = null;
      this.clearHeartbeats();
      this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
    }
    teardown(callback2, code, reason) {
      if (!this.conn) {
        return callback2 && callback2();
      }
      this.waitForBufferDone(() => {
        if (this.conn) {
          if (code) {
            this.conn.close(code, reason || "");
          } else {
            this.conn.close();
          }
        }
        this.waitForSocketClosed(() => {
          if (this.conn) {
            this.conn.onopen = function() {
            };
            this.conn.onerror = function() {
            };
            this.conn.onmessage = function() {
            };
            this.conn.onclose = function() {
            };
            this.conn = null;
          }
          callback2 && callback2();
        });
      });
    }
    waitForBufferDone(callback2, tries = 1) {
      if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {
        callback2();
        return;
      }
      setTimeout(() => {
        this.waitForBufferDone(callback2, tries + 1);
      }, 150 * tries);
    }
    waitForSocketClosed(callback2, tries = 1) {
      if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {
        callback2();
        return;
      }
      setTimeout(() => {
        this.waitForSocketClosed(callback2, tries + 1);
      }, 150 * tries);
    }
    onConnClose(event) {
      let closeCode = event && event.code;
      if (this.hasLogger())
        this.log("transport", "close", event);
      this.triggerChanError();
      this.clearHeartbeats();
      if (!this.closeWasClean && closeCode !== 1e3) {
        this.reconnectTimer.scheduleTimeout();
      }
      this.stateChangeCallbacks.close.forEach(([, callback2]) => callback2(event));
    }
    /**
     * @private
     */
    onConnError(error) {
      if (this.hasLogger())
        this.log("transport", error);
      let transportBefore = this.transport;
      let establishedBefore = this.establishedConnections;
      this.stateChangeCallbacks.error.forEach(([, callback2]) => {
        callback2(error, transportBefore, establishedBefore);
      });
      if (transportBefore === this.transport || establishedBefore > 0) {
        this.triggerChanError();
      }
    }
    /**
     * @private
     */
    triggerChanError() {
      this.channels.forEach((channel) => {
        if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {
          channel.trigger(CHANNEL_EVENTS.error);
        }
      });
    }
    /**
     * @returns {string}
     */
    connectionState() {
      switch (this.conn && this.conn.readyState) {
        case SOCKET_STATES.connecting:
          return "connecting";
        case SOCKET_STATES.open:
          return "open";
        case SOCKET_STATES.closing:
          return "closing";
        default:
          return "closed";
      }
    }
    /**
     * @returns {boolean}
     */
    isConnected() {
      return this.connectionState() === "open";
    }
    /**
     * @private
     *
     * @param {Channel}
     */
    remove(channel) {
      this.off(channel.stateChangeRefs);
      this.channels = this.channels.filter((c2) => c2 !== channel);
    }
    /**
     * Removes `onOpen`, `onClose`, `onError,` and `onMessage` registrations.
     *
     * @param {refs} - list of refs returned by calls to
     *                 `onOpen`, `onClose`, `onError,` and `onMessage`
     */
    off(refs) {
      for (let key in this.stateChangeCallbacks) {
        this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {
          return refs.indexOf(ref) === -1;
        });
      }
    }
    /**
     * Initiates a new channel for the given topic
     *
     * @param {string} topic
     * @param {Object} chanParams - Parameters for the channel
     * @returns {Channel}
     */
    channel(topic, chanParams = {}) {
      let chan = new Channel(topic, chanParams, this);
      this.channels.push(chan);
      return chan;
    }
    /**
     * @param {Object} data
     */
    push(data) {
      if (this.hasLogger()) {
        let { topic, event, payload, ref, join_ref } = data;
        this.log("push", `${topic} ${event} (${join_ref}, ${ref})`, payload);
      }
      if (this.isConnected()) {
        this.encode(data, (result) => this.conn.send(result));
      } else {
        this.sendBuffer.push(() => this.encode(data, (result) => this.conn.send(result)));
      }
    }
    /**
     * Return the next message ref, accounting for overflows
     * @returns {string}
     */
    makeRef() {
      let newRef = this.ref + 1;
      if (newRef === this.ref) {
        this.ref = 0;
      } else {
        this.ref = newRef;
      }
      return this.ref.toString();
    }
    sendHeartbeat() {
      if (this.pendingHeartbeatRef && !this.isConnected()) {
        return;
      }
      this.pendingHeartbeatRef = this.makeRef();
      this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref: this.pendingHeartbeatRef });
      this.heartbeatTimeoutTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);
    }
    flushSendBuffer() {
      if (this.isConnected() && this.sendBuffer.length > 0) {
        this.sendBuffer.forEach((callback2) => callback2());
        this.sendBuffer = [];
      }
    }
    onConnMessage(rawMessage) {
      this.decode(rawMessage.data, (msg) => {
        let { topic, event, payload, ref, join_ref } = msg;
        if (ref && ref === this.pendingHeartbeatRef) {
          this.clearHeartbeats();
          this.pendingHeartbeatRef = null;
          this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
        }
        if (this.hasLogger())
          this.log("receive", `${payload.status || ""} ${topic} ${event} ${ref && "(" + ref + ")" || ""}`, payload);
        for (let i2 = 0; i2 < this.channels.length; i2++) {
          const channel = this.channels[i2];
          if (!channel.isMember(topic, event, payload, join_ref)) {
            continue;
          }
          channel.trigger(event, payload, ref, join_ref);
        }
        for (let i2 = 0; i2 < this.stateChangeCallbacks.message.length; i2++) {
          let [, callback2] = this.stateChangeCallbacks.message[i2];
          callback2(msg);
        }
      });
    }
    leaveOpenTopic(topic) {
      let dupChannel = this.channels.find((c2) => c2.topic === topic && (c2.isJoined() || c2.isJoining()));
      if (dupChannel) {
        if (this.hasLogger())
          this.log("transport", `leaving duplicate topic "${topic}"`);
        dupChannel.leave();
      }
    }
  };

  // ../../../deps/phoenix_live_view/priv/static/phoenix_live_view.esm.js
  var CONSECUTIVE_RELOADS = "consecutive-reloads";
  var MAX_RELOADS = 10;
  var RELOAD_JITTER_MIN = 5e3;
  var RELOAD_JITTER_MAX = 1e4;
  var FAILSAFE_JITTER = 3e4;
  var PHX_EVENT_CLASSES = [
    "phx-click-loading",
    "phx-change-loading",
    "phx-submit-loading",
    "phx-keydown-loading",
    "phx-keyup-loading",
    "phx-blur-loading",
    "phx-focus-loading",
    "phx-hook-loading"
  ];
  var PHX_COMPONENT = "data-phx-component";
  var PHX_LIVE_LINK = "data-phx-link";
  var PHX_TRACK_STATIC = "track-static";
  var PHX_LINK_STATE = "data-phx-link-state";
  var PHX_REF_LOADING = "data-phx-ref-loading";
  var PHX_REF_SRC = "data-phx-ref-src";
  var PHX_REF_LOCK = "data-phx-ref-lock";
  var PHX_TRACK_UPLOADS = "track-uploads";
  var PHX_UPLOAD_REF = "data-phx-upload-ref";
  var PHX_PREFLIGHTED_REFS = "data-phx-preflighted-refs";
  var PHX_DONE_REFS = "data-phx-done-refs";
  var PHX_DROP_TARGET = "drop-target";
  var PHX_ACTIVE_ENTRY_REFS = "data-phx-active-refs";
  var PHX_LIVE_FILE_UPDATED = "phx:live-file:updated";
  var PHX_SKIP = "data-phx-skip";
  var PHX_MAGIC_ID = "data-phx-id";
  var PHX_PRUNE = "data-phx-prune";
  var PHX_CONNECTED_CLASS = "phx-connected";
  var PHX_LOADING_CLASS = "phx-loading";
  var PHX_ERROR_CLASS = "phx-error";
  var PHX_CLIENT_ERROR_CLASS = "phx-client-error";
  var PHX_SERVER_ERROR_CLASS = "phx-server-error";
  var PHX_PARENT_ID = "data-phx-parent-id";
  var PHX_MAIN = "data-phx-main";
  var PHX_ROOT_ID = "data-phx-root-id";
  var PHX_VIEWPORT_TOP = "viewport-top";
  var PHX_VIEWPORT_BOTTOM = "viewport-bottom";
  var PHX_TRIGGER_ACTION = "trigger-action";
  var PHX_HAS_FOCUSED = "phx-has-focused";
  var FOCUSABLE_INPUTS = ["text", "textarea", "number", "email", "password", "search", "tel", "url", "date", "time", "datetime-local", "color", "range"];
  var CHECKABLE_INPUTS = ["checkbox", "radio"];
  var PHX_HAS_SUBMITTED = "phx-has-submitted";
  var PHX_SESSION = "data-phx-session";
  var PHX_VIEW_SELECTOR = `[${PHX_SESSION}]`;
  var PHX_STICKY = "data-phx-sticky";
  var PHX_STATIC = "data-phx-static";
  var PHX_READONLY = "data-phx-readonly";
  var PHX_DISABLED = "data-phx-disabled";
  var PHX_DISABLE_WITH = "disable-with";
  var PHX_DISABLE_WITH_RESTORE = "data-phx-disable-with-restore";
  var PHX_HOOK = "hook";
  var PHX_DEBOUNCE = "debounce";
  var PHX_THROTTLE = "throttle";
  var PHX_UPDATE = "update";
  var PHX_STREAM = "stream";
  var PHX_STREAM_REF = "data-phx-stream";
  var PHX_KEY = "key";
  var PHX_PRIVATE = "phxPrivate";
  var PHX_AUTO_RECOVER = "auto-recover";
  var PHX_LV_DEBUG = "phx:live-socket:debug";
  var PHX_LV_PROFILE = "phx:live-socket:profiling";
  var PHX_LV_LATENCY_SIM = "phx:live-socket:latency-sim";
  var PHX_LV_HISTORY_POSITION = "phx:nav-history-position";
  var PHX_PROGRESS = "progress";
  var PHX_MOUNTED = "mounted";
  var PHX_RELOAD_STATUS = "__phoenix_reload_status__";
  var LOADER_TIMEOUT = 1;
  var MAX_CHILD_JOIN_ATTEMPTS = 3;
  var BEFORE_UNLOAD_LOADER_TIMEOUT = 200;
  var BINDING_PREFIX = "phx-";
  var PUSH_TIMEOUT = 3e4;
  var DEBOUNCE_TRIGGER = "debounce-trigger";
  var THROTTLED = "throttled";
  var DEBOUNCE_PREV_KEY = "debounce-prev-key";
  var DEFAULTS = {
    debounce: 300,
    throttle: 300
  };
  var PHX_PENDING_ATTRS = [PHX_REF_LOADING, PHX_REF_SRC, PHX_REF_LOCK];
  var DYNAMICS = "d";
  var STATIC = "s";
  var ROOT = "r";
  var COMPONENTS = "c";
  var EVENTS = "e";
  var REPLY = "r";
  var TITLE = "t";
  var TEMPLATES = "p";
  var STREAM = "stream";
  var EntryUploader = class {
    constructor(entry, config, liveSocket2) {
      let { chunk_size, chunk_timeout } = config;
      this.liveSocket = liveSocket2;
      this.entry = entry;
      this.offset = 0;
      this.chunkSize = chunk_size;
      this.chunkTimeout = chunk_timeout;
      this.chunkTimer = null;
      this.errored = false;
      this.uploadChannel = liveSocket2.channel(`lvu:${entry.ref}`, { token: entry.metadata() });
    }
    error(reason) {
      if (this.errored) {
        return;
      }
      this.uploadChannel.leave();
      this.errored = true;
      clearTimeout(this.chunkTimer);
      this.entry.error(reason);
    }
    upload() {
      this.uploadChannel.onError((reason) => this.error(reason));
      this.uploadChannel.join().receive("ok", (_data) => this.readNextChunk()).receive("error", (reason) => this.error(reason));
    }
    isDone() {
      return this.offset >= this.entry.file.size;
    }
    readNextChunk() {
      let reader = new window.FileReader();
      let blob = this.entry.file.slice(this.offset, this.chunkSize + this.offset);
      reader.onload = (e2) => {
        if (e2.target.error === null) {
          this.offset += e2.target.result.byteLength;
          this.pushChunk(e2.target.result);
        } else {
          return logError("Read error: " + e2.target.error);
        }
      };
      reader.readAsArrayBuffer(blob);
    }
    pushChunk(chunk) {
      if (!this.uploadChannel.isJoined()) {
        return;
      }
      this.uploadChannel.push("chunk", chunk, this.chunkTimeout).receive("ok", () => {
        this.entry.progress(this.offset / this.entry.file.size * 100);
        if (!this.isDone()) {
          this.chunkTimer = setTimeout(() => this.readNextChunk(), this.liveSocket.getLatencySim() || 0);
        }
      }).receive("error", ({ reason }) => this.error(reason));
    }
  };
  var logError = (msg, obj) => console.error && console.error(msg, obj);
  var isCid = (cid) => {
    let type = typeof cid;
    return type === "number" || type === "string" && /^(0|[1-9]\d*)$/.test(cid);
  };
  function detectDuplicateIds() {
    let ids = /* @__PURE__ */ new Set();
    let elems = document.querySelectorAll("*[id]");
    for (let i2 = 0, len = elems.length; i2 < len; i2++) {
      if (ids.has(elems[i2].id)) {
        console.error(`Multiple IDs detected: ${elems[i2].id}. Ensure unique element ids.`);
      } else {
        ids.add(elems[i2].id);
      }
    }
  }
  function detectInvalidStreamInserts(inserts) {
    const errors = /* @__PURE__ */ new Set();
    Object.keys(inserts).forEach((id) => {
      const streamEl = document.getElementById(id);
      if (streamEl && streamEl.parentElement && streamEl.parentElement.getAttribute("phx-update") !== "stream") {
        errors.add(`The stream container with id "${streamEl.parentElement.id}" is missing the phx-update="stream" attribute. Ensure it is set for streams to work properly.`);
      }
    });
    errors.forEach((error) => console.error(error));
  }
  var debug = (view, kind, msg, obj) => {
    if (view.liveSocket.isDebugEnabled()) {
      console.log(`${view.id} ${kind}: ${msg} - `, obj);
    }
  };
  var closure2 = (val) => typeof val === "function" ? val : function() {
    return val;
  };
  var clone = (obj) => {
    return JSON.parse(JSON.stringify(obj));
  };
  var closestPhxBinding = (el, binding, borderEl) => {
    do {
      if (el.matches(`[${binding}]`) && !el.disabled) {
        return el;
      }
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === 1 && !(borderEl && borderEl.isSameNode(el) || el.matches(PHX_VIEW_SELECTOR)));
    return null;
  };
  var isObject = (obj) => {
    return obj !== null && typeof obj === "object" && !(obj instanceof Array);
  };
  var isEqualObj = (obj1, obj2) => JSON.stringify(obj1) === JSON.stringify(obj2);
  var isEmpty = (obj) => {
    for (let x in obj) {
      return false;
    }
    return true;
  };
  var maybe = (el, callback2) => el && callback2(el);
  var channelUploader = function(entries, onError, resp, liveSocket2) {
    entries.forEach((entry) => {
      let entryUploader = new EntryUploader(entry, resp.config, liveSocket2);
      entryUploader.upload();
    });
  };
  var Browser = {
    canPushState() {
      return typeof history.pushState !== "undefined";
    },
    dropLocal(localStorage, namespace, subkey) {
      return localStorage.removeItem(this.localKey(namespace, subkey));
    },
    updateLocal(localStorage, namespace, subkey, initial, func) {
      let current = this.getLocal(localStorage, namespace, subkey);
      let key = this.localKey(namespace, subkey);
      let newVal = current === null ? initial : func(current);
      localStorage.setItem(key, JSON.stringify(newVal));
      return newVal;
    },
    getLocal(localStorage, namespace, subkey) {
      return JSON.parse(localStorage.getItem(this.localKey(namespace, subkey)));
    },
    updateCurrentState(callback2) {
      if (!this.canPushState()) {
        return;
      }
      history.replaceState(callback2(history.state || {}), "", window.location.href);
    },
    pushState(kind, meta, to2) {
      if (this.canPushState()) {
        if (to2 !== window.location.href) {
          if (meta.type == "redirect" && meta.scroll) {
            let currentState = history.state || {};
            currentState.scroll = meta.scroll;
            history.replaceState(currentState, "", window.location.href);
          }
          delete meta.scroll;
          history[kind + "State"](meta, "", to2 || null);
          window.requestAnimationFrame(() => {
            let hashEl = this.getHashTargetEl(window.location.hash);
            if (hashEl) {
              hashEl.scrollIntoView();
            } else if (meta.type === "redirect") {
              window.scroll(0, 0);
            }
          });
        }
      } else {
        this.redirect(to2);
      }
    },
    setCookie(name, value, maxAgeSeconds) {
      let expires = typeof maxAgeSeconds === "number" ? ` max-age=${maxAgeSeconds};` : "";
      document.cookie = `${name}=${value};${expires} path=/`;
    },
    getCookie(name) {
      return document.cookie.replace(new RegExp(`(?:(?:^|.*;s*)${name}s*=s*([^;]*).*$)|^.*$`), "$1");
    },
    deleteCookie(name) {
      document.cookie = `${name}=; max-age=-1; path=/`;
    },
    redirect(toURL, flash) {
      if (flash) {
        this.setCookie("__phoenix_flash__", flash, 60);
      }
      window.location = toURL;
    },
    localKey(namespace, subkey) {
      return `${namespace}-${subkey}`;
    },
    getHashTargetEl(maybeHash) {
      let hash = maybeHash.toString().substring(1);
      if (hash === "") {
        return;
      }
      return document.getElementById(hash) || document.querySelector(`a[name="${hash}"]`);
    }
  };
  var browser_default = Browser;
  var DOM = {
    byId(id) {
      return document.getElementById(id) || logError(`no id found for ${id}`);
    },
    removeClass(el, className) {
      el.classList.remove(className);
      if (el.classList.length === 0) {
        el.removeAttribute("class");
      }
    },
    all(node, query, callback2) {
      if (!node) {
        return [];
      }
      let array = Array.from(node.querySelectorAll(query));
      return callback2 ? array.forEach(callback2) : array;
    },
    childNodeLength(html) {
      let template = document.createElement("template");
      template.innerHTML = html;
      return template.content.childElementCount;
    },
    isUploadInput(el) {
      return el.type === "file" && el.getAttribute(PHX_UPLOAD_REF) !== null;
    },
    isAutoUpload(inputEl) {
      return inputEl.hasAttribute("data-phx-auto-upload");
    },
    findUploadInputs(node) {
      const formId = node.id;
      const inputsOutsideForm = this.all(document, `input[type="file"][${PHX_UPLOAD_REF}][form="${formId}"]`);
      return this.all(node, `input[type="file"][${PHX_UPLOAD_REF}]`).concat(inputsOutsideForm);
    },
    findComponentNodeList(node, cid) {
      return this.filterWithinSameLiveView(this.all(node, `[${PHX_COMPONENT}="${cid}"]`), node);
    },
    isPhxDestroyed(node) {
      return node.id && DOM.private(node, "destroyed") ? true : false;
    },
    wantsNewTab(e2) {
      let wantsNewTab = e2.ctrlKey || e2.shiftKey || e2.metaKey || e2.button && e2.button === 1;
      let isDownload = e2.target instanceof HTMLAnchorElement && e2.target.hasAttribute("download");
      let isTargetBlank = e2.target.hasAttribute("target") && e2.target.getAttribute("target").toLowerCase() === "_blank";
      let isTargetNamedTab = e2.target.hasAttribute("target") && !e2.target.getAttribute("target").startsWith("_");
      return wantsNewTab || isTargetBlank || isDownload || isTargetNamedTab;
    },
    isUnloadableFormSubmit(e2) {
      let isDialogSubmit = e2.target && e2.target.getAttribute("method") === "dialog" || e2.submitter && e2.submitter.getAttribute("formmethod") === "dialog";
      if (isDialogSubmit) {
        return false;
      } else {
        return !e2.defaultPrevented && !this.wantsNewTab(e2);
      }
    },
    isNewPageClick(e2, currentLocation) {
      let href = e2.target instanceof HTMLAnchorElement ? e2.target.getAttribute("href") : null;
      let url;
      if (e2.defaultPrevented || href === null || this.wantsNewTab(e2)) {
        return false;
      }
      if (href.startsWith("mailto:") || href.startsWith("tel:")) {
        return false;
      }
      if (e2.target.isContentEditable) {
        return false;
      }
      try {
        url = new URL(href);
      } catch (e3) {
        try {
          url = new URL(href, currentLocation);
        } catch (e4) {
          return true;
        }
      }
      if (url.host === currentLocation.host && url.protocol === currentLocation.protocol) {
        if (url.pathname === currentLocation.pathname && url.search === currentLocation.search) {
          return url.hash === "" && !url.href.endsWith("#");
        }
      }
      return url.protocol.startsWith("http");
    },
    markPhxChildDestroyed(el) {
      if (this.isPhxChild(el)) {
        el.setAttribute(PHX_SESSION, "");
      }
      this.putPrivate(el, "destroyed", true);
    },
    findPhxChildrenInFragment(html, parentId) {
      let template = document.createElement("template");
      template.innerHTML = html;
      return this.findPhxChildren(template.content, parentId);
    },
    isIgnored(el, phxUpdate) {
      return (el.getAttribute(phxUpdate) || el.getAttribute("data-phx-update")) === "ignore";
    },
    isPhxUpdate(el, phxUpdate, updateTypes) {
      return el.getAttribute && updateTypes.indexOf(el.getAttribute(phxUpdate)) >= 0;
    },
    findPhxSticky(el) {
      return this.all(el, `[${PHX_STICKY}]`);
    },
    findPhxChildren(el, parentId) {
      return this.all(el, `${PHX_VIEW_SELECTOR}[${PHX_PARENT_ID}="${parentId}"]`);
    },
    findExistingParentCIDs(node, cids) {
      let parentCids = /* @__PURE__ */ new Set();
      let childrenCids = /* @__PURE__ */ new Set();
      cids.forEach((cid) => {
        this.filterWithinSameLiveView(this.all(node, `[${PHX_COMPONENT}="${cid}"]`), node).forEach((parent) => {
          parentCids.add(cid);
          this.filterWithinSameLiveView(this.all(parent, `[${PHX_COMPONENT}]`), parent).map((el) => parseInt(el.getAttribute(PHX_COMPONENT))).forEach((childCID) => childrenCids.add(childCID));
        });
      });
      childrenCids.forEach((childCid) => parentCids.delete(childCid));
      return parentCids;
    },
    filterWithinSameLiveView(nodes, parent) {
      if (parent.querySelector(PHX_VIEW_SELECTOR)) {
        return nodes.filter((el) => this.withinSameLiveView(el, parent));
      } else {
        return nodes;
      }
    },
    withinSameLiveView(node, parent) {
      while (node = node.parentNode) {
        if (node.isSameNode(parent)) {
          return true;
        }
        if (node.getAttribute(PHX_SESSION) !== null) {
          return false;
        }
      }
    },
    private(el, key) {
      return el[PHX_PRIVATE] && el[PHX_PRIVATE][key];
    },
    deletePrivate(el, key) {
      el[PHX_PRIVATE] && delete el[PHX_PRIVATE][key];
    },
    putPrivate(el, key, value) {
      if (!el[PHX_PRIVATE]) {
        el[PHX_PRIVATE] = {};
      }
      el[PHX_PRIVATE][key] = value;
    },
    updatePrivate(el, key, defaultVal, updateFunc) {
      let existing = this.private(el, key);
      if (existing === void 0) {
        this.putPrivate(el, key, updateFunc(defaultVal));
      } else {
        this.putPrivate(el, key, updateFunc(existing));
      }
    },
    syncPendingAttrs(fromEl, toEl) {
      if (!fromEl.hasAttribute(PHX_REF_SRC)) {
        return;
      }
      PHX_EVENT_CLASSES.forEach((className) => {
        fromEl.classList.contains(className) && toEl.classList.add(className);
      });
      PHX_PENDING_ATTRS.filter((attr) => fromEl.hasAttribute(attr)).forEach((attr) => {
        toEl.setAttribute(attr, fromEl.getAttribute(attr));
      });
    },
    copyPrivates(target, source) {
      if (source[PHX_PRIVATE]) {
        target[PHX_PRIVATE] = source[PHX_PRIVATE];
      }
    },
    putTitle(str) {
      let titleEl = document.querySelector("title");
      if (titleEl) {
        let { prefix, suffix, default: defaultTitle } = titleEl.dataset;
        let isEmpty2 = typeof str !== "string" || str.trim() === "";
        if (isEmpty2 && typeof defaultTitle !== "string") {
          return;
        }
        let inner = isEmpty2 ? defaultTitle : str;
        document.title = `${prefix || ""}${inner || ""}${suffix || ""}`;
      } else {
        document.title = str;
      }
    },
    debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, asyncFilter, callback2) {
      let debounce2 = el.getAttribute(phxDebounce);
      let throttle = el.getAttribute(phxThrottle);
      if (debounce2 === "") {
        debounce2 = defaultDebounce;
      }
      if (throttle === "") {
        throttle = defaultThrottle;
      }
      let value = debounce2 || throttle;
      switch (value) {
        case null:
          return callback2();
        case "blur":
          if (this.once(el, "debounce-blur")) {
            el.addEventListener("blur", () => {
              if (asyncFilter()) {
                callback2();
              }
            });
          }
          return;
        default:
          let timeout = parseInt(value);
          let trigger = () => throttle ? this.deletePrivate(el, THROTTLED) : callback2();
          let currentCycle = this.incCycle(el, DEBOUNCE_TRIGGER, trigger);
          if (isNaN(timeout)) {
            return logError(`invalid throttle/debounce value: ${value}`);
          }
          if (throttle) {
            let newKeyDown = false;
            if (event.type === "keydown") {
              let prevKey = this.private(el, DEBOUNCE_PREV_KEY);
              this.putPrivate(el, DEBOUNCE_PREV_KEY, event.key);
              newKeyDown = prevKey !== event.key;
            }
            if (!newKeyDown && this.private(el, THROTTLED)) {
              return false;
            } else {
              callback2();
              const t2 = setTimeout(() => {
                if (asyncFilter()) {
                  this.triggerCycle(el, DEBOUNCE_TRIGGER);
                }
              }, timeout);
              this.putPrivate(el, THROTTLED, t2);
            }
          } else {
            setTimeout(() => {
              if (asyncFilter()) {
                this.triggerCycle(el, DEBOUNCE_TRIGGER, currentCycle);
              }
            }, timeout);
          }
          let form = el.form;
          if (form && this.once(form, "bind-debounce")) {
            form.addEventListener("submit", () => {
              Array.from(new FormData(form).entries(), ([name]) => {
                let input = form.querySelector(`[name="${name}"]`);
                this.incCycle(input, DEBOUNCE_TRIGGER);
                this.deletePrivate(input, THROTTLED);
              });
            });
          }
          if (this.once(el, "bind-debounce")) {
            el.addEventListener("blur", () => {
              clearTimeout(this.private(el, THROTTLED));
              this.triggerCycle(el, DEBOUNCE_TRIGGER);
            });
          }
      }
    },
    triggerCycle(el, key, currentCycle) {
      let [cycle, trigger] = this.private(el, key);
      if (!currentCycle) {
        currentCycle = cycle;
      }
      if (currentCycle === cycle) {
        this.incCycle(el, key);
        trigger();
      }
    },
    once(el, key) {
      if (this.private(el, key) === true) {
        return false;
      }
      this.putPrivate(el, key, true);
      return true;
    },
    incCycle(el, key, trigger = function() {
    }) {
      let [currentCycle] = this.private(el, key) || [0, trigger];
      currentCycle++;
      this.putPrivate(el, key, [currentCycle, trigger]);
      return currentCycle;
    },
    // maintains or adds privately used hook information
    // fromEl and toEl can be the same element in the case of a newly added node
    // fromEl and toEl can be any HTML node type, so we need to check if it's an element node
    maintainPrivateHooks(fromEl, toEl, phxViewportTop, phxViewportBottom) {
      if (fromEl.hasAttribute && fromEl.hasAttribute("data-phx-hook") && !toEl.hasAttribute("data-phx-hook")) {
        toEl.setAttribute("data-phx-hook", fromEl.getAttribute("data-phx-hook"));
      }
      if (toEl.hasAttribute && (toEl.hasAttribute(phxViewportTop) || toEl.hasAttribute(phxViewportBottom))) {
        toEl.setAttribute("data-phx-hook", "Phoenix.InfiniteScroll");
      }
    },
    putCustomElHook(el, hook) {
      if (el.isConnected) {
        el.setAttribute("data-phx-hook", "");
      } else {
        console.error(`
        hook attached to non-connected DOM element
        ensure you are calling createHook within your connectedCallback. ${el.outerHTML}
      `);
      }
      this.putPrivate(el, "custom-el-hook", hook);
    },
    getCustomElHook(el) {
      return this.private(el, "custom-el-hook");
    },
    isUsedInput(el) {
      return el.nodeType === Node.ELEMENT_NODE && (this.private(el, PHX_HAS_FOCUSED) || this.private(el, PHX_HAS_SUBMITTED));
    },
    resetForm(form) {
      Array.from(form.elements).forEach((input) => {
        this.deletePrivate(input, PHX_HAS_FOCUSED);
        this.deletePrivate(input, PHX_HAS_SUBMITTED);
      });
    },
    isPhxChild(node) {
      return node.getAttribute && node.getAttribute(PHX_PARENT_ID);
    },
    isPhxSticky(node) {
      return node.getAttribute && node.getAttribute(PHX_STICKY) !== null;
    },
    isChildOfAny(el, parents) {
      return !!parents.find((parent) => parent.contains(el));
    },
    firstPhxChild(el) {
      return this.isPhxChild(el) ? el : this.all(el, `[${PHX_PARENT_ID}]`)[0];
    },
    dispatchEvent(target, name, opts = {}) {
      let defaultBubble = true;
      let isUploadTarget = target.nodeName === "INPUT" && target.type === "file";
      if (isUploadTarget && name === "click") {
        defaultBubble = false;
      }
      let bubbles = opts.bubbles === void 0 ? defaultBubble : !!opts.bubbles;
      let eventOpts = { bubbles, cancelable: true, detail: opts.detail || {} };
      let event = name === "click" ? new MouseEvent("click", eventOpts) : new CustomEvent(name, eventOpts);
      target.dispatchEvent(event);
    },
    cloneNode(node, html) {
      if (typeof html === "undefined") {
        return node.cloneNode(true);
      } else {
        let cloned = node.cloneNode(false);
        cloned.innerHTML = html;
        return cloned;
      }
    },
    // merge attributes from source to target
    // if an element is ignored, we only merge data attributes
    // including removing data attributes that are no longer in the source
    mergeAttrs(target, source, opts = {}) {
      let exclude = new Set(opts.exclude || []);
      let isIgnored = opts.isIgnored;
      let sourceAttrs = source.attributes;
      for (let i2 = sourceAttrs.length - 1; i2 >= 0; i2--) {
        let name = sourceAttrs[i2].name;
        if (!exclude.has(name)) {
          const sourceValue = source.getAttribute(name);
          if (target.getAttribute(name) !== sourceValue && (!isIgnored || isIgnored && name.startsWith("data-"))) {
            target.setAttribute(name, sourceValue);
          }
        } else {
          if (name === "value" && target.value === source.value) {
            target.setAttribute("value", source.getAttribute(name));
          }
        }
      }
      let targetAttrs = target.attributes;
      for (let i2 = targetAttrs.length - 1; i2 >= 0; i2--) {
        let name = targetAttrs[i2].name;
        if (isIgnored) {
          if (name.startsWith("data-") && !source.hasAttribute(name) && !PHX_PENDING_ATTRS.includes(name)) {
            target.removeAttribute(name);
          }
        } else {
          if (!source.hasAttribute(name)) {
            target.removeAttribute(name);
          }
        }
      }
    },
    mergeFocusedInput(target, source) {
      if (!(target instanceof HTMLSelectElement)) {
        DOM.mergeAttrs(target, source, { exclude: ["value"] });
      }
      if (source.readOnly) {
        target.setAttribute("readonly", true);
      } else {
        target.removeAttribute("readonly");
      }
    },
    hasSelectionRange(el) {
      return el.setSelectionRange && (el.type === "text" || el.type === "textarea");
    },
    restoreFocus(focused, selectionStart, selectionEnd) {
      if (focused instanceof HTMLSelectElement) {
        focused.focus();
      }
      if (!DOM.isTextualInput(focused)) {
        return;
      }
      let wasFocused = focused.matches(":focus");
      if (!wasFocused) {
        focused.focus();
      }
      if (this.hasSelectionRange(focused)) {
        focused.setSelectionRange(selectionStart, selectionEnd);
      }
    },
    isFormInput(el) {
      return /^(?:input|select|textarea)$/i.test(el.tagName) && el.type !== "button";
    },
    syncAttrsToProps(el) {
      if (el instanceof HTMLInputElement && CHECKABLE_INPUTS.indexOf(el.type.toLocaleLowerCase()) >= 0) {
        el.checked = el.getAttribute("checked") !== null;
      }
    },
    isTextualInput(el) {
      return FOCUSABLE_INPUTS.indexOf(el.type) >= 0;
    },
    isNowTriggerFormExternal(el, phxTriggerExternal) {
      return el.getAttribute && el.getAttribute(phxTriggerExternal) !== null && document.body.contains(el);
    },
    cleanChildNodes(container, phxUpdate) {
      if (DOM.isPhxUpdate(container, phxUpdate, ["append", "prepend"])) {
        let toRemove = [];
        container.childNodes.forEach((childNode) => {
          if (!childNode.id) {
            let isEmptyTextNode = childNode.nodeType === Node.TEXT_NODE && childNode.nodeValue.trim() === "";
            if (!isEmptyTextNode && childNode.nodeType !== Node.COMMENT_NODE) {
              logError(`only HTML element tags with an id are allowed inside containers with phx-update.

removing illegal node: "${(childNode.outerHTML || childNode.nodeValue).trim()}"

`);
            }
            toRemove.push(childNode);
          }
        });
        toRemove.forEach((childNode) => childNode.remove());
      }
    },
    replaceRootContainer(container, tagName, attrs) {
      let retainedAttrs = /* @__PURE__ */ new Set(["id", PHX_SESSION, PHX_STATIC, PHX_MAIN, PHX_ROOT_ID]);
      if (container.tagName.toLowerCase() === tagName.toLowerCase()) {
        Array.from(container.attributes).filter((attr) => !retainedAttrs.has(attr.name.toLowerCase())).forEach((attr) => container.removeAttribute(attr.name));
        Object.keys(attrs).filter((name) => !retainedAttrs.has(name.toLowerCase())).forEach((attr) => container.setAttribute(attr, attrs[attr]));
        return container;
      } else {
        let newContainer = document.createElement(tagName);
        Object.keys(attrs).forEach((attr) => newContainer.setAttribute(attr, attrs[attr]));
        retainedAttrs.forEach((attr) => newContainer.setAttribute(attr, container.getAttribute(attr)));
        newContainer.innerHTML = container.innerHTML;
        container.replaceWith(newContainer);
        return newContainer;
      }
    },
    getSticky(el, name, defaultVal) {
      let op = (DOM.private(el, "sticky") || []).find(([existingName]) => name === existingName);
      if (op) {
        let [_name, _op, stashedResult] = op;
        return stashedResult;
      } else {
        return typeof defaultVal === "function" ? defaultVal() : defaultVal;
      }
    },
    deleteSticky(el, name) {
      this.updatePrivate(el, "sticky", [], (ops) => {
        return ops.filter(([existingName, _]) => existingName !== name);
      });
    },
    putSticky(el, name, op) {
      let stashedResult = op(el);
      this.updatePrivate(el, "sticky", [], (ops) => {
        let existingIndex = ops.findIndex(([existingName]) => name === existingName);
        if (existingIndex >= 0) {
          ops[existingIndex] = [name, op, stashedResult];
        } else {
          ops.push([name, op, stashedResult]);
        }
        return ops;
      });
    },
    applyStickyOperations(el) {
      let ops = DOM.private(el, "sticky");
      if (!ops) {
        return;
      }
      ops.forEach(([name, op, _stashed]) => this.putSticky(el, name, op));
    },
    isLocked(el) {
      return el.hasAttribute && el.hasAttribute(PHX_REF_LOCK);
    }
  };
  var dom_default = DOM;
  var UploadEntry = class {
    static isActive(fileEl, file) {
      let isNew = file._phxRef === void 0;
      let activeRefs = fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(",");
      let isActive = activeRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;
      return file.size > 0 && (isNew || isActive);
    }
    static isPreflighted(fileEl, file) {
      let preflightedRefs = fileEl.getAttribute(PHX_PREFLIGHTED_REFS).split(",");
      let isPreflighted = preflightedRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;
      return isPreflighted && this.isActive(fileEl, file);
    }
    static isPreflightInProgress(file) {
      return file._preflightInProgress === true;
    }
    static markPreflightInProgress(file) {
      file._preflightInProgress = true;
    }
    constructor(fileEl, file, view, autoUpload) {
      this.ref = LiveUploader.genFileRef(file);
      this.fileEl = fileEl;
      this.file = file;
      this.view = view;
      this.meta = null;
      this._isCancelled = false;
      this._isDone = false;
      this._progress = 0;
      this._lastProgressSent = -1;
      this._onDone = function() {
      };
      this._onElUpdated = this.onElUpdated.bind(this);
      this.fileEl.addEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
      this.autoUpload = autoUpload;
    }
    metadata() {
      return this.meta;
    }
    progress(progress) {
      this._progress = Math.floor(progress);
      if (this._progress > this._lastProgressSent) {
        if (this._progress >= 100) {
          this._progress = 100;
          this._lastProgressSent = 100;
          this._isDone = true;
          this.view.pushFileProgress(this.fileEl, this.ref, 100, () => {
            LiveUploader.untrackFile(this.fileEl, this.file);
            this._onDone();
          });
        } else {
          this._lastProgressSent = this._progress;
          this.view.pushFileProgress(this.fileEl, this.ref, this._progress);
        }
      }
    }
    isCancelled() {
      return this._isCancelled;
    }
    cancel() {
      this.file._preflightInProgress = false;
      this._isCancelled = true;
      this._isDone = true;
      this._onDone();
    }
    isDone() {
      return this._isDone;
    }
    error(reason = "failed") {
      this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
      this.view.pushFileProgress(this.fileEl, this.ref, { error: reason });
      if (!this.isAutoUpload()) {
        LiveUploader.clearFiles(this.fileEl);
      }
    }
    isAutoUpload() {
      return this.autoUpload;
    }
    //private
    onDone(callback2) {
      this._onDone = () => {
        this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
        callback2();
      };
    }
    onElUpdated() {
      let activeRefs = this.fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(",");
      if (activeRefs.indexOf(this.ref) === -1) {
        LiveUploader.untrackFile(this.fileEl, this.file);
        this.cancel();
      }
    }
    toPreflightPayload() {
      return {
        last_modified: this.file.lastModified,
        name: this.file.name,
        relative_path: this.file.webkitRelativePath,
        size: this.file.size,
        type: this.file.type,
        ref: this.ref,
        meta: typeof this.file.meta === "function" ? this.file.meta() : void 0
      };
    }
    uploader(uploaders) {
      if (this.meta.uploader) {
        let callback2 = uploaders[this.meta.uploader] || logError(`no uploader configured for ${this.meta.uploader}`);
        return { name: this.meta.uploader, callback: callback2 };
      } else {
        return { name: "channel", callback: channelUploader };
      }
    }
    zipPostFlight(resp) {
      this.meta = resp.entries[this.ref];
      if (!this.meta) {
        logError(`no preflight upload response returned with ref ${this.ref}`, { input: this.fileEl, response: resp });
      }
    }
  };
  var liveUploaderFileRef = 0;
  var LiveUploader = class _LiveUploader {
    static genFileRef(file) {
      let ref = file._phxRef;
      if (ref !== void 0) {
        return ref;
      } else {
        file._phxRef = (liveUploaderFileRef++).toString();
        return file._phxRef;
      }
    }
    static getEntryDataURL(inputEl, ref, callback2) {
      let file = this.activeFiles(inputEl).find((file2) => this.genFileRef(file2) === ref);
      callback2(URL.createObjectURL(file));
    }
    static hasUploadsInProgress(formEl) {
      let active = 0;
      dom_default.findUploadInputs(formEl).forEach((input) => {
        if (input.getAttribute(PHX_PREFLIGHTED_REFS) !== input.getAttribute(PHX_DONE_REFS)) {
          active++;
        }
      });
      return active > 0;
    }
    static serializeUploads(inputEl) {
      let files = this.activeFiles(inputEl);
      let fileData = {};
      files.forEach((file) => {
        let entry = { path: inputEl.name };
        let uploadRef = inputEl.getAttribute(PHX_UPLOAD_REF);
        fileData[uploadRef] = fileData[uploadRef] || [];
        entry.ref = this.genFileRef(file);
        entry.last_modified = file.lastModified;
        entry.name = file.name || entry.ref;
        entry.relative_path = file.webkitRelativePath;
        entry.type = file.type;
        entry.size = file.size;
        if (typeof file.meta === "function") {
          entry.meta = file.meta();
        }
        fileData[uploadRef].push(entry);
      });
      return fileData;
    }
    static clearFiles(inputEl) {
      inputEl.value = null;
      inputEl.removeAttribute(PHX_UPLOAD_REF);
      dom_default.putPrivate(inputEl, "files", []);
    }
    static untrackFile(inputEl, file) {
      dom_default.putPrivate(inputEl, "files", dom_default.private(inputEl, "files").filter((f) => !Object.is(f, file)));
    }
    static trackFiles(inputEl, files, dataTransfer) {
      if (inputEl.getAttribute("multiple") !== null) {
        let newFiles = files.filter((file) => !this.activeFiles(inputEl).find((f) => Object.is(f, file)));
        dom_default.updatePrivate(inputEl, "files", [], (existing) => existing.concat(newFiles));
        inputEl.value = null;
      } else {
        if (dataTransfer && dataTransfer.files.length > 0) {
          inputEl.files = dataTransfer.files;
        }
        dom_default.putPrivate(inputEl, "files", files);
      }
    }
    static activeFileInputs(formEl) {
      let fileInputs = dom_default.findUploadInputs(formEl);
      return Array.from(fileInputs).filter((el) => el.files && this.activeFiles(el).length > 0);
    }
    static activeFiles(input) {
      return (dom_default.private(input, "files") || []).filter((f) => UploadEntry.isActive(input, f));
    }
    static inputsAwaitingPreflight(formEl) {
      let fileInputs = dom_default.findUploadInputs(formEl);
      return Array.from(fileInputs).filter((input) => this.filesAwaitingPreflight(input).length > 0);
    }
    static filesAwaitingPreflight(input) {
      return this.activeFiles(input).filter((f) => !UploadEntry.isPreflighted(input, f) && !UploadEntry.isPreflightInProgress(f));
    }
    static markPreflightInProgress(entries) {
      entries.forEach((entry) => UploadEntry.markPreflightInProgress(entry.file));
    }
    constructor(inputEl, view, onComplete) {
      this.autoUpload = dom_default.isAutoUpload(inputEl);
      this.view = view;
      this.onComplete = onComplete;
      this._entries = Array.from(_LiveUploader.filesAwaitingPreflight(inputEl) || []).map((file) => new UploadEntry(inputEl, file, view, this.autoUpload));
      _LiveUploader.markPreflightInProgress(this._entries);
      this.numEntriesInProgress = this._entries.length;
    }
    isAutoUpload() {
      return this.autoUpload;
    }
    entries() {
      return this._entries;
    }
    initAdapterUpload(resp, onError, liveSocket2) {
      this._entries = this._entries.map((entry) => {
        if (entry.isCancelled()) {
          this.numEntriesInProgress--;
          if (this.numEntriesInProgress === 0) {
            this.onComplete();
          }
        } else {
          entry.zipPostFlight(resp);
          entry.onDone(() => {
            this.numEntriesInProgress--;
            if (this.numEntriesInProgress === 0) {
              this.onComplete();
            }
          });
        }
        return entry;
      });
      let groupedEntries = this._entries.reduce((acc, entry) => {
        if (!entry.meta) {
          return acc;
        }
        let { name, callback: callback2 } = entry.uploader(liveSocket2.uploaders);
        acc[name] = acc[name] || { callback: callback2, entries: [] };
        acc[name].entries.push(entry);
        return acc;
      }, {});
      for (let name in groupedEntries) {
        let { callback: callback2, entries } = groupedEntries[name];
        callback2(entries, onError, resp, liveSocket2);
      }
    }
  };
  var ARIA = {
    anyOf(instance, classes) {
      return classes.find((name) => instance instanceof name);
    },
    isFocusable(el, interactiveOnly) {
      return el instanceof HTMLAnchorElement && el.rel !== "ignore" || el instanceof HTMLAreaElement && el.href !== void 0 || !el.disabled && this.anyOf(el, [HTMLInputElement, HTMLSelectElement, HTMLTextAreaElement, HTMLButtonElement]) || el instanceof HTMLIFrameElement || (el.tabIndex > 0 || !interactiveOnly && el.getAttribute("tabindex") !== null && el.getAttribute("aria-hidden") !== "true");
    },
    attemptFocus(el, interactiveOnly) {
      if (this.isFocusable(el, interactiveOnly)) {
        try {
          el.focus();
        } catch (e2) {
        }
      }
      return !!document.activeElement && document.activeElement.isSameNode(el);
    },
    focusFirstInteractive(el) {
      let child = el.firstElementChild;
      while (child) {
        if (this.attemptFocus(child, true) || this.focusFirstInteractive(child, true)) {
          return true;
        }
        child = child.nextElementSibling;
      }
    },
    focusFirst(el) {
      let child = el.firstElementChild;
      while (child) {
        if (this.attemptFocus(child) || this.focusFirst(child)) {
          return true;
        }
        child = child.nextElementSibling;
      }
    },
    focusLast(el) {
      let child = el.lastElementChild;
      while (child) {
        if (this.attemptFocus(child) || this.focusLast(child)) {
          return true;
        }
        child = child.previousElementSibling;
      }
    }
  };
  var aria_default = ARIA;
  var Hooks = {
    LiveFileUpload: {
      activeRefs() {
        return this.el.getAttribute(PHX_ACTIVE_ENTRY_REFS);
      },
      preflightedRefs() {
        return this.el.getAttribute(PHX_PREFLIGHTED_REFS);
      },
      mounted() {
        this.preflightedWas = this.preflightedRefs();
      },
      updated() {
        let newPreflights = this.preflightedRefs();
        if (this.preflightedWas !== newPreflights) {
          this.preflightedWas = newPreflights;
          if (newPreflights === "") {
            this.__view().cancelSubmit(this.el.form);
          }
        }
        if (this.activeRefs() === "") {
          this.el.value = null;
        }
        this.el.dispatchEvent(new CustomEvent(PHX_LIVE_FILE_UPDATED));
      }
    },
    LiveImgPreview: {
      mounted() {
        this.ref = this.el.getAttribute("data-phx-entry-ref");
        this.inputEl = document.getElementById(this.el.getAttribute(PHX_UPLOAD_REF));
        LiveUploader.getEntryDataURL(this.inputEl, this.ref, (url) => {
          this.url = url;
          this.el.src = url;
        });
      },
      destroyed() {
        URL.revokeObjectURL(this.url);
      }
    },
    FocusWrap: {
      mounted() {
        this.focusStart = this.el.firstElementChild;
        this.focusEnd = this.el.lastElementChild;
        this.focusStart.addEventListener("focus", (e2) => {
          if (!e2.relatedTarget || !this.el.contains(e2.relatedTarget)) {
            const nextFocus = e2.target.nextElementSibling;
            aria_default.attemptFocus(nextFocus) || aria_default.focusFirst(nextFocus);
          } else {
            aria_default.focusLast(this.el);
          }
        });
        this.focusEnd.addEventListener("focus", (e2) => {
          if (!e2.relatedTarget || !this.el.contains(e2.relatedTarget)) {
            const nextFocus = e2.target.previousElementSibling;
            aria_default.attemptFocus(nextFocus) || aria_default.focusLast(nextFocus);
          } else {
            aria_default.focusFirst(this.el);
          }
        });
        if (!this.el.contains(document.activeElement)) {
          this.el.addEventListener("phx:show-end", () => this.el.focus());
          if (window.getComputedStyle(this.el).display !== "none") {
            aria_default.focusFirst(this.el);
          }
        }
      }
    }
  };
  var findScrollContainer = (el) => {
    if (["HTML", "BODY"].indexOf(el.nodeName.toUpperCase()) >= 0)
      return null;
    if (["scroll", "auto"].indexOf(getComputedStyle(el).overflowY) >= 0)
      return el;
    return findScrollContainer(el.parentElement);
  };
  var scrollTop = (scrollContainer) => {
    if (scrollContainer) {
      return scrollContainer.scrollTop;
    } else {
      return document.documentElement.scrollTop || document.body.scrollTop;
    }
  };
  var bottom = (scrollContainer) => {
    if (scrollContainer) {
      return scrollContainer.getBoundingClientRect().bottom;
    } else {
      return window.innerHeight || document.documentElement.clientHeight;
    }
  };
  var top = (scrollContainer) => {
    if (scrollContainer) {
      return scrollContainer.getBoundingClientRect().top;
    } else {
      return 0;
    }
  };
  var isAtViewportTop = (el, scrollContainer) => {
    let rect = el.getBoundingClientRect();
    return Math.ceil(rect.top) >= top(scrollContainer) && Math.ceil(rect.left) >= 0 && Math.floor(rect.top) <= bottom(scrollContainer);
  };
  var isAtViewportBottom = (el, scrollContainer) => {
    let rect = el.getBoundingClientRect();
    return Math.ceil(rect.bottom) >= top(scrollContainer) && Math.ceil(rect.left) >= 0 && Math.floor(rect.bottom) <= bottom(scrollContainer);
  };
  var isWithinViewport = (el, scrollContainer) => {
    let rect = el.getBoundingClientRect();
    return Math.ceil(rect.top) >= top(scrollContainer) && Math.ceil(rect.left) >= 0 && Math.floor(rect.top) <= bottom(scrollContainer);
  };
  Hooks.InfiniteScroll = {
    mounted() {
      this.scrollContainer = findScrollContainer(this.el);
      let scrollBefore = scrollTop(this.scrollContainer);
      let topOverran = false;
      let throttleInterval = 500;
      let pendingOp = null;
      let onTopOverrun = this.throttle(throttleInterval, (topEvent, firstChild) => {
        pendingOp = () => true;
        this.liveSocket.execJSHookPush(this.el, topEvent, { id: firstChild.id, _overran: true }, () => {
          pendingOp = null;
        });
      });
      let onFirstChildAtTop = this.throttle(throttleInterval, (topEvent, firstChild) => {
        pendingOp = () => firstChild.scrollIntoView({ block: "start" });
        this.liveSocket.execJSHookPush(this.el, topEvent, { id: firstChild.id }, () => {
          pendingOp = null;
          window.requestAnimationFrame(() => {
            if (!isWithinViewport(firstChild, this.scrollContainer)) {
              firstChild.scrollIntoView({ block: "start" });
            }
          });
        });
      });
      let onLastChildAtBottom = this.throttle(throttleInterval, (bottomEvent, lastChild) => {
        pendingOp = () => lastChild.scrollIntoView({ block: "end" });
        this.liveSocket.execJSHookPush(this.el, bottomEvent, { id: lastChild.id }, () => {
          pendingOp = null;
          window.requestAnimationFrame(() => {
            if (!isWithinViewport(lastChild, this.scrollContainer)) {
              lastChild.scrollIntoView({ block: "end" });
            }
          });
        });
      });
      this.onScroll = (_e) => {
        let scrollNow = scrollTop(this.scrollContainer);
        if (pendingOp) {
          scrollBefore = scrollNow;
          return pendingOp();
        }
        let rect = this.el.getBoundingClientRect();
        let topEvent = this.el.getAttribute(this.liveSocket.binding("viewport-top"));
        let bottomEvent = this.el.getAttribute(this.liveSocket.binding("viewport-bottom"));
        let lastChild = this.el.lastElementChild;
        let firstChild = this.el.firstElementChild;
        let isScrollingUp = scrollNow < scrollBefore;
        let isScrollingDown = scrollNow > scrollBefore;
        if (isScrollingUp && topEvent && !topOverran && rect.top >= 0) {
          topOverran = true;
          onTopOverrun(topEvent, firstChild);
        } else if (isScrollingDown && topOverran && rect.top <= 0) {
          topOverran = false;
        }
        if (topEvent && isScrollingUp && isAtViewportTop(firstChild, this.scrollContainer)) {
          onFirstChildAtTop(topEvent, firstChild);
        } else if (bottomEvent && isScrollingDown && isAtViewportBottom(lastChild, this.scrollContainer)) {
          onLastChildAtBottom(bottomEvent, lastChild);
        }
        scrollBefore = scrollNow;
      };
      if (this.scrollContainer) {
        this.scrollContainer.addEventListener("scroll", this.onScroll);
      } else {
        window.addEventListener("scroll", this.onScroll);
      }
    },
    destroyed() {
      if (this.scrollContainer) {
        this.scrollContainer.removeEventListener("scroll", this.onScroll);
      } else {
        window.removeEventListener("scroll", this.onScroll);
      }
    },
    throttle(interval, callback2) {
      let lastCallAt = 0;
      let timer;
      return (...args) => {
        let now = Date.now();
        let remainingTime = interval - (now - lastCallAt);
        if (remainingTime <= 0 || remainingTime > interval) {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
          lastCallAt = now;
          callback2(...args);
        } else if (!timer) {
          timer = setTimeout(() => {
            lastCallAt = Date.now();
            timer = null;
            callback2(...args);
          }, remainingTime);
        }
      };
    }
  };
  var hooks_default = Hooks;
  var ElementRef = class {
    static onUnlock(el, callback2) {
      if (!dom_default.isLocked(el) && !el.closest(`[${PHX_REF_LOCK}]`)) {
        return callback2();
      }
      const closestLock = el.closest(`[${PHX_REF_LOCK}]`);
      const ref = closestLock.closest(`[${PHX_REF_LOCK}]`).getAttribute(PHX_REF_LOCK);
      closestLock.addEventListener(`phx:undo-lock:${ref}`, () => {
        callback2();
      }, { once: true });
    }
    constructor(el) {
      this.el = el;
      this.loadingRef = el.hasAttribute(PHX_REF_LOADING) ? parseInt(el.getAttribute(PHX_REF_LOADING), 10) : null;
      this.lockRef = el.hasAttribute(PHX_REF_LOCK) ? parseInt(el.getAttribute(PHX_REF_LOCK), 10) : null;
    }
    // public
    maybeUndo(ref, phxEvent, eachCloneCallback) {
      if (!this.isWithin(ref)) {
        return;
      }
      this.undoLocks(ref, phxEvent, eachCloneCallback);
      this.undoLoading(ref, phxEvent);
      if (this.isFullyResolvedBy(ref)) {
        this.el.removeAttribute(PHX_REF_SRC);
      }
    }
    // private
    isWithin(ref) {
      return !(this.loadingRef !== null && this.loadingRef > ref && (this.lockRef !== null && this.lockRef > ref));
    }
    // Check for cloned PHX_REF_LOCK element that has been morphed behind
    // the scenes while this element was locked in the DOM.
    // When we apply the cloned tree to the active DOM element, we must
    //
    //   1. execute pending mounted hooks for nodes now in the DOM
    //   2. undo any ref inside the cloned tree that has since been ack'd
    undoLocks(ref, phxEvent, eachCloneCallback) {
      if (!this.isLockUndoneBy(ref)) {
        return;
      }
      let clonedTree = dom_default.private(this.el, PHX_REF_LOCK);
      if (clonedTree) {
        eachCloneCallback(clonedTree);
        dom_default.deletePrivate(this.el, PHX_REF_LOCK);
      }
      this.el.removeAttribute(PHX_REF_LOCK);
      let opts = { detail: { ref, event: phxEvent }, bubbles: true, cancelable: false };
      this.el.dispatchEvent(new CustomEvent(`phx:undo-lock:${this.lockRef}`, opts));
    }
    undoLoading(ref, phxEvent) {
      if (!this.isLoadingUndoneBy(ref)) {
        if (this.canUndoLoading(ref) && this.el.classList.contains("phx-submit-loading")) {
          this.el.classList.remove("phx-change-loading");
        }
        return;
      }
      if (this.canUndoLoading(ref)) {
        this.el.removeAttribute(PHX_REF_LOADING);
        let disabledVal = this.el.getAttribute(PHX_DISABLED);
        let readOnlyVal = this.el.getAttribute(PHX_READONLY);
        if (readOnlyVal !== null) {
          this.el.readOnly = readOnlyVal === "true" ? true : false;
          this.el.removeAttribute(PHX_READONLY);
        }
        if (disabledVal !== null) {
          this.el.disabled = disabledVal === "true" ? true : false;
          this.el.removeAttribute(PHX_DISABLED);
        }
        let disableRestore = this.el.getAttribute(PHX_DISABLE_WITH_RESTORE);
        if (disableRestore !== null) {
          this.el.innerText = disableRestore;
          this.el.removeAttribute(PHX_DISABLE_WITH_RESTORE);
        }
        let opts = { detail: { ref, event: phxEvent }, bubbles: true, cancelable: false };
        this.el.dispatchEvent(new CustomEvent(`phx:undo-loading:${this.loadingRef}`, opts));
      }
      PHX_EVENT_CLASSES.forEach((name) => {
        if (name !== "phx-submit-loading" || this.canUndoLoading(ref)) {
          dom_default.removeClass(this.el, name);
        }
      });
    }
    isLoadingUndoneBy(ref) {
      return this.loadingRef === null ? false : this.loadingRef <= ref;
    }
    isLockUndoneBy(ref) {
      return this.lockRef === null ? false : this.lockRef <= ref;
    }
    isFullyResolvedBy(ref) {
      return (this.loadingRef === null || this.loadingRef <= ref) && (this.lockRef === null || this.lockRef <= ref);
    }
    // only remove the phx-submit-loading class if we are not locked
    canUndoLoading(ref) {
      return this.lockRef === null || this.lockRef <= ref;
    }
  };
  var DOMPostMorphRestorer = class {
    constructor(containerBefore, containerAfter, updateType) {
      let idsBefore = /* @__PURE__ */ new Set();
      let idsAfter = new Set([...containerAfter.children].map((child) => child.id));
      let elementsToModify = [];
      Array.from(containerBefore.children).forEach((child) => {
        if (child.id) {
          idsBefore.add(child.id);
          if (idsAfter.has(child.id)) {
            let previousElementId = child.previousElementSibling && child.previousElementSibling.id;
            elementsToModify.push({ elementId: child.id, previousElementId });
          }
        }
      });
      this.containerId = containerAfter.id;
      this.updateType = updateType;
      this.elementsToModify = elementsToModify;
      this.elementIdsToAdd = [...idsAfter].filter((id) => !idsBefore.has(id));
    }
    // We do the following to optimize append/prepend operations:
    //   1) Track ids of modified elements & of new elements
    //   2) All the modified elements are put back in the correct position in the DOM tree
    //      by storing the id of their previous sibling
    //   3) New elements are going to be put in the right place by morphdom during append.
    //      For prepend, we move them to the first position in the container
    perform() {
      let container = dom_default.byId(this.containerId);
      this.elementsToModify.forEach((elementToModify) => {
        if (elementToModify.previousElementId) {
          maybe(document.getElementById(elementToModify.previousElementId), (previousElem) => {
            maybe(document.getElementById(elementToModify.elementId), (elem) => {
              let isInRightPlace = elem.previousElementSibling && elem.previousElementSibling.id == previousElem.id;
              if (!isInRightPlace) {
                previousElem.insertAdjacentElement("afterend", elem);
              }
            });
          });
        } else {
          maybe(document.getElementById(elementToModify.elementId), (elem) => {
            let isInRightPlace = elem.previousElementSibling == null;
            if (!isInRightPlace) {
              container.insertAdjacentElement("afterbegin", elem);
            }
          });
        }
      });
      if (this.updateType == "prepend") {
        this.elementIdsToAdd.reverse().forEach((elemId) => {
          maybe(document.getElementById(elemId), (elem) => container.insertAdjacentElement("afterbegin", elem));
        });
      }
    }
  };
  var DOCUMENT_FRAGMENT_NODE = 11;
  function morphAttrs(fromNode, toNode) {
    var toNodeAttrs = toNode.attributes;
    var attr;
    var attrName;
    var attrNamespaceURI;
    var attrValue;
    var fromValue;
    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return;
    }
    for (var i2 = toNodeAttrs.length - 1; i2 >= 0; i2--) {
      attr = toNodeAttrs[i2];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      attrValue = attr.value;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);
        if (fromValue !== attrValue) {
          if (attr.prefix === "xmlns") {
            attrName = attr.name;
          }
          fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
        }
      } else {
        fromValue = fromNode.getAttribute(attrName);
        if (fromValue !== attrValue) {
          fromNode.setAttribute(attrName, attrValue);
        }
      }
    }
    var fromNodeAttrs = fromNode.attributes;
    for (var d2 = fromNodeAttrs.length - 1; d2 >= 0; d2--) {
      attr = fromNodeAttrs[d2];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {
          fromNode.removeAttributeNS(attrNamespaceURI, attrName);
        }
      } else {
        if (!toNode.hasAttribute(attrName)) {
          fromNode.removeAttribute(attrName);
        }
      }
    }
  }
  var range;
  var NS_XHTML = "http://www.w3.org/1999/xhtml";
  var doc = typeof document === "undefined" ? void 0 : document;
  var HAS_TEMPLATE_SUPPORT = !!doc && "content" in doc.createElement("template");
  var HAS_RANGE_SUPPORT = !!doc && doc.createRange && "createContextualFragment" in doc.createRange();
  function createFragmentFromTemplate(str) {
    var template = doc.createElement("template");
    template.innerHTML = str;
    return template.content.childNodes[0];
  }
  function createFragmentFromRange(str) {
    if (!range) {
      range = doc.createRange();
      range.selectNode(doc.body);
    }
    var fragment = range.createContextualFragment(str);
    return fragment.childNodes[0];
  }
  function createFragmentFromWrap(str) {
    var fragment = doc.createElement("body");
    fragment.innerHTML = str;
    return fragment.childNodes[0];
  }
  function toElement(str) {
    str = str.trim();
    if (HAS_TEMPLATE_SUPPORT) {
      return createFragmentFromTemplate(str);
    } else if (HAS_RANGE_SUPPORT) {
      return createFragmentFromRange(str);
    }
    return createFragmentFromWrap(str);
  }
  function compareNodeNames(fromEl, toEl) {
    var fromNodeName = fromEl.nodeName;
    var toNodeName = toEl.nodeName;
    var fromCodeStart, toCodeStart;
    if (fromNodeName === toNodeName) {
      return true;
    }
    fromCodeStart = fromNodeName.charCodeAt(0);
    toCodeStart = toNodeName.charCodeAt(0);
    if (fromCodeStart <= 90 && toCodeStart >= 97) {
      return fromNodeName === toNodeName.toUpperCase();
    } else if (toCodeStart <= 90 && fromCodeStart >= 97) {
      return toNodeName === fromNodeName.toUpperCase();
    } else {
      return false;
    }
  }
  function createElementNS(name, namespaceURI) {
    return !namespaceURI || namespaceURI === NS_XHTML ? doc.createElement(name) : doc.createElementNS(namespaceURI, name);
  }
  function moveChildren(fromEl, toEl) {
    var curChild = fromEl.firstChild;
    while (curChild) {
      var nextChild = curChild.nextSibling;
      toEl.appendChild(curChild);
      curChild = nextChild;
    }
    return toEl;
  }
  function syncBooleanAttrProp(fromEl, toEl, name) {
    if (fromEl[name] !== toEl[name]) {
      fromEl[name] = toEl[name];
      if (fromEl[name]) {
        fromEl.setAttribute(name, "");
      } else {
        fromEl.removeAttribute(name);
      }
    }
  }
  var specialElHandlers = {
    OPTION: function(fromEl, toEl) {
      var parentNode = fromEl.parentNode;
      if (parentNode) {
        var parentName = parentNode.nodeName.toUpperCase();
        if (parentName === "OPTGROUP") {
          parentNode = parentNode.parentNode;
          parentName = parentNode && parentNode.nodeName.toUpperCase();
        }
        if (parentName === "SELECT" && !parentNode.hasAttribute("multiple")) {
          if (fromEl.hasAttribute("selected") && !toEl.selected) {
            fromEl.setAttribute("selected", "selected");
            fromEl.removeAttribute("selected");
          }
          parentNode.selectedIndex = -1;
        }
      }
      syncBooleanAttrProp(fromEl, toEl, "selected");
    },
    /**
     * The "value" attribute is special for the <input> element since it sets
     * the initial value. Changing the "value" attribute without changing the
     * "value" property will have no effect since it is only used to the set the
     * initial value.  Similar for the "checked" attribute, and "disabled".
     */
    INPUT: function(fromEl, toEl) {
      syncBooleanAttrProp(fromEl, toEl, "checked");
      syncBooleanAttrProp(fromEl, toEl, "disabled");
      if (fromEl.value !== toEl.value) {
        fromEl.value = toEl.value;
      }
      if (!toEl.hasAttribute("value")) {
        fromEl.removeAttribute("value");
      }
    },
    TEXTAREA: function(fromEl, toEl) {
      var newValue = toEl.value;
      if (fromEl.value !== newValue) {
        fromEl.value = newValue;
      }
      var firstChild = fromEl.firstChild;
      if (firstChild) {
        var oldValue = firstChild.nodeValue;
        if (oldValue == newValue || !newValue && oldValue == fromEl.placeholder) {
          return;
        }
        firstChild.nodeValue = newValue;
      }
    },
    SELECT: function(fromEl, toEl) {
      if (!toEl.hasAttribute("multiple")) {
        var selectedIndex = -1;
        var i2 = 0;
        var curChild = fromEl.firstChild;
        var optgroup;
        var nodeName;
        while (curChild) {
          nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();
          if (nodeName === "OPTGROUP") {
            optgroup = curChild;
            curChild = optgroup.firstChild;
          } else {
            if (nodeName === "OPTION") {
              if (curChild.hasAttribute("selected")) {
                selectedIndex = i2;
                break;
              }
              i2++;
            }
            curChild = curChild.nextSibling;
            if (!curChild && optgroup) {
              curChild = optgroup.nextSibling;
              optgroup = null;
            }
          }
        }
        fromEl.selectedIndex = selectedIndex;
      }
    }
  };
  var ELEMENT_NODE = 1;
  var DOCUMENT_FRAGMENT_NODE$1 = 11;
  var TEXT_NODE = 3;
  var COMMENT_NODE = 8;
  function noop() {
  }
  function defaultGetNodeKey(node) {
    if (node) {
      return node.getAttribute && node.getAttribute("id") || node.id;
    }
  }
  function morphdomFactory(morphAttrs2) {
    return function morphdom2(fromNode, toNode, options) {
      if (!options) {
        options = {};
      }
      if (typeof toNode === "string") {
        if (fromNode.nodeName === "#document" || fromNode.nodeName === "HTML" || fromNode.nodeName === "BODY") {
          var toNodeHtml = toNode;
          toNode = doc.createElement("html");
          toNode.innerHTML = toNodeHtml;
        } else {
          toNode = toElement(toNode);
        }
      } else if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
        toNode = toNode.firstElementChild;
      }
      var getNodeKey = options.getNodeKey || defaultGetNodeKey;
      var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;
      var onNodeAdded = options.onNodeAdded || noop;
      var onBeforeElUpdated = options.onBeforeElUpdated || noop;
      var onElUpdated = options.onElUpdated || noop;
      var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;
      var onNodeDiscarded = options.onNodeDiscarded || noop;
      var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;
      var skipFromChildren = options.skipFromChildren || noop;
      var addChild = options.addChild || function(parent, child) {
        return parent.appendChild(child);
      };
      var childrenOnly = options.childrenOnly === true;
      var fromNodesLookup = /* @__PURE__ */ Object.create(null);
      var keyedRemovalList = [];
      function addKeyedRemoval(key) {
        keyedRemovalList.push(key);
      }
      function walkDiscardedChildNodes(node, skipKeyedNodes) {
        if (node.nodeType === ELEMENT_NODE) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = void 0;
            if (skipKeyedNodes && (key = getNodeKey(curChild))) {
              addKeyedRemoval(key);
            } else {
              onNodeDiscarded(curChild);
              if (curChild.firstChild) {
                walkDiscardedChildNodes(curChild, skipKeyedNodes);
              }
            }
            curChild = curChild.nextSibling;
          }
        }
      }
      function removeNode(node, parentNode, skipKeyedNodes) {
        if (onBeforeNodeDiscarded(node) === false) {
          return;
        }
        if (parentNode) {
          parentNode.removeChild(node);
        }
        onNodeDiscarded(node);
        walkDiscardedChildNodes(node, skipKeyedNodes);
      }
      function indexTree(node) {
        if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = getNodeKey(curChild);
            if (key) {
              fromNodesLookup[key] = curChild;
            }
            indexTree(curChild);
            curChild = curChild.nextSibling;
          }
        }
      }
      indexTree(fromNode);
      function handleNodeAdded(el) {
        onNodeAdded(el);
        var curChild = el.firstChild;
        while (curChild) {
          var nextSibling = curChild.nextSibling;
          var key = getNodeKey(curChild);
          if (key) {
            var unmatchedFromEl = fromNodesLookup[key];
            if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {
              curChild.parentNode.replaceChild(unmatchedFromEl, curChild);
              morphEl(unmatchedFromEl, curChild);
            } else {
              handleNodeAdded(curChild);
            }
          } else {
            handleNodeAdded(curChild);
          }
          curChild = nextSibling;
        }
      }
      function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {
        while (curFromNodeChild) {
          var fromNextSibling = curFromNodeChild.nextSibling;
          if (curFromNodeKey = getNodeKey(curFromNodeChild)) {
            addKeyedRemoval(curFromNodeKey);
          } else {
            removeNode(
              curFromNodeChild,
              fromEl,
              true
              /* skip keyed nodes */
            );
          }
          curFromNodeChild = fromNextSibling;
        }
      }
      function morphEl(fromEl, toEl, childrenOnly2) {
        var toElKey = getNodeKey(toEl);
        if (toElKey) {
          delete fromNodesLookup[toElKey];
        }
        if (!childrenOnly2) {
          var beforeUpdateResult = onBeforeElUpdated(fromEl, toEl);
          if (beforeUpdateResult === false) {
            return;
          } else if (beforeUpdateResult instanceof HTMLElement) {
            fromEl = beforeUpdateResult;
            indexTree(fromEl);
          }
          morphAttrs2(fromEl, toEl);
          onElUpdated(fromEl);
          if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {
            return;
          }
        }
        if (fromEl.nodeName !== "TEXTAREA") {
          morphChildren(fromEl, toEl);
        } else {
          specialElHandlers.TEXTAREA(fromEl, toEl);
        }
      }
      function morphChildren(fromEl, toEl) {
        var skipFrom = skipFromChildren(fromEl, toEl);
        var curToNodeChild = toEl.firstChild;
        var curFromNodeChild = fromEl.firstChild;
        var curToNodeKey;
        var curFromNodeKey;
        var fromNextSibling;
        var toNextSibling;
        var matchingFromEl;
        outer:
          while (curToNodeChild) {
            toNextSibling = curToNodeChild.nextSibling;
            curToNodeKey = getNodeKey(curToNodeChild);
            while (!skipFrom && curFromNodeChild) {
              fromNextSibling = curFromNodeChild.nextSibling;
              if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              curFromNodeKey = getNodeKey(curFromNodeChild);
              var curFromNodeType = curFromNodeChild.nodeType;
              var isCompatible = void 0;
              if (curFromNodeType === curToNodeChild.nodeType) {
                if (curFromNodeType === ELEMENT_NODE) {
                  if (curToNodeKey) {
                    if (curToNodeKey !== curFromNodeKey) {
                      if (matchingFromEl = fromNodesLookup[curToNodeKey]) {
                        if (fromNextSibling === matchingFromEl) {
                          isCompatible = false;
                        } else {
                          fromEl.insertBefore(matchingFromEl, curFromNodeChild);
                          if (curFromNodeKey) {
                            addKeyedRemoval(curFromNodeKey);
                          } else {
                            removeNode(
                              curFromNodeChild,
                              fromEl,
                              true
                              /* skip keyed nodes */
                            );
                          }
                          curFromNodeChild = matchingFromEl;
                          curFromNodeKey = getNodeKey(curFromNodeChild);
                        }
                      } else {
                        isCompatible = false;
                      }
                    }
                  } else if (curFromNodeKey) {
                    isCompatible = false;
                  }
                  isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);
                  if (isCompatible) {
                    morphEl(curFromNodeChild, curToNodeChild);
                  }
                } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {
                  isCompatible = true;
                  if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {
                    curFromNodeChild.nodeValue = curToNodeChild.nodeValue;
                  }
                }
              }
              if (isCompatible) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              if (curFromNodeKey) {
                addKeyedRemoval(curFromNodeKey);
              } else {
                removeNode(
                  curFromNodeChild,
                  fromEl,
                  true
                  /* skip keyed nodes */
                );
              }
              curFromNodeChild = fromNextSibling;
            }
            if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {
              if (!skipFrom) {
                addChild(fromEl, matchingFromEl);
              }
              morphEl(matchingFromEl, curToNodeChild);
            } else {
              var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);
              if (onBeforeNodeAddedResult !== false) {
                if (onBeforeNodeAddedResult) {
                  curToNodeChild = onBeforeNodeAddedResult;
                }
                if (curToNodeChild.actualize) {
                  curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);
                }
                addChild(fromEl, curToNodeChild);
                handleNodeAdded(curToNodeChild);
              }
            }
            curToNodeChild = toNextSibling;
            curFromNodeChild = fromNextSibling;
          }
        cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);
        var specialElHandler = specialElHandlers[fromEl.nodeName];
        if (specialElHandler) {
          specialElHandler(fromEl, toEl);
        }
      }
      var morphedNode = fromNode;
      var morphedNodeType = morphedNode.nodeType;
      var toNodeType = toNode.nodeType;
      if (!childrenOnly) {
        if (morphedNodeType === ELEMENT_NODE) {
          if (toNodeType === ELEMENT_NODE) {
            if (!compareNodeNames(fromNode, toNode)) {
              onNodeDiscarded(fromNode);
              morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));
            }
          } else {
            morphedNode = toNode;
          }
        } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) {
          if (toNodeType === morphedNodeType) {
            if (morphedNode.nodeValue !== toNode.nodeValue) {
              morphedNode.nodeValue = toNode.nodeValue;
            }
            return morphedNode;
          } else {
            morphedNode = toNode;
          }
        }
      }
      if (morphedNode === toNode) {
        onNodeDiscarded(fromNode);
      } else {
        if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {
          return;
        }
        morphEl(morphedNode, toNode, childrenOnly);
        if (keyedRemovalList) {
          for (var i2 = 0, len = keyedRemovalList.length; i2 < len; i2++) {
            var elToRemove = fromNodesLookup[keyedRemovalList[i2]];
            if (elToRemove) {
              removeNode(elToRemove, elToRemove.parentNode, false);
            }
          }
        }
      }
      if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {
        if (morphedNode.actualize) {
          morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);
        }
        fromNode.parentNode.replaceChild(morphedNode, fromNode);
      }
      return morphedNode;
    };
  }
  var morphdom = morphdomFactory(morphAttrs);
  var morphdom_esm_default = morphdom;
  var DOMPatch = class {
    constructor(view, container, id, html, streams, targetCID, opts = {}) {
      this.view = view;
      this.liveSocket = view.liveSocket;
      this.container = container;
      this.id = id;
      this.rootID = view.root.id;
      this.html = html;
      this.streams = streams;
      this.streamInserts = {};
      this.streamComponentRestore = {};
      this.targetCID = targetCID;
      this.cidPatch = isCid(this.targetCID);
      this.pendingRemoves = [];
      this.phxRemove = this.liveSocket.binding("remove");
      this.targetContainer = this.isCIDPatch() ? this.targetCIDContainer(html) : container;
      this.callbacks = {
        beforeadded: [],
        beforeupdated: [],
        beforephxChildAdded: [],
        afteradded: [],
        afterupdated: [],
        afterdiscarded: [],
        afterphxChildAdded: [],
        aftertransitionsDiscarded: []
      };
      this.withChildren = opts.withChildren || opts.undoRef || false;
      this.undoRef = opts.undoRef;
    }
    before(kind, callback2) {
      this.callbacks[`before${kind}`].push(callback2);
    }
    after(kind, callback2) {
      this.callbacks[`after${kind}`].push(callback2);
    }
    trackBefore(kind, ...args) {
      this.callbacks[`before${kind}`].forEach((callback2) => callback2(...args));
    }
    trackAfter(kind, ...args) {
      this.callbacks[`after${kind}`].forEach((callback2) => callback2(...args));
    }
    markPrunableContentForRemoval() {
      let phxUpdate = this.liveSocket.binding(PHX_UPDATE);
      dom_default.all(this.container, `[${phxUpdate}=append] > *, [${phxUpdate}=prepend] > *`, (el) => {
        el.setAttribute(PHX_PRUNE, "");
      });
    }
    perform(isJoinPatch) {
      let { view, liveSocket: liveSocket2, html, container, targetContainer } = this;
      if (this.isCIDPatch() && !targetContainer) {
        return;
      }
      let focused = liveSocket2.getActiveElement();
      let { selectionStart, selectionEnd } = focused && dom_default.hasSelectionRange(focused) ? focused : {};
      let phxUpdate = liveSocket2.binding(PHX_UPDATE);
      let phxViewportTop = liveSocket2.binding(PHX_VIEWPORT_TOP);
      let phxViewportBottom = liveSocket2.binding(PHX_VIEWPORT_BOTTOM);
      let phxTriggerExternal = liveSocket2.binding(PHX_TRIGGER_ACTION);
      let added = [];
      let updates = [];
      let appendPrependUpdates = [];
      let externalFormTriggered = null;
      function morph(targetContainer2, source, withChildren = this.withChildren) {
        let morphCallbacks = {
          // normally, we are running with childrenOnly, as the patch HTML for a LV
          // does not include the LV attrs (data-phx-session, etc.)
          // when we are patching a live component, we do want to patch the root element as well;
          // another case is the recursive patch of a stream item that was kept on reset (-> onBeforeNodeAdded)
          childrenOnly: targetContainer2.getAttribute(PHX_COMPONENT) === null && !withChildren,
          getNodeKey: (node) => {
            if (dom_default.isPhxDestroyed(node)) {
              return null;
            }
            if (isJoinPatch) {
              return node.id;
            }
            return node.id || node.getAttribute && node.getAttribute(PHX_MAGIC_ID);
          },
          // skip indexing from children when container is stream
          skipFromChildren: (from2) => {
            return from2.getAttribute(phxUpdate) === PHX_STREAM;
          },
          // tell morphdom how to add a child
          addChild: (parent, child) => {
            let { ref, streamAt } = this.getStreamInsert(child);
            if (ref === void 0) {
              return parent.appendChild(child);
            }
            this.setStreamRef(child, ref);
            if (streamAt === 0) {
              parent.insertAdjacentElement("afterbegin", child);
            } else if (streamAt === -1) {
              let lastChild = parent.lastElementChild;
              if (lastChild && !lastChild.hasAttribute(PHX_STREAM_REF)) {
                let nonStreamChild = Array.from(parent.children).find((c2) => !c2.hasAttribute(PHX_STREAM_REF));
                parent.insertBefore(child, nonStreamChild);
              } else {
                parent.appendChild(child);
              }
            } else if (streamAt > 0) {
              let sibling = Array.from(parent.children)[streamAt];
              parent.insertBefore(child, sibling);
            }
          },
          onBeforeNodeAdded: (el) => {
            dom_default.maintainPrivateHooks(el, el, phxViewportTop, phxViewportBottom);
            this.trackBefore("added", el);
            let morphedEl = el;
            if (this.streamComponentRestore[el.id]) {
              morphedEl = this.streamComponentRestore[el.id];
              delete this.streamComponentRestore[el.id];
              morph.call(this, morphedEl, el, true);
            }
            return morphedEl;
          },
          onNodeAdded: (el) => {
            if (el.getAttribute) {
              this.maybeReOrderStream(el, true);
            }
            if (el instanceof HTMLImageElement && el.srcset) {
              el.srcset = el.srcset;
            } else if (el instanceof HTMLVideoElement && el.autoplay) {
              el.play();
            }
            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {
              externalFormTriggered = el;
            }
            if (dom_default.isPhxChild(el) && view.ownsElement(el) || dom_default.isPhxSticky(el) && view.ownsElement(el.parentNode)) {
              this.trackAfter("phxChildAdded", el);
            }
            added.push(el);
          },
          onNodeDiscarded: (el) => this.onNodeDiscarded(el),
          onBeforeNodeDiscarded: (el) => {
            if (el.getAttribute && el.getAttribute(PHX_PRUNE) !== null) {
              return true;
            }
            if (el.parentElement !== null && el.id && dom_default.isPhxUpdate(el.parentElement, phxUpdate, [PHX_STREAM, "append", "prepend"])) {
              return false;
            }
            if (this.maybePendingRemove(el)) {
              return false;
            }
            if (this.skipCIDSibling(el)) {
              return false;
            }
            return true;
          },
          onElUpdated: (el) => {
            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {
              externalFormTriggered = el;
            }
            updates.push(el);
            this.maybeReOrderStream(el, false);
          },
          onBeforeElUpdated: (fromEl, toEl) => {
            if (fromEl.id && fromEl.isSameNode(targetContainer2) && fromEl.id !== toEl.id) {
              morphCallbacks.onNodeDiscarded(fromEl);
              fromEl.replaceWith(toEl);
              return morphCallbacks.onNodeAdded(toEl);
            }
            dom_default.syncPendingAttrs(fromEl, toEl);
            dom_default.maintainPrivateHooks(fromEl, toEl, phxViewportTop, phxViewportBottom);
            dom_default.cleanChildNodes(toEl, phxUpdate);
            if (this.skipCIDSibling(toEl)) {
              this.maybeReOrderStream(fromEl);
              return false;
            }
            if (dom_default.isPhxSticky(fromEl)) {
              [PHX_SESSION, PHX_STATIC, PHX_ROOT_ID].map((attr) => [attr, fromEl.getAttribute(attr), toEl.getAttribute(attr)]).forEach(([attr, fromVal, toVal]) => {
                if (toVal && fromVal !== toVal) {
                  fromEl.setAttribute(attr, toVal);
                }
              });
              return false;
            }
            if (dom_default.isIgnored(fromEl, phxUpdate) || fromEl.form && fromEl.form.isSameNode(externalFormTriggered)) {
              this.trackBefore("updated", fromEl, toEl);
              dom_default.mergeAttrs(fromEl, toEl, { isIgnored: dom_default.isIgnored(fromEl, phxUpdate) });
              updates.push(fromEl);
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            if (fromEl.type === "number" && (fromEl.validity && fromEl.validity.badInput)) {
              return false;
            }
            let isFocusedFormEl = focused && fromEl.isSameNode(focused) && dom_default.isFormInput(fromEl);
            let focusedSelectChanged = isFocusedFormEl && this.isChangedSelect(fromEl, toEl);
            if (fromEl.hasAttribute(PHX_REF_SRC) && fromEl.getAttribute(PHX_REF_LOCK) != this.undoRef) {
              if (dom_default.isUploadInput(fromEl)) {
                dom_default.mergeAttrs(fromEl, toEl, { isIgnored: true });
                this.trackBefore("updated", fromEl, toEl);
                updates.push(fromEl);
              }
              dom_default.applyStickyOperations(fromEl);
              let isLocked = fromEl.hasAttribute(PHX_REF_LOCK);
              let clone22 = isLocked ? dom_default.private(fromEl, PHX_REF_LOCK) || fromEl.cloneNode(true) : null;
              if (clone22) {
                dom_default.putPrivate(fromEl, PHX_REF_LOCK, clone22);
                if (!isFocusedFormEl) {
                  fromEl = clone22;
                }
              }
            }
            if (dom_default.isPhxChild(toEl)) {
              let prevSession = fromEl.getAttribute(PHX_SESSION);
              dom_default.mergeAttrs(fromEl, toEl, { exclude: [PHX_STATIC] });
              if (prevSession !== "") {
                fromEl.setAttribute(PHX_SESSION, prevSession);
              }
              fromEl.setAttribute(PHX_ROOT_ID, this.rootID);
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            dom_default.copyPrivates(toEl, fromEl);
            if (isFocusedFormEl && fromEl.type !== "hidden" && !focusedSelectChanged) {
              this.trackBefore("updated", fromEl, toEl);
              dom_default.mergeFocusedInput(fromEl, toEl);
              dom_default.syncAttrsToProps(fromEl);
              updates.push(fromEl);
              dom_default.applyStickyOperations(fromEl);
              return false;
            } else {
              if (focusedSelectChanged) {
                fromEl.blur();
              }
              if (dom_default.isPhxUpdate(toEl, phxUpdate, ["append", "prepend"])) {
                appendPrependUpdates.push(new DOMPostMorphRestorer(fromEl, toEl, toEl.getAttribute(phxUpdate)));
              }
              dom_default.syncAttrsToProps(toEl);
              dom_default.applyStickyOperations(toEl);
              this.trackBefore("updated", fromEl, toEl);
              return fromEl;
            }
          }
        };
        morphdom_esm_default(targetContainer2, source, morphCallbacks);
      }
      this.trackBefore("added", container);
      this.trackBefore("updated", container, container);
      liveSocket2.time("morphdom", () => {
        this.streams.forEach(([ref, inserts, deleteIds, reset]) => {
          inserts.forEach(([key, streamAt, limit]) => {
            this.streamInserts[key] = { ref, streamAt, limit, reset };
          });
          if (reset !== void 0) {
            dom_default.all(container, `[${PHX_STREAM_REF}="${ref}"]`, (child) => {
              this.removeStreamChildElement(child);
            });
          }
          deleteIds.forEach((id) => {
            let child = container.querySelector(`[id="${id}"]`);
            if (child) {
              this.removeStreamChildElement(child);
            }
          });
        });
        if (isJoinPatch) {
          dom_default.all(this.container, `[${phxUpdate}=${PHX_STREAM}]`, (el) => {
            this.liveSocket.owner(el, (view2) => {
              if (view2 === this.view) {
                Array.from(el.children).forEach((child) => {
                  this.removeStreamChildElement(child);
                });
              }
            });
          });
        }
        morph.call(this, targetContainer, html);
      });
      if (liveSocket2.isDebugEnabled()) {
        detectDuplicateIds();
        detectInvalidStreamInserts(this.streamInserts);
        Array.from(document.querySelectorAll("input[name=id]")).forEach((node) => {
          if (node.form) {
            console.error('Detected an input with name="id" inside a form! This will cause problems when patching the DOM.\n', node);
          }
        });
      }
      if (appendPrependUpdates.length > 0) {
        liveSocket2.time("post-morph append/prepend restoration", () => {
          appendPrependUpdates.forEach((update) => update.perform());
        });
      }
      liveSocket2.silenceEvents(() => dom_default.restoreFocus(focused, selectionStart, selectionEnd));
      dom_default.dispatchEvent(document, "phx:update");
      added.forEach((el) => this.trackAfter("added", el));
      updates.forEach((el) => this.trackAfter("updated", el));
      this.transitionPendingRemoves();
      if (externalFormTriggered) {
        liveSocket2.unload();
        Object.getPrototypeOf(externalFormTriggered).submit.call(externalFormTriggered);
      }
      return true;
    }
    onNodeDiscarded(el) {
      if (dom_default.isPhxChild(el) || dom_default.isPhxSticky(el)) {
        this.liveSocket.destroyViewByEl(el);
      }
      this.trackAfter("discarded", el);
    }
    maybePendingRemove(node) {
      if (node.getAttribute && node.getAttribute(this.phxRemove) !== null) {
        this.pendingRemoves.push(node);
        return true;
      } else {
        return false;
      }
    }
    removeStreamChildElement(child) {
      if (this.streamInserts[child.id]) {
        this.streamComponentRestore[child.id] = child;
        child.remove();
      } else {
        if (!this.maybePendingRemove(child)) {
          child.remove();
          this.onNodeDiscarded(child);
        }
      }
    }
    getStreamInsert(el) {
      let insert = el.id ? this.streamInserts[el.id] : {};
      return insert || {};
    }
    setStreamRef(el, ref) {
      dom_default.putSticky(el, PHX_STREAM_REF, (el2) => el2.setAttribute(PHX_STREAM_REF, ref));
    }
    maybeReOrderStream(el, isNew) {
      let { ref, streamAt, reset } = this.getStreamInsert(el);
      if (streamAt === void 0) {
        return;
      }
      this.setStreamRef(el, ref);
      if (!reset && !isNew) {
        return;
      }
      if (!el.parentElement) {
        return;
      }
      if (streamAt === 0) {
        el.parentElement.insertBefore(el, el.parentElement.firstElementChild);
      } else if (streamAt > 0) {
        let children = Array.from(el.parentElement.children);
        let oldIndex = children.indexOf(el);
        if (streamAt >= children.length - 1) {
          el.parentElement.appendChild(el);
        } else {
          let sibling = children[streamAt];
          if (oldIndex > streamAt) {
            el.parentElement.insertBefore(el, sibling);
          } else {
            el.parentElement.insertBefore(el, sibling.nextElementSibling);
          }
        }
      }
      this.maybeLimitStream(el);
    }
    maybeLimitStream(el) {
      let { limit } = this.getStreamInsert(el);
      let children = limit !== null && Array.from(el.parentElement.children);
      if (limit && limit < 0 && children.length > limit * -1) {
        children.slice(0, children.length + limit).forEach((child) => this.removeStreamChildElement(child));
      } else if (limit && limit >= 0 && children.length > limit) {
        children.slice(limit).forEach((child) => this.removeStreamChildElement(child));
      }
    }
    transitionPendingRemoves() {
      let { pendingRemoves, liveSocket: liveSocket2 } = this;
      if (pendingRemoves.length > 0) {
        liveSocket2.transitionRemoves(pendingRemoves, () => {
          pendingRemoves.forEach((el) => {
            let child = dom_default.firstPhxChild(el);
            if (child) {
              liveSocket2.destroyViewByEl(child);
            }
            el.remove();
          });
          this.trackAfter("transitionsDiscarded", pendingRemoves);
        });
      }
    }
    isChangedSelect(fromEl, toEl) {
      if (!(fromEl instanceof HTMLSelectElement) || fromEl.multiple) {
        return false;
      }
      if (fromEl.options.length !== toEl.options.length) {
        return true;
      }
      toEl.value = fromEl.value;
      return !fromEl.isEqualNode(toEl);
    }
    isCIDPatch() {
      return this.cidPatch;
    }
    skipCIDSibling(el) {
      return el.nodeType === Node.ELEMENT_NODE && el.hasAttribute(PHX_SKIP);
    }
    targetCIDContainer(html) {
      if (!this.isCIDPatch()) {
        return;
      }
      let [first, ...rest] = dom_default.findComponentNodeList(this.container, this.targetCID);
      if (rest.length === 0 && dom_default.childNodeLength(html) === 1) {
        return first;
      } else {
        return first && first.parentNode;
      }
    }
    indexOf(parent, child) {
      return Array.from(parent.children).indexOf(child);
    }
  };
  var VOID_TAGS = /* @__PURE__ */ new Set([
    "area",
    "base",
    "br",
    "col",
    "command",
    "embed",
    "hr",
    "img",
    "input",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  var quoteChars = /* @__PURE__ */ new Set(["'", '"']);
  var modifyRoot = (html, attrs, clearInnerHTML) => {
    let i2 = 0;
    let insideComment = false;
    let beforeTag, afterTag, tag, tagNameEndsAt, id, newHTML;
    let lookahead = html.match(/^(\s*(?:<!--.*?-->\s*)*)<([^\s\/>]+)/);
    if (lookahead === null) {
      throw new Error(`malformed html ${html}`);
    }
    i2 = lookahead[0].length;
    beforeTag = lookahead[1];
    tag = lookahead[2];
    tagNameEndsAt = i2;
    for (i2; i2 < html.length; i2++) {
      if (html.charAt(i2) === ">") {
        break;
      }
      if (html.charAt(i2) === "=") {
        let isId = html.slice(i2 - 3, i2) === " id";
        i2++;
        let char = html.charAt(i2);
        if (quoteChars.has(char)) {
          let attrStartsAt = i2;
          i2++;
          for (i2; i2 < html.length; i2++) {
            if (html.charAt(i2) === char) {
              break;
            }
          }
          if (isId) {
            id = html.slice(attrStartsAt + 1, i2);
            break;
          }
        }
      }
    }
    let closeAt = html.length - 1;
    insideComment = false;
    while (closeAt >= beforeTag.length + tag.length) {
      let char = html.charAt(closeAt);
      if (insideComment) {
        if (char === "-" && html.slice(closeAt - 3, closeAt) === "<!-") {
          insideComment = false;
          closeAt -= 4;
        } else {
          closeAt -= 1;
        }
      } else if (char === ">" && html.slice(closeAt - 2, closeAt) === "--") {
        insideComment = true;
        closeAt -= 3;
      } else if (char === ">") {
        break;
      } else {
        closeAt -= 1;
      }
    }
    afterTag = html.slice(closeAt + 1, html.length);
    let attrsStr = Object.keys(attrs).map((attr) => attrs[attr] === true ? attr : `${attr}="${attrs[attr]}"`).join(" ");
    if (clearInnerHTML) {
      let idAttrStr = id ? ` id="${id}"` : "";
      if (VOID_TAGS.has(tag)) {
        newHTML = `<${tag}${idAttrStr}${attrsStr === "" ? "" : " "}${attrsStr}/>`;
      } else {
        newHTML = `<${tag}${idAttrStr}${attrsStr === "" ? "" : " "}${attrsStr}></${tag}>`;
      }
    } else {
      let rest = html.slice(tagNameEndsAt, closeAt + 1);
      newHTML = `<${tag}${attrsStr === "" ? "" : " "}${attrsStr}${rest}`;
    }
    return [newHTML, beforeTag, afterTag];
  };
  var Rendered = class {
    static extract(diff) {
      let { [REPLY]: reply, [EVENTS]: events, [TITLE]: title } = diff;
      delete diff[REPLY];
      delete diff[EVENTS];
      delete diff[TITLE];
      return { diff, title, reply: reply || null, events: events || [] };
    }
    constructor(viewId, rendered) {
      this.viewId = viewId;
      this.rendered = {};
      this.magicId = 0;
      this.mergeDiff(rendered);
    }
    parentViewId() {
      return this.viewId;
    }
    toString(onlyCids) {
      let [str, streams] = this.recursiveToString(this.rendered, this.rendered[COMPONENTS], onlyCids, true, {});
      return [str, streams];
    }
    recursiveToString(rendered, components = rendered[COMPONENTS], onlyCids, changeTracking, rootAttrs) {
      onlyCids = onlyCids ? new Set(onlyCids) : null;
      let output = { buffer: "", components, onlyCids, streams: /* @__PURE__ */ new Set() };
      this.toOutputBuffer(rendered, null, output, changeTracking, rootAttrs);
      return [output.buffer, output.streams];
    }
    componentCIDs(diff) {
      return Object.keys(diff[COMPONENTS] || {}).map((i2) => parseInt(i2));
    }
    isComponentOnlyDiff(diff) {
      if (!diff[COMPONENTS]) {
        return false;
      }
      return Object.keys(diff).length === 1;
    }
    getComponent(diff, cid) {
      return diff[COMPONENTS][cid];
    }
    resetRender(cid) {
      if (this.rendered[COMPONENTS][cid]) {
        this.rendered[COMPONENTS][cid].reset = true;
      }
    }
    mergeDiff(diff) {
      let newc = diff[COMPONENTS];
      let cache = {};
      delete diff[COMPONENTS];
      this.rendered = this.mutableMerge(this.rendered, diff);
      this.rendered[COMPONENTS] = this.rendered[COMPONENTS] || {};
      if (newc) {
        let oldc = this.rendered[COMPONENTS];
        for (let cid in newc) {
          newc[cid] = this.cachedFindComponent(cid, newc[cid], oldc, newc, cache);
        }
        for (let cid in newc) {
          oldc[cid] = newc[cid];
        }
        diff[COMPONENTS] = newc;
      }
    }
    cachedFindComponent(cid, cdiff, oldc, newc, cache) {
      if (cache[cid]) {
        return cache[cid];
      } else {
        let ndiff, stat, scid = cdiff[STATIC];
        if (isCid(scid)) {
          let tdiff;
          if (scid > 0) {
            tdiff = this.cachedFindComponent(scid, newc[scid], oldc, newc, cache);
          } else {
            tdiff = oldc[-scid];
          }
          stat = tdiff[STATIC];
          ndiff = this.cloneMerge(tdiff, cdiff, true);
          ndiff[STATIC] = stat;
        } else {
          ndiff = cdiff[STATIC] !== void 0 || oldc[cid] === void 0 ? cdiff : this.cloneMerge(oldc[cid], cdiff, false);
        }
        cache[cid] = ndiff;
        return ndiff;
      }
    }
    mutableMerge(target, source) {
      if (source[STATIC] !== void 0) {
        return source;
      } else {
        this.doMutableMerge(target, source);
        return target;
      }
    }
    doMutableMerge(target, source) {
      for (let key in source) {
        let val = source[key];
        let targetVal = target[key];
        let isObjVal = isObject(val);
        if (isObjVal && val[STATIC] === void 0 && isObject(targetVal)) {
          this.doMutableMerge(targetVal, val);
        } else {
          target[key] = val;
        }
      }
      if (target[ROOT]) {
        target.newRender = true;
      }
    }
    // Merges cid trees together, copying statics from source tree.
    //
    // The `pruneMagicId` is passed to control pruning the magicId of the
    // target. We must always prune the magicId when we are sharing statics
    // from another component. If not pruning, we replicate the logic from
    // mutableMerge, where we set newRender to true if there is a root
    // (effectively forcing the new version to be rendered instead of skipped)
    //
    cloneMerge(target, source, pruneMagicId) {
      let merged = __spreadValues(__spreadValues({}, target), source);
      for (let key in merged) {
        let val = source[key];
        let targetVal = target[key];
        if (isObject(val) && val[STATIC] === void 0 && isObject(targetVal)) {
          merged[key] = this.cloneMerge(targetVal, val, pruneMagicId);
        } else if (val === void 0 && isObject(targetVal)) {
          merged[key] = this.cloneMerge(targetVal, {}, pruneMagicId);
        }
      }
      if (pruneMagicId) {
        delete merged.magicId;
        delete merged.newRender;
      } else if (target[ROOT]) {
        merged.newRender = true;
      }
      return merged;
    }
    componentToString(cid) {
      let [str, streams] = this.recursiveCIDToString(this.rendered[COMPONENTS], cid, null);
      let [strippedHTML, _before, _after] = modifyRoot(str, {});
      return [strippedHTML, streams];
    }
    pruneCIDs(cids) {
      cids.forEach((cid) => delete this.rendered[COMPONENTS][cid]);
    }
    // private
    get() {
      return this.rendered;
    }
    isNewFingerprint(diff = {}) {
      return !!diff[STATIC];
    }
    templateStatic(part, templates) {
      if (typeof part === "number") {
        return templates[part];
      } else {
        return part;
      }
    }
    nextMagicID() {
      this.magicId++;
      return `m${this.magicId}-${this.parentViewId()}`;
    }
    // Converts rendered tree to output buffer.
    //
    // changeTracking controls if we can apply the PHX_SKIP optimization.
    // It is disabled for comprehensions since we must re-render the entire collection
    // and no individual element is tracked inside the comprehension.
    toOutputBuffer(rendered, templates, output, changeTracking, rootAttrs = {}) {
      if (rendered[DYNAMICS]) {
        return this.comprehensionToBuffer(rendered, templates, output);
      }
      let { [STATIC]: statics } = rendered;
      statics = this.templateStatic(statics, templates);
      let isRoot = rendered[ROOT];
      let prevBuffer = output.buffer;
      if (isRoot) {
        output.buffer = "";
      }
      if (changeTracking && isRoot && !rendered.magicId) {
        rendered.newRender = true;
        rendered.magicId = this.nextMagicID();
      }
      output.buffer += statics[0];
      for (let i2 = 1; i2 < statics.length; i2++) {
        this.dynamicToBuffer(rendered[i2 - 1], templates, output, changeTracking);
        output.buffer += statics[i2];
      }
      if (isRoot) {
        let skip2 = false;
        let attrs;
        if (changeTracking || rendered.magicId) {
          skip2 = changeTracking && !rendered.newRender;
          attrs = __spreadValues({ [PHX_MAGIC_ID]: rendered.magicId }, rootAttrs);
        } else {
          attrs = rootAttrs;
        }
        if (skip2) {
          attrs[PHX_SKIP] = true;
        }
        let [newRoot, commentBefore, commentAfter] = modifyRoot(output.buffer, attrs, skip2);
        rendered.newRender = false;
        output.buffer = prevBuffer + commentBefore + newRoot + commentAfter;
      }
    }
    comprehensionToBuffer(rendered, templates, output) {
      let { [DYNAMICS]: dynamics, [STATIC]: statics, [STREAM]: stream } = rendered;
      let [_ref, _inserts, deleteIds, reset] = stream || [null, {}, [], null];
      statics = this.templateStatic(statics, templates);
      let compTemplates = templates || rendered[TEMPLATES];
      for (let d2 = 0; d2 < dynamics.length; d2++) {
        let dynamic = dynamics[d2];
        output.buffer += statics[0];
        for (let i2 = 1; i2 < statics.length; i2++) {
          let changeTracking = false;
          this.dynamicToBuffer(dynamic[i2 - 1], compTemplates, output, changeTracking);
          output.buffer += statics[i2];
        }
      }
      if (stream !== void 0 && (rendered[DYNAMICS].length > 0 || deleteIds.length > 0 || reset)) {
        delete rendered[STREAM];
        rendered[DYNAMICS] = [];
        output.streams.add(stream);
      }
    }
    dynamicToBuffer(rendered, templates, output, changeTracking) {
      if (typeof rendered === "number") {
        let [str, streams] = this.recursiveCIDToString(output.components, rendered, output.onlyCids);
        output.buffer += str;
        output.streams = /* @__PURE__ */ new Set([...output.streams, ...streams]);
      } else if (isObject(rendered)) {
        this.toOutputBuffer(rendered, templates, output, changeTracking, {});
      } else {
        output.buffer += rendered;
      }
    }
    recursiveCIDToString(components, cid, onlyCids) {
      let component = components[cid] || logError(`no component for CID ${cid}`, components);
      let attrs = { [PHX_COMPONENT]: cid };
      let skip2 = onlyCids && !onlyCids.has(cid);
      component.newRender = !skip2;
      component.magicId = `c${cid}-${this.parentViewId()}`;
      let changeTracking = !component.reset;
      let [html, streams] = this.recursiveToString(component, components, onlyCids, changeTracking, attrs);
      delete component.reset;
      return [html, streams];
    }
  };
  var focusStack = [];
  var default_transition_time = 200;
  var JS = {
    // private
    exec(e2, eventType, phxEvent, view, sourceEl, defaults2) {
      let [defaultKind, defaultArgs] = defaults2 || [null, { callback: defaults2 && defaults2.callback }];
      let commands = phxEvent.charAt(0) === "[" ? JSON.parse(phxEvent) : [[defaultKind, defaultArgs]];
      commands.forEach(([kind, args]) => {
        if (kind === defaultKind) {
          args = __spreadValues(__spreadValues({}, defaultArgs), args);
          args.callback = args.callback || defaultArgs.callback;
        }
        this.filterToEls(view.liveSocket, sourceEl, args).forEach((el) => {
          this[`exec_${kind}`](e2, eventType, phxEvent, view, sourceEl, el, args);
        });
      });
    },
    isVisible(el) {
      return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length > 0);
    },
    // returns true if any part of the element is inside the viewport
    isInViewport(el) {
      const rect = el.getBoundingClientRect();
      const windowHeight = window.innerHeight || document.documentElement.clientHeight;
      const windowWidth = window.innerWidth || document.documentElement.clientWidth;
      return rect.right > 0 && rect.bottom > 0 && rect.left < windowWidth && rect.top < windowHeight;
    },
    // private
    // commands
    exec_exec(e2, eventType, phxEvent, view, sourceEl, el, { attr, to: to2 }) {
      let nodes = to2 ? dom_default.all(document, to2) : [sourceEl];
      nodes.forEach((node) => {
        let encodedJS = node.getAttribute(attr);
        if (!encodedJS) {
          throw new Error(`expected ${attr} to contain JS command on "${to2}"`);
        }
        view.liveSocket.execJS(node, encodedJS, eventType);
      });
    },
    exec_dispatch(e2, eventType, phxEvent, view, sourceEl, el, { event, detail, bubbles }) {
      detail = detail || {};
      detail.dispatcher = sourceEl;
      dom_default.dispatchEvent(el, event, { detail, bubbles });
    },
    exec_push(e2, eventType, phxEvent, view, sourceEl, el, args) {
      let { event, data, target, page_loading, loading, value, dispatcher, callback: callback2 } = args;
      let pushOpts = { loading, value, target, page_loading: !!page_loading };
      let targetSrc = eventType === "change" && dispatcher ? dispatcher : sourceEl;
      let phxTarget = target || targetSrc.getAttribute(view.binding("target")) || targetSrc;
      const handler = (targetView, targetCtx) => {
        if (!targetView.isConnected()) {
          return;
        }
        if (eventType === "change") {
          let { newCid, _target } = args;
          _target = _target || (dom_default.isFormInput(sourceEl) ? sourceEl.name : void 0);
          if (_target) {
            pushOpts._target = _target;
          }
          targetView.pushInput(sourceEl, targetCtx, newCid, event || phxEvent, pushOpts, callback2);
        } else if (eventType === "submit") {
          let { submitter } = args;
          targetView.submitForm(sourceEl, targetCtx, event || phxEvent, submitter, pushOpts, callback2);
        } else {
          targetView.pushEvent(eventType, sourceEl, targetCtx, event || phxEvent, data, pushOpts, callback2);
        }
      };
      if (args.targetView && args.targetCtx) {
        handler(args.targetView, args.targetCtx);
      } else {
        view.withinTargets(phxTarget, handler);
      }
    },
    exec_navigate(e2, eventType, phxEvent, view, sourceEl, el, { href, replace }) {
      view.liveSocket.historyRedirect(e2, href, replace ? "replace" : "push", null, sourceEl);
    },
    exec_patch(e2, eventType, phxEvent, view, sourceEl, el, { href, replace }) {
      view.liveSocket.pushHistoryPatch(e2, href, replace ? "replace" : "push", sourceEl);
    },
    exec_focus(e2, eventType, phxEvent, view, sourceEl, el) {
      aria_default.attemptFocus(el);
    },
    exec_focus_first(e2, eventType, phxEvent, view, sourceEl, el) {
      aria_default.focusFirstInteractive(el) || aria_default.focusFirst(el);
    },
    exec_push_focus(e2, eventType, phxEvent, view, sourceEl, el) {
      window.requestAnimationFrame(() => focusStack.push(el || sourceEl));
    },
    exec_pop_focus(_e, _eventType, _phxEvent, _view, _sourceEl, _el) {
      window.requestAnimationFrame(() => {
        const el = focusStack.pop();
        if (el) {
          el.focus();
        }
      });
    },
    exec_add_class(e2, eventType, phxEvent, view, sourceEl, el, { names: names2, transition, time, blocking }) {
      this.addOrRemoveClasses(el, names2, [], transition, time, view, blocking);
    },
    exec_remove_class(e2, eventType, phxEvent, view, sourceEl, el, { names: names2, transition, time, blocking }) {
      this.addOrRemoveClasses(el, [], names2, transition, time, view, blocking);
    },
    exec_toggle_class(e2, eventType, phxEvent, view, sourceEl, el, { names: names2, transition, time, blocking }) {
      this.toggleClasses(el, names2, transition, time, view, blocking);
    },
    exec_toggle_attr(e2, eventType, phxEvent, view, sourceEl, el, { attr: [attr, val1, val2] }) {
      this.toggleAttr(el, attr, val1, val2);
    },
    exec_transition(e2, eventType, phxEvent, view, sourceEl, el, { time, transition, blocking }) {
      this.addOrRemoveClasses(el, [], [], transition, time, view, blocking);
    },
    exec_toggle(e2, eventType, phxEvent, view, sourceEl, el, { display, ins, outs, time, blocking }) {
      this.toggle(eventType, view, el, display, ins, outs, time, blocking);
    },
    exec_show(e2, eventType, phxEvent, view, sourceEl, el, { display, transition, time, blocking }) {
      this.show(eventType, view, el, display, transition, time, blocking);
    },
    exec_hide(e2, eventType, phxEvent, view, sourceEl, el, { display, transition, time, blocking }) {
      this.hide(eventType, view, el, display, transition, time, blocking);
    },
    exec_set_attr(e2, eventType, phxEvent, view, sourceEl, el, { attr: [attr, val] }) {
      this.setOrRemoveAttrs(el, [[attr, val]], []);
    },
    exec_remove_attr(e2, eventType, phxEvent, view, sourceEl, el, { attr }) {
      this.setOrRemoveAttrs(el, [], [attr]);
    },
    // utils for commands
    show(eventType, view, el, display, transition, time, blocking) {
      if (!this.isVisible(el)) {
        this.toggle(eventType, view, el, display, transition, null, time, blocking);
      }
    },
    hide(eventType, view, el, display, transition, time, blocking) {
      if (this.isVisible(el)) {
        this.toggle(eventType, view, el, display, null, transition, time, blocking);
      }
    },
    toggle(eventType, view, el, display, ins, outs, time, blocking) {
      time = time || default_transition_time;
      let [inClasses, inStartClasses, inEndClasses] = ins || [[], [], []];
      let [outClasses, outStartClasses, outEndClasses] = outs || [[], [], []];
      if (inClasses.length > 0 || outClasses.length > 0) {
        if (this.isVisible(el)) {
          let onStart = () => {
            this.addOrRemoveClasses(el, outStartClasses, inClasses.concat(inStartClasses).concat(inEndClasses));
            window.requestAnimationFrame(() => {
              this.addOrRemoveClasses(el, outClasses, []);
              window.requestAnimationFrame(() => this.addOrRemoveClasses(el, outEndClasses, outStartClasses));
            });
          };
          let onEnd = () => {
            this.addOrRemoveClasses(el, [], outClasses.concat(outEndClasses));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = "none");
            el.dispatchEvent(new Event("phx:hide-end"));
          };
          el.dispatchEvent(new Event("phx:hide-start"));
          if (blocking === false) {
            onStart();
            setTimeout(onEnd, time);
          } else {
            view.transition(time, onStart, onEnd);
          }
        } else {
          if (eventType === "remove") {
            return;
          }
          let onStart = () => {
            this.addOrRemoveClasses(el, inStartClasses, outClasses.concat(outStartClasses).concat(outEndClasses));
            let stickyDisplay = display || this.defaultDisplay(el);
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = stickyDisplay);
            window.requestAnimationFrame(() => {
              this.addOrRemoveClasses(el, inClasses, []);
              window.requestAnimationFrame(() => this.addOrRemoveClasses(el, inEndClasses, inStartClasses));
            });
          };
          let onEnd = () => {
            this.addOrRemoveClasses(el, [], inClasses.concat(inEndClasses));
            el.dispatchEvent(new Event("phx:show-end"));
          };
          el.dispatchEvent(new Event("phx:show-start"));
          if (blocking === false) {
            onStart();
            setTimeout(onEnd, time);
          } else {
            view.transition(time, onStart, onEnd);
          }
        }
      } else {
        if (this.isVisible(el)) {
          el.dispatchEvent(new Event("phx:hide-start"));
          dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = "none");
          el.dispatchEvent(new Event("phx:hide-end"));
        } else {
          el.dispatchEvent(new Event("phx:show-start"));
          let stickyDisplay = display || this.defaultDisplay(el);
          dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = stickyDisplay);
          el.dispatchEvent(new Event("phx:show-end"));
        }
      }
    },
    toggleClasses(el, classes, transition, time, view, blocking) {
      window.requestAnimationFrame(() => {
        let [prevAdds, prevRemoves] = dom_default.getSticky(el, "classes", [[], []]);
        let newAdds = classes.filter((name) => prevAdds.indexOf(name) < 0 && !el.classList.contains(name));
        let newRemoves = classes.filter((name) => prevRemoves.indexOf(name) < 0 && el.classList.contains(name));
        this.addOrRemoveClasses(el, newAdds, newRemoves, transition, time, view, blocking);
      });
    },
    toggleAttr(el, attr, val1, val2) {
      if (el.hasAttribute(attr)) {
        if (val2 !== void 0) {
          if (el.getAttribute(attr) === val1) {
            this.setOrRemoveAttrs(el, [[attr, val2]], []);
          } else {
            this.setOrRemoveAttrs(el, [[attr, val1]], []);
          }
        } else {
          this.setOrRemoveAttrs(el, [], [attr]);
        }
      } else {
        this.setOrRemoveAttrs(el, [[attr, val1]], []);
      }
    },
    addOrRemoveClasses(el, adds, removes, transition, time, view, blocking) {
      time = time || default_transition_time;
      let [transitionRun, transitionStart, transitionEnd] = transition || [[], [], []];
      if (transitionRun.length > 0) {
        let onStart = () => {
          this.addOrRemoveClasses(el, transitionStart, [].concat(transitionRun).concat(transitionEnd));
          window.requestAnimationFrame(() => {
            this.addOrRemoveClasses(el, transitionRun, []);
            window.requestAnimationFrame(() => this.addOrRemoveClasses(el, transitionEnd, transitionStart));
          });
        };
        let onDone = () => this.addOrRemoveClasses(el, adds.concat(transitionEnd), removes.concat(transitionRun).concat(transitionStart));
        if (blocking === false) {
          onStart();
          setTimeout(onDone, time);
        } else {
          view.transition(time, onStart, onDone);
        }
        return;
      }
      window.requestAnimationFrame(() => {
        let [prevAdds, prevRemoves] = dom_default.getSticky(el, "classes", [[], []]);
        let keepAdds = adds.filter((name) => prevAdds.indexOf(name) < 0 && !el.classList.contains(name));
        let keepRemoves = removes.filter((name) => prevRemoves.indexOf(name) < 0 && el.classList.contains(name));
        let newAdds = prevAdds.filter((name) => removes.indexOf(name) < 0).concat(keepAdds);
        let newRemoves = prevRemoves.filter((name) => adds.indexOf(name) < 0).concat(keepRemoves);
        dom_default.putSticky(el, "classes", (currentEl) => {
          currentEl.classList.remove(...newRemoves);
          currentEl.classList.add(...newAdds);
          return [newAdds, newRemoves];
        });
      });
    },
    setOrRemoveAttrs(el, sets, removes) {
      let [prevSets, prevRemoves] = dom_default.getSticky(el, "attrs", [[], []]);
      let alteredAttrs = sets.map(([attr, _val]) => attr).concat(removes);
      let newSets = prevSets.filter(([attr, _val]) => !alteredAttrs.includes(attr)).concat(sets);
      let newRemoves = prevRemoves.filter((attr) => !alteredAttrs.includes(attr)).concat(removes);
      dom_default.putSticky(el, "attrs", (currentEl) => {
        newRemoves.forEach((attr) => currentEl.removeAttribute(attr));
        newSets.forEach(([attr, val]) => currentEl.setAttribute(attr, val));
        return [newSets, newRemoves];
      });
    },
    hasAllClasses(el, classes) {
      return classes.every((name) => el.classList.contains(name));
    },
    isToggledOut(el, outClasses) {
      return !this.isVisible(el) || this.hasAllClasses(el, outClasses);
    },
    filterToEls(liveSocket2, sourceEl, { to: to2 }) {
      let defaultQuery = () => {
        if (typeof to2 === "string") {
          return document.querySelectorAll(to2);
        } else if (to2.closest) {
          let toEl = sourceEl.closest(to2.closest);
          return toEl ? [toEl] : [];
        } else if (to2.inner) {
          return sourceEl.querySelectorAll(to2.inner);
        }
      };
      return to2 ? liveSocket2.jsQuerySelectorAll(sourceEl, to2, defaultQuery) : [sourceEl];
    },
    defaultDisplay(el) {
      return { tr: "table-row", td: "table-cell" }[el.tagName.toLowerCase()] || "block";
    },
    transitionClasses(val) {
      if (!val) {
        return null;
      }
      let [trans, tStart, tEnd] = Array.isArray(val) ? val : [val.split(" "), [], []];
      trans = Array.isArray(trans) ? trans : trans.split(" ");
      tStart = Array.isArray(tStart) ? tStart : tStart.split(" ");
      tEnd = Array.isArray(tEnd) ? tEnd : tEnd.split(" ");
      return [trans, tStart, tEnd];
    }
  };
  var js_default = JS;
  var HOOK_ID = "hookId";
  var viewHookID = 1;
  var ViewHook = class {
    static makeID() {
      return viewHookID++;
    }
    static elementID(el) {
      return dom_default.private(el, HOOK_ID);
    }
    constructor(view, el, callbacks) {
      this.el = el;
      this.__attachView(view);
      this.__callbacks = callbacks;
      this.__listeners = /* @__PURE__ */ new Set();
      this.__isDisconnected = false;
      dom_default.putPrivate(this.el, HOOK_ID, this.constructor.makeID());
      for (let key in this.__callbacks) {
        this[key] = this.__callbacks[key];
      }
    }
    __attachView(view) {
      if (view) {
        this.__view = () => view;
        this.liveSocket = view.liveSocket;
      } else {
        this.__view = () => {
          throw new Error(`hook not yet attached to a live view: ${this.el.outerHTML}`);
        };
        this.liveSocket = null;
      }
    }
    __mounted() {
      this.mounted && this.mounted();
    }
    __updated() {
      this.updated && this.updated();
    }
    __beforeUpdate() {
      this.beforeUpdate && this.beforeUpdate();
    }
    __destroyed() {
      this.destroyed && this.destroyed();
      dom_default.deletePrivate(this.el, HOOK_ID);
    }
    __reconnected() {
      if (this.__isDisconnected) {
        this.__isDisconnected = false;
        this.reconnected && this.reconnected();
      }
    }
    __disconnected() {
      this.__isDisconnected = true;
      this.disconnected && this.disconnected();
    }
    /**
     * Binds the hook to JS commands.
     *
     * @param {ViewHook} hook - The ViewHook instance to bind.
     *
     * @returns {Object} An object with methods to manipulate the DOM and execute JavaScript.
     */
    js() {
      let hook = this;
      return {
        /**
         * Executes encoded JavaScript in the context of the hook element.
         *
         * @param {string} encodedJS - The encoded JavaScript string to execute.
         */
        exec(encodedJS) {
          hook.__view().liveSocket.execJS(hook.el, encodedJS, "hook");
        },
        /**
         * Shows an element.
         *
         * @param {HTMLElement} el - The element to show.
         * @param {Object} [opts={}] - Optional settings.
         * @param {string} [opts.display] - The CSS display value to set. Defaults "block".
         * @param {string} [opts.transition] - The CSS transition classes to set when showing.
         * @param {number} [opts.time] - The transition duration in milliseconds. Defaults 200.
         * @param {boolean} [opts.blocking] - The boolean flag to block the UI during the transition.
         *  Defaults `true`.
         */
        show(el, opts = {}) {
          let owner = hook.__view().liveSocket.owner(el);
          js_default.show("hook", owner, el, opts.display, opts.transition, opts.time, opts.blocking);
        },
        /**
         * Hides an element.
         *
         * @param {HTMLElement} el - The element to hide.
         * @param {Object} [opts={}] - Optional settings.
         * @param {string} [opts.transition] - The CSS transition classes to set when hiding.
         * @param {number} [opts.time] - The transition duration in milliseconds. Defaults 200.
         * @param {boolean} [opts.blocking] - The boolean flag to block the UI during the transition.
         *   Defaults `true`.
         */
        hide(el, opts = {}) {
          let owner = hook.__view().liveSocket.owner(el);
          js_default.hide("hook", owner, el, null, opts.transition, opts.time, opts.blocking);
        },
        /**
         * Toggles the visibility of an element.
         *
         * @param {HTMLElement} el - The element to toggle.
         * @param {Object} [opts={}] - Optional settings.
         * @param {string} [opts.display] - The CSS display value to set. Defaults "block".
         * @param {string} [opts.in] - The CSS transition classes for showing.
         *   Accepts either the string of classes to apply when toggling in, or
         *   a 3-tuple containing the transition class, the class to apply
         *   to start the transition, and the ending transition class, such as:
         *
         *       ["ease-out duration-300", "opacity-0", "opacity-100"]
         *
         * @param {string} [opts.out] - The CSS transition classes for hiding.
         *   Accepts either string of classes to apply when toggling out, or
         *   a 3-tuple containing the transition class, the class to apply
         *   to start the transition, and the ending transition class, such as:
         *
         *       ["ease-out duration-300", "opacity-100", "opacity-0"]
         *
         * @param {number} [opts.time] - The transition duration in milliseconds.
         *
         * @param {boolean} [opts.blocking] - The boolean flag to block the UI during the transition.
         *   Defaults `true`.
         */
        toggle(el, opts = {}) {
          let owner = hook.__view().liveSocket.owner(el);
          opts.in = js_default.transitionClasses(opts.in);
          opts.out = js_default.transitionClasses(opts.out);
          js_default.toggle("hook", owner, el, opts.display, opts.in, opts.out, opts.time, opts.blocking);
        },
        /**
         * Adds CSS classes to an element.
         *
         * @param {HTMLElement} el - The element to add classes to.
         * @param {string|string[]} names - The class name(s) to add.
         * @param {Object} [opts={}] - Optional settings.
         * @param {string} [opts.transition] - The CSS transition property to set.
         *   Accepts a string of classes to apply when adding classes or
         *   a 3-tuple containing the transition class, the class to apply
         *   to start the transition, and the ending transition class, such as:
         *
         *       ["ease-out duration-300", "opacity-0", "opacity-100"]
         *
         * @param {number} [opts.time] - The transition duration in milliseconds.
         * @param {boolean} [opts.blocking] - The boolean flag to block the UI during the transition.
         *   Defaults `true`.
         */
        addClass(el, names2, opts = {}) {
          names2 = Array.isArray(names2) ? names2 : names2.split(" ");
          let owner = hook.__view().liveSocket.owner(el);
          js_default.addOrRemoveClasses(el, names2, [], opts.transition, opts.time, owner, opts.blocking);
        },
        /**
         * Removes CSS classes from an element.
         *
         * @param {HTMLElement} el - The element to remove classes from.
         * @param {string|string[]} names - The class name(s) to remove.
         * @param {Object} [opts={}] - Optional settings.
         * @param {string} [opts.transition] - The CSS transition classes to set.
         *   Accepts a string of classes to apply when removing classes or
         *   a 3-tuple containing the transition class, the class to apply
         *   to start the transition, and the ending transition class, such as:
         *
         *       ["ease-out duration-300", "opacity-100", "opacity-0"]
         *
         * @param {number} [opts.time] - The transition duration in milliseconds.
         * @param {boolean} [opts.blocking] - The boolean flag to block the UI during the transition.
         *   Defaults `true`.
         */
        removeClass(el, names2, opts = {}) {
          opts.transition = js_default.transitionClasses(opts.transition);
          names2 = Array.isArray(names2) ? names2 : names2.split(" ");
          let owner = hook.__view().liveSocket.owner(el);
          js_default.addOrRemoveClasses(el, [], names2, opts.transition, opts.time, owner, opts.blocking);
        },
        /**
         * Toggles CSS classes on an element.
         *
         * @param {HTMLElement} el - The element to toggle classes on.
         * @param {string|string[]} names - The class name(s) to toggle.
         * @param {Object} [opts={}] - Optional settings.
         * @param {string} [opts.transition] - The CSS transition classes to set.
         *   Accepts a string of classes to apply when toggling classes or
         *   a 3-tuple containing the transition class, the class to apply
         *   to start the transition, and the ending transition class, such as:
         *
         *       ["ease-out duration-300", "opacity-100", "opacity-0"]
         *
         * @param {number} [opts.time] - The transition duration in milliseconds.
         * @param {boolean} [opts.blocking] - The boolean flag to block the UI during the transition.
         *   Defaults `true`.
         */
        toggleClass(el, names2, opts = {}) {
          opts.transition = js_default.transitionClasses(opts.transition);
          names2 = Array.isArray(names2) ? names2 : names2.split(" ");
          let owner = hook.__view().liveSocket.owner(el);
          js_default.toggleClasses(el, names2, opts.transition, opts.time, owner, opts.blocking);
        },
        /**
         * Applies a CSS transition to an element.
         *
         * @param {HTMLElement} el - The element to apply the transition to.
         * @param {string|string[]} transition - The transition class(es) to apply.
         *   Accepts a string of classes to apply when transitioning or
         *   a 3-tuple containing the transition class, the class to apply
         *   to start the transition, and the ending transition class, such as:
         *
         *       ["ease-out duration-300", "opacity-100", "opacity-0"]
         *
         * @param {Object} [opts={}] - Optional settings.
         * @param {number} [opts.time] - The transition duration in milliseconds.
         * @param {boolean} [opts.blocking] - The boolean flag to block the UI during the transition.
         *   Defaults `true`.
         */
        transition(el, transition, opts = {}) {
          let owner = hook.__view().liveSocket.owner(el);
          js_default.addOrRemoveClasses(el, [], [], js_default.transitionClasses(transition), opts.time, owner, opts.blocking);
        },
        /**
         * Sets an attribute on an element.
         *
         * @param {HTMLElement} el - The element to set the attribute on.
         * @param {string} attr - The attribute name to set.
         * @param {string} val - The value to set for the attribute.
         */
        setAttribute(el, attr, val) {
          js_default.setOrRemoveAttrs(el, [[attr, val]], []);
        },
        /**
         * Removes an attribute from an element.
         *
         * @param {HTMLElement} el - The element to remove the attribute from.
         * @param {string} attr - The attribute name to remove.
         */
        removeAttribute(el, attr) {
          js_default.setOrRemoveAttrs(el, [], [attr]);
        },
        /**
         * Toggles an attribute on an element between two values.
         *
         * @param {HTMLElement} el - The element to toggle the attribute on.
         * @param {string} attr - The attribute name to toggle.
         * @param {string} val1 - The first value to toggle between.
         * @param {string} val2 - The second value to toggle between.
         */
        toggleAttribute(el, attr, val1, val2) {
          js_default.toggleAttr(el, attr, val1, val2);
        }
      };
    }
    pushEvent(event, payload = {}, onReply) {
      if (onReply === void 0) {
        return new Promise((resolve2, reject) => {
          try {
            const ref = this.__view().pushHookEvent(this.el, null, event, payload, (reply, _ref) => resolve2(reply));
            if (ref === false) {
              reject(new Error("unable to push hook event. LiveView not connected"));
            }
          } catch (error) {
            reject(error);
          }
        });
      }
      return this.__view().pushHookEvent(this.el, null, event, payload, onReply);
    }
    pushEventTo(phxTarget, event, payload = {}, onReply) {
      if (onReply === void 0) {
        return new Promise((resolve2, reject) => {
          try {
            this.__view().withinTargets(phxTarget, (view, targetCtx) => {
              const ref = view.pushHookEvent(this.el, targetCtx, event, payload, (reply, _ref) => resolve2(reply));
              if (ref === false) {
                reject(new Error("unable to push hook event. LiveView not connected"));
              }
            });
          } catch (error) {
            reject(error);
          }
        });
      }
      return this.__view().withinTargets(phxTarget, (view, targetCtx) => {
        return view.pushHookEvent(this.el, targetCtx, event, payload, onReply);
      });
    }
    handleEvent(event, callback2) {
      let callbackRef = (customEvent, bypass) => bypass ? event : callback2(customEvent.detail);
      window.addEventListener(`phx:${event}`, callbackRef);
      this.__listeners.add(callbackRef);
      return callbackRef;
    }
    removeHandleEvent(callbackRef) {
      let event = callbackRef(null, true);
      window.removeEventListener(`phx:${event}`, callbackRef);
      this.__listeners.delete(callbackRef);
    }
    upload(name, files) {
      return this.__view().dispatchUploads(null, name, files);
    }
    uploadTo(phxTarget, name, files) {
      return this.__view().withinTargets(phxTarget, (view, targetCtx) => {
        view.dispatchUploads(targetCtx, name, files);
      });
    }
    __cleanup__() {
      this.__listeners.forEach((callbackRef) => this.removeHandleEvent(callbackRef));
    }
  };
  var prependFormDataKey = (key, prefix) => {
    let isArray2 = key.endsWith("[]");
    let baseKey = isArray2 ? key.slice(0, -2) : key;
    baseKey = baseKey.replace(/([^\[\]]+)(\]?$)/, `${prefix}$1$2`);
    if (isArray2) {
      baseKey += "[]";
    }
    return baseKey;
  };
  var serializeForm = (form, metadata, onlyNames = []) => {
    const _a = metadata, { submitter } = _a, meta = __objRest(_a, ["submitter"]);
    let injectedElement;
    if (submitter && submitter.name) {
      const input = document.createElement("input");
      input.type = "hidden";
      const formId = submitter.getAttribute("form");
      if (formId) {
        input.setAttribute("form", formId);
      }
      input.name = submitter.name;
      input.value = submitter.value;
      submitter.parentElement.insertBefore(input, submitter);
      injectedElement = input;
    }
    const formData = new FormData(form);
    const toRemove = [];
    formData.forEach((val, key, _index) => {
      if (val instanceof File) {
        toRemove.push(key);
      }
    });
    toRemove.forEach((key) => formData.delete(key));
    const params = new URLSearchParams();
    let elements2 = Array.from(form.elements);
    for (let [key, val] of formData.entries()) {
      if (onlyNames.length === 0 || onlyNames.indexOf(key) >= 0) {
        let inputs = elements2.filter((input) => input.name === key);
        let isUnused = !inputs.some((input) => dom_default.private(input, PHX_HAS_FOCUSED) || dom_default.private(input, PHX_HAS_SUBMITTED));
        let hidden = inputs.every((input) => input.type === "hidden");
        if (isUnused && !(submitter && submitter.name == key) && !hidden) {
          params.append(prependFormDataKey(key, "_unused_"), "");
        }
        params.append(key, val);
      }
    }
    if (submitter && injectedElement) {
      submitter.parentElement.removeChild(injectedElement);
    }
    for (let metaKey in meta) {
      params.append(metaKey, meta[metaKey]);
    }
    return params.toString();
  };
  var View = class _View {
    static closestView(el) {
      let liveViewEl = el.closest(PHX_VIEW_SELECTOR);
      return liveViewEl ? dom_default.private(liveViewEl, "view") : null;
    }
    constructor(el, liveSocket2, parentView, flash, liveReferer) {
      this.isDead = false;
      this.liveSocket = liveSocket2;
      this.flash = flash;
      this.parent = parentView;
      this.root = parentView ? parentView.root : this;
      this.el = el;
      dom_default.putPrivate(this.el, "view", this);
      this.id = this.el.id;
      this.ref = 0;
      this.lastAckRef = null;
      this.childJoins = 0;
      this.loaderTimer = null;
      this.pendingDiffs = [];
      this.pendingForms = /* @__PURE__ */ new Set();
      this.redirect = false;
      this.href = null;
      this.joinCount = this.parent ? this.parent.joinCount - 1 : 0;
      this.joinAttempts = 0;
      this.joinPending = true;
      this.destroyed = false;
      this.joinCallback = function(onDone) {
        onDone && onDone();
      };
      this.stopCallback = function() {
      };
      this.pendingJoinOps = this.parent ? null : [];
      this.viewHooks = {};
      this.formSubmits = [];
      this.children = this.parent ? null : {};
      this.root.children[this.id] = {};
      this.formsForRecovery = {};
      this.channel = this.liveSocket.channel(`lv:${this.id}`, () => {
        let url = this.href && this.expandURL(this.href);
        return {
          redirect: this.redirect ? url : void 0,
          url: this.redirect ? void 0 : url || void 0,
          params: this.connectParams(liveReferer),
          session: this.getSession(),
          static: this.getStatic(),
          flash: this.flash
        };
      });
    }
    setHref(href) {
      this.href = href;
    }
    setRedirect(href) {
      this.redirect = true;
      this.href = href;
    }
    isMain() {
      return this.el.hasAttribute(PHX_MAIN);
    }
    connectParams(liveReferer) {
      let params = this.liveSocket.params(this.el);
      let manifest = dom_default.all(document, `[${this.binding(PHX_TRACK_STATIC)}]`).map((node) => node.src || node.href).filter((url) => typeof url === "string");
      if (manifest.length > 0) {
        params["_track_static"] = manifest;
      }
      params["_mounts"] = this.joinCount;
      params["_mount_attempts"] = this.joinAttempts;
      params["_live_referer"] = liveReferer;
      this.joinAttempts++;
      return params;
    }
    isConnected() {
      return this.channel.canPush();
    }
    getSession() {
      return this.el.getAttribute(PHX_SESSION);
    }
    getStatic() {
      let val = this.el.getAttribute(PHX_STATIC);
      return val === "" ? null : val;
    }
    destroy(callback2 = function() {
    }) {
      this.destroyAllChildren();
      this.destroyed = true;
      delete this.root.children[this.id];
      if (this.parent) {
        delete this.root.children[this.parent.id][this.id];
      }
      clearTimeout(this.loaderTimer);
      let onFinished = () => {
        callback2();
        for (let id in this.viewHooks) {
          this.destroyHook(this.viewHooks[id]);
        }
      };
      dom_default.markPhxChildDestroyed(this.el);
      this.log("destroyed", () => ["the child has been removed from the parent"]);
      this.channel.leave().receive("ok", onFinished).receive("error", onFinished).receive("timeout", onFinished);
    }
    setContainerClasses(...classes) {
      this.el.classList.remove(
        PHX_CONNECTED_CLASS,
        PHX_LOADING_CLASS,
        PHX_ERROR_CLASS,
        PHX_CLIENT_ERROR_CLASS,
        PHX_SERVER_ERROR_CLASS
      );
      this.el.classList.add(...classes);
    }
    showLoader(timeout) {
      clearTimeout(this.loaderTimer);
      if (timeout) {
        this.loaderTimer = setTimeout(() => this.showLoader(), timeout);
      } else {
        for (let id in this.viewHooks) {
          this.viewHooks[id].__disconnected();
        }
        this.setContainerClasses(PHX_LOADING_CLASS);
      }
    }
    execAll(binding) {
      dom_default.all(this.el, `[${binding}]`, (el) => this.liveSocket.execJS(el, el.getAttribute(binding)));
    }
    hideLoader() {
      clearTimeout(this.loaderTimer);
      this.setContainerClasses(PHX_CONNECTED_CLASS);
      this.execAll(this.binding("connected"));
    }
    triggerReconnected() {
      for (let id in this.viewHooks) {
        this.viewHooks[id].__reconnected();
      }
    }
    log(kind, msgCallback) {
      this.liveSocket.log(this, kind, msgCallback);
    }
    transition(time, onStart, onDone = function() {
    }) {
      this.liveSocket.transition(time, onStart, onDone);
    }
    // calls the callback with the view and target element for the given phxTarget
    // targets can be:
    //  * an element itself, then it is simply passed to liveSocket.owner;
    //  * a CID (Component ID), then we first search the component's element in the DOM
    //  * a selector, then we search the selector in the DOM and call the callback
    //    for each element found with the corresponding owner view
    withinTargets(phxTarget, callback2, dom = document, viewEl) {
      if (phxTarget instanceof HTMLElement || phxTarget instanceof SVGElement) {
        return this.liveSocket.owner(phxTarget, (view) => callback2(view, phxTarget));
      }
      if (isCid(phxTarget)) {
        let targets = dom_default.findComponentNodeList(viewEl || this.el, phxTarget);
        if (targets.length === 0) {
          logError(`no component found matching phx-target of ${phxTarget}`);
        } else {
          callback2(this, parseInt(phxTarget));
        }
      } else {
        let targets = Array.from(dom.querySelectorAll(phxTarget));
        if (targets.length === 0) {
          logError(`nothing found matching the phx-target selector "${phxTarget}"`);
        }
        targets.forEach((target) => this.liveSocket.owner(target, (view) => callback2(view, target)));
      }
    }
    applyDiff(type, rawDiff, callback2) {
      this.log(type, () => ["", clone(rawDiff)]);
      let { diff, reply, events, title } = Rendered.extract(rawDiff);
      callback2({ diff, reply, events });
      if (typeof title === "string" || type == "mount") {
        window.requestAnimationFrame(() => dom_default.putTitle(title));
      }
    }
    onJoin(resp) {
      let { rendered, container, liveview_version } = resp;
      if (container) {
        let [tag, attrs] = container;
        this.el = dom_default.replaceRootContainer(this.el, tag, attrs);
      }
      this.childJoins = 0;
      this.joinPending = true;
      this.flash = null;
      if (this.root === this) {
        this.formsForRecovery = this.getFormsForRecovery();
      }
      if (this.isMain() && window.history.state === null) {
        browser_default.pushState("replace", {
          type: "patch",
          id: this.id,
          position: this.liveSocket.currentHistoryPosition
        });
      }
      if (liveview_version !== this.liveSocket.version()) {
        console.error(`LiveView asset version mismatch. JavaScript version ${this.liveSocket.version()} vs. server ${liveview_version}. To avoid issues, please ensure that your assets use the same version as the server.`);
      }
      browser_default.dropLocal(this.liveSocket.localStorage, window.location.pathname, CONSECUTIVE_RELOADS);
      this.applyDiff("mount", rendered, ({ diff, events }) => {
        this.rendered = new Rendered(this.id, diff);
        let [html, streams] = this.renderContainer(null, "join");
        this.dropPendingRefs();
        this.joinCount++;
        this.joinAttempts = 0;
        this.maybeRecoverForms(html, () => {
          this.onJoinComplete(resp, html, streams, events);
        });
      });
    }
    dropPendingRefs() {
      dom_default.all(document, `[${PHX_REF_SRC}="${this.refSrc()}"]`, (el) => {
        el.removeAttribute(PHX_REF_LOADING);
        el.removeAttribute(PHX_REF_SRC);
        el.removeAttribute(PHX_REF_LOCK);
      });
    }
    onJoinComplete({ live_patch }, html, streams, events) {
      if (this.joinCount > 1 || this.parent && !this.parent.isJoinPending()) {
        return this.applyJoinPatch(live_patch, html, streams, events);
      }
      let newChildren = dom_default.findPhxChildrenInFragment(html, this.id).filter((toEl) => {
        let fromEl = toEl.id && this.el.querySelector(`[id="${toEl.id}"]`);
        let phxStatic = fromEl && fromEl.getAttribute(PHX_STATIC);
        if (phxStatic) {
          toEl.setAttribute(PHX_STATIC, phxStatic);
        }
        if (fromEl) {
          fromEl.setAttribute(PHX_ROOT_ID, this.root.id);
        }
        return this.joinChild(toEl);
      });
      if (newChildren.length === 0) {
        if (this.parent) {
          this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, streams, events)]);
          this.parent.ackJoin(this);
        } else {
          this.onAllChildJoinsComplete();
          this.applyJoinPatch(live_patch, html, streams, events);
        }
      } else {
        this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, streams, events)]);
      }
    }
    attachTrueDocEl() {
      this.el = dom_default.byId(this.id);
      this.el.setAttribute(PHX_ROOT_ID, this.root.id);
    }
    // this is invoked for dead and live views, so we must filter by
    // by owner to ensure we aren't duplicating hooks across disconnect
    // and connected states. This also handles cases where hooks exist
    // in a root layout with a LV in the body
    execNewMounted(parent = this.el) {
      let phxViewportTop = this.binding(PHX_VIEWPORT_TOP);
      let phxViewportBottom = this.binding(PHX_VIEWPORT_BOTTOM);
      dom_default.all(parent, `[${phxViewportTop}], [${phxViewportBottom}]`, (hookEl) => {
        if (this.ownsElement(hookEl)) {
          dom_default.maintainPrivateHooks(hookEl, hookEl, phxViewportTop, phxViewportBottom);
          this.maybeAddNewHook(hookEl);
        }
      });
      dom_default.all(parent, `[${this.binding(PHX_HOOK)}], [data-phx-${PHX_HOOK}]`, (hookEl) => {
        if (this.ownsElement(hookEl)) {
          this.maybeAddNewHook(hookEl);
        }
      });
      dom_default.all(parent, `[${this.binding(PHX_MOUNTED)}]`, (el) => {
        if (this.ownsElement(el)) {
          this.maybeMounted(el);
        }
      });
    }
    applyJoinPatch(live_patch, html, streams, events) {
      this.attachTrueDocEl();
      let patch = new DOMPatch(this, this.el, this.id, html, streams, null);
      patch.markPrunableContentForRemoval();
      this.performPatch(patch, false, true);
      this.joinNewChildren();
      this.execNewMounted();
      this.joinPending = false;
      this.liveSocket.dispatchEvents(events);
      this.applyPendingUpdates();
      if (live_patch) {
        let { kind, to: to2 } = live_patch;
        this.liveSocket.historyPatch(to2, kind);
      }
      this.hideLoader();
      if (this.joinCount > 1) {
        this.triggerReconnected();
      }
      this.stopCallback();
    }
    triggerBeforeUpdateHook(fromEl, toEl) {
      this.liveSocket.triggerDOM("onBeforeElUpdated", [fromEl, toEl]);
      let hook = this.getHook(fromEl);
      let isIgnored = hook && dom_default.isIgnored(fromEl, this.binding(PHX_UPDATE));
      if (hook && !fromEl.isEqualNode(toEl) && !(isIgnored && isEqualObj(fromEl.dataset, toEl.dataset))) {
        hook.__beforeUpdate();
        return hook;
      }
    }
    maybeMounted(el) {
      let phxMounted = el.getAttribute(this.binding(PHX_MOUNTED));
      let hasBeenInvoked = phxMounted && dom_default.private(el, "mounted");
      if (phxMounted && !hasBeenInvoked) {
        this.liveSocket.execJS(el, phxMounted);
        dom_default.putPrivate(el, "mounted", true);
      }
    }
    maybeAddNewHook(el) {
      let newHook = this.addHook(el);
      if (newHook) {
        newHook.__mounted();
      }
    }
    performPatch(patch, pruneCids, isJoinPatch = false) {
      let removedEls = [];
      let phxChildrenAdded = false;
      let updatedHookIds = /* @__PURE__ */ new Set();
      this.liveSocket.triggerDOM("onPatchStart", [patch.targetContainer]);
      patch.after("added", (el) => {
        this.liveSocket.triggerDOM("onNodeAdded", [el]);
        let phxViewportTop = this.binding(PHX_VIEWPORT_TOP);
        let phxViewportBottom = this.binding(PHX_VIEWPORT_BOTTOM);
        dom_default.maintainPrivateHooks(el, el, phxViewportTop, phxViewportBottom);
        this.maybeAddNewHook(el);
        if (el.getAttribute) {
          this.maybeMounted(el);
        }
      });
      patch.after("phxChildAdded", (el) => {
        if (dom_default.isPhxSticky(el)) {
          this.liveSocket.joinRootViews();
        } else {
          phxChildrenAdded = true;
        }
      });
      patch.before("updated", (fromEl, toEl) => {
        let hook = this.triggerBeforeUpdateHook(fromEl, toEl);
        if (hook) {
          updatedHookIds.add(fromEl.id);
        }
      });
      patch.after("updated", (el) => {
        if (updatedHookIds.has(el.id)) {
          this.getHook(el).__updated();
        }
      });
      patch.after("discarded", (el) => {
        if (el.nodeType === Node.ELEMENT_NODE) {
          removedEls.push(el);
        }
      });
      patch.after("transitionsDiscarded", (els) => this.afterElementsRemoved(els, pruneCids));
      patch.perform(isJoinPatch);
      this.afterElementsRemoved(removedEls, pruneCids);
      this.liveSocket.triggerDOM("onPatchEnd", [patch.targetContainer]);
      return phxChildrenAdded;
    }
    afterElementsRemoved(elements2, pruneCids) {
      let destroyedCIDs = [];
      elements2.forEach((parent) => {
        let components = dom_default.all(parent, `[${PHX_COMPONENT}]`);
        let hooks2 = dom_default.all(parent, `[${this.binding(PHX_HOOK)}], [data-phx-hook]`);
        components.concat(parent).forEach((el) => {
          let cid = this.componentID(el);
          if (isCid(cid) && destroyedCIDs.indexOf(cid) === -1) {
            destroyedCIDs.push(cid);
          }
        });
        hooks2.concat(parent).forEach((hookEl) => {
          let hook = this.getHook(hookEl);
          hook && this.destroyHook(hook);
        });
      });
      if (pruneCids) {
        this.maybePushComponentsDestroyed(destroyedCIDs);
      }
    }
    joinNewChildren() {
      dom_default.findPhxChildren(this.el, this.id).forEach((el) => this.joinChild(el));
    }
    maybeRecoverForms(html, callback2) {
      const phxChange = this.binding("change");
      const oldForms = this.root.formsForRecovery;
      let template = document.createElement("template");
      template.innerHTML = html;
      const rootEl = template.content.firstElementChild;
      rootEl.id = this.id;
      rootEl.setAttribute(PHX_ROOT_ID, this.root.id);
      rootEl.setAttribute(PHX_SESSION, this.getSession());
      rootEl.setAttribute(PHX_STATIC, this.getStatic());
      rootEl.setAttribute(PHX_PARENT_ID, this.parent ? this.parent.id : null);
      const formsToRecover = (
        // we go over all forms in the new DOM; because this is only the HTML for the current
        // view, we can be sure that all forms are owned by this view:
        dom_default.all(template.content, "form").filter((newForm) => newForm.id && oldForms[newForm.id]).filter((newForm) => !this.pendingForms.has(newForm.id)).filter((newForm) => oldForms[newForm.id].getAttribute(phxChange) === newForm.getAttribute(phxChange)).map((newForm) => {
          return [oldForms[newForm.id], newForm];
        })
      );
      if (formsToRecover.length === 0) {
        return callback2();
      }
      formsToRecover.forEach(([oldForm, newForm], i2) => {
        this.pendingForms.add(newForm.id);
        this.pushFormRecovery(oldForm, newForm, template.content.firstElementChild, () => {
          this.pendingForms.delete(newForm.id);
          if (i2 === formsToRecover.length - 1) {
            callback2();
          }
        });
      });
    }
    getChildById(id) {
      return this.root.children[this.id][id];
    }
    getDescendentByEl(el) {
      var _a;
      if (el.id === this.id) {
        return this;
      } else {
        return (_a = this.children[el.getAttribute(PHX_PARENT_ID)]) == null ? void 0 : _a[el.id];
      }
    }
    destroyDescendent(id) {
      for (let parentId in this.root.children) {
        for (let childId in this.root.children[parentId]) {
          if (childId === id) {
            return this.root.children[parentId][childId].destroy();
          }
        }
      }
    }
    joinChild(el) {
      let child = this.getChildById(el.id);
      if (!child) {
        let view = new _View(el, this.liveSocket, this);
        this.root.children[this.id][view.id] = view;
        view.join();
        this.childJoins++;
        return true;
      }
    }
    isJoinPending() {
      return this.joinPending;
    }
    ackJoin(_child) {
      this.childJoins--;
      if (this.childJoins === 0) {
        if (this.parent) {
          this.parent.ackJoin(this);
        } else {
          this.onAllChildJoinsComplete();
        }
      }
    }
    onAllChildJoinsComplete() {
      this.pendingForms.clear();
      this.formsForRecovery = {};
      this.joinCallback(() => {
        this.pendingJoinOps.forEach(([view, op]) => {
          if (!view.isDestroyed()) {
            op();
          }
        });
        this.pendingJoinOps = [];
      });
    }
    update(diff, events) {
      if (this.isJoinPending() || this.liveSocket.hasPendingLink() && this.root.isMain()) {
        return this.pendingDiffs.push({ diff, events });
      }
      this.rendered.mergeDiff(diff);
      let phxChildrenAdded = false;
      if (this.rendered.isComponentOnlyDiff(diff)) {
        this.liveSocket.time("component patch complete", () => {
          let parentCids = dom_default.findExistingParentCIDs(this.el, this.rendered.componentCIDs(diff));
          parentCids.forEach((parentCID) => {
            if (this.componentPatch(this.rendered.getComponent(diff, parentCID), parentCID)) {
              phxChildrenAdded = true;
            }
          });
        });
      } else if (!isEmpty(diff)) {
        this.liveSocket.time("full patch complete", () => {
          let [html, streams] = this.renderContainer(diff, "update");
          let patch = new DOMPatch(this, this.el, this.id, html, streams, null);
          phxChildrenAdded = this.performPatch(patch, true);
        });
      }
      this.liveSocket.dispatchEvents(events);
      if (phxChildrenAdded) {
        this.joinNewChildren();
      }
    }
    renderContainer(diff, kind) {
      return this.liveSocket.time(`toString diff (${kind})`, () => {
        let tag = this.el.tagName;
        let cids = diff ? this.rendered.componentCIDs(diff) : null;
        let [html, streams] = this.rendered.toString(cids);
        return [`<${tag}>${html}</${tag}>`, streams];
      });
    }
    componentPatch(diff, cid) {
      if (isEmpty(diff))
        return false;
      let [html, streams] = this.rendered.componentToString(cid);
      let patch = new DOMPatch(this, this.el, this.id, html, streams, cid);
      let childrenAdded = this.performPatch(patch, true);
      return childrenAdded;
    }
    getHook(el) {
      return this.viewHooks[ViewHook.elementID(el)];
    }
    addHook(el) {
      let hookElId = ViewHook.elementID(el);
      if (el.getAttribute && !this.ownsElement(el)) {
        return;
      }
      if (hookElId && !this.viewHooks[hookElId]) {
        let hook = dom_default.getCustomElHook(el) || logError(`no hook found for custom element: ${el.id}`);
        this.viewHooks[hookElId] = hook;
        hook.__attachView(this);
        return hook;
      } else if (hookElId || !el.getAttribute) {
        return;
      } else {
        let hookName = el.getAttribute(`data-phx-${PHX_HOOK}`) || el.getAttribute(this.binding(PHX_HOOK));
        let callbacks = this.liveSocket.getHookCallbacks(hookName);
        if (callbacks) {
          if (!el.id) {
            logError(`no DOM ID for hook "${hookName}". Hooks require a unique ID on each element.`, el);
          }
          let hook = new ViewHook(this, el, callbacks);
          this.viewHooks[ViewHook.elementID(hook.el)] = hook;
          return hook;
        } else if (hookName !== null) {
          logError(`unknown hook found for "${hookName}"`, el);
        }
      }
    }
    destroyHook(hook) {
      const hookId = ViewHook.elementID(hook.el);
      hook.__destroyed();
      hook.__cleanup__();
      delete this.viewHooks[hookId];
    }
    applyPendingUpdates() {
      this.pendingDiffs.forEach(({ diff, events }) => this.update(diff, events));
      this.pendingDiffs = [];
      this.eachChild((child) => child.applyPendingUpdates());
    }
    eachChild(callback2) {
      let children = this.root.children[this.id] || {};
      for (let id in children) {
        callback2(this.getChildById(id));
      }
    }
    onChannel(event, cb) {
      this.liveSocket.onChannel(this.channel, event, (resp) => {
        if (this.isJoinPending()) {
          this.root.pendingJoinOps.push([this, () => cb(resp)]);
        } else {
          this.liveSocket.requestDOMUpdate(() => cb(resp));
        }
      });
    }
    bindChannel() {
      this.liveSocket.onChannel(this.channel, "diff", (rawDiff) => {
        this.liveSocket.requestDOMUpdate(() => {
          this.applyDiff("update", rawDiff, ({ diff, events }) => this.update(diff, events));
        });
      });
      this.onChannel("redirect", ({ to: to2, flash }) => this.onRedirect({ to: to2, flash }));
      this.onChannel("live_patch", (redir) => this.onLivePatch(redir));
      this.onChannel("live_redirect", (redir) => this.onLiveRedirect(redir));
      this.channel.onError((reason) => this.onError(reason));
      this.channel.onClose((reason) => this.onClose(reason));
    }
    destroyAllChildren() {
      this.eachChild((child) => child.destroy());
    }
    onLiveRedirect(redir) {
      let { to: to2, kind, flash } = redir;
      let url = this.expandURL(to2);
      let e2 = new CustomEvent("phx:server-navigate", { detail: { to: to2, kind, flash } });
      this.liveSocket.historyRedirect(e2, url, kind, flash);
    }
    onLivePatch(redir) {
      let { to: to2, kind } = redir;
      this.href = this.expandURL(to2);
      this.liveSocket.historyPatch(to2, kind);
    }
    expandURL(to2) {
      return to2.startsWith("/") ? `${window.location.protocol}//${window.location.host}${to2}` : to2;
    }
    onRedirect({ to: to2, flash, reloadToken }) {
      this.liveSocket.redirect(to2, flash, reloadToken);
    }
    isDestroyed() {
      return this.destroyed;
    }
    joinDead() {
      this.isDead = true;
    }
    joinPush() {
      this.joinPush = this.joinPush || this.channel.join();
      return this.joinPush;
    }
    join(callback2) {
      this.showLoader(this.liveSocket.loaderTimeout);
      this.bindChannel();
      if (this.isMain()) {
        this.stopCallback = this.liveSocket.withPageLoading({ to: this.href, kind: "initial" });
      }
      this.joinCallback = (onDone) => {
        onDone = onDone || function() {
        };
        callback2 ? callback2(this.joinCount, onDone) : onDone();
      };
      this.wrapPush(() => this.channel.join(), {
        ok: (resp) => this.liveSocket.requestDOMUpdate(() => this.onJoin(resp)),
        error: (error) => this.onJoinError(error),
        timeout: () => this.onJoinError({ reason: "timeout" })
      });
    }
    onJoinError(resp) {
      if (resp.reason === "reload") {
        this.log("error", () => [`failed mount with ${resp.status}. Falling back to page reload`, resp]);
        this.onRedirect({ to: this.root.href, reloadToken: resp.token });
        return;
      } else if (resp.reason === "unauthorized" || resp.reason === "stale") {
        this.log("error", () => ["unauthorized live_redirect. Falling back to page request", resp]);
        this.onRedirect({ to: this.root.href });
        return;
      }
      if (resp.redirect || resp.live_redirect) {
        this.joinPending = false;
        this.channel.leave();
      }
      if (resp.redirect) {
        return this.onRedirect(resp.redirect);
      }
      if (resp.live_redirect) {
        return this.onLiveRedirect(resp.live_redirect);
      }
      this.log("error", () => ["unable to join", resp]);
      if (this.isMain()) {
        this.displayError([PHX_LOADING_CLASS, PHX_ERROR_CLASS, PHX_SERVER_ERROR_CLASS]);
        if (this.liveSocket.isConnected()) {
          this.liveSocket.reloadWithJitter(this);
        }
      } else {
        if (this.joinAttempts >= MAX_CHILD_JOIN_ATTEMPTS) {
          this.root.displayError([PHX_LOADING_CLASS, PHX_ERROR_CLASS, PHX_SERVER_ERROR_CLASS]);
          this.log("error", () => [`giving up trying to mount after ${MAX_CHILD_JOIN_ATTEMPTS} tries`, resp]);
          this.destroy();
        }
        let trueChildEl = dom_default.byId(this.el.id);
        if (trueChildEl) {
          dom_default.mergeAttrs(trueChildEl, this.el);
          this.displayError([PHX_LOADING_CLASS, PHX_ERROR_CLASS, PHX_SERVER_ERROR_CLASS]);
          this.el = trueChildEl;
        } else {
          this.destroy();
        }
      }
    }
    onClose(reason) {
      if (this.isDestroyed()) {
        return;
      }
      if (this.isMain() && this.liveSocket.hasPendingLink() && reason !== "leave") {
        return this.liveSocket.reloadWithJitter(this);
      }
      this.destroyAllChildren();
      this.liveSocket.dropActiveElement(this);
      if (document.activeElement) {
        document.activeElement.blur();
      }
      if (this.liveSocket.isUnloaded()) {
        this.showLoader(BEFORE_UNLOAD_LOADER_TIMEOUT);
      }
    }
    onError(reason) {
      this.onClose(reason);
      if (this.liveSocket.isConnected()) {
        this.log("error", () => ["view crashed", reason]);
      }
      if (!this.liveSocket.isUnloaded()) {
        if (this.liveSocket.isConnected()) {
          this.displayError([PHX_LOADING_CLASS, PHX_ERROR_CLASS, PHX_SERVER_ERROR_CLASS]);
        } else {
          this.displayError([PHX_LOADING_CLASS, PHX_ERROR_CLASS, PHX_CLIENT_ERROR_CLASS]);
        }
      }
    }
    displayError(classes) {
      if (this.isMain()) {
        dom_default.dispatchEvent(window, "phx:page-loading-start", { detail: { to: this.href, kind: "error" } });
      }
      this.showLoader();
      this.setContainerClasses(...classes);
      this.execAll(this.binding("disconnected"));
    }
    wrapPush(callerPush, receives) {
      let latency = this.liveSocket.getLatencySim();
      let withLatency = latency ? (cb) => setTimeout(() => !this.isDestroyed() && cb(), latency) : (cb) => !this.isDestroyed() && cb();
      withLatency(() => {
        callerPush().receive("ok", (resp) => withLatency(() => receives.ok && receives.ok(resp))).receive("error", (reason) => withLatency(() => receives.error && receives.error(reason))).receive("timeout", () => withLatency(() => receives.timeout && receives.timeout()));
      });
    }
    pushWithReply(refGenerator, event, payload) {
      if (!this.isConnected()) {
        return Promise.reject({ error: "noconnection" });
      }
      let [ref, [el], opts] = refGenerator ? refGenerator() : [null, [], {}];
      let oldJoinCount = this.joinCount;
      let onLoadingDone = function() {
      };
      if (opts.page_loading) {
        onLoadingDone = this.liveSocket.withPageLoading({ kind: "element", target: el });
      }
      if (typeof payload.cid !== "number") {
        delete payload.cid;
      }
      return new Promise((resolve2, reject) => {
        this.wrapPush(() => this.channel.push(event, payload, PUSH_TIMEOUT), {
          ok: (resp) => {
            if (ref !== null) {
              this.lastAckRef = ref;
            }
            let finish = (hookReply) => {
              if (resp.redirect) {
                this.onRedirect(resp.redirect);
              }
              if (resp.live_patch) {
                this.onLivePatch(resp.live_patch);
              }
              if (resp.live_redirect) {
                this.onLiveRedirect(resp.live_redirect);
              }
              onLoadingDone();
              resolve2({ resp, reply: hookReply });
            };
            if (resp.diff) {
              this.liveSocket.requestDOMUpdate(() => {
                this.applyDiff("update", resp.diff, ({ diff, reply, events }) => {
                  if (ref !== null) {
                    this.undoRefs(ref, payload.event);
                  }
                  this.update(diff, events);
                  finish(reply);
                });
              });
            } else {
              if (ref !== null) {
                this.undoRefs(ref, payload.event);
              }
              finish(null);
            }
          },
          error: (reason) => reject({ error: reason }),
          timeout: () => {
            reject({ timeout: true });
            if (this.joinCount === oldJoinCount) {
              this.liveSocket.reloadWithJitter(this, () => {
                this.log("timeout", () => ["received timeout while communicating with server. Falling back to hard refresh for recovery"]);
              });
            }
          }
        });
      });
    }
    undoRefs(ref, phxEvent, onlyEls) {
      if (!this.isConnected()) {
        return;
      }
      let selector = `[${PHX_REF_SRC}="${this.refSrc()}"]`;
      if (onlyEls) {
        onlyEls = new Set(onlyEls);
        dom_default.all(document, selector, (parent) => {
          if (onlyEls && !onlyEls.has(parent)) {
            return;
          }
          dom_default.all(parent, selector, (child) => this.undoElRef(child, ref, phxEvent));
          this.undoElRef(parent, ref, phxEvent);
        });
      } else {
        dom_default.all(document, selector, (el) => this.undoElRef(el, ref, phxEvent));
      }
    }
    undoElRef(el, ref, phxEvent) {
      let elRef = new ElementRef(el);
      elRef.maybeUndo(ref, phxEvent, (clonedTree) => {
        let patch = new DOMPatch(this, el, this.id, clonedTree, [], null, { undoRef: ref });
        const phxChildrenAdded = this.performPatch(patch, true);
        dom_default.all(el, `[${PHX_REF_SRC}="${this.refSrc()}"]`, (child) => this.undoElRef(child, ref, phxEvent));
        if (phxChildrenAdded) {
          this.joinNewChildren();
        }
      });
    }
    refSrc() {
      return this.el.id;
    }
    putRef(elements2, phxEvent, eventType, opts = {}) {
      let newRef = this.ref++;
      let disableWith = this.binding(PHX_DISABLE_WITH);
      if (opts.loading) {
        let loadingEls = dom_default.all(document, opts.loading).map((el) => {
          return { el, lock: true, loading: true };
        });
        elements2 = elements2.concat(loadingEls);
      }
      for (let { el, lock, loading } of elements2) {
        if (!lock && !loading) {
          throw new Error("putRef requires lock or loading");
        }
        el.setAttribute(PHX_REF_SRC, this.refSrc());
        if (loading) {
          el.setAttribute(PHX_REF_LOADING, newRef);
        }
        if (lock) {
          el.setAttribute(PHX_REF_LOCK, newRef);
        }
        if (!loading || opts.submitter && !(el === opts.submitter || el === opts.form)) {
          continue;
        }
        let lockCompletePromise = new Promise((resolve2) => {
          el.addEventListener(`phx:undo-lock:${newRef}`, () => resolve2(detail), { once: true });
        });
        let loadingCompletePromise = new Promise((resolve2) => {
          el.addEventListener(`phx:undo-loading:${newRef}`, () => resolve2(detail), { once: true });
        });
        el.classList.add(`phx-${eventType}-loading`);
        let disableText = el.getAttribute(disableWith);
        if (disableText !== null) {
          if (!el.getAttribute(PHX_DISABLE_WITH_RESTORE)) {
            el.setAttribute(PHX_DISABLE_WITH_RESTORE, el.innerText);
          }
          if (disableText !== "") {
            el.innerText = disableText;
          }
          el.setAttribute(PHX_DISABLED, el.getAttribute(PHX_DISABLED) || el.disabled);
          el.setAttribute("disabled", "");
        }
        let detail = {
          event: phxEvent,
          eventType,
          ref: newRef,
          isLoading: loading,
          isLocked: lock,
          lockElements: elements2.filter(({ lock: lock2 }) => lock2).map(({ el: el2 }) => el2),
          loadingElements: elements2.filter(({ loading: loading2 }) => loading2).map(({ el: el2 }) => el2),
          unlock: (els) => {
            els = Array.isArray(els) ? els : [els];
            this.undoRefs(newRef, phxEvent, els);
          },
          lockComplete: lockCompletePromise,
          loadingComplete: loadingCompletePromise,
          lock: (lockEl) => {
            return new Promise((resolve2) => {
              if (this.isAcked(newRef)) {
                return resolve2(detail);
              }
              lockEl.setAttribute(PHX_REF_LOCK, newRef);
              lockEl.setAttribute(PHX_REF_SRC, this.refSrc());
              lockEl.addEventListener(`phx:lock-stop:${newRef}`, () => resolve2(detail), { once: true });
            });
          }
        };
        el.dispatchEvent(new CustomEvent("phx:push", {
          detail,
          bubbles: true,
          cancelable: false
        }));
        if (phxEvent) {
          el.dispatchEvent(new CustomEvent(`phx:push:${phxEvent}`, {
            detail,
            bubbles: true,
            cancelable: false
          }));
        }
      }
      return [newRef, elements2.map(({ el }) => el), opts];
    }
    isAcked(ref) {
      return this.lastAckRef !== null && this.lastAckRef >= ref;
    }
    componentID(el) {
      let cid = el.getAttribute && el.getAttribute(PHX_COMPONENT);
      return cid ? parseInt(cid) : null;
    }
    targetComponentID(target, targetCtx, opts = {}) {
      if (isCid(targetCtx)) {
        return targetCtx;
      }
      let cidOrSelector = opts.target || target.getAttribute(this.binding("target"));
      if (isCid(cidOrSelector)) {
        return parseInt(cidOrSelector);
      } else if (targetCtx && (cidOrSelector !== null || opts.target)) {
        return this.closestComponentID(targetCtx);
      } else {
        return null;
      }
    }
    closestComponentID(targetCtx) {
      if (isCid(targetCtx)) {
        return targetCtx;
      } else if (targetCtx) {
        return maybe(targetCtx.closest(`[${PHX_COMPONENT}]`), (el) => this.ownsElement(el) && this.componentID(el));
      } else {
        return null;
      }
    }
    pushHookEvent(el, targetCtx, event, payload, onReply) {
      if (!this.isConnected()) {
        this.log("hook", () => ["unable to push hook event. LiveView not connected", event, payload]);
        return false;
      }
      let [ref, els, opts] = this.putRef([{ el, loading: true, lock: true }], event, "hook");
      this.pushWithReply(() => [ref, els, opts], "event", {
        type: "hook",
        event,
        value: payload,
        cid: this.closestComponentID(targetCtx)
      }).then(({ resp: _resp, reply: hookReply }) => onReply(hookReply, ref));
      return ref;
    }
    extractMeta(el, meta, value) {
      let prefix = this.binding("value-");
      for (let i2 = 0; i2 < el.attributes.length; i2++) {
        if (!meta) {
          meta = {};
        }
        let name = el.attributes[i2].name;
        if (name.startsWith(prefix)) {
          meta[name.replace(prefix, "")] = el.getAttribute(name);
        }
      }
      if (el.value !== void 0 && !(el instanceof HTMLFormElement)) {
        if (!meta) {
          meta = {};
        }
        meta.value = el.value;
        if (el.tagName === "INPUT" && CHECKABLE_INPUTS.indexOf(el.type) >= 0 && !el.checked) {
          delete meta.value;
        }
      }
      if (value) {
        if (!meta) {
          meta = {};
        }
        for (let key in value) {
          meta[key] = value[key];
        }
      }
      return meta;
    }
    pushEvent(type, el, targetCtx, phxEvent, meta, opts = {}, onReply) {
      this.pushWithReply(() => this.putRef([{ el, loading: true, lock: true }], phxEvent, type, opts), "event", {
        type,
        event: phxEvent,
        value: this.extractMeta(el, meta, opts.value),
        cid: this.targetComponentID(el, targetCtx, opts)
      }).then(({ reply }) => onReply && onReply(reply));
    }
    pushFileProgress(fileEl, entryRef, progress, onReply = function() {
    }) {
      this.liveSocket.withinOwners(fileEl.form, (view, targetCtx) => {
        view.pushWithReply(null, "progress", {
          event: fileEl.getAttribute(view.binding(PHX_PROGRESS)),
          ref: fileEl.getAttribute(PHX_UPLOAD_REF),
          entry_ref: entryRef,
          progress,
          cid: view.targetComponentID(fileEl.form, targetCtx)
        }).then(({ resp }) => onReply(resp));
      });
    }
    pushInput(inputEl, targetCtx, forceCid, phxEvent, opts, callback2) {
      if (!inputEl.form) {
        throw new Error("form events require the input to be inside a form");
      }
      let uploads;
      let cid = isCid(forceCid) ? forceCid : this.targetComponentID(inputEl.form, targetCtx, opts);
      let refGenerator = () => {
        return this.putRef([
          { el: inputEl, loading: true, lock: true },
          { el: inputEl.form, loading: true, lock: true }
        ], phxEvent, "change", opts);
      };
      let formData;
      let meta = this.extractMeta(inputEl.form);
      if (inputEl instanceof HTMLButtonElement) {
        meta.submitter = inputEl;
      }
      if (inputEl.getAttribute(this.binding("change"))) {
        formData = serializeForm(inputEl.form, __spreadValues({ _target: opts._target }, meta), [inputEl.name]);
      } else {
        formData = serializeForm(inputEl.form, __spreadValues({ _target: opts._target }, meta));
      }
      if (dom_default.isUploadInput(inputEl) && inputEl.files && inputEl.files.length > 0) {
        LiveUploader.trackFiles(inputEl, Array.from(inputEl.files));
      }
      uploads = LiveUploader.serializeUploads(inputEl);
      let event = {
        type: "form",
        event: phxEvent,
        value: formData,
        uploads,
        cid
      };
      this.pushWithReply(refGenerator, "event", event).then(({ resp }) => {
        if (dom_default.isUploadInput(inputEl) && dom_default.isAutoUpload(inputEl)) {
          ElementRef.onUnlock(inputEl, () => {
            if (LiveUploader.filesAwaitingPreflight(inputEl).length > 0) {
              let [ref, _els] = refGenerator();
              this.undoRefs(ref, phxEvent, [inputEl.form]);
              this.uploadFiles(inputEl.form, phxEvent, targetCtx, ref, cid, (_uploads) => {
                callback2 && callback2(resp);
                this.triggerAwaitingSubmit(inputEl.form, phxEvent);
                this.undoRefs(ref, phxEvent);
              });
            }
          });
        } else {
          callback2 && callback2(resp);
        }
      });
    }
    triggerAwaitingSubmit(formEl, phxEvent) {
      let awaitingSubmit = this.getScheduledSubmit(formEl);
      if (awaitingSubmit) {
        let [_el, _ref, _opts, callback2] = awaitingSubmit;
        this.cancelSubmit(formEl, phxEvent);
        callback2();
      }
    }
    getScheduledSubmit(formEl) {
      return this.formSubmits.find(([el, _ref, _opts, _callback]) => el.isSameNode(formEl));
    }
    scheduleSubmit(formEl, ref, opts, callback2) {
      if (this.getScheduledSubmit(formEl)) {
        return true;
      }
      this.formSubmits.push([formEl, ref, opts, callback2]);
    }
    cancelSubmit(formEl, phxEvent) {
      this.formSubmits = this.formSubmits.filter(([el, ref, _opts, _callback]) => {
        if (el.isSameNode(formEl)) {
          this.undoRefs(ref, phxEvent);
          return false;
        } else {
          return true;
        }
      });
    }
    disableForm(formEl, phxEvent, opts = {}) {
      let filterIgnored = (el) => {
        let userIgnored = closestPhxBinding(el, `${this.binding(PHX_UPDATE)}=ignore`, el.form);
        return !(userIgnored || closestPhxBinding(el, "data-phx-update=ignore", el.form));
      };
      let filterDisables = (el) => {
        return el.hasAttribute(this.binding(PHX_DISABLE_WITH));
      };
      let filterButton = (el) => el.tagName == "BUTTON";
      let filterInput = (el) => ["INPUT", "TEXTAREA", "SELECT"].includes(el.tagName);
      let formElements = Array.from(formEl.elements);
      let disables = formElements.filter(filterDisables);
      let buttons = formElements.filter(filterButton).filter(filterIgnored);
      let inputs = formElements.filter(filterInput).filter(filterIgnored);
      buttons.forEach((button) => {
        button.setAttribute(PHX_DISABLED, button.disabled);
        button.disabled = true;
      });
      inputs.forEach((input) => {
        input.setAttribute(PHX_READONLY, input.readOnly);
        input.readOnly = true;
        if (input.files) {
          input.setAttribute(PHX_DISABLED, input.disabled);
          input.disabled = true;
        }
      });
      let formEls = disables.concat(buttons).concat(inputs).map((el) => {
        return { el, loading: true, lock: true };
      });
      let els = [{ el: formEl, loading: true, lock: false }].concat(formEls).reverse();
      return this.putRef(els, phxEvent, "submit", opts);
    }
    pushFormSubmit(formEl, targetCtx, phxEvent, submitter, opts, onReply) {
      let refGenerator = () => this.disableForm(formEl, phxEvent, __spreadProps(__spreadValues({}, opts), {
        form: formEl,
        submitter
      }));
      let cid = this.targetComponentID(formEl, targetCtx);
      if (LiveUploader.hasUploadsInProgress(formEl)) {
        let [ref, _els] = refGenerator();
        let push = () => this.pushFormSubmit(formEl, targetCtx, phxEvent, submitter, opts, onReply);
        return this.scheduleSubmit(formEl, ref, opts, push);
      } else if (LiveUploader.inputsAwaitingPreflight(formEl).length > 0) {
        let [ref, els] = refGenerator();
        let proxyRefGen = () => [ref, els, opts];
        this.uploadFiles(formEl, phxEvent, targetCtx, ref, cid, (_uploads) => {
          if (LiveUploader.inputsAwaitingPreflight(formEl).length > 0) {
            return this.undoRefs(ref, phxEvent);
          }
          let meta = this.extractMeta(formEl);
          let formData = serializeForm(formEl, __spreadValues({ submitter }, meta));
          this.pushWithReply(proxyRefGen, "event", {
            type: "form",
            event: phxEvent,
            value: formData,
            cid
          }).then(({ resp }) => onReply(resp));
        });
      } else if (!(formEl.hasAttribute(PHX_REF_SRC) && formEl.classList.contains("phx-submit-loading"))) {
        let meta = this.extractMeta(formEl);
        let formData = serializeForm(formEl, __spreadValues({ submitter }, meta));
        this.pushWithReply(refGenerator, "event", {
          type: "form",
          event: phxEvent,
          value: formData,
          cid
        }).then(({ resp }) => onReply(resp));
      }
    }
    uploadFiles(formEl, phxEvent, targetCtx, ref, cid, onComplete) {
      let joinCountAtUpload = this.joinCount;
      let inputEls = LiveUploader.activeFileInputs(formEl);
      let numFileInputsInProgress = inputEls.length;
      inputEls.forEach((inputEl) => {
        let uploader = new LiveUploader(inputEl, this, () => {
          numFileInputsInProgress--;
          if (numFileInputsInProgress === 0) {
            onComplete();
          }
        });
        let entries = uploader.entries().map((entry) => entry.toPreflightPayload());
        if (entries.length === 0) {
          numFileInputsInProgress--;
          return;
        }
        let payload = {
          ref: inputEl.getAttribute(PHX_UPLOAD_REF),
          entries,
          cid: this.targetComponentID(inputEl.form, targetCtx)
        };
        this.log("upload", () => ["sending preflight request", payload]);
        this.pushWithReply(null, "allow_upload", payload).then(({ resp }) => {
          this.log("upload", () => ["got preflight response", resp]);
          uploader.entries().forEach((entry) => {
            if (resp.entries && !resp.entries[entry.ref]) {
              this.handleFailedEntryPreflight(entry.ref, "failed preflight", uploader);
            }
          });
          if (resp.error || Object.keys(resp.entries).length === 0) {
            this.undoRefs(ref, phxEvent);
            let errors = resp.error || [];
            errors.map(([entry_ref, reason]) => {
              this.handleFailedEntryPreflight(entry_ref, reason, uploader);
            });
          } else {
            let onError = (callback2) => {
              this.channel.onError(() => {
                if (this.joinCount === joinCountAtUpload) {
                  callback2();
                }
              });
            };
            uploader.initAdapterUpload(resp, onError, this.liveSocket);
          }
        });
      });
    }
    handleFailedEntryPreflight(uploadRef, reason, uploader) {
      if (uploader.isAutoUpload()) {
        let entry = uploader.entries().find((entry2) => entry2.ref === uploadRef.toString());
        if (entry) {
          entry.cancel();
        }
      } else {
        uploader.entries().map((entry) => entry.cancel());
      }
      this.log("upload", () => [`error for entry ${uploadRef}`, reason]);
    }
    dispatchUploads(targetCtx, name, filesOrBlobs) {
      let targetElement = this.targetCtxElement(targetCtx) || this.el;
      let inputs = dom_default.findUploadInputs(targetElement).filter((el) => el.name === name);
      if (inputs.length === 0) {
        logError(`no live file inputs found matching the name "${name}"`);
      } else if (inputs.length > 1) {
        logError(`duplicate live file inputs found matching the name "${name}"`);
      } else {
        dom_default.dispatchEvent(inputs[0], PHX_TRACK_UPLOADS, { detail: { files: filesOrBlobs } });
      }
    }
    targetCtxElement(targetCtx) {
      if (isCid(targetCtx)) {
        let [target] = dom_default.findComponentNodeList(this.el, targetCtx);
        return target;
      } else if (targetCtx) {
        return targetCtx;
      } else {
        return null;
      }
    }
    pushFormRecovery(oldForm, newForm, templateDom, callback2) {
      const phxChange = this.binding("change");
      const phxTarget = newForm.getAttribute(this.binding("target")) || newForm;
      const phxEvent = newForm.getAttribute(this.binding(PHX_AUTO_RECOVER)) || newForm.getAttribute(this.binding("change"));
      const inputs = Array.from(oldForm.elements).filter((el) => dom_default.isFormInput(el) && el.name && !el.hasAttribute(phxChange));
      if (inputs.length === 0) {
        return;
      }
      inputs.forEach((input2) => input2.hasAttribute(PHX_UPLOAD_REF) && LiveUploader.clearFiles(input2));
      let input = inputs.find((el) => el.type !== "hidden") || inputs[0];
      let pending = 0;
      this.withinTargets(phxTarget, (targetView, targetCtx) => {
        const cid = this.targetComponentID(newForm, targetCtx);
        pending++;
        let e2 = new CustomEvent("phx:form-recovery", { detail: { sourceElement: oldForm } });
        js_default.exec(e2, "change", phxEvent, this, input, ["push", {
          _target: input.name,
          targetView,
          targetCtx,
          newCid: cid,
          callback: () => {
            pending--;
            if (pending === 0) {
              callback2();
            }
          }
        }]);
      }, templateDom, templateDom);
    }
    pushLinkPatch(e2, href, targetEl, callback2) {
      let linkRef = this.liveSocket.setPendingLink(href);
      let loading = e2.isTrusted && e2.type !== "popstate";
      let refGen = targetEl ? () => this.putRef([{ el: targetEl, loading, lock: true }], null, "click") : null;
      let fallback = () => this.liveSocket.redirect(window.location.href);
      let url = href.startsWith("/") ? `${location.protocol}//${location.host}${href}` : href;
      this.pushWithReply(refGen, "live_patch", { url }).then(
        ({ resp }) => {
          this.liveSocket.requestDOMUpdate(() => {
            if (resp.link_redirect) {
              this.liveSocket.replaceMain(href, null, callback2, linkRef);
            } else {
              if (this.liveSocket.commitPendingLink(linkRef)) {
                this.href = href;
              }
              this.applyPendingUpdates();
              callback2 && callback2(linkRef);
            }
          });
        },
        ({ error: _error, timeout: _timeout }) => fallback()
      );
    }
    getFormsForRecovery() {
      if (this.joinCount === 0) {
        return {};
      }
      let phxChange = this.binding("change");
      return dom_default.all(this.el, `form[${phxChange}]`).filter((form) => form.id).filter((form) => form.elements.length > 0).filter((form) => form.getAttribute(this.binding(PHX_AUTO_RECOVER)) !== "ignore").map((form) => form.cloneNode(true)).reduce((acc, form) => {
        acc[form.id] = form;
        return acc;
      }, {});
    }
    maybePushComponentsDestroyed(destroyedCIDs) {
      let willDestroyCIDs = destroyedCIDs.filter((cid) => {
        return dom_default.findComponentNodeList(this.el, cid).length === 0;
      });
      if (willDestroyCIDs.length > 0) {
        willDestroyCIDs.forEach((cid) => this.rendered.resetRender(cid));
        this.pushWithReply(null, "cids_will_destroy", { cids: willDestroyCIDs }).then(() => {
          this.liveSocket.requestDOMUpdate(() => {
            let completelyDestroyCIDs = willDestroyCIDs.filter((cid) => {
              return dom_default.findComponentNodeList(this.el, cid).length === 0;
            });
            if (completelyDestroyCIDs.length > 0) {
              this.pushWithReply(null, "cids_destroyed", { cids: completelyDestroyCIDs }).then(({ resp }) => {
                this.rendered.pruneCIDs(resp.cids);
              });
            }
          });
        });
      }
    }
    ownsElement(el) {
      let parentViewEl = el.closest(PHX_VIEW_SELECTOR);
      return el.getAttribute(PHX_PARENT_ID) === this.id || parentViewEl && parentViewEl.id === this.id || !parentViewEl && this.isDead;
    }
    submitForm(form, targetCtx, phxEvent, submitter, opts = {}) {
      dom_default.putPrivate(form, PHX_HAS_SUBMITTED, true);
      const inputs = Array.from(form.elements);
      inputs.forEach((input) => dom_default.putPrivate(input, PHX_HAS_SUBMITTED, true));
      this.liveSocket.blurActiveElement(this);
      this.pushFormSubmit(form, targetCtx, phxEvent, submitter, opts, () => {
        this.liveSocket.restorePreviouslyActiveFocus();
      });
    }
    binding(kind) {
      return this.liveSocket.binding(kind);
    }
  };
  var LiveSocket = class {
    constructor(url, phxSocket, opts = {}) {
      this.unloaded = false;
      if (!phxSocket || phxSocket.constructor.name === "Object") {
        throw new Error(`
      a phoenix Socket must be provided as the second argument to the LiveSocket constructor. For example:

          import {Socket} from "phoenix"
          import {LiveSocket} from "phoenix_live_view"
          let liveSocket = new LiveSocket("/live", Socket, {...})
      `);
      }
      this.socket = new phxSocket(url, opts);
      this.bindingPrefix = opts.bindingPrefix || BINDING_PREFIX;
      this.opts = opts;
      this.params = closure2(opts.params || {});
      this.viewLogger = opts.viewLogger;
      this.metadataCallbacks = opts.metadata || {};
      this.defaults = Object.assign(clone(DEFAULTS), opts.defaults || {});
      this.activeElement = null;
      this.prevActive = null;
      this.silenced = false;
      this.main = null;
      this.outgoingMainEl = null;
      this.clickStartedAtTarget = null;
      this.linkRef = 1;
      this.roots = {};
      this.href = window.location.href;
      this.pendingLink = null;
      this.currentLocation = clone(window.location);
      this.hooks = opts.hooks || {};
      this.uploaders = opts.uploaders || {};
      this.loaderTimeout = opts.loaderTimeout || LOADER_TIMEOUT;
      this.reloadWithJitterTimer = null;
      this.maxReloads = opts.maxReloads || MAX_RELOADS;
      this.reloadJitterMin = opts.reloadJitterMin || RELOAD_JITTER_MIN;
      this.reloadJitterMax = opts.reloadJitterMax || RELOAD_JITTER_MAX;
      this.failsafeJitter = opts.failsafeJitter || FAILSAFE_JITTER;
      this.localStorage = opts.localStorage || window.localStorage;
      this.sessionStorage = opts.sessionStorage || window.sessionStorage;
      this.boundTopLevelEvents = false;
      this.boundEventNames = /* @__PURE__ */ new Set();
      this.serverCloseRef = null;
      this.domCallbacks = Object.assign(
        {
          jsQuerySelectorAll: null,
          onPatchStart: closure2(),
          onPatchEnd: closure2(),
          onNodeAdded: closure2(),
          onBeforeElUpdated: closure2()
        },
        opts.dom || {}
      );
      this.transitions = new TransitionSet();
      this.currentHistoryPosition = parseInt(this.sessionStorage.getItem(PHX_LV_HISTORY_POSITION)) || 0;
      window.addEventListener("pagehide", (_e) => {
        this.unloaded = true;
      });
      this.socket.onOpen(() => {
        if (this.isUnloaded()) {
          window.location.reload();
        }
      });
    }
    // public
    version() {
      return "1.0.4";
    }
    isProfileEnabled() {
      return this.sessionStorage.getItem(PHX_LV_PROFILE) === "true";
    }
    isDebugEnabled() {
      return this.sessionStorage.getItem(PHX_LV_DEBUG) === "true";
    }
    isDebugDisabled() {
      return this.sessionStorage.getItem(PHX_LV_DEBUG) === "false";
    }
    enableDebug() {
      this.sessionStorage.setItem(PHX_LV_DEBUG, "true");
    }
    enableProfiling() {
      this.sessionStorage.setItem(PHX_LV_PROFILE, "true");
    }
    disableDebug() {
      this.sessionStorage.setItem(PHX_LV_DEBUG, "false");
    }
    disableProfiling() {
      this.sessionStorage.removeItem(PHX_LV_PROFILE);
    }
    enableLatencySim(upperBoundMs) {
      this.enableDebug();
      console.log("latency simulator enabled for the duration of this browser session. Call disableLatencySim() to disable");
      this.sessionStorage.setItem(PHX_LV_LATENCY_SIM, upperBoundMs);
    }
    disableLatencySim() {
      this.sessionStorage.removeItem(PHX_LV_LATENCY_SIM);
    }
    getLatencySim() {
      let str = this.sessionStorage.getItem(PHX_LV_LATENCY_SIM);
      return str ? parseInt(str) : null;
    }
    getSocket() {
      return this.socket;
    }
    connect() {
      if (window.location.hostname === "localhost" && !this.isDebugDisabled()) {
        this.enableDebug();
      }
      let doConnect = () => {
        this.resetReloadStatus();
        if (this.joinRootViews()) {
          this.bindTopLevelEvents();
          this.socket.connect();
        } else if (this.main) {
          this.socket.connect();
        } else {
          this.bindTopLevelEvents({ dead: true });
        }
        this.joinDeadView();
      };
      if (["complete", "loaded", "interactive"].indexOf(document.readyState) >= 0) {
        doConnect();
      } else {
        document.addEventListener("DOMContentLoaded", () => doConnect());
      }
    }
    disconnect(callback2) {
      clearTimeout(this.reloadWithJitterTimer);
      if (this.serverCloseRef) {
        this.socket.off(this.serverCloseRef);
        this.serverCloseRef = null;
      }
      this.socket.disconnect(callback2);
    }
    replaceTransport(transport) {
      clearTimeout(this.reloadWithJitterTimer);
      this.socket.replaceTransport(transport);
      this.connect();
    }
    execJS(el, encodedJS, eventType = null) {
      let e2 = new CustomEvent("phx:exec", { detail: { sourceElement: el } });
      this.owner(el, (view) => js_default.exec(e2, eventType, encodedJS, view, el));
    }
    // private
    execJSHookPush(el, phxEvent, data, callback2) {
      this.withinOwners(el, (view) => {
        let e2 = new CustomEvent("phx:exec", { detail: { sourceElement: el } });
        js_default.exec(e2, "hook", phxEvent, view, el, ["push", { data, callback: callback2 }]);
      });
    }
    unload() {
      if (this.unloaded) {
        return;
      }
      if (this.main && this.isConnected()) {
        this.log(this.main, "socket", () => ["disconnect for page nav"]);
      }
      this.unloaded = true;
      this.destroyAllViews();
      this.disconnect();
    }
    triggerDOM(kind, args) {
      this.domCallbacks[kind](...args);
    }
    time(name, func) {
      if (!this.isProfileEnabled() || !console.time) {
        return func();
      }
      console.time(name);
      let result = func();
      console.timeEnd(name);
      return result;
    }
    log(view, kind, msgCallback) {
      if (this.viewLogger) {
        let [msg, obj] = msgCallback();
        this.viewLogger(view, kind, msg, obj);
      } else if (this.isDebugEnabled()) {
        let [msg, obj] = msgCallback();
        debug(view, kind, msg, obj);
      }
    }
    requestDOMUpdate(callback2) {
      this.transitions.after(callback2);
    }
    transition(time, onStart, onDone = function() {
    }) {
      this.transitions.addTransition(time, onStart, onDone);
    }
    onChannel(channel, event, cb) {
      channel.on(event, (data) => {
        let latency = this.getLatencySim();
        if (!latency) {
          cb(data);
        } else {
          setTimeout(() => cb(data), latency);
        }
      });
    }
    reloadWithJitter(view, log) {
      clearTimeout(this.reloadWithJitterTimer);
      this.disconnect();
      let minMs = this.reloadJitterMin;
      let maxMs = this.reloadJitterMax;
      let afterMs = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;
      let tries = browser_default.updateLocal(this.localStorage, window.location.pathname, CONSECUTIVE_RELOADS, 0, (count) => count + 1);
      if (tries >= this.maxReloads) {
        afterMs = this.failsafeJitter;
      }
      this.reloadWithJitterTimer = setTimeout(() => {
        if (view.isDestroyed() || view.isConnected()) {
          return;
        }
        view.destroy();
        log ? log() : this.log(view, "join", () => [`encountered ${tries} consecutive reloads`]);
        if (tries >= this.maxReloads) {
          this.log(view, "join", () => [`exceeded ${this.maxReloads} consecutive reloads. Entering failsafe mode`]);
        }
        if (this.hasPendingLink()) {
          window.location = this.pendingLink;
        } else {
          window.location.reload();
        }
      }, afterMs);
    }
    getHookCallbacks(name) {
      return name && name.startsWith("Phoenix.") ? hooks_default[name.split(".")[1]] : this.hooks[name];
    }
    isUnloaded() {
      return this.unloaded;
    }
    isConnected() {
      return this.socket.isConnected();
    }
    getBindingPrefix() {
      return this.bindingPrefix;
    }
    binding(kind) {
      return `${this.getBindingPrefix()}${kind}`;
    }
    channel(topic, params) {
      return this.socket.channel(topic, params);
    }
    joinDeadView() {
      let body = document.body;
      if (body && !this.isPhxView(body) && !this.isPhxView(document.firstElementChild)) {
        let view = this.newRootView(body);
        view.setHref(this.getHref());
        view.joinDead();
        if (!this.main) {
          this.main = view;
        }
        window.requestAnimationFrame(() => {
          var _a;
          view.execNewMounted();
          this.maybeScroll((_a = history.state) == null ? void 0 : _a.scroll);
        });
      }
    }
    joinRootViews() {
      let rootsFound = false;
      dom_default.all(document, `${PHX_VIEW_SELECTOR}:not([${PHX_PARENT_ID}])`, (rootEl) => {
        if (!this.getRootById(rootEl.id)) {
          let view = this.newRootView(rootEl);
          if (!dom_default.isPhxSticky(rootEl)) {
            view.setHref(this.getHref());
          }
          view.join();
          if (rootEl.hasAttribute(PHX_MAIN)) {
            this.main = view;
          }
        }
        rootsFound = true;
      });
      return rootsFound;
    }
    redirect(to2, flash, reloadToken) {
      if (reloadToken) {
        browser_default.setCookie(PHX_RELOAD_STATUS, reloadToken, 60);
      }
      this.unload();
      browser_default.redirect(to2, flash);
    }
    replaceMain(href, flash, callback2 = null, linkRef = this.setPendingLink(href)) {
      const liveReferer = this.currentLocation.href;
      this.outgoingMainEl = this.outgoingMainEl || this.main.el;
      const stickies = dom_default.findPhxSticky(document) || [];
      const removeEls = dom_default.all(this.outgoingMainEl, `[${this.binding("remove")}]`).filter((el) => !dom_default.isChildOfAny(el, stickies));
      const newMainEl = dom_default.cloneNode(this.outgoingMainEl, "");
      this.main.showLoader(this.loaderTimeout);
      this.main.destroy();
      this.main = this.newRootView(newMainEl, flash, liveReferer);
      this.main.setRedirect(href);
      this.transitionRemoves(removeEls);
      this.main.join((joinCount, onDone) => {
        if (joinCount === 1 && this.commitPendingLink(linkRef)) {
          this.requestDOMUpdate(() => {
            removeEls.forEach((el) => el.remove());
            stickies.forEach((el) => newMainEl.appendChild(el));
            this.outgoingMainEl.replaceWith(newMainEl);
            this.outgoingMainEl = null;
            callback2 && callback2(linkRef);
            onDone();
          });
        }
      });
    }
    transitionRemoves(elements2, callback2) {
      let removeAttr = this.binding("remove");
      let silenceEvents = (e2) => {
        e2.preventDefault();
        e2.stopImmediatePropagation();
      };
      elements2.forEach((el) => {
        for (let event of this.boundEventNames) {
          el.addEventListener(event, silenceEvents, true);
        }
        this.execJS(el, el.getAttribute(removeAttr), "remove");
      });
      this.requestDOMUpdate(() => {
        elements2.forEach((el) => {
          for (let event of this.boundEventNames) {
            el.removeEventListener(event, silenceEvents, true);
          }
        });
        callback2 && callback2();
      });
    }
    isPhxView(el) {
      return el.getAttribute && el.getAttribute(PHX_SESSION) !== null;
    }
    newRootView(el, flash, liveReferer) {
      let view = new View(el, this, null, flash, liveReferer);
      this.roots[view.id] = view;
      return view;
    }
    owner(childEl, callback2) {
      let view = maybe(childEl.closest(PHX_VIEW_SELECTOR), (el) => this.getViewByEl(el)) || this.main;
      return view && callback2 ? callback2(view) : view;
    }
    withinOwners(childEl, callback2) {
      this.owner(childEl, (view) => callback2(view, childEl));
    }
    getViewByEl(el) {
      let rootId = el.getAttribute(PHX_ROOT_ID);
      return maybe(this.getRootById(rootId), (root) => root.getDescendentByEl(el));
    }
    getRootById(id) {
      return this.roots[id];
    }
    destroyAllViews() {
      for (let id in this.roots) {
        this.roots[id].destroy();
        delete this.roots[id];
      }
      this.main = null;
    }
    destroyViewByEl(el) {
      let root = this.getRootById(el.getAttribute(PHX_ROOT_ID));
      if (root && root.id === el.id) {
        root.destroy();
        delete this.roots[root.id];
      } else if (root) {
        root.destroyDescendent(el.id);
      }
    }
    getActiveElement() {
      return document.activeElement;
    }
    dropActiveElement(view) {
      if (this.prevActive && view.ownsElement(this.prevActive)) {
        this.prevActive = null;
      }
    }
    restorePreviouslyActiveFocus() {
      if (this.prevActive && this.prevActive !== document.body) {
        this.prevActive.focus();
      }
    }
    blurActiveElement() {
      this.prevActive = this.getActiveElement();
      if (this.prevActive !== document.body) {
        this.prevActive.blur();
      }
    }
    bindTopLevelEvents({ dead } = {}) {
      if (this.boundTopLevelEvents) {
        return;
      }
      this.boundTopLevelEvents = true;
      this.serverCloseRef = this.socket.onClose((event) => {
        if (event && event.code === 1e3 && this.main) {
          return this.reloadWithJitter(this.main);
        }
      });
      document.body.addEventListener("click", function() {
      });
      window.addEventListener("pageshow", (e2) => {
        if (e2.persisted) {
          this.getSocket().disconnect();
          this.withPageLoading({ to: window.location.href, kind: "redirect" });
          window.location.reload();
        }
      }, true);
      if (!dead) {
        this.bindNav();
      }
      this.bindClicks();
      if (!dead) {
        this.bindForms();
      }
      this.bind({ keyup: "keyup", keydown: "keydown" }, (e2, type, view, targetEl, phxEvent, _phxTarget) => {
        let matchKey = targetEl.getAttribute(this.binding(PHX_KEY));
        let pressedKey = e2.key && e2.key.toLowerCase();
        if (matchKey && matchKey.toLowerCase() !== pressedKey) {
          return;
        }
        let data = __spreadValues({ key: e2.key }, this.eventMeta(type, e2, targetEl));
        js_default.exec(e2, type, phxEvent, view, targetEl, ["push", { data }]);
      });
      this.bind({ blur: "focusout", focus: "focusin" }, (e2, type, view, targetEl, phxEvent, phxTarget) => {
        if (!phxTarget) {
          let data = __spreadValues({ key: e2.key }, this.eventMeta(type, e2, targetEl));
          js_default.exec(e2, type, phxEvent, view, targetEl, ["push", { data }]);
        }
      });
      this.bind({ blur: "blur", focus: "focus" }, (e2, type, view, targetEl, phxEvent, phxTarget) => {
        if (phxTarget === "window") {
          let data = this.eventMeta(type, e2, targetEl);
          js_default.exec(e2, type, phxEvent, view, targetEl, ["push", { data }]);
        }
      });
      this.on("dragover", (e2) => e2.preventDefault());
      this.on("drop", (e2) => {
        e2.preventDefault();
        let dropTargetId = maybe(closestPhxBinding(e2.target, this.binding(PHX_DROP_TARGET)), (trueTarget) => {
          return trueTarget.getAttribute(this.binding(PHX_DROP_TARGET));
        });
        let dropTarget = dropTargetId && document.getElementById(dropTargetId);
        let files = Array.from(e2.dataTransfer.files || []);
        if (!dropTarget || dropTarget.disabled || files.length === 0 || !(dropTarget.files instanceof FileList)) {
          return;
        }
        LiveUploader.trackFiles(dropTarget, files, e2.dataTransfer);
        dropTarget.dispatchEvent(new Event("input", { bubbles: true }));
      });
      this.on(PHX_TRACK_UPLOADS, (e2) => {
        let uploadTarget = e2.target;
        if (!dom_default.isUploadInput(uploadTarget)) {
          return;
        }
        let files = Array.from(e2.detail.files || []).filter((f) => f instanceof File || f instanceof Blob);
        LiveUploader.trackFiles(uploadTarget, files);
        uploadTarget.dispatchEvent(new Event("input", { bubbles: true }));
      });
    }
    eventMeta(eventName, e2, targetEl) {
      let callback2 = this.metadataCallbacks[eventName];
      return callback2 ? callback2(e2, targetEl) : {};
    }
    setPendingLink(href) {
      this.linkRef++;
      this.pendingLink = href;
      this.resetReloadStatus();
      return this.linkRef;
    }
    // anytime we are navigating or connecting, drop reload cookie in case
    // we issue the cookie but the next request was interrupted and the server never dropped it
    resetReloadStatus() {
      browser_default.deleteCookie(PHX_RELOAD_STATUS);
    }
    commitPendingLink(linkRef) {
      if (this.linkRef !== linkRef) {
        return false;
      } else {
        this.href = this.pendingLink;
        this.pendingLink = null;
        return true;
      }
    }
    getHref() {
      return this.href;
    }
    hasPendingLink() {
      return !!this.pendingLink;
    }
    bind(events, callback2) {
      for (let event in events) {
        let browserEventName = events[event];
        this.on(browserEventName, (e2) => {
          let binding = this.binding(event);
          let windowBinding = this.binding(`window-${event}`);
          let targetPhxEvent = e2.target.getAttribute && e2.target.getAttribute(binding);
          if (targetPhxEvent) {
            this.debounce(e2.target, e2, browserEventName, () => {
              this.withinOwners(e2.target, (view) => {
                callback2(e2, event, view, e2.target, targetPhxEvent, null);
              });
            });
          } else {
            dom_default.all(document, `[${windowBinding}]`, (el) => {
              let phxEvent = el.getAttribute(windowBinding);
              this.debounce(el, e2, browserEventName, () => {
                this.withinOwners(el, (view) => {
                  callback2(e2, event, view, el, phxEvent, "window");
                });
              });
            });
          }
        });
      }
    }
    bindClicks() {
      this.on("mousedown", (e2) => this.clickStartedAtTarget = e2.target);
      this.bindClick("click", "click");
    }
    bindClick(eventName, bindingName) {
      let click = this.binding(bindingName);
      window.addEventListener(eventName, (e2) => {
        let target = null;
        if (e2.detail === 0)
          this.clickStartedAtTarget = e2.target;
        let clickStartedAtTarget = this.clickStartedAtTarget || e2.target;
        target = closestPhxBinding(e2.target, click);
        this.dispatchClickAway(e2, clickStartedAtTarget);
        this.clickStartedAtTarget = null;
        let phxEvent = target && target.getAttribute(click);
        if (!phxEvent) {
          if (dom_default.isNewPageClick(e2, window.location)) {
            this.unload();
          }
          return;
        }
        if (target.getAttribute("href") === "#") {
          e2.preventDefault();
        }
        if (target.hasAttribute(PHX_REF_SRC)) {
          return;
        }
        this.debounce(target, e2, "click", () => {
          this.withinOwners(target, (view) => {
            js_default.exec(e2, "click", phxEvent, view, target, ["push", { data: this.eventMeta("click", e2, target) }]);
          });
        });
      }, false);
    }
    dispatchClickAway(e2, clickStartedAt) {
      let phxClickAway = this.binding("click-away");
      dom_default.all(document, `[${phxClickAway}]`, (el) => {
        if (!(el.isSameNode(clickStartedAt) || el.contains(clickStartedAt))) {
          this.withinOwners(el, (view) => {
            let phxEvent = el.getAttribute(phxClickAway);
            if (js_default.isVisible(el) && js_default.isInViewport(el)) {
              js_default.exec(e2, "click", phxEvent, view, el, ["push", { data: this.eventMeta("click", e2, e2.target) }]);
            }
          });
        }
      });
    }
    bindNav() {
      if (!browser_default.canPushState()) {
        return;
      }
      if (history.scrollRestoration) {
        history.scrollRestoration = "manual";
      }
      let scrollTimer = null;
      window.addEventListener("scroll", (_e) => {
        clearTimeout(scrollTimer);
        scrollTimer = setTimeout(() => {
          browser_default.updateCurrentState((state) => Object.assign(state, { scroll: window.scrollY }));
        }, 100);
      });
      window.addEventListener("popstate", (event) => {
        if (!this.registerNewLocation(window.location)) {
          return;
        }
        let { type, backType, id, scroll, position } = event.state || {};
        let href = window.location.href;
        let isForward = position > this.currentHistoryPosition;
        type = isForward ? type : backType || type;
        this.currentHistoryPosition = position || 0;
        this.sessionStorage.setItem(PHX_LV_HISTORY_POSITION, this.currentHistoryPosition.toString());
        dom_default.dispatchEvent(window, "phx:navigate", { detail: { href, patch: type === "patch", pop: true, direction: isForward ? "forward" : "backward" } });
        this.requestDOMUpdate(() => {
          const callback2 = () => {
            this.maybeScroll(scroll);
          };
          if (this.main.isConnected() && (type === "patch" && id === this.main.id)) {
            this.main.pushLinkPatch(event, href, null, callback2);
          } else {
            this.replaceMain(href, null, callback2);
          }
        });
      }, false);
      window.addEventListener("click", (e2) => {
        let target = closestPhxBinding(e2.target, PHX_LIVE_LINK);
        let type = target && target.getAttribute(PHX_LIVE_LINK);
        if (!type || !this.isConnected() || !this.main || dom_default.wantsNewTab(e2)) {
          return;
        }
        let href = target.href instanceof SVGAnimatedString ? target.href.baseVal : target.href;
        let linkState = target.getAttribute(PHX_LINK_STATE);
        e2.preventDefault();
        e2.stopImmediatePropagation();
        if (this.pendingLink === href) {
          return;
        }
        this.requestDOMUpdate(() => {
          if (type === "patch") {
            this.pushHistoryPatch(e2, href, linkState, target);
          } else if (type === "redirect") {
            this.historyRedirect(e2, href, linkState, null, target);
          } else {
            throw new Error(`expected ${PHX_LIVE_LINK} to be "patch" or "redirect", got: ${type}`);
          }
          let phxClick = target.getAttribute(this.binding("click"));
          if (phxClick) {
            this.requestDOMUpdate(() => this.execJS(target, phxClick, "click"));
          }
        });
      }, false);
    }
    maybeScroll(scroll) {
      if (typeof scroll === "number") {
        requestAnimationFrame(() => {
          window.scrollTo(0, scroll);
        });
      }
    }
    dispatchEvent(event, payload = {}) {
      dom_default.dispatchEvent(window, `phx:${event}`, { detail: payload });
    }
    dispatchEvents(events) {
      events.forEach(([event, payload]) => this.dispatchEvent(event, payload));
    }
    withPageLoading(info, callback2) {
      dom_default.dispatchEvent(window, "phx:page-loading-start", { detail: info });
      let done = () => dom_default.dispatchEvent(window, "phx:page-loading-stop", { detail: info });
      return callback2 ? callback2(done) : done;
    }
    pushHistoryPatch(e2, href, linkState, targetEl) {
      if (!this.isConnected() || !this.main.isMain()) {
        return browser_default.redirect(href);
      }
      this.withPageLoading({ to: href, kind: "patch" }, (done) => {
        this.main.pushLinkPatch(e2, href, targetEl, (linkRef) => {
          this.historyPatch(href, linkState, linkRef);
          done();
        });
      });
    }
    historyPatch(href, linkState, linkRef = this.setPendingLink(href)) {
      if (!this.commitPendingLink(linkRef)) {
        return;
      }
      this.currentHistoryPosition++;
      this.sessionStorage.setItem(PHX_LV_HISTORY_POSITION, this.currentHistoryPosition.toString());
      browser_default.updateCurrentState((state) => __spreadProps(__spreadValues({}, state), { backType: "patch" }));
      browser_default.pushState(linkState, {
        type: "patch",
        id: this.main.id,
        position: this.currentHistoryPosition
      }, href);
      dom_default.dispatchEvent(window, "phx:navigate", { detail: { patch: true, href, pop: false, direction: "forward" } });
      this.registerNewLocation(window.location);
    }
    historyRedirect(e2, href, linkState, flash, targetEl) {
      const clickLoading = targetEl && e2.isTrusted && e2.type !== "popstate";
      if (clickLoading) {
        targetEl.classList.add("phx-click-loading");
      }
      if (!this.isConnected() || !this.main.isMain()) {
        return browser_default.redirect(href, flash);
      }
      if (/^\/$|^\/[^\/]+.*$/.test(href)) {
        let { protocol, host } = window.location;
        href = `${protocol}//${host}${href}`;
      }
      let scroll = window.scrollY;
      this.withPageLoading({ to: href, kind: "redirect" }, (done) => {
        this.replaceMain(href, flash, (linkRef) => {
          if (linkRef === this.linkRef) {
            this.currentHistoryPosition++;
            this.sessionStorage.setItem(PHX_LV_HISTORY_POSITION, this.currentHistoryPosition.toString());
            browser_default.updateCurrentState((state) => __spreadProps(__spreadValues({}, state), { backType: "redirect" }));
            browser_default.pushState(linkState, {
              type: "redirect",
              id: this.main.id,
              scroll,
              position: this.currentHistoryPosition
            }, href);
            dom_default.dispatchEvent(window, "phx:navigate", { detail: { href, patch: false, pop: false, direction: "forward" } });
            this.registerNewLocation(window.location);
          }
          if (clickLoading) {
            targetEl.classList.remove("phx-click-loading");
          }
          done();
        });
      });
    }
    registerNewLocation(newLocation) {
      let { pathname, search } = this.currentLocation;
      if (pathname + search === newLocation.pathname + newLocation.search) {
        return false;
      } else {
        this.currentLocation = clone(newLocation);
        return true;
      }
    }
    bindForms() {
      let iterations = 0;
      let externalFormSubmitted = false;
      this.on("submit", (e2) => {
        let phxSubmit = e2.target.getAttribute(this.binding("submit"));
        let phxChange = e2.target.getAttribute(this.binding("change"));
        if (!externalFormSubmitted && phxChange && !phxSubmit) {
          externalFormSubmitted = true;
          e2.preventDefault();
          this.withinOwners(e2.target, (view) => {
            view.disableForm(e2.target);
            window.requestAnimationFrame(() => {
              if (dom_default.isUnloadableFormSubmit(e2)) {
                this.unload();
              }
              e2.target.submit();
            });
          });
        }
      });
      this.on("submit", (e2) => {
        let phxEvent = e2.target.getAttribute(this.binding("submit"));
        if (!phxEvent) {
          if (dom_default.isUnloadableFormSubmit(e2)) {
            this.unload();
          }
          return;
        }
        e2.preventDefault();
        e2.target.disabled = true;
        this.withinOwners(e2.target, (view) => {
          js_default.exec(e2, "submit", phxEvent, view, e2.target, ["push", { submitter: e2.submitter }]);
        });
      });
      for (let type of ["change", "input"]) {
        this.on(type, (e2) => {
          if (e2 instanceof CustomEvent && e2.target.form === void 0) {
            if (e2.detail && e2.detail.dispatcher) {
              throw new Error(`dispatching a custom ${type} event is only supported on input elements inside a form`);
            }
            return;
          }
          let phxChange = this.binding("change");
          let input = e2.target;
          if (e2.isComposing) {
            const key = `composition-listener-${type}`;
            if (!dom_default.private(input, key)) {
              dom_default.putPrivate(input, key, true);
              input.addEventListener("compositionend", () => {
                input.dispatchEvent(new Event(type, { bubbles: true }));
                dom_default.deletePrivate(input, key);
              }, { once: true });
            }
            return;
          }
          let inputEvent = input.getAttribute(phxChange);
          let formEvent = input.form && input.form.getAttribute(phxChange);
          let phxEvent = inputEvent || formEvent;
          if (!phxEvent) {
            return;
          }
          if (input.type === "number" && input.validity && input.validity.badInput) {
            return;
          }
          let dispatcher = inputEvent ? input : input.form;
          let currentIterations = iterations;
          iterations++;
          let { at, type: lastType } = dom_default.private(input, "prev-iteration") || {};
          if (at === currentIterations - 1 && type === "change" && lastType === "input") {
            return;
          }
          dom_default.putPrivate(input, "prev-iteration", { at: currentIterations, type });
          this.debounce(input, e2, type, () => {
            this.withinOwners(dispatcher, (view) => {
              dom_default.putPrivate(input, PHX_HAS_FOCUSED, true);
              js_default.exec(e2, "change", phxEvent, view, input, ["push", { _target: e2.target.name, dispatcher }]);
            });
          });
        });
      }
      this.on("reset", (e2) => {
        let form = e2.target;
        dom_default.resetForm(form);
        let input = Array.from(form.elements).find((el) => el.type === "reset");
        if (input) {
          window.requestAnimationFrame(() => {
            input.dispatchEvent(new Event("input", { bubbles: true, cancelable: false }));
          });
        }
      });
    }
    debounce(el, event, eventType, callback2) {
      if (eventType === "blur" || eventType === "focusout") {
        return callback2();
      }
      let phxDebounce = this.binding(PHX_DEBOUNCE);
      let phxThrottle = this.binding(PHX_THROTTLE);
      let defaultDebounce = this.defaults.debounce.toString();
      let defaultThrottle = this.defaults.throttle.toString();
      this.withinOwners(el, (view) => {
        let asyncFilter = () => !view.isDestroyed() && document.body.contains(el);
        dom_default.debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, asyncFilter, () => {
          callback2();
        });
      });
    }
    silenceEvents(callback2) {
      this.silenced = true;
      callback2();
      this.silenced = false;
    }
    on(event, callback2) {
      this.boundEventNames.add(event);
      window.addEventListener(event, (e2) => {
        if (!this.silenced) {
          callback2(e2);
        }
      });
    }
    jsQuerySelectorAll(sourceEl, query, defaultQuery) {
      let all = this.domCallbacks.jsQuerySelectorAll;
      return all ? all(sourceEl, query, defaultQuery) : defaultQuery();
    }
  };
  var TransitionSet = class {
    constructor() {
      this.transitions = /* @__PURE__ */ new Set();
      this.pendingOps = [];
    }
    reset() {
      this.transitions.forEach((timer) => {
        clearTimeout(timer);
        this.transitions.delete(timer);
      });
      this.flushPendingOps();
    }
    after(callback2) {
      if (this.size() === 0) {
        callback2();
      } else {
        this.pushPendingOp(callback2);
      }
    }
    addTransition(time, onStart, onDone) {
      onStart();
      let timer = setTimeout(() => {
        this.transitions.delete(timer);
        onDone();
        this.flushPendingOps();
      }, time);
      this.transitions.add(timer);
    }
    pushPendingOp(op) {
      this.pendingOps.push(op);
    }
    size() {
      return this.transitions.size;
    }
    flushPendingOps() {
      if (this.size() > 0) {
        return;
      }
      let op = this.pendingOps.shift();
      if (op) {
        op();
        this.flushPendingOps();
      }
    }
  };

  // js/app.js
  var import_topbar = __toESM(require_topbar());

  // node_modules/wavesurfer.js/dist/wavesurfer.esm.js
  function t(t2, e2, i2, s2) {
    return new (i2 || (i2 = Promise))(function(n2, r2) {
      function o2(t3) {
        try {
          h3(s2.next(t3));
        } catch (t4) {
          r2(t4);
        }
      }
      function a2(t3) {
        try {
          h3(s2.throw(t3));
        } catch (t4) {
          r2(t4);
        }
      }
      function h3(t3) {
        var e3;
        t3.done ? n2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
          t4(e3);
        })).then(o2, a2);
      }
      h3((s2 = s2.apply(t2, e2 || [])).next());
    });
  }
  var e = class {
    constructor() {
      this.listeners = {};
    }
    on(t2, e2, i2) {
      if (this.listeners[t2] || (this.listeners[t2] = /* @__PURE__ */ new Set()), this.listeners[t2].add(e2), null == i2 ? void 0 : i2.once) {
        const i3 = () => {
          this.un(t2, i3), this.un(t2, e2);
        };
        return this.on(t2, i3), i3;
      }
      return () => this.un(t2, e2);
    }
    un(t2, e2) {
      var i2;
      null === (i2 = this.listeners[t2]) || void 0 === i2 || i2.delete(e2);
    }
    once(t2, e2) {
      return this.on(t2, e2, { once: true });
    }
    unAll() {
      this.listeners = {};
    }
    emit(t2, ...e2) {
      this.listeners[t2] && this.listeners[t2].forEach((t3) => t3(...e2));
    }
  };
  var i = { decode: function(e2, i2) {
    return t(this, void 0, void 0, function* () {
      const t2 = new AudioContext({ sampleRate: i2 });
      return t2.decodeAudioData(e2).finally(() => t2.close());
    });
  }, createBuffer: function(t2, e2) {
    return "number" == typeof t2[0] && (t2 = [t2]), function(t3) {
      const e3 = t3[0];
      if (e3.some((t4) => t4 > 1 || t4 < -1)) {
        const i2 = e3.length;
        let s2 = 0;
        for (let t4 = 0; t4 < i2; t4++) {
          const i3 = Math.abs(e3[t4]);
          i3 > s2 && (s2 = i3);
        }
        for (const e4 of t3)
          for (let t4 = 0; t4 < i2; t4++)
            e4[t4] /= s2;
      }
    }(t2), { duration: e2, length: t2[0].length, sampleRate: t2[0].length / e2, numberOfChannels: t2.length, getChannelData: (e3) => null == t2 ? void 0 : t2[e3], copyFromChannel: AudioBuffer.prototype.copyFromChannel, copyToChannel: AudioBuffer.prototype.copyToChannel };
  } };
  function s(t2, e2) {
    const i2 = e2.xmlns ? document.createElementNS(e2.xmlns, t2) : document.createElement(t2);
    for (const [t3, n2] of Object.entries(e2))
      if ("children" === t3)
        for (const [t4, n3] of Object.entries(e2))
          "string" == typeof n3 ? i2.appendChild(document.createTextNode(n3)) : i2.appendChild(s(t4, n3));
      else
        "style" === t3 ? Object.assign(i2.style, n2) : "textContent" === t3 ? i2.textContent = n2 : i2.setAttribute(t3, n2.toString());
    return i2;
  }
  function n(t2, e2, i2) {
    const n2 = s(t2, e2 || {});
    return null == i2 || i2.appendChild(n2), n2;
  }
  var r = Object.freeze({ __proto__: null, createElement: n, default: n });
  var o = { fetchBlob: function(e2, i2, s2) {
    return t(this, void 0, void 0, function* () {
      const n2 = yield fetch(e2, s2);
      if (n2.status >= 400)
        throw new Error(`Failed to fetch ${e2}: ${n2.status} (${n2.statusText})`);
      return function(e3, i3) {
        t(this, void 0, void 0, function* () {
          if (!e3.body || !e3.headers)
            return;
          const s3 = e3.body.getReader(), n3 = Number(e3.headers.get("Content-Length")) || 0;
          let r2 = 0;
          const o2 = (e4) => t(this, void 0, void 0, function* () {
            r2 += (null == e4 ? void 0 : e4.length) || 0;
            const t2 = Math.round(r2 / n3 * 100);
            i3(t2);
          }), a2 = () => t(this, void 0, void 0, function* () {
            let t2;
            try {
              t2 = yield s3.read();
            } catch (t3) {
              return;
            }
            t2.done || (o2(t2.value), yield a2());
          });
          a2();
        });
      }(n2.clone(), i2), n2.blob();
    });
  } };
  var a = class extends e {
    constructor(t2) {
      super(), this.isExternalMedia = false, t2.media ? (this.media = t2.media, this.isExternalMedia = true) : this.media = document.createElement("audio"), t2.mediaControls && (this.media.controls = true), t2.autoplay && (this.media.autoplay = true), null != t2.playbackRate && this.onMediaEvent("canplay", () => {
        null != t2.playbackRate && (this.media.playbackRate = t2.playbackRate);
      }, { once: true });
    }
    onMediaEvent(t2, e2, i2) {
      return this.media.addEventListener(t2, e2, i2), () => this.media.removeEventListener(t2, e2, i2);
    }
    getSrc() {
      return this.media.currentSrc || this.media.src || "";
    }
    revokeSrc() {
      const t2 = this.getSrc();
      t2.startsWith("blob:") && URL.revokeObjectURL(t2);
    }
    canPlayType(t2) {
      return "" !== this.media.canPlayType(t2);
    }
    setSrc(t2, e2) {
      const i2 = this.getSrc();
      if (t2 && i2 === t2)
        return;
      this.revokeSrc();
      const s2 = e2 instanceof Blob && (this.canPlayType(e2.type) || !t2) ? URL.createObjectURL(e2) : t2;
      i2 && (this.media.src = "");
      try {
        this.media.src = s2;
      } catch (e3) {
        this.media.src = t2;
      }
    }
    destroy() {
      this.isExternalMedia || (this.media.pause(), this.media.remove(), this.revokeSrc(), this.media.src = "", this.media.load());
    }
    setMediaElement(t2) {
      this.media = t2;
    }
    play() {
      return t(this, void 0, void 0, function* () {
        return this.media.play();
      });
    }
    pause() {
      this.media.pause();
    }
    isPlaying() {
      return !this.media.paused && !this.media.ended;
    }
    setTime(t2) {
      this.media.currentTime = t2;
    }
    getDuration() {
      return this.media.duration;
    }
    getCurrentTime() {
      return this.media.currentTime;
    }
    getVolume() {
      return this.media.volume;
    }
    setVolume(t2) {
      this.media.volume = t2;
    }
    getMuted() {
      return this.media.muted;
    }
    setMuted(t2) {
      this.media.muted = t2;
    }
    getPlaybackRate() {
      return this.media.playbackRate;
    }
    isSeeking() {
      return this.media.seeking;
    }
    setPlaybackRate(t2, e2) {
      null != e2 && (this.media.preservesPitch = e2), this.media.playbackRate = t2;
    }
    getMediaElement() {
      return this.media;
    }
    setSinkId(t2) {
      return this.media.setSinkId(t2);
    }
  };
  var h = class extends e {
    constructor(t2, e2) {
      super(), this.timeouts = [], this.isScrollable = false, this.audioData = null, this.resizeObserver = null, this.lastContainerWidth = 0, this.isDragging = false, this.subscriptions = [], this.unsubscribeOnScroll = [], this.subscriptions = [], this.options = t2;
      const i2 = this.parentFromOptionsContainer(t2.container);
      this.parent = i2;
      const [s2, n2] = this.initHtml();
      i2.appendChild(s2), this.container = s2, this.scrollContainer = n2.querySelector(".scroll"), this.wrapper = n2.querySelector(".wrapper"), this.canvasWrapper = n2.querySelector(".canvases"), this.progressWrapper = n2.querySelector(".progress"), this.cursor = n2.querySelector(".cursor"), e2 && n2.appendChild(e2), this.initEvents();
    }
    parentFromOptionsContainer(t2) {
      let e2;
      if ("string" == typeof t2 ? e2 = document.querySelector(t2) : t2 instanceof HTMLElement && (e2 = t2), !e2)
        throw new Error("Container not found");
      return e2;
    }
    initEvents() {
      const t2 = (t3) => {
        const e2 = this.wrapper.getBoundingClientRect(), i2 = t3.clientX - e2.left, s2 = t3.clientY - e2.top;
        return [i2 / e2.width, s2 / e2.height];
      };
      if (this.wrapper.addEventListener("click", (e2) => {
        const [i2, s2] = t2(e2);
        this.emit("click", i2, s2);
      }), this.wrapper.addEventListener("dblclick", (e2) => {
        const [i2, s2] = t2(e2);
        this.emit("dblclick", i2, s2);
      }), true !== this.options.dragToSeek && "object" != typeof this.options.dragToSeek || this.initDrag(), this.scrollContainer.addEventListener("scroll", () => {
        const { scrollLeft: t3, scrollWidth: e2, clientWidth: i2 } = this.scrollContainer, s2 = t3 / e2, n2 = (t3 + i2) / e2;
        this.emit("scroll", s2, n2, t3, t3 + i2);
      }), "function" == typeof ResizeObserver) {
        const t3 = this.createDelay(100);
        this.resizeObserver = new ResizeObserver(() => {
          t3().then(() => this.onContainerResize()).catch(() => {
          });
        }), this.resizeObserver.observe(this.scrollContainer);
      }
    }
    onContainerResize() {
      const t2 = this.parent.clientWidth;
      t2 === this.lastContainerWidth && "auto" !== this.options.height || (this.lastContainerWidth = t2, this.reRender());
    }
    initDrag() {
      this.subscriptions.push(function(t2, e2, i2, s2, n2 = 3, r2 = 0, o2 = 100) {
        if (!t2)
          return () => {
          };
        const a2 = matchMedia("(pointer: coarse)").matches;
        let h3 = () => {
        };
        const l2 = (l3) => {
          if (l3.button !== r2)
            return;
          l3.preventDefault(), l3.stopPropagation();
          let d2 = l3.clientX, c2 = l3.clientY, u2 = false;
          const p = Date.now(), m = (s3) => {
            if (s3.preventDefault(), s3.stopPropagation(), a2 && Date.now() - p < o2)
              return;
            const r3 = s3.clientX, h4 = s3.clientY, l4 = r3 - d2, m2 = h4 - c2;
            if (u2 || Math.abs(l4) > n2 || Math.abs(m2) > n2) {
              const s4 = t2.getBoundingClientRect(), { left: n3, top: o3 } = s4;
              u2 || (null == i2 || i2(d2 - n3, c2 - o3), u2 = true), e2(l4, m2, r3 - n3, h4 - o3), d2 = r3, c2 = h4;
            }
          }, f = (e3) => {
            if (u2) {
              const i3 = e3.clientX, n3 = e3.clientY, r3 = t2.getBoundingClientRect(), { left: o3, top: a3 } = r3;
              null == s2 || s2(i3 - o3, n3 - a3);
            }
            h3();
          }, g = (t3) => {
            t3.relatedTarget && t3.relatedTarget !== document.documentElement || f(t3);
          }, v = (t3) => {
            u2 && (t3.stopPropagation(), t3.preventDefault());
          }, b = (t3) => {
            u2 && t3.preventDefault();
          };
          document.addEventListener("pointermove", m), document.addEventListener("pointerup", f), document.addEventListener("pointerout", g), document.addEventListener("pointercancel", g), document.addEventListener("touchmove", b, { passive: false }), document.addEventListener("click", v, { capture: true }), h3 = () => {
            document.removeEventListener("pointermove", m), document.removeEventListener("pointerup", f), document.removeEventListener("pointerout", g), document.removeEventListener("pointercancel", g), document.removeEventListener("touchmove", b), setTimeout(() => {
              document.removeEventListener("click", v, { capture: true });
            }, 10);
          };
        };
        return t2.addEventListener("pointerdown", l2), () => {
          h3(), t2.removeEventListener("pointerdown", l2);
        };
      }(this.wrapper, (t2, e2, i2) => {
        this.emit("drag", Math.max(0, Math.min(1, i2 / this.wrapper.getBoundingClientRect().width)));
      }, (t2) => {
        this.isDragging = true, this.emit("dragstart", Math.max(0, Math.min(1, t2 / this.wrapper.getBoundingClientRect().width)));
      }, (t2) => {
        this.isDragging = false, this.emit("dragend", Math.max(0, Math.min(1, t2 / this.wrapper.getBoundingClientRect().width)));
      }));
    }
    getHeight(t2, e2) {
      var i2;
      const s2 = (null === (i2 = this.audioData) || void 0 === i2 ? void 0 : i2.numberOfChannels) || 1;
      if (null == t2)
        return 128;
      if (!isNaN(Number(t2)))
        return Number(t2);
      if ("auto" === t2) {
        const t3 = this.parent.clientHeight || 128;
        return (null == e2 ? void 0 : e2.every((t4) => !t4.overlay)) ? t3 / s2 : t3;
      }
      return 128;
    }
    initHtml() {
      const t2 = document.createElement("div"), e2 = t2.attachShadow({ mode: "open" }), i2 = this.options.cspNonce && "string" == typeof this.options.cspNonce ? this.options.cspNonce.replace(/"/g, "") : "";
      return e2.innerHTML = `
      <style${i2 ? ` nonce="${i2}"` : ""}>
        :host {
          user-select: none;
          min-width: 1px;
        }
        :host audio {
          display: block;
          width: 100%;
        }
        :host .scroll {
          overflow-x: auto;
          overflow-y: hidden;
          width: 100%;
          position: relative;
        }
        :host .noScrollbar {
          scrollbar-color: transparent;
          scrollbar-width: none;
        }
        :host .noScrollbar::-webkit-scrollbar {
          display: none;
          -webkit-appearance: none;
        }
        :host .wrapper {
          position: relative;
          overflow: visible;
          z-index: 2;
        }
        :host .canvases {
          min-height: ${this.getHeight(this.options.height, this.options.splitChannels)}px;
        }
        :host .canvases > div {
          position: relative;
        }
        :host canvas {
          display: block;
          position: absolute;
          top: 0;
          image-rendering: pixelated;
        }
        :host .progress {
          pointer-events: none;
          position: absolute;
          z-index: 2;
          top: 0;
          left: 0;
          width: 0;
          height: 100%;
          overflow: hidden;
        }
        :host .progress > div {
          position: relative;
        }
        :host .cursor {
          pointer-events: none;
          position: absolute;
          z-index: 5;
          top: 0;
          left: 0;
          height: 100%;
          border-radius: 2px;
        }
      </style>

      <div class="scroll" part="scroll">
        <div class="wrapper" part="wrapper">
          <div class="canvases" part="canvases"></div>
          <div class="progress" part="progress"></div>
          <div class="cursor" part="cursor"></div>
        </div>
      </div>
    `, [t2, e2];
    }
    setOptions(t2) {
      if (this.options.container !== t2.container) {
        const e2 = this.parentFromOptionsContainer(t2.container);
        e2.appendChild(this.container), this.parent = e2;
      }
      true !== t2.dragToSeek && "object" != typeof this.options.dragToSeek || this.initDrag(), this.options = t2, this.reRender();
    }
    getWrapper() {
      return this.wrapper;
    }
    getWidth() {
      return this.scrollContainer.clientWidth;
    }
    getScroll() {
      return this.scrollContainer.scrollLeft;
    }
    setScroll(t2) {
      this.scrollContainer.scrollLeft = t2;
    }
    setScrollPercentage(t2) {
      const { scrollWidth: e2 } = this.scrollContainer, i2 = e2 * t2;
      this.setScroll(i2);
    }
    destroy() {
      var t2, e2;
      this.subscriptions.forEach((t3) => t3()), this.container.remove(), null === (t2 = this.resizeObserver) || void 0 === t2 || t2.disconnect(), null === (e2 = this.unsubscribeOnScroll) || void 0 === e2 || e2.forEach((t3) => t3()), this.unsubscribeOnScroll = [];
    }
    createDelay(t2 = 10) {
      let e2, i2;
      const s2 = () => {
        e2 && clearTimeout(e2), i2 && i2();
      };
      return this.timeouts.push(s2), () => new Promise((n2, r2) => {
        s2(), i2 = r2, e2 = setTimeout(() => {
          e2 = void 0, i2 = void 0, n2();
        }, t2);
      });
    }
    convertColorValues(t2) {
      if (!Array.isArray(t2))
        return t2 || "";
      if (t2.length < 2)
        return t2[0] || "";
      const e2 = document.createElement("canvas"), i2 = e2.getContext("2d"), s2 = e2.height * (window.devicePixelRatio || 1), n2 = i2.createLinearGradient(0, 0, 0, s2), r2 = 1 / (t2.length - 1);
      return t2.forEach((t3, e3) => {
        const i3 = e3 * r2;
        n2.addColorStop(i3, t3);
      }), n2;
    }
    getPixelRatio() {
      return Math.max(1, window.devicePixelRatio || 1);
    }
    renderBarWaveform(t2, e2, i2, s2) {
      const n2 = t2[0], r2 = t2[1] || t2[0], o2 = n2.length, { width: a2, height: h3 } = i2.canvas, l2 = h3 / 2, d2 = this.getPixelRatio(), c2 = e2.barWidth ? e2.barWidth * d2 : 1, u2 = e2.barGap ? e2.barGap * d2 : e2.barWidth ? c2 / 2 : 0, p = e2.barRadius || 0, m = a2 / (c2 + u2) / o2, f = p && "roundRect" in i2 ? "roundRect" : "rect";
      i2.beginPath();
      let g = 0, v = 0, b = 0;
      for (let t3 = 0; t3 <= o2; t3++) {
        const o3 = Math.round(t3 * m);
        if (o3 > g) {
          const t4 = Math.round(v * l2 * s2), n3 = t4 + Math.round(b * l2 * s2) || 1;
          let r3 = l2 - t4;
          "top" === e2.barAlign ? r3 = 0 : "bottom" === e2.barAlign && (r3 = h3 - n3), i2[f](g * (c2 + u2), r3, c2, n3, p), g = o3, v = 0, b = 0;
        }
        const a3 = Math.abs(n2[t3] || 0), d3 = Math.abs(r2[t3] || 0);
        a3 > v && (v = a3), d3 > b && (b = d3);
      }
      i2.fill(), i2.closePath();
    }
    renderLineWaveform(t2, e2, i2, s2) {
      const n2 = (e3) => {
        const n3 = t2[e3] || t2[0], r2 = n3.length, { height: o2 } = i2.canvas, a2 = o2 / 2, h3 = i2.canvas.width / r2;
        i2.moveTo(0, a2);
        let l2 = 0, d2 = 0;
        for (let t3 = 0; t3 <= r2; t3++) {
          const r3 = Math.round(t3 * h3);
          if (r3 > l2) {
            const t4 = a2 + (Math.round(d2 * a2 * s2) || 1) * (0 === e3 ? -1 : 1);
            i2.lineTo(l2, t4), l2 = r3, d2 = 0;
          }
          const o3 = Math.abs(n3[t3] || 0);
          o3 > d2 && (d2 = o3);
        }
        i2.lineTo(l2, a2);
      };
      i2.beginPath(), n2(0), n2(1), i2.fill(), i2.closePath();
    }
    renderWaveform(t2, e2, i2) {
      if (i2.fillStyle = this.convertColorValues(e2.waveColor), e2.renderFunction)
        return void e2.renderFunction(t2, i2);
      let s2 = e2.barHeight || 1;
      if (e2.normalize) {
        const e3 = Array.from(t2[0]).reduce((t3, e4) => Math.max(t3, Math.abs(e4)), 0);
        s2 = e3 ? 1 / e3 : 1;
      }
      e2.barWidth || e2.barGap || e2.barAlign ? this.renderBarWaveform(t2, e2, i2, s2) : this.renderLineWaveform(t2, e2, i2, s2);
    }
    renderSingleCanvas(t2, e2, i2, s2, n2, r2, o2) {
      const a2 = this.getPixelRatio(), h3 = document.createElement("canvas");
      h3.width = Math.round(i2 * a2), h3.height = Math.round(s2 * a2), h3.style.width = `${i2}px`, h3.style.height = `${s2}px`, h3.style.left = `${Math.round(n2)}px`, r2.appendChild(h3);
      const l2 = h3.getContext("2d");
      if (this.renderWaveform(t2, e2, l2), h3.width > 0 && h3.height > 0) {
        const t3 = h3.cloneNode(), i3 = t3.getContext("2d");
        i3.drawImage(h3, 0, 0), i3.globalCompositeOperation = "source-in", i3.fillStyle = this.convertColorValues(e2.progressColor), i3.fillRect(0, 0, h3.width, h3.height), o2.appendChild(t3);
      }
    }
    renderMultiCanvas(t2, e2, i2, s2, n2, r2) {
      const o2 = this.getPixelRatio(), { clientWidth: a2 } = this.scrollContainer, l2 = i2 / o2;
      let d2 = Math.min(h.MAX_CANVAS_WIDTH, a2, l2), c2 = {};
      if (0 === d2)
        return;
      if (e2.barWidth || e2.barGap) {
        const t3 = e2.barWidth || 0.5, i3 = t3 + (e2.barGap || t3 / 2);
        d2 % i3 != 0 && (d2 = Math.floor(d2 / i3) * i3);
      }
      const u2 = (i3) => {
        if (i3 < 0 || i3 >= p)
          return;
        if (c2[i3])
          return;
        c2[i3] = true;
        const o3 = i3 * d2, a3 = Math.min(l2 - o3, d2);
        if (a3 <= 0)
          return;
        const h3 = t2.map((t3) => {
          const e3 = Math.floor(o3 / l2 * t3.length), i4 = Math.floor((o3 + a3) / l2 * t3.length);
          return t3.slice(e3, i4);
        });
        this.renderSingleCanvas(h3, e2, a3, s2, o3, n2, r2);
      }, p = Math.ceil(l2 / d2);
      if (!this.isScrollable) {
        for (let t3 = 0; t3 < p; t3++)
          u2(t3);
        return;
      }
      const m = this.scrollContainer.scrollLeft / l2, f = Math.floor(m * p);
      if (u2(f - 1), u2(f), u2(f + 1), p > 1) {
        const t3 = this.on("scroll", () => {
          const { scrollLeft: t4 } = this.scrollContainer, e3 = Math.floor(t4 / l2 * p);
          Object.keys(c2).length > h.MAX_NODES && (n2.innerHTML = "", r2.innerHTML = "", c2 = {}), u2(e3 - 1), u2(e3), u2(e3 + 1);
        });
        this.unsubscribeOnScroll.push(t3);
      }
    }
    renderChannel(t2, e2, i2, s2) {
      var { overlay: n2 } = e2, r2 = function(t3, e3) {
        var i3 = {};
        for (var s3 in t3)
          Object.prototype.hasOwnProperty.call(t3, s3) && e3.indexOf(s3) < 0 && (i3[s3] = t3[s3]);
        if (null != t3 && "function" == typeof Object.getOwnPropertySymbols) {
          var n3 = 0;
          for (s3 = Object.getOwnPropertySymbols(t3); n3 < s3.length; n3++)
            e3.indexOf(s3[n3]) < 0 && Object.prototype.propertyIsEnumerable.call(t3, s3[n3]) && (i3[s3[n3]] = t3[s3[n3]]);
        }
        return i3;
      }(e2, ["overlay"]);
      const o2 = document.createElement("div"), a2 = this.getHeight(r2.height, r2.splitChannels);
      o2.style.height = `${a2}px`, n2 && s2 > 0 && (o2.style.marginTop = `-${a2}px`), this.canvasWrapper.style.minHeight = `${a2}px`, this.canvasWrapper.appendChild(o2);
      const h3 = o2.cloneNode();
      this.progressWrapper.appendChild(h3), this.renderMultiCanvas(t2, r2, i2, a2, o2, h3);
    }
    render(e2) {
      return t(this, void 0, void 0, function* () {
        var t2;
        this.timeouts.forEach((t3) => t3()), this.timeouts = [], this.canvasWrapper.innerHTML = "", this.progressWrapper.innerHTML = "", null != this.options.width && (this.scrollContainer.style.width = "number" == typeof this.options.width ? `${this.options.width}px` : this.options.width);
        const i2 = this.getPixelRatio(), s2 = this.scrollContainer.clientWidth, n2 = Math.ceil(e2.duration * (this.options.minPxPerSec || 0));
        this.isScrollable = n2 > s2;
        const r2 = this.options.fillParent && !this.isScrollable, o2 = (r2 ? s2 : n2) * i2;
        if (this.wrapper.style.width = r2 ? "100%" : `${n2}px`, this.scrollContainer.style.overflowX = this.isScrollable ? "auto" : "hidden", this.scrollContainer.classList.toggle("noScrollbar", !!this.options.hideScrollbar), this.cursor.style.backgroundColor = `${this.options.cursorColor || this.options.progressColor}`, this.cursor.style.width = `${this.options.cursorWidth}px`, this.audioData = e2, this.emit("render"), this.options.splitChannels)
          for (let i3 = 0; i3 < e2.numberOfChannels; i3++) {
            const s3 = Object.assign(Object.assign({}, this.options), null === (t2 = this.options.splitChannels) || void 0 === t2 ? void 0 : t2[i3]);
            this.renderChannel([e2.getChannelData(i3)], s3, o2, i3);
          }
        else {
          const t3 = [e2.getChannelData(0)];
          e2.numberOfChannels > 1 && t3.push(e2.getChannelData(1)), this.renderChannel(t3, this.options, o2, 0);
        }
        Promise.resolve().then(() => this.emit("rendered"));
      });
    }
    reRender() {
      if (this.unsubscribeOnScroll.forEach((t3) => t3()), this.unsubscribeOnScroll = [], !this.audioData)
        return;
      const { scrollWidth: t2 } = this.scrollContainer, { right: e2 } = this.progressWrapper.getBoundingClientRect();
      if (this.render(this.audioData), this.isScrollable && t2 !== this.scrollContainer.scrollWidth) {
        const { right: t3 } = this.progressWrapper.getBoundingClientRect();
        let i2 = t3 - e2;
        i2 *= 2, i2 = i2 < 0 ? Math.floor(i2) : Math.ceil(i2), i2 /= 2, this.scrollContainer.scrollLeft += i2;
      }
    }
    zoom(t2) {
      this.options.minPxPerSec = t2, this.reRender();
    }
    scrollIntoView(t2, e2 = false) {
      const { scrollLeft: i2, scrollWidth: s2, clientWidth: n2 } = this.scrollContainer, r2 = t2 * s2, o2 = i2, a2 = i2 + n2, h3 = n2 / 2;
      if (this.isDragging) {
        const t3 = 30;
        r2 + t3 > a2 ? this.scrollContainer.scrollLeft += t3 : r2 - t3 < o2 && (this.scrollContainer.scrollLeft -= t3);
      } else {
        (r2 < o2 || r2 > a2) && (this.scrollContainer.scrollLeft = r2 - (this.options.autoCenter ? h3 : 0));
        const t3 = r2 - i2 - h3;
        e2 && this.options.autoCenter && t3 > 0 && (this.scrollContainer.scrollLeft += Math.min(t3, 10));
      }
      {
        const t3 = this.scrollContainer.scrollLeft, e3 = t3 / s2, i3 = (t3 + n2) / s2;
        this.emit("scroll", e3, i3, t3, t3 + n2);
      }
    }
    renderProgress(t2, e2) {
      if (isNaN(t2))
        return;
      const i2 = 100 * t2;
      this.canvasWrapper.style.clipPath = `polygon(${i2}% 0, 100% 0, 100% 100%, ${i2}% 100%)`, this.progressWrapper.style.width = `${i2}%`, this.cursor.style.left = `${i2}%`, this.cursor.style.transform = `translateX(-${100 === Math.round(i2) ? this.options.cursorWidth : 0}px)`, this.isScrollable && this.options.autoScroll && this.scrollIntoView(t2, e2);
    }
    exportImage(e2, i2, s2) {
      return t(this, void 0, void 0, function* () {
        const t2 = this.canvasWrapper.querySelectorAll("canvas");
        if (!t2.length)
          throw new Error("No waveform data");
        if ("dataURL" === s2) {
          const s3 = Array.from(t2).map((t3) => t3.toDataURL(e2, i2));
          return Promise.resolve(s3);
        }
        return Promise.all(Array.from(t2).map((t3) => new Promise((s3, n2) => {
          t3.toBlob((t4) => {
            t4 ? s3(t4) : n2(new Error("Could not export image"));
          }, e2, i2);
        })));
      });
    }
  };
  h.MAX_CANVAS_WIDTH = 8e3, h.MAX_NODES = 10;
  var l = class extends e {
    constructor() {
      super(...arguments), this.unsubscribe = () => {
      };
    }
    start() {
      this.unsubscribe = this.on("tick", () => {
        requestAnimationFrame(() => {
          this.emit("tick");
        });
      }), this.emit("tick");
    }
    stop() {
      this.unsubscribe();
    }
    destroy() {
      this.unsubscribe();
    }
  };
  var d = class extends e {
    constructor(t2 = new AudioContext()) {
      super(), this.bufferNode = null, this.playStartTime = 0, this.playedDuration = 0, this._muted = false, this._playbackRate = 1, this._duration = void 0, this.buffer = null, this.currentSrc = "", this.paused = true, this.crossOrigin = null, this.seeking = false, this.autoplay = false, this.addEventListener = this.on, this.removeEventListener = this.un, this.audioContext = t2, this.gainNode = this.audioContext.createGain(), this.gainNode.connect(this.audioContext.destination);
    }
    load() {
      return t(this, void 0, void 0, function* () {
      });
    }
    get src() {
      return this.currentSrc;
    }
    set src(t2) {
      if (this.currentSrc = t2, this._duration = void 0, !t2)
        return this.buffer = null, void this.emit("emptied");
      fetch(t2).then((e2) => {
        if (e2.status >= 400)
          throw new Error(`Failed to fetch ${t2}: ${e2.status} (${e2.statusText})`);
        return e2.arrayBuffer();
      }).then((e2) => this.currentSrc !== t2 ? null : this.audioContext.decodeAudioData(e2)).then((e2) => {
        this.currentSrc === t2 && (this.buffer = e2, this.emit("loadedmetadata"), this.emit("canplay"), this.autoplay && this.play());
      });
    }
    _play() {
      var t2;
      if (!this.paused)
        return;
      this.paused = false, null === (t2 = this.bufferNode) || void 0 === t2 || t2.disconnect(), this.bufferNode = this.audioContext.createBufferSource(), this.buffer && (this.bufferNode.buffer = this.buffer), this.bufferNode.playbackRate.value = this._playbackRate, this.bufferNode.connect(this.gainNode);
      let e2 = this.playedDuration * this._playbackRate;
      e2 >= this.duration && (e2 = 0, this.playedDuration = 0), this.bufferNode.start(this.audioContext.currentTime, e2), this.playStartTime = this.audioContext.currentTime, this.bufferNode.onended = () => {
        this.currentTime >= this.duration && (this.pause(), this.emit("ended"));
      };
    }
    _pause() {
      var t2;
      this.paused = true, null === (t2 = this.bufferNode) || void 0 === t2 || t2.stop(), this.playedDuration += this.audioContext.currentTime - this.playStartTime;
    }
    play() {
      return t(this, void 0, void 0, function* () {
        this.paused && (this._play(), this.emit("play"));
      });
    }
    pause() {
      this.paused || (this._pause(), this.emit("pause"));
    }
    stopAt(t2) {
      var e2, i2;
      const s2 = t2 - this.currentTime;
      null === (e2 = this.bufferNode) || void 0 === e2 || e2.stop(this.audioContext.currentTime + s2), null === (i2 = this.bufferNode) || void 0 === i2 || i2.addEventListener("ended", () => {
        this.bufferNode = null, this.pause();
      }, { once: true });
    }
    setSinkId(e2) {
      return t(this, void 0, void 0, function* () {
        return this.audioContext.setSinkId(e2);
      });
    }
    get playbackRate() {
      return this._playbackRate;
    }
    set playbackRate(t2) {
      this._playbackRate = t2, this.bufferNode && (this.bufferNode.playbackRate.value = t2);
    }
    get currentTime() {
      return (this.paused ? this.playedDuration : this.playedDuration + (this.audioContext.currentTime - this.playStartTime)) * this._playbackRate;
    }
    set currentTime(t2) {
      const e2 = !this.paused;
      e2 && this._pause(), this.playedDuration = t2 / this._playbackRate, e2 && this._play(), this.emit("seeking"), this.emit("timeupdate");
    }
    get duration() {
      var t2, e2;
      return null !== (t2 = this._duration) && void 0 !== t2 ? t2 : (null === (e2 = this.buffer) || void 0 === e2 ? void 0 : e2.duration) || 0;
    }
    set duration(t2) {
      this._duration = t2;
    }
    get volume() {
      return this.gainNode.gain.value;
    }
    set volume(t2) {
      this.gainNode.gain.value = t2, this.emit("volumechange");
    }
    get muted() {
      return this._muted;
    }
    set muted(t2) {
      this._muted !== t2 && (this._muted = t2, this._muted ? this.gainNode.disconnect() : this.gainNode.connect(this.audioContext.destination));
    }
    canPlayType(t2) {
      return /^(audio|video)\//.test(t2);
    }
    getGainNode() {
      return this.gainNode;
    }
    getChannelData() {
      const t2 = [];
      if (!this.buffer)
        return t2;
      const e2 = this.buffer.numberOfChannels;
      for (let i2 = 0; i2 < e2; i2++)
        t2.push(this.buffer.getChannelData(i2));
      return t2;
    }
  };
  var c = { waveColor: "#999", progressColor: "#555", cursorWidth: 1, minPxPerSec: 0, fillParent: true, interact: true, dragToSeek: false, autoScroll: true, autoCenter: true, sampleRate: 8e3 };
  var u = class extends a {
    static create(t2) {
      return new u(t2);
    }
    constructor(t2) {
      const e2 = t2.media || ("WebAudio" === t2.backend ? new d() : void 0);
      super({ media: e2, mediaControls: t2.mediaControls, autoplay: t2.autoplay, playbackRate: t2.audioRate }), this.plugins = [], this.decodedData = null, this.subscriptions = [], this.mediaSubscriptions = [], this.abortController = null, this.options = Object.assign({}, c, t2), this.timer = new l();
      const i2 = e2 ? void 0 : this.getMediaElement();
      this.renderer = new h(this.options, i2), this.initPlayerEvents(), this.initRendererEvents(), this.initTimerEvents(), this.initPlugins();
      const s2 = this.options.url || this.getSrc() || "";
      Promise.resolve().then(() => {
        this.emit("init");
        const { peaks: t3, duration: e3 } = this.options;
        (s2 || t3 && e3) && this.load(s2, t3, e3).catch(() => null);
      });
    }
    updateProgress(t2 = this.getCurrentTime()) {
      return this.renderer.renderProgress(t2 / this.getDuration(), this.isPlaying()), t2;
    }
    initTimerEvents() {
      this.subscriptions.push(this.timer.on("tick", () => {
        if (!this.isSeeking()) {
          const t2 = this.updateProgress();
          this.emit("timeupdate", t2), this.emit("audioprocess", t2);
        }
      }));
    }
    initPlayerEvents() {
      this.isPlaying() && (this.emit("play"), this.timer.start()), this.mediaSubscriptions.push(this.onMediaEvent("timeupdate", () => {
        const t2 = this.updateProgress();
        this.emit("timeupdate", t2);
      }), this.onMediaEvent("play", () => {
        this.emit("play"), this.timer.start();
      }), this.onMediaEvent("pause", () => {
        this.emit("pause"), this.timer.stop();
      }), this.onMediaEvent("emptied", () => {
        this.timer.stop();
      }), this.onMediaEvent("ended", () => {
        this.emit("timeupdate", this.getDuration()), this.emit("finish");
      }), this.onMediaEvent("seeking", () => {
        this.emit("seeking", this.getCurrentTime());
      }), this.onMediaEvent("error", (t2) => {
        var e2;
        this.emit("error", null !== (e2 = this.getMediaElement().error) && void 0 !== e2 ? e2 : new Error("Media error"));
      }));
    }
    initRendererEvents() {
      this.subscriptions.push(this.renderer.on("click", (t2, e2) => {
        this.options.interact && (this.seekTo(t2), this.emit("interaction", t2 * this.getDuration()), this.emit("click", t2, e2));
      }), this.renderer.on("dblclick", (t2, e2) => {
        this.emit("dblclick", t2, e2);
      }), this.renderer.on("scroll", (t2, e2, i2, s2) => {
        const n2 = this.getDuration();
        this.emit("scroll", t2 * n2, e2 * n2, i2, s2);
      }), this.renderer.on("render", () => {
        this.emit("redraw");
      }), this.renderer.on("rendered", () => {
        this.emit("redrawcomplete");
      }), this.renderer.on("dragstart", (t2) => {
        this.emit("dragstart", t2);
      }), this.renderer.on("dragend", (t2) => {
        this.emit("dragend", t2);
      }));
      {
        let t2;
        this.subscriptions.push(this.renderer.on("drag", (e2) => {
          if (!this.options.interact)
            return;
          let i2;
          this.renderer.renderProgress(e2), clearTimeout(t2), this.isPlaying() ? i2 = 0 : true === this.options.dragToSeek ? i2 = 200 : "object" == typeof this.options.dragToSeek && void 0 !== this.options.dragToSeek && (i2 = this.options.dragToSeek.debounceTime), t2 = setTimeout(() => {
            this.seekTo(e2);
          }, i2), this.emit("interaction", e2 * this.getDuration()), this.emit("drag", e2);
        }));
      }
    }
    initPlugins() {
      var t2;
      (null === (t2 = this.options.plugins) || void 0 === t2 ? void 0 : t2.length) && this.options.plugins.forEach((t3) => {
        this.registerPlugin(t3);
      });
    }
    unsubscribePlayerEvents() {
      this.mediaSubscriptions.forEach((t2) => t2()), this.mediaSubscriptions = [];
    }
    setOptions(t2) {
      this.options = Object.assign({}, this.options, t2), t2.duration && !t2.peaks && (this.decodedData = i.createBuffer(this.exportPeaks(), t2.duration)), t2.peaks && t2.duration && (this.decodedData = i.createBuffer(t2.peaks, t2.duration)), this.renderer.setOptions(this.options), t2.audioRate && this.setPlaybackRate(t2.audioRate), null != t2.mediaControls && (this.getMediaElement().controls = t2.mediaControls);
    }
    registerPlugin(t2) {
      return t2._init(this), this.plugins.push(t2), this.subscriptions.push(t2.once("destroy", () => {
        this.plugins = this.plugins.filter((e2) => e2 !== t2);
      })), t2;
    }
    getWrapper() {
      return this.renderer.getWrapper();
    }
    getWidth() {
      return this.renderer.getWidth();
    }
    getScroll() {
      return this.renderer.getScroll();
    }
    setScroll(t2) {
      return this.renderer.setScroll(t2);
    }
    setScrollTime(t2) {
      const e2 = t2 / this.getDuration();
      this.renderer.setScrollPercentage(e2);
    }
    getActivePlugins() {
      return this.plugins;
    }
    loadAudio(e2, s2, n2, r2) {
      return t(this, void 0, void 0, function* () {
        var t2;
        if (this.emit("load", e2), !this.options.media && this.isPlaying() && this.pause(), this.decodedData = null, !s2 && !n2) {
          const i2 = this.options.fetchParams || {};
          window.AbortController && !i2.signal && (this.abortController = new AbortController(), i2.signal = null === (t2 = this.abortController) || void 0 === t2 ? void 0 : t2.signal);
          const n3 = (t3) => this.emit("loading", t3);
          s2 = yield o.fetchBlob(e2, n3, i2);
          const r3 = this.options.blobMimeType;
          r3 && (s2 = new Blob([s2], { type: r3 }));
        }
        this.setSrc(e2, s2);
        const a2 = yield new Promise((t3) => {
          const e3 = r2 || this.getDuration();
          e3 ? t3(e3) : this.mediaSubscriptions.push(this.onMediaEvent("loadedmetadata", () => t3(this.getDuration()), { once: true }));
        });
        if (!e2 && !s2) {
          const t3 = this.getMediaElement();
          t3 instanceof d && (t3.duration = a2);
        }
        if (n2)
          this.decodedData = i.createBuffer(n2, a2 || 0);
        else if (s2) {
          const t3 = yield s2.arrayBuffer();
          this.decodedData = yield i.decode(t3, this.options.sampleRate);
        }
        this.decodedData && (this.emit("decode", this.getDuration()), this.renderer.render(this.decodedData)), this.emit("ready", this.getDuration());
      });
    }
    load(e2, i2, s2) {
      return t(this, void 0, void 0, function* () {
        try {
          return yield this.loadAudio(e2, void 0, i2, s2);
        } catch (t2) {
          throw this.emit("error", t2), t2;
        }
      });
    }
    loadBlob(e2, i2, s2) {
      return t(this, void 0, void 0, function* () {
        try {
          return yield this.loadAudio("", e2, i2, s2);
        } catch (t2) {
          throw this.emit("error", t2), t2;
        }
      });
    }
    zoom(t2) {
      if (!this.decodedData)
        throw new Error("No audio loaded");
      this.renderer.zoom(t2), this.emit("zoom", t2);
    }
    getDecodedData() {
      return this.decodedData;
    }
    exportPeaks({ channels: t2 = 2, maxLength: e2 = 8e3, precision: i2 = 1e4 } = {}) {
      if (!this.decodedData)
        throw new Error("The audio has not been decoded yet");
      const s2 = Math.min(t2, this.decodedData.numberOfChannels), n2 = [];
      for (let t3 = 0; t3 < s2; t3++) {
        const s3 = this.decodedData.getChannelData(t3), r2 = [], o2 = s3.length / e2;
        for (let t4 = 0; t4 < e2; t4++) {
          const e3 = s3.slice(Math.floor(t4 * o2), Math.ceil((t4 + 1) * o2));
          let n3 = 0;
          for (let t5 = 0; t5 < e3.length; t5++) {
            const i3 = e3[t5];
            Math.abs(i3) > Math.abs(n3) && (n3 = i3);
          }
          r2.push(Math.round(n3 * i2) / i2);
        }
        n2.push(r2);
      }
      return n2;
    }
    getDuration() {
      let t2 = super.getDuration() || 0;
      return 0 !== t2 && t2 !== 1 / 0 || !this.decodedData || (t2 = this.decodedData.duration), t2;
    }
    toggleInteraction(t2) {
      this.options.interact = t2;
    }
    setTime(t2) {
      super.setTime(t2), this.updateProgress(t2), this.emit("timeupdate", t2);
    }
    seekTo(t2) {
      const e2 = this.getDuration() * t2;
      this.setTime(e2);
    }
    playPause() {
      return t(this, void 0, void 0, function* () {
        return this.isPlaying() ? this.pause() : this.play();
      });
    }
    stop() {
      this.pause(), this.setTime(0);
    }
    skip(t2) {
      this.setTime(this.getCurrentTime() + t2);
    }
    empty() {
      this.load("", [[0]], 1e-3);
    }
    setMediaElement(t2) {
      this.unsubscribePlayerEvents(), super.setMediaElement(t2), this.initPlayerEvents();
    }
    exportImage() {
      return t(this, arguments, void 0, function* (t2 = "image/png", e2 = 1, i2 = "dataURL") {
        return this.renderer.exportImage(t2, e2, i2);
      });
    }
    destroy() {
      var t2;
      this.emit("destroy"), null === (t2 = this.abortController) || void 0 === t2 || t2.abort(), this.plugins.forEach((t3) => t3.destroy()), this.subscriptions.forEach((t3) => t3()), this.unsubscribePlayerEvents(), this.timer.destroy(), this.renderer.destroy(), super.destroy();
    }
  };
  u.BasePlugin = class extends e {
    constructor(t2) {
      super(), this.subscriptions = [], this.options = t2;
    }
    onInit() {
    }
    _init(t2) {
      this.wavesurfer = t2, this.onInit();
    }
    destroy() {
      this.emit("destroy"), this.subscriptions.forEach((t2) => t2());
    }
  }, u.dom = r;

  // js/audio_player.js
  var audio_player_default = AudioPlayer = {
    mounted() {
      const playButton = this.el;
      const audio_path = this.el.dataset.audiopath;
      const container = this.el.dataset.container;
      const progressColor = this.el.dataset.progresscolor;
      const audioContainer = document.getElementById(container);
      const waveSurfer = u.create({
        container: audioContainer,
        height: 70,
        waveColor: "#ECF2FF",
        progressColor,
        barWidth: 5,
        barGap: 2,
        barRadius: 10,
        cursorColor: "#787186",
        cursorWidth: 1,
        responsive: true
        // plugins: [TimelinePlugin.create({
        //   height: 17,
        // })],
      });
      const token = "your_valid_token";
      fetch(audio_path, {
        headers: {
          "Authorization": `Bearer ${token}`
        }
      }).then((response) => {
        if (!response.ok) {
          throw new Error("Network response was not ok");
        }
        return response.blob();
      }).then((blob) => {
        const url = URL.createObjectURL(blob);
        waveSurfer.load(url);
      }).catch((error) => {
        console.error("There was a problem with the fetch operation:", error);
      });
      const clickPlay = (el) => {
        waveSurfer.playPause();
        el.target.innerHTML = waveSurfer.isPlaying() ? "Pause" : "Play";
      };
      waveSurfer.on("ready", () => {
        console.log(waveSurfer);
      });
      const dummy = (el) => {
        alert("You clicked.");
      };
      playButton.addEventListener("click", clickPlay);
    }
  };

  // node_modules/@kurkle/color/dist/color.esm.js
  function round(v) {
    return v + 0.5 | 0;
  }
  var lim = (v, l2, h3) => Math.max(Math.min(v, h3), l2);
  function p2b(v) {
    return lim(round(v * 2.55), 0, 255);
  }
  function n2b(v) {
    return lim(round(v * 255), 0, 255);
  }
  function b2n(v) {
    return lim(round(v / 2.55) / 100, 0, 1);
  }
  function n2p(v) {
    return lim(round(v * 100), 0, 100);
  }
  var map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
  var hex = [..."0123456789ABCDEF"];
  var h1 = (b) => hex[b & 15];
  var h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
  var eq = (b) => (b & 240) >> 4 === (b & 15);
  var isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
  function hexParse(str) {
    var len = str.length;
    var ret;
    if (str[0] === "#") {
      if (len === 4 || len === 5) {
        ret = {
          r: 255 & map$1[str[1]] * 17,
          g: 255 & map$1[str[2]] * 17,
          b: 255 & map$1[str[3]] * 17,
          a: len === 5 ? map$1[str[4]] * 17 : 255
        };
      } else if (len === 7 || len === 9) {
        ret = {
          r: map$1[str[1]] << 4 | map$1[str[2]],
          g: map$1[str[3]] << 4 | map$1[str[4]],
          b: map$1[str[5]] << 4 | map$1[str[6]],
          a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
        };
      }
    }
    return ret;
  }
  var alpha = (a2, f) => a2 < 255 ? f(a2) : "";
  function hexString(v) {
    var f = isShort(v) ? h1 : h2;
    return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
  }
  var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
  function hsl2rgbn(h3, s2, l2) {
    const a2 = s2 * Math.min(l2, 1 - l2);
    const f = (n2, k = (n2 + h3 / 30) % 12) => l2 - a2 * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return [f(0), f(8), f(4)];
  }
  function hsv2rgbn(h3, s2, v) {
    const f = (n2, k = (n2 + h3 / 60) % 6) => v - v * s2 * Math.max(Math.min(k, 4 - k, 1), 0);
    return [f(5), f(3), f(1)];
  }
  function hwb2rgbn(h3, w, b) {
    const rgb = hsl2rgbn(h3, 1, 0.5);
    let i2;
    if (w + b > 1) {
      i2 = 1 / (w + b);
      w *= i2;
      b *= i2;
    }
    for (i2 = 0; i2 < 3; i2++) {
      rgb[i2] *= 1 - w - b;
      rgb[i2] += w;
    }
    return rgb;
  }
  function hueValue(r2, g, b, d2, max2) {
    if (r2 === max2) {
      return (g - b) / d2 + (g < b ? 6 : 0);
    }
    if (g === max2) {
      return (b - r2) / d2 + 2;
    }
    return (r2 - g) / d2 + 4;
  }
  function rgb2hsl(v) {
    const range2 = 255;
    const r2 = v.r / range2;
    const g = v.g / range2;
    const b = v.b / range2;
    const max2 = Math.max(r2, g, b);
    const min = Math.min(r2, g, b);
    const l2 = (max2 + min) / 2;
    let h3, s2, d2;
    if (max2 !== min) {
      d2 = max2 - min;
      s2 = l2 > 0.5 ? d2 / (2 - max2 - min) : d2 / (max2 + min);
      h3 = hueValue(r2, g, b, d2, max2);
      h3 = h3 * 60 + 0.5;
    }
    return [h3 | 0, s2 || 0, l2];
  }
  function calln(f, a2, b, c2) {
    return (Array.isArray(a2) ? f(a2[0], a2[1], a2[2]) : f(a2, b, c2)).map(n2b);
  }
  function hsl2rgb(h3, s2, l2) {
    return calln(hsl2rgbn, h3, s2, l2);
  }
  function hwb2rgb(h3, w, b) {
    return calln(hwb2rgbn, h3, w, b);
  }
  function hsv2rgb(h3, s2, v) {
    return calln(hsv2rgbn, h3, s2, v);
  }
  function hue(h3) {
    return (h3 % 360 + 360) % 360;
  }
  function hueParse(str) {
    const m = HUE_RE.exec(str);
    let a2 = 255;
    let v;
    if (!m) {
      return;
    }
    if (m[5] !== v) {
      a2 = m[6] ? p2b(+m[5]) : n2b(+m[5]);
    }
    const h3 = hue(+m[2]);
    const p1 = +m[3] / 100;
    const p2 = +m[4] / 100;
    if (m[1] === "hwb") {
      v = hwb2rgb(h3, p1, p2);
    } else if (m[1] === "hsv") {
      v = hsv2rgb(h3, p1, p2);
    } else {
      v = hsl2rgb(h3, p1, p2);
    }
    return {
      r: v[0],
      g: v[1],
      b: v[2],
      a: a2
    };
  }
  function rotate(v, deg) {
    var h3 = rgb2hsl(v);
    h3[0] = hue(h3[0] + deg);
    h3 = hsl2rgb(h3);
    v.r = h3[0];
    v.g = h3[1];
    v.b = h3[2];
  }
  function hslString(v) {
    if (!v) {
      return;
    }
    const a2 = rgb2hsl(v);
    const h3 = a2[0];
    const s2 = n2p(a2[1]);
    const l2 = n2p(a2[2]);
    return v.a < 255 ? `hsla(${h3}, ${s2}%, ${l2}%, ${b2n(v.a)})` : `hsl(${h3}, ${s2}%, ${l2}%)`;
  }
  var map = {
    x: "dark",
    Z: "light",
    Y: "re",
    X: "blu",
    W: "gr",
    V: "medium",
    U: "slate",
    A: "ee",
    T: "ol",
    S: "or",
    B: "ra",
    C: "lateg",
    D: "ights",
    R: "in",
    Q: "turquois",
    E: "hi",
    P: "ro",
    O: "al",
    N: "le",
    M: "de",
    L: "yello",
    F: "en",
    K: "ch",
    G: "arks",
    H: "ea",
    I: "ightg",
    J: "wh"
  };
  var names$1 = {
    OiceXe: "f0f8ff",
    antiquewEte: "faebd7",
    aqua: "ffff",
    aquamarRe: "7fffd4",
    azuY: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "0",
    blanKedOmond: "ffebcd",
    Xe: "ff",
    XeviTet: "8a2be2",
    bPwn: "a52a2a",
    burlywood: "deb887",
    caMtXe: "5f9ea0",
    KartYuse: "7fff00",
    KocTate: "d2691e",
    cSO: "ff7f50",
    cSnflowerXe: "6495ed",
    cSnsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "ffff",
    xXe: "8b",
    xcyan: "8b8b",
    xgTMnPd: "b8860b",
    xWay: "a9a9a9",
    xgYF: "6400",
    xgYy: "a9a9a9",
    xkhaki: "bdb76b",
    xmagFta: "8b008b",
    xTivegYF: "556b2f",
    xSange: "ff8c00",
    xScEd: "9932cc",
    xYd: "8b0000",
    xsOmon: "e9967a",
    xsHgYF: "8fbc8f",
    xUXe: "483d8b",
    xUWay: "2f4f4f",
    xUgYy: "2f4f4f",
    xQe: "ced1",
    xviTet: "9400d3",
    dAppRk: "ff1493",
    dApskyXe: "bfff",
    dimWay: "696969",
    dimgYy: "696969",
    dodgerXe: "1e90ff",
    fiYbrick: "b22222",
    flSOwEte: "fffaf0",
    foYstWAn: "228b22",
    fuKsia: "ff00ff",
    gaRsbSo: "dcdcdc",
    ghostwEte: "f8f8ff",
    gTd: "ffd700",
    gTMnPd: "daa520",
    Way: "808080",
    gYF: "8000",
    gYFLw: "adff2f",
    gYy: "808080",
    honeyMw: "f0fff0",
    hotpRk: "ff69b4",
    RdianYd: "cd5c5c",
    Rdigo: "4b0082",
    ivSy: "fffff0",
    khaki: "f0e68c",
    lavFMr: "e6e6fa",
    lavFMrXsh: "fff0f5",
    lawngYF: "7cfc00",
    NmoncEffon: "fffacd",
    ZXe: "add8e6",
    ZcSO: "f08080",
    Zcyan: "e0ffff",
    ZgTMnPdLw: "fafad2",
    ZWay: "d3d3d3",
    ZgYF: "90ee90",
    ZgYy: "d3d3d3",
    ZpRk: "ffb6c1",
    ZsOmon: "ffa07a",
    ZsHgYF: "20b2aa",
    ZskyXe: "87cefa",
    ZUWay: "778899",
    ZUgYy: "778899",
    ZstAlXe: "b0c4de",
    ZLw: "ffffe0",
    lime: "ff00",
    limegYF: "32cd32",
    lRF: "faf0e6",
    magFta: "ff00ff",
    maPon: "800000",
    VaquamarRe: "66cdaa",
    VXe: "cd",
    VScEd: "ba55d3",
    VpurpN: "9370db",
    VsHgYF: "3cb371",
    VUXe: "7b68ee",
    VsprRggYF: "fa9a",
    VQe: "48d1cc",
    VviTetYd: "c71585",
    midnightXe: "191970",
    mRtcYam: "f5fffa",
    mistyPse: "ffe4e1",
    moccasR: "ffe4b5",
    navajowEte: "ffdead",
    navy: "80",
    Tdlace: "fdf5e6",
    Tive: "808000",
    TivedBb: "6b8e23",
    Sange: "ffa500",
    SangeYd: "ff4500",
    ScEd: "da70d6",
    pOegTMnPd: "eee8aa",
    pOegYF: "98fb98",
    pOeQe: "afeeee",
    pOeviTetYd: "db7093",
    papayawEp: "ffefd5",
    pHKpuff: "ffdab9",
    peru: "cd853f",
    pRk: "ffc0cb",
    plum: "dda0dd",
    powMrXe: "b0e0e6",
    purpN: "800080",
    YbeccapurpN: "663399",
    Yd: "ff0000",
    Psybrown: "bc8f8f",
    PyOXe: "4169e1",
    saddNbPwn: "8b4513",
    sOmon: "fa8072",
    sandybPwn: "f4a460",
    sHgYF: "2e8b57",
    sHshell: "fff5ee",
    siFna: "a0522d",
    silver: "c0c0c0",
    skyXe: "87ceeb",
    UXe: "6a5acd",
    UWay: "708090",
    UgYy: "708090",
    snow: "fffafa",
    sprRggYF: "ff7f",
    stAlXe: "4682b4",
    tan: "d2b48c",
    teO: "8080",
    tEstN: "d8bfd8",
    tomato: "ff6347",
    Qe: "40e0d0",
    viTet: "ee82ee",
    JHt: "f5deb3",
    wEte: "ffffff",
    wEtesmoke: "f5f5f5",
    Lw: "ffff00",
    LwgYF: "9acd32"
  };
  function unpack() {
    const unpacked = {};
    const keys = Object.keys(names$1);
    const tkeys = Object.keys(map);
    let i2, j, k, ok, nk;
    for (i2 = 0; i2 < keys.length; i2++) {
      ok = nk = keys[i2];
      for (j = 0; j < tkeys.length; j++) {
        k = tkeys[j];
        nk = nk.replace(k, map[k]);
      }
      k = parseInt(names$1[ok], 16);
      unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
    }
    return unpacked;
  }
  var names;
  function nameParse(str) {
    if (!names) {
      names = unpack();
      names.transparent = [0, 0, 0, 0];
    }
    const a2 = names[str.toLowerCase()];
    return a2 && {
      r: a2[0],
      g: a2[1],
      b: a2[2],
      a: a2.length === 4 ? a2[3] : 255
    };
  }
  var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
  function rgbParse(str) {
    const m = RGB_RE.exec(str);
    let a2 = 255;
    let r2, g, b;
    if (!m) {
      return;
    }
    if (m[7] !== r2) {
      const v = +m[7];
      a2 = m[8] ? p2b(v) : lim(v * 255, 0, 255);
    }
    r2 = +m[1];
    g = +m[3];
    b = +m[5];
    r2 = 255 & (m[2] ? p2b(r2) : lim(r2, 0, 255));
    g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
    b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
    return {
      r: r2,
      g,
      b,
      a: a2
    };
  }
  function rgbString(v) {
    return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
  }
  var to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
  var from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
  function interpolate(rgb1, rgb2, t2) {
    const r2 = from(b2n(rgb1.r));
    const g = from(b2n(rgb1.g));
    const b = from(b2n(rgb1.b));
    return {
      r: n2b(to(r2 + t2 * (from(b2n(rgb2.r)) - r2))),
      g: n2b(to(g + t2 * (from(b2n(rgb2.g)) - g))),
      b: n2b(to(b + t2 * (from(b2n(rgb2.b)) - b))),
      a: rgb1.a + t2 * (rgb2.a - rgb1.a)
    };
  }
  function modHSL(v, i2, ratio) {
    if (v) {
      let tmp = rgb2hsl(v);
      tmp[i2] = Math.max(0, Math.min(tmp[i2] + tmp[i2] * ratio, i2 === 0 ? 360 : 1));
      tmp = hsl2rgb(tmp);
      v.r = tmp[0];
      v.g = tmp[1];
      v.b = tmp[2];
    }
  }
  function clone2(v, proto) {
    return v ? Object.assign(proto || {}, v) : v;
  }
  function fromObject(input) {
    var v = { r: 0, g: 0, b: 0, a: 255 };
    if (Array.isArray(input)) {
      if (input.length >= 3) {
        v = { r: input[0], g: input[1], b: input[2], a: 255 };
        if (input.length > 3) {
          v.a = n2b(input[3]);
        }
      }
    } else {
      v = clone2(input, { r: 0, g: 0, b: 0, a: 1 });
      v.a = n2b(v.a);
    }
    return v;
  }
  function functionParse(str) {
    if (str.charAt(0) === "r") {
      return rgbParse(str);
    }
    return hueParse(str);
  }
  var Color = class {
    constructor(input) {
      if (input instanceof Color) {
        return input;
      }
      const type = typeof input;
      let v;
      if (type === "object") {
        v = fromObject(input);
      } else if (type === "string") {
        v = hexParse(input) || nameParse(input) || functionParse(input);
      }
      this._rgb = v;
      this._valid = !!v;
    }
    get valid() {
      return this._valid;
    }
    get rgb() {
      var v = clone2(this._rgb);
      if (v) {
        v.a = b2n(v.a);
      }
      return v;
    }
    set rgb(obj) {
      this._rgb = fromObject(obj);
    }
    rgbString() {
      return this._valid ? rgbString(this._rgb) : void 0;
    }
    hexString() {
      return this._valid ? hexString(this._rgb) : void 0;
    }
    hslString() {
      return this._valid ? hslString(this._rgb) : void 0;
    }
    mix(color2, weight) {
      if (color2) {
        const c1 = this.rgb;
        const c2 = color2.rgb;
        let w2;
        const p = weight === w2 ? 0.5 : weight;
        const w = 2 * p - 1;
        const a2 = c1.a - c2.a;
        const w1 = ((w * a2 === -1 ? w : (w + a2) / (1 + w * a2)) + 1) / 2;
        w2 = 1 - w1;
        c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
        c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
        c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
        c1.a = p * c1.a + (1 - p) * c2.a;
        this.rgb = c1;
      }
      return this;
    }
    interpolate(color2, t2) {
      if (color2) {
        this._rgb = interpolate(this._rgb, color2._rgb, t2);
      }
      return this;
    }
    clone() {
      return new Color(this.rgb);
    }
    alpha(a2) {
      this._rgb.a = n2b(a2);
      return this;
    }
    clearer(ratio) {
      const rgb = this._rgb;
      rgb.a *= 1 - ratio;
      return this;
    }
    greyscale() {
      const rgb = this._rgb;
      const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
      rgb.r = rgb.g = rgb.b = val;
      return this;
    }
    opaquer(ratio) {
      const rgb = this._rgb;
      rgb.a *= 1 + ratio;
      return this;
    }
    negate() {
      const v = this._rgb;
      v.r = 255 - v.r;
      v.g = 255 - v.g;
      v.b = 255 - v.b;
      return this;
    }
    lighten(ratio) {
      modHSL(this._rgb, 2, ratio);
      return this;
    }
    darken(ratio) {
      modHSL(this._rgb, 2, -ratio);
      return this;
    }
    saturate(ratio) {
      modHSL(this._rgb, 1, ratio);
      return this;
    }
    desaturate(ratio) {
      modHSL(this._rgb, 1, -ratio);
      return this;
    }
    rotate(deg) {
      rotate(this._rgb, deg);
      return this;
    }
  };

  // node_modules/chart.js/dist/chunks/helpers.segment.js
  function noop2() {
  }
  var uid = (() => {
    let id = 0;
    return () => id++;
  })();
  function isNullOrUndef(value) {
    return value === null || value === void 0;
  }
  function isArray(value) {
    if (Array.isArray && Array.isArray(value)) {
      return true;
    }
    const type = Object.prototype.toString.call(value);
    if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
      return true;
    }
    return false;
  }
  function isObject2(value) {
    return value !== null && Object.prototype.toString.call(value) === "[object Object]";
  }
  function isNumberFinite(value) {
    return (typeof value === "number" || value instanceof Number) && isFinite(+value);
  }
  function finiteOrDefault(value, defaultValue) {
    return isNumberFinite(value) ? value : defaultValue;
  }
  function valueOrDefault(value, defaultValue) {
    return typeof value === "undefined" ? defaultValue : value;
  }
  var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
  var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
  function callback(fn, args, thisArg) {
    if (fn && typeof fn.call === "function") {
      return fn.apply(thisArg, args);
    }
  }
  function each(loopable, fn, thisArg, reverse) {
    let i2, len, keys;
    if (isArray(loopable)) {
      len = loopable.length;
      if (reverse) {
        for (i2 = len - 1; i2 >= 0; i2--) {
          fn.call(thisArg, loopable[i2], i2);
        }
      } else {
        for (i2 = 0; i2 < len; i2++) {
          fn.call(thisArg, loopable[i2], i2);
        }
      }
    } else if (isObject2(loopable)) {
      keys = Object.keys(loopable);
      len = keys.length;
      for (i2 = 0; i2 < len; i2++) {
        fn.call(thisArg, loopable[keys[i2]], keys[i2]);
      }
    }
  }
  function _elementsEqual(a0, a1) {
    let i2, ilen, v0, v1;
    if (!a0 || !a1 || a0.length !== a1.length) {
      return false;
    }
    for (i2 = 0, ilen = a0.length; i2 < ilen; ++i2) {
      v0 = a0[i2];
      v1 = a1[i2];
      if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
        return false;
      }
    }
    return true;
  }
  function clone3(source) {
    if (isArray(source)) {
      return source.map(clone3);
    }
    if (isObject2(source)) {
      const target = /* @__PURE__ */ Object.create(null);
      const keys = Object.keys(source);
      const klen = keys.length;
      let k = 0;
      for (; k < klen; ++k) {
        target[keys[k]] = clone3(source[keys[k]]);
      }
      return target;
    }
    return source;
  }
  function isValidKey(key) {
    return [
      "__proto__",
      "prototype",
      "constructor"
    ].indexOf(key) === -1;
  }
  function _merger(key, target, source, options) {
    if (!isValidKey(key)) {
      return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject2(tval) && isObject2(sval)) {
      merge(tval, sval, options);
    } else {
      target[key] = clone3(sval);
    }
  }
  function merge(target, source, options) {
    const sources = isArray(source) ? source : [
      source
    ];
    const ilen = sources.length;
    if (!isObject2(target)) {
      return target;
    }
    options = options || {};
    const merger = options.merger || _merger;
    let current;
    for (let i2 = 0; i2 < ilen; ++i2) {
      current = sources[i2];
      if (!isObject2(current)) {
        continue;
      }
      const keys = Object.keys(current);
      for (let k = 0, klen = keys.length; k < klen; ++k) {
        merger(keys[k], target, current, options);
      }
    }
    return target;
  }
  function mergeIf(target, source) {
    return merge(target, source, {
      merger: _mergerIf
    });
  }
  function _mergerIf(key, target, source) {
    if (!isValidKey(key)) {
      return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject2(tval) && isObject2(sval)) {
      mergeIf(tval, sval);
    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
      target[key] = clone3(sval);
    }
  }
  var keyResolvers = {
    // Chart.helpers.core resolveObjectKey should resolve empty key to root object
    "": (v) => v,
    // default resolvers
    x: (o2) => o2.x,
    y: (o2) => o2.y
  };
  function _splitKey(key) {
    const parts = key.split(".");
    const keys = [];
    let tmp = "";
    for (const part of parts) {
      tmp += part;
      if (tmp.endsWith("\\")) {
        tmp = tmp.slice(0, -1) + ".";
      } else {
        keys.push(tmp);
        tmp = "";
      }
    }
    return keys;
  }
  function _getKeyResolver(key) {
    const keys = _splitKey(key);
    return (obj) => {
      for (const k of keys) {
        if (k === "") {
          break;
        }
        obj = obj && obj[k];
      }
      return obj;
    };
  }
  function resolveObjectKey(obj, key) {
    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
    return resolver(obj);
  }
  function _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  var defined = (value) => typeof value !== "undefined";
  var isFunction = (value) => typeof value === "function";
  var setsEqual = (a2, b) => {
    if (a2.size !== b.size) {
      return false;
    }
    for (const item of a2) {
      if (!b.has(item)) {
        return false;
      }
    }
    return true;
  };
  function _isClickEvent(e2) {
    return e2.type === "mouseup" || e2.type === "click" || e2.type === "contextmenu";
  }
  var PI = Math.PI;
  var TAU = 2 * PI;
  var PITAU = TAU + PI;
  var INFINITY = Number.POSITIVE_INFINITY;
  var RAD_PER_DEG = PI / 180;
  var HALF_PI = PI / 2;
  var QUARTER_PI = PI / 4;
  var TWO_THIRDS_PI = PI * 2 / 3;
  var log10 = Math.log10;
  var sign = Math.sign;
  function almostEquals(x, y, epsilon) {
    return Math.abs(x - y) < epsilon;
  }
  function niceNum(range2) {
    const roundedRange = Math.round(range2);
    range2 = almostEquals(range2, roundedRange, range2 / 1e3) ? roundedRange : range2;
    const niceRange = Math.pow(10, Math.floor(log10(range2)));
    const fraction = range2 / niceRange;
    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
    return niceFraction * niceRange;
  }
  function _factorize(value) {
    const result = [];
    const sqrt = Math.sqrt(value);
    let i2;
    for (i2 = 1; i2 < sqrt; i2++) {
      if (value % i2 === 0) {
        result.push(i2);
        result.push(value / i2);
      }
    }
    if (sqrt === (sqrt | 0)) {
      result.push(sqrt);
    }
    result.sort((a2, b) => a2 - b).pop();
    return result;
  }
  function isNumber(n2) {
    return !isNaN(parseFloat(n2)) && isFinite(n2);
  }
  function almostWhole(x, epsilon) {
    const rounded = Math.round(x);
    return rounded - epsilon <= x && rounded + epsilon >= x;
  }
  function _setMinAndMaxByKey(array, target, property) {
    let i2, ilen, value;
    for (i2 = 0, ilen = array.length; i2 < ilen; i2++) {
      value = array[i2][property];
      if (!isNaN(value)) {
        target.min = Math.min(target.min, value);
        target.max = Math.max(target.max, value);
      }
    }
  }
  function toRadians(degrees) {
    return degrees * (PI / 180);
  }
  function toDegrees(radians) {
    return radians * (180 / PI);
  }
  function _decimalPlaces(x) {
    if (!isNumberFinite(x)) {
      return;
    }
    let e2 = 1;
    let p = 0;
    while (Math.round(x * e2) / e2 !== x) {
      e2 *= 10;
      p++;
    }
    return p;
  }
  function getAngleFromPoint(centrePoint, anglePoint) {
    const distanceFromXCenter = anglePoint.x - centrePoint.x;
    const distanceFromYCenter = anglePoint.y - centrePoint.y;
    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
    if (angle < -0.5 * PI) {
      angle += TAU;
    }
    return {
      angle,
      distance: radialDistanceFromCenter
    };
  }
  function distanceBetweenPoints(pt1, pt2) {
    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
  }
  function _angleDiff(a2, b) {
    return (a2 - b + PITAU) % TAU - PI;
  }
  function _normalizeAngle(a2) {
    return (a2 % TAU + TAU) % TAU;
  }
  function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
    const a2 = _normalizeAngle(angle);
    const s2 = _normalizeAngle(start);
    const e2 = _normalizeAngle(end);
    const angleToStart = _normalizeAngle(s2 - a2);
    const angleToEnd = _normalizeAngle(e2 - a2);
    const startToAngle = _normalizeAngle(a2 - s2);
    const endToAngle = _normalizeAngle(a2 - e2);
    return a2 === s2 || a2 === e2 || sameAngleIsFullCircle && s2 === e2 || angleToStart > angleToEnd && startToAngle < endToAngle;
  }
  function _limitValue(value, min, max2) {
    return Math.max(min, Math.min(max2, value));
  }
  function _int16Range(value) {
    return _limitValue(value, -32768, 32767);
  }
  function _isBetween(value, start, end, epsilon = 1e-6) {
    return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
  }
  function _lookup(table, value, cmp) {
    cmp = cmp || ((index2) => table[index2] < value);
    let hi = table.length - 1;
    let lo = 0;
    let mid;
    while (hi - lo > 1) {
      mid = lo + hi >> 1;
      if (cmp(mid)) {
        lo = mid;
      } else {
        hi = mid;
      }
    }
    return {
      lo,
      hi
    };
  }
  var _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index2) => {
    const ti = table[index2][key];
    return ti < value || ti === value && table[index2 + 1][key] === value;
  } : (index2) => table[index2][key] < value);
  var _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);
  function _filterBetween(values, min, max2) {
    let start = 0;
    let end = values.length;
    while (start < end && values[start] < min) {
      start++;
    }
    while (end > start && values[end - 1] > max2) {
      end--;
    }
    return start > 0 || end < values.length ? values.slice(start, end) : values;
  }
  var arrayEvents = [
    "push",
    "pop",
    "shift",
    "splice",
    "unshift"
  ];
  function listenArrayEvents(array, listener) {
    if (array._chartjs) {
      array._chartjs.listeners.push(listener);
      return;
    }
    Object.defineProperty(array, "_chartjs", {
      configurable: true,
      enumerable: false,
      value: {
        listeners: [
          listener
        ]
      }
    });
    arrayEvents.forEach((key) => {
      const method = "_onData" + _capitalize(key);
      const base = array[key];
      Object.defineProperty(array, key, {
        configurable: true,
        enumerable: false,
        value(...args) {
          const res = base.apply(this, args);
          array._chartjs.listeners.forEach((object) => {
            if (typeof object[method] === "function") {
              object[method](...args);
            }
          });
          return res;
        }
      });
    });
  }
  function unlistenArrayEvents(array, listener) {
    const stub = array._chartjs;
    if (!stub) {
      return;
    }
    const listeners = stub.listeners;
    const index2 = listeners.indexOf(listener);
    if (index2 !== -1) {
      listeners.splice(index2, 1);
    }
    if (listeners.length > 0) {
      return;
    }
    arrayEvents.forEach((key) => {
      delete array[key];
    });
    delete array._chartjs;
  }
  function _arrayUnique(items) {
    const set2 = new Set(items);
    if (set2.size === items.length) {
      return items;
    }
    return Array.from(set2);
  }
  var requestAnimFrame = function() {
    if (typeof window === "undefined") {
      return function(callback2) {
        return callback2();
      };
    }
    return window.requestAnimationFrame;
  }();
  function throttled(fn, thisArg) {
    let argsToUse = [];
    let ticking = false;
    return function(...args) {
      argsToUse = args;
      if (!ticking) {
        ticking = true;
        requestAnimFrame.call(window, () => {
          ticking = false;
          fn.apply(thisArg, argsToUse);
        });
      }
    };
  }
  function debounce(fn, delay) {
    let timeout;
    return function(...args) {
      if (delay) {
        clearTimeout(timeout);
        timeout = setTimeout(fn, delay, args);
      } else {
        fn.apply(this, args);
      }
      return delay;
    };
  }
  var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
  var _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
  var _textX = (align, left, right, rtl) => {
    const check = rtl ? "left" : "right";
    return align === check ? right : align === "center" ? (left + right) / 2 : left;
  };
  function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
    const pointCount = points.length;
    let start = 0;
    let count = pointCount;
    if (meta._sorted) {
      const { iScale, _parsed } = meta;
      const axis = iScale.axis;
      const { min, max: max2, minDefined, maxDefined } = iScale.getUserBounds();
      if (minDefined) {
        start = _limitValue(Math.min(
          // @ts-expect-error Need to type _parsed
          _lookupByKey(_parsed, axis, min).lo,
          // @ts-expect-error Need to fix types on _lookupByKey
          animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo
        ), 0, pointCount - 1);
      }
      if (maxDefined) {
        count = _limitValue(Math.max(
          // @ts-expect-error Need to type _parsed
          _lookupByKey(_parsed, iScale.axis, max2, true).hi + 1,
          // @ts-expect-error Need to fix types on _lookupByKey
          animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max2), true).hi + 1
        ), start, pointCount) - start;
      } else {
        count = pointCount - start;
      }
    }
    return {
      start,
      count
    };
  }
  function _scaleRangesChanged(meta) {
    const { xScale, yScale, _scaleRanges } = meta;
    const newRanges = {
      xmin: xScale.min,
      xmax: xScale.max,
      ymin: yScale.min,
      ymax: yScale.max
    };
    if (!_scaleRanges) {
      meta._scaleRanges = newRanges;
      return true;
    }
    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
    Object.assign(_scaleRanges, newRanges);
    return changed;
  }
  var atEdge = (t2) => t2 === 0 || t2 === 1;
  var elasticIn = (t2, s2, p) => -(Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 - s2) * TAU / p));
  var elasticOut = (t2, s2, p) => Math.pow(2, -10 * t2) * Math.sin((t2 - s2) * TAU / p) + 1;
  var effects = {
    linear: (t2) => t2,
    easeInQuad: (t2) => t2 * t2,
    easeOutQuad: (t2) => -t2 * (t2 - 2),
    easeInOutQuad: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 : -0.5 * (--t2 * (t2 - 2) - 1),
    easeInCubic: (t2) => t2 * t2 * t2,
    easeOutCubic: (t2) => (t2 -= 1) * t2 * t2 + 1,
    easeInOutCubic: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 + 2),
    easeInQuart: (t2) => t2 * t2 * t2 * t2,
    easeOutQuart: (t2) => -((t2 -= 1) * t2 * t2 * t2 - 1),
    easeInOutQuart: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 : -0.5 * ((t2 -= 2) * t2 * t2 * t2 - 2),
    easeInQuint: (t2) => t2 * t2 * t2 * t2 * t2,
    easeOutQuint: (t2) => (t2 -= 1) * t2 * t2 * t2 * t2 + 1,
    easeInOutQuint: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 * t2 * t2 + 2),
    easeInSine: (t2) => -Math.cos(t2 * HALF_PI) + 1,
    easeOutSine: (t2) => Math.sin(t2 * HALF_PI),
    easeInOutSine: (t2) => -0.5 * (Math.cos(PI * t2) - 1),
    easeInExpo: (t2) => t2 === 0 ? 0 : Math.pow(2, 10 * (t2 - 1)),
    easeOutExpo: (t2) => t2 === 1 ? 1 : -Math.pow(2, -10 * t2) + 1,
    easeInOutExpo: (t2) => atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * Math.pow(2, 10 * (t2 * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t2 * 2 - 1)) + 2),
    easeInCirc: (t2) => t2 >= 1 ? t2 : -(Math.sqrt(1 - t2 * t2) - 1),
    easeOutCirc: (t2) => Math.sqrt(1 - (t2 -= 1) * t2),
    easeInOutCirc: (t2) => (t2 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t2 * t2) - 1) : 0.5 * (Math.sqrt(1 - (t2 -= 2) * t2) + 1),
    easeInElastic: (t2) => atEdge(t2) ? t2 : elasticIn(t2, 0.075, 0.3),
    easeOutElastic: (t2) => atEdge(t2) ? t2 : elasticOut(t2, 0.075, 0.3),
    easeInOutElastic(t2) {
      const s2 = 0.1125;
      const p = 0.45;
      return atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * elasticIn(t2 * 2, s2, p) : 0.5 + 0.5 * elasticOut(t2 * 2 - 1, s2, p);
    },
    easeInBack(t2) {
      const s2 = 1.70158;
      return t2 * t2 * ((s2 + 1) * t2 - s2);
    },
    easeOutBack(t2) {
      const s2 = 1.70158;
      return (t2 -= 1) * t2 * ((s2 + 1) * t2 + s2) + 1;
    },
    easeInOutBack(t2) {
      let s2 = 1.70158;
      if ((t2 /= 0.5) < 1) {
        return 0.5 * (t2 * t2 * (((s2 *= 1.525) + 1) * t2 - s2));
      }
      return 0.5 * ((t2 -= 2) * t2 * (((s2 *= 1.525) + 1) * t2 + s2) + 2);
    },
    easeInBounce: (t2) => 1 - effects.easeOutBounce(1 - t2),
    easeOutBounce(t2) {
      const m = 7.5625;
      const d2 = 2.75;
      if (t2 < 1 / d2) {
        return m * t2 * t2;
      }
      if (t2 < 2 / d2) {
        return m * (t2 -= 1.5 / d2) * t2 + 0.75;
      }
      if (t2 < 2.5 / d2) {
        return m * (t2 -= 2.25 / d2) * t2 + 0.9375;
      }
      return m * (t2 -= 2.625 / d2) * t2 + 0.984375;
    },
    easeInOutBounce: (t2) => t2 < 0.5 ? effects.easeInBounce(t2 * 2) * 0.5 : effects.easeOutBounce(t2 * 2 - 1) * 0.5 + 0.5
  };
  function isPatternOrGradient(value) {
    if (value && typeof value === "object") {
      const type = value.toString();
      return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
    }
    return false;
  }
  function color(value) {
    return isPatternOrGradient(value) ? value : new Color(value);
  }
  function getHoverColor(value) {
    return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
  }
  var numbers = [
    "x",
    "y",
    "borderWidth",
    "radius",
    "tension"
  ];
  var colors = [
    "color",
    "borderColor",
    "backgroundColor"
  ];
  function applyAnimationsDefaults(defaults2) {
    defaults2.set("animation", {
      delay: void 0,
      duration: 1e3,
      easing: "easeOutQuart",
      fn: void 0,
      from: void 0,
      loop: void 0,
      to: void 0,
      type: void 0
    });
    defaults2.describe("animation", {
      _fallback: false,
      _indexable: false,
      _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
    });
    defaults2.set("animations", {
      colors: {
        type: "color",
        properties: colors
      },
      numbers: {
        type: "number",
        properties: numbers
      }
    });
    defaults2.describe("animations", {
      _fallback: "animation"
    });
    defaults2.set("transitions", {
      active: {
        animation: {
          duration: 400
        }
      },
      resize: {
        animation: {
          duration: 0
        }
      },
      show: {
        animations: {
          colors: {
            from: "transparent"
          },
          visible: {
            type: "boolean",
            duration: 0
          }
        }
      },
      hide: {
        animations: {
          colors: {
            to: "transparent"
          },
          visible: {
            type: "boolean",
            easing: "linear",
            fn: (v) => v | 0
          }
        }
      }
    });
  }
  function applyLayoutsDefaults(defaults2) {
    defaults2.set("layout", {
      autoPadding: true,
      padding: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }
    });
  }
  var intlCache = /* @__PURE__ */ new Map();
  function getNumberFormat(locale, options) {
    options = options || {};
    const cacheKey = locale + JSON.stringify(options);
    let formatter = intlCache.get(cacheKey);
    if (!formatter) {
      formatter = new Intl.NumberFormat(locale, options);
      intlCache.set(cacheKey, formatter);
    }
    return formatter;
  }
  function formatNumber(num, locale, options) {
    return getNumberFormat(locale, options).format(num);
  }
  var formatters = {
    values(value) {
      return isArray(value) ? value : "" + value;
    },
    numeric(tickValue, index2, ticks) {
      if (tickValue === 0) {
        return "0";
      }
      const locale = this.chart.options.locale;
      let notation;
      let delta = tickValue;
      if (ticks.length > 1) {
        const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
        if (maxTick < 1e-4 || maxTick > 1e15) {
          notation = "scientific";
        }
        delta = calculateDelta(tickValue, ticks);
      }
      const logDelta = log10(Math.abs(delta));
      const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
      const options = {
        notation,
        minimumFractionDigits: numDecimal,
        maximumFractionDigits: numDecimal
      };
      Object.assign(options, this.options.ticks.format);
      return formatNumber(tickValue, locale, options);
    },
    logarithmic(tickValue, index2, ticks) {
      if (tickValue === 0) {
        return "0";
      }
      const remain = ticks[index2].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
      if ([
        1,
        2,
        3,
        5,
        10,
        15
      ].includes(remain) || index2 > 0.8 * ticks.length) {
        return formatters.numeric.call(this, tickValue, index2, ticks);
      }
      return "";
    }
  };
  function calculateDelta(tickValue, ticks) {
    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
      delta = tickValue - Math.floor(tickValue);
    }
    return delta;
  }
  var Ticks = {
    formatters
  };
  function applyScaleDefaults(defaults2) {
    defaults2.set("scale", {
      display: true,
      offset: false,
      reverse: false,
      beginAtZero: false,
      bounds: "ticks",
      clip: true,
      grace: 0,
      grid: {
        display: true,
        lineWidth: 1,
        drawOnChartArea: true,
        drawTicks: true,
        tickLength: 8,
        tickWidth: (_ctx, options) => options.lineWidth,
        tickColor: (_ctx, options) => options.color,
        offset: false
      },
      border: {
        display: true,
        dash: [],
        dashOffset: 0,
        width: 1
      },
      title: {
        display: false,
        text: "",
        padding: {
          top: 4,
          bottom: 4
        }
      },
      ticks: {
        minRotation: 0,
        maxRotation: 50,
        mirror: false,
        textStrokeWidth: 0,
        textStrokeColor: "",
        padding: 3,
        display: true,
        autoSkip: true,
        autoSkipPadding: 3,
        labelOffset: 0,
        callback: Ticks.formatters.values,
        minor: {},
        major: {},
        align: "center",
        crossAlign: "near",
        showLabelBackdrop: false,
        backdropColor: "rgba(255, 255, 255, 0.75)",
        backdropPadding: 2
      }
    });
    defaults2.route("scale.ticks", "color", "", "color");
    defaults2.route("scale.grid", "color", "", "borderColor");
    defaults2.route("scale.border", "color", "", "borderColor");
    defaults2.route("scale.title", "color", "", "color");
    defaults2.describe("scale", {
      _fallback: false,
      _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
      _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash" && name !== "dash"
    });
    defaults2.describe("scales", {
      _fallback: "scale"
    });
    defaults2.describe("scale.ticks", {
      _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
      _indexable: (name) => name !== "backdropPadding"
    });
  }
  var overrides = /* @__PURE__ */ Object.create(null);
  var descriptors = /* @__PURE__ */ Object.create(null);
  function getScope$1(node, key) {
    if (!key) {
      return node;
    }
    const keys = key.split(".");
    for (let i2 = 0, n2 = keys.length; i2 < n2; ++i2) {
      const k = keys[i2];
      node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
    }
    return node;
  }
  function set(root, scope, values) {
    if (typeof scope === "string") {
      return merge(getScope$1(root, scope), values);
    }
    return merge(getScope$1(root, ""), scope);
  }
  var Defaults = class {
    constructor(_descriptors2, _appliers) {
      this.animation = void 0;
      this.backgroundColor = "rgba(0,0,0,0.1)";
      this.borderColor = "rgba(0,0,0,0.1)";
      this.color = "#666";
      this.datasets = {};
      this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
      this.elements = {};
      this.events = [
        "mousemove",
        "mouseout",
        "click",
        "touchstart",
        "touchmove"
      ];
      this.font = {
        family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
        size: 12,
        style: "normal",
        lineHeight: 1.2,
        weight: null
      };
      this.hover = {};
      this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
      this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
      this.hoverColor = (ctx, options) => getHoverColor(options.color);
      this.indexAxis = "x";
      this.interaction = {
        mode: "nearest",
        intersect: true,
        includeInvisible: false
      };
      this.maintainAspectRatio = true;
      this.onHover = null;
      this.onClick = null;
      this.parsing = true;
      this.plugins = {};
      this.responsive = true;
      this.scale = void 0;
      this.scales = {};
      this.showLine = true;
      this.drawActiveElementsOnTop = true;
      this.describe(_descriptors2);
      this.apply(_appliers);
    }
    set(scope, values) {
      return set(this, scope, values);
    }
    get(scope) {
      return getScope$1(this, scope);
    }
    describe(scope, values) {
      return set(descriptors, scope, values);
    }
    override(scope, values) {
      return set(overrides, scope, values);
    }
    route(scope, name, targetScope, targetName) {
      const scopeObject = getScope$1(this, scope);
      const targetScopeObject = getScope$1(this, targetScope);
      const privateName = "_" + name;
      Object.defineProperties(scopeObject, {
        [privateName]: {
          value: scopeObject[name],
          writable: true
        },
        [name]: {
          enumerable: true,
          get() {
            const local = this[privateName];
            const target = targetScopeObject[targetName];
            if (isObject2(local)) {
              return Object.assign({}, target, local);
            }
            return valueOrDefault(local, target);
          },
          set(value) {
            this[privateName] = value;
          }
        }
      });
    }
    apply(appliers) {
      appliers.forEach((apply) => apply(this));
    }
  };
  var defaults = /* @__PURE__ */ new Defaults({
    _scriptable: (name) => !name.startsWith("on"),
    _indexable: (name) => name !== "events",
    hover: {
      _fallback: "interaction"
    },
    interaction: {
      _scriptable: false,
      _indexable: false
    }
  }, [
    applyAnimationsDefaults,
    applyLayoutsDefaults,
    applyScaleDefaults
  ]);
  function toFontString(font) {
    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
      return null;
    }
    return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
  }
  function _measureText(ctx, data, gc, longest, string) {
    let textWidth = data[string];
    if (!textWidth) {
      textWidth = data[string] = ctx.measureText(string).width;
      gc.push(string);
    }
    if (textWidth > longest) {
      longest = textWidth;
    }
    return longest;
  }
  function _longestText(ctx, font, arrayOfThings, cache) {
    cache = cache || {};
    let data = cache.data = cache.data || {};
    let gc = cache.garbageCollect = cache.garbageCollect || [];
    if (cache.font !== font) {
      data = cache.data = {};
      gc = cache.garbageCollect = [];
      cache.font = font;
    }
    ctx.save();
    ctx.font = font;
    let longest = 0;
    const ilen = arrayOfThings.length;
    let i2, j, jlen, thing, nestedThing;
    for (i2 = 0; i2 < ilen; i2++) {
      thing = arrayOfThings[i2];
      if (thing !== void 0 && thing !== null && !isArray(thing)) {
        longest = _measureText(ctx, data, gc, longest, thing);
      } else if (isArray(thing)) {
        for (j = 0, jlen = thing.length; j < jlen; j++) {
          nestedThing = thing[j];
          if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
            longest = _measureText(ctx, data, gc, longest, nestedThing);
          }
        }
      }
    }
    ctx.restore();
    const gcLen = gc.length / 2;
    if (gcLen > arrayOfThings.length) {
      for (i2 = 0; i2 < gcLen; i2++) {
        delete data[gc[i2]];
      }
      gc.splice(0, gcLen);
    }
    return longest;
  }
  function _alignPixel(chart, pixel, width) {
    const devicePixelRatio = chart.currentDevicePixelRatio;
    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
  }
  function clearCanvas(canvas, ctx) {
    if (!ctx && !canvas) {
      return;
    }
    ctx = ctx || canvas.getContext("2d");
    ctx.save();
    ctx.resetTransform();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
  }
  function drawPoint(ctx, options, x, y) {
    drawPointLegend(ctx, options, x, y, null);
  }
  function drawPointLegend(ctx, options, x, y, w) {
    let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
    const style = options.pointStyle;
    const rotation = options.rotation;
    const radius = options.radius;
    let rad = (rotation || 0) * RAD_PER_DEG;
    if (style && typeof style === "object") {
      type = style.toString();
      if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rad);
        ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
        ctx.restore();
        return;
      }
    }
    if (isNaN(radius) || radius <= 0) {
      return;
    }
    ctx.beginPath();
    switch (style) {
      default:
        if (w) {
          ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
        } else {
          ctx.arc(x, y, radius, 0, TAU);
        }
        ctx.closePath();
        break;
      case "triangle":
        width = w ? w / 2 : radius;
        ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
        rad += TWO_THIRDS_PI;
        ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
        rad += TWO_THIRDS_PI;
        ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
        ctx.closePath();
        break;
      case "rectRounded":
        cornerRadius = radius * 0.516;
        size = radius - cornerRadius;
        xOffset = Math.cos(rad + QUARTER_PI) * size;
        xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
        yOffset = Math.sin(rad + QUARTER_PI) * size;
        yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
        ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
        ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
        ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
        ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
        ctx.closePath();
        break;
      case "rect":
        if (!rotation) {
          size = Math.SQRT1_2 * radius;
          width = w ? w / 2 : size;
          ctx.rect(x - width, y - size, 2 * width, 2 * size);
          break;
        }
        rad += QUARTER_PI;
      case "rectRot":
        xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
        ctx.moveTo(x - xOffsetW, y - yOffset);
        ctx.lineTo(x + yOffsetW, y - xOffset);
        ctx.lineTo(x + xOffsetW, y + yOffset);
        ctx.lineTo(x - yOffsetW, y + xOffset);
        ctx.closePath();
        break;
      case "crossRot":
        rad += QUARTER_PI;
      case "cross":
        xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
        ctx.moveTo(x - xOffsetW, y - yOffset);
        ctx.lineTo(x + xOffsetW, y + yOffset);
        ctx.moveTo(x + yOffsetW, y - xOffset);
        ctx.lineTo(x - yOffsetW, y + xOffset);
        break;
      case "star":
        xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
        ctx.moveTo(x - xOffsetW, y - yOffset);
        ctx.lineTo(x + xOffsetW, y + yOffset);
        ctx.moveTo(x + yOffsetW, y - xOffset);
        ctx.lineTo(x - yOffsetW, y + xOffset);
        rad += QUARTER_PI;
        xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
        ctx.moveTo(x - xOffsetW, y - yOffset);
        ctx.lineTo(x + xOffsetW, y + yOffset);
        ctx.moveTo(x + yOffsetW, y - xOffset);
        ctx.lineTo(x - yOffsetW, y + xOffset);
        break;
      case "line":
        xOffset = w ? w / 2 : Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x - xOffset, y - yOffset);
        ctx.lineTo(x + xOffset, y + yOffset);
        break;
      case "dash":
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
        break;
      case false:
        ctx.closePath();
        break;
    }
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  function _isPointInArea(point, area, margin) {
    margin = margin || 0.5;
    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
  }
  function clipArea(ctx, area) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
    ctx.clip();
  }
  function unclipArea(ctx) {
    ctx.restore();
  }
  function _steppedLineTo(ctx, previous, target, flip, mode) {
    if (!previous) {
      return ctx.lineTo(target.x, target.y);
    }
    if (mode === "middle") {
      const midpoint = (previous.x + target.x) / 2;
      ctx.lineTo(midpoint, previous.y);
      ctx.lineTo(midpoint, target.y);
    } else if (mode === "after" !== !!flip) {
      ctx.lineTo(previous.x, target.y);
    } else {
      ctx.lineTo(target.x, previous.y);
    }
    ctx.lineTo(target.x, target.y);
  }
  function _bezierCurveTo(ctx, previous, target, flip) {
    if (!previous) {
      return ctx.lineTo(target.x, target.y);
    }
    ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
  }
  function setRenderOpts(ctx, opts) {
    if (opts.translation) {
      ctx.translate(opts.translation[0], opts.translation[1]);
    }
    if (!isNullOrUndef(opts.rotation)) {
      ctx.rotate(opts.rotation);
    }
    if (opts.color) {
      ctx.fillStyle = opts.color;
    }
    if (opts.textAlign) {
      ctx.textAlign = opts.textAlign;
    }
    if (opts.textBaseline) {
      ctx.textBaseline = opts.textBaseline;
    }
  }
  function decorateText(ctx, x, y, line, opts) {
    if (opts.strikethrough || opts.underline) {
      const metrics = ctx.measureText(line);
      const left = x - metrics.actualBoundingBoxLeft;
      const right = x + metrics.actualBoundingBoxRight;
      const top2 = y - metrics.actualBoundingBoxAscent;
      const bottom2 = y + metrics.actualBoundingBoxDescent;
      const yDecoration = opts.strikethrough ? (top2 + bottom2) / 2 : bottom2;
      ctx.strokeStyle = ctx.fillStyle;
      ctx.beginPath();
      ctx.lineWidth = opts.decorationWidth || 2;
      ctx.moveTo(left, yDecoration);
      ctx.lineTo(right, yDecoration);
      ctx.stroke();
    }
  }
  function drawBackdrop(ctx, opts) {
    const oldColor = ctx.fillStyle;
    ctx.fillStyle = opts.color;
    ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
    ctx.fillStyle = oldColor;
  }
  function renderText(ctx, text, x, y, font, opts = {}) {
    const lines = isArray(text) ? text : [
      text
    ];
    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
    let i2, line;
    ctx.save();
    ctx.font = font.string;
    setRenderOpts(ctx, opts);
    for (i2 = 0; i2 < lines.length; ++i2) {
      line = lines[i2];
      if (opts.backdrop) {
        drawBackdrop(ctx, opts.backdrop);
      }
      if (stroke) {
        if (opts.strokeColor) {
          ctx.strokeStyle = opts.strokeColor;
        }
        if (!isNullOrUndef(opts.strokeWidth)) {
          ctx.lineWidth = opts.strokeWidth;
        }
        ctx.strokeText(line, x, y, opts.maxWidth);
      }
      ctx.fillText(line, x, y, opts.maxWidth);
      decorateText(ctx, x, y, line, opts);
      y += Number(font.lineHeight);
    }
    ctx.restore();
  }
  function addRoundedRectPath(ctx, rect) {
    const { x, y, w, h: h3, radius } = rect;
    ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
    ctx.lineTo(x, y + h3 - radius.bottomLeft);
    ctx.arc(x + radius.bottomLeft, y + h3 - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
    ctx.lineTo(x + w - radius.bottomRight, y + h3);
    ctx.arc(x + w - radius.bottomRight, y + h3 - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
    ctx.lineTo(x + w, y + radius.topRight);
    ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
    ctx.lineTo(x + radius.topLeft, y);
  }
  var LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
  var FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
  function toLineHeight(value, size) {
    const matches = ("" + value).match(LINE_HEIGHT);
    if (!matches || matches[1] === "normal") {
      return size * 1.2;
    }
    value = +matches[2];
    switch (matches[3]) {
      case "px":
        return value;
      case "%":
        value /= 100;
        break;
    }
    return size * value;
  }
  var numberOrZero = (v) => +v || 0;
  function _readValueToProps(value, props) {
    const ret = {};
    const objProps = isObject2(props);
    const keys = objProps ? Object.keys(props) : props;
    const read = isObject2(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
    for (const prop of keys) {
      ret[prop] = numberOrZero(read(prop));
    }
    return ret;
  }
  function toTRBL(value) {
    return _readValueToProps(value, {
      top: "y",
      right: "x",
      bottom: "y",
      left: "x"
    });
  }
  function toTRBLCorners(value) {
    return _readValueToProps(value, [
      "topLeft",
      "topRight",
      "bottomLeft",
      "bottomRight"
    ]);
  }
  function toPadding(value) {
    const obj = toTRBL(value);
    obj.width = obj.left + obj.right;
    obj.height = obj.top + obj.bottom;
    return obj;
  }
  function toFont(options, fallback) {
    options = options || {};
    fallback = fallback || defaults.font;
    let size = valueOrDefault(options.size, fallback.size);
    if (typeof size === "string") {
      size = parseInt(size, 10);
    }
    let style = valueOrDefault(options.style, fallback.style);
    if (style && !("" + style).match(FONT_STYLE)) {
      console.warn('Invalid font style specified: "' + style + '"');
      style = void 0;
    }
    const font = {
      family: valueOrDefault(options.family, fallback.family),
      lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
      size,
      style,
      weight: valueOrDefault(options.weight, fallback.weight),
      string: ""
    };
    font.string = toFontString(font);
    return font;
  }
  function resolve(inputs, context, index2, info) {
    let cacheable = true;
    let i2, ilen, value;
    for (i2 = 0, ilen = inputs.length; i2 < ilen; ++i2) {
      value = inputs[i2];
      if (value === void 0) {
        continue;
      }
      if (context !== void 0 && typeof value === "function") {
        value = value(context);
        cacheable = false;
      }
      if (index2 !== void 0 && isArray(value)) {
        value = value[index2 % value.length];
        cacheable = false;
      }
      if (value !== void 0) {
        if (info && !cacheable) {
          info.cacheable = false;
        }
        return value;
      }
    }
  }
  function _addGrace(minmax, grace, beginAtZero) {
    const { min, max: max2 } = minmax;
    const change = toDimension(grace, (max2 - min) / 2);
    const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
    return {
      min: keepZero(min, -Math.abs(change)),
      max: keepZero(max2, change)
    };
  }
  function createContext(parentContext, context) {
    return Object.assign(Object.create(parentContext), context);
  }
  function _createResolver(scopes, prefixes = [
    ""
  ], rootScopes, fallback, getTarget = () => scopes[0]) {
    const finalRootScopes = rootScopes || scopes;
    if (typeof fallback === "undefined") {
      fallback = _resolve("_fallback", scopes);
    }
    const cache = {
      [Symbol.toStringTag]: "Object",
      _cacheable: true,
      _scopes: scopes,
      _rootScopes: finalRootScopes,
      _fallback: fallback,
      _getTarget: getTarget,
      override: (scope) => _createResolver([
        scope,
        ...scopes
      ], prefixes, finalRootScopes, fallback)
    };
    return new Proxy(cache, {
      /**
      * A trap for the delete operator.
      */
      deleteProperty(target, prop) {
        delete target[prop];
        delete target._keys;
        delete scopes[0][prop];
        return true;
      },
      /**
      * A trap for getting property values.
      */
      get(target, prop) {
        return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
      },
      /**
      * A trap for Object.getOwnPropertyDescriptor.
      * Also used by Object.hasOwnProperty.
      */
      getOwnPropertyDescriptor(target, prop) {
        return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
      },
      /**
      * A trap for Object.getPrototypeOf.
      */
      getPrototypeOf() {
        return Reflect.getPrototypeOf(scopes[0]);
      },
      /**
      * A trap for the in operator.
      */
      has(target, prop) {
        return getKeysFromAllScopes(target).includes(prop);
      },
      /**
      * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
      */
      ownKeys(target) {
        return getKeysFromAllScopes(target);
      },
      /**
      * A trap for setting property values.
      */
      set(target, prop, value) {
        const storage = target._storage || (target._storage = getTarget());
        target[prop] = storage[prop] = value;
        delete target._keys;
        return true;
      }
    });
  }
  function _attachContext(proxy, context, subProxy, descriptorDefaults) {
    const cache = {
      _cacheable: false,
      _proxy: proxy,
      _context: context,
      _subProxy: subProxy,
      _stack: /* @__PURE__ */ new Set(),
      _descriptors: _descriptors(proxy, descriptorDefaults),
      setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
      override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
    };
    return new Proxy(cache, {
      /**
      * A trap for the delete operator.
      */
      deleteProperty(target, prop) {
        delete target[prop];
        delete proxy[prop];
        return true;
      },
      /**
      * A trap for getting property values.
      */
      get(target, prop, receiver) {
        return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
      },
      /**
      * A trap for Object.getOwnPropertyDescriptor.
      * Also used by Object.hasOwnProperty.
      */
      getOwnPropertyDescriptor(target, prop) {
        return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
          enumerable: true,
          configurable: true
        } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
      },
      /**
      * A trap for Object.getPrototypeOf.
      */
      getPrototypeOf() {
        return Reflect.getPrototypeOf(proxy);
      },
      /**
      * A trap for the in operator.
      */
      has(target, prop) {
        return Reflect.has(proxy, prop);
      },
      /**
      * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
      */
      ownKeys() {
        return Reflect.ownKeys(proxy);
      },
      /**
      * A trap for setting property values.
      */
      set(target, prop, value) {
        proxy[prop] = value;
        delete target[prop];
        return true;
      }
    });
  }
  function _descriptors(proxy, defaults2 = {
    scriptable: true,
    indexable: true
  }) {
    const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
    return {
      allKeys: _allKeys,
      scriptable: _scriptable,
      indexable: _indexable,
      isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
      isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
    };
  }
  var readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
  var needsSubResolver = (prop, value) => isObject2(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
  function _cached(target, prop, resolve2) {
    if (Object.prototype.hasOwnProperty.call(target, prop) || prop === "constructor") {
      return target[prop];
    }
    const value = resolve2();
    target[prop] = value;
    return value;
  }
  function _resolveWithContext(target, prop, receiver) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
    let value = _proxy[prop];
    if (isFunction(value) && descriptors2.isScriptable(prop)) {
      value = _resolveScriptable(prop, value, target, receiver);
    }
    if (isArray(value) && value.length) {
      value = _resolveArray(prop, value, target, descriptors2.isIndexable);
    }
    if (needsSubResolver(prop, value)) {
      value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
    }
    return value;
  }
  function _resolveScriptable(prop, getValue, target, receiver) {
    const { _proxy, _context, _subProxy, _stack } = target;
    if (_stack.has(prop)) {
      throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
    }
    _stack.add(prop);
    let value = getValue(_context, _subProxy || receiver);
    _stack.delete(prop);
    if (needsSubResolver(prop, value)) {
      value = createSubResolver(_proxy._scopes, _proxy, prop, value);
    }
    return value;
  }
  function _resolveArray(prop, value, target, isIndexable) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
    if (typeof _context.index !== "undefined" && isIndexable(prop)) {
      return value[_context.index % value.length];
    } else if (isObject2(value[0])) {
      const arr = value;
      const scopes = _proxy._scopes.filter((s2) => s2 !== arr);
      value = [];
      for (const item of arr) {
        const resolver = createSubResolver(scopes, _proxy, prop, item);
        value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
      }
    }
    return value;
  }
  function resolveFallback(fallback, prop, value) {
    return isFunction(fallback) ? fallback(prop, value) : fallback;
  }
  var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
  function addScopes(set2, parentScopes, key, parentFallback, value) {
    for (const parent of parentScopes) {
      const scope = getScope(key, parent);
      if (scope) {
        set2.add(scope);
        const fallback = resolveFallback(scope._fallback, key, value);
        if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) {
          return fallback;
        }
      } else if (scope === false && typeof parentFallback !== "undefined" && key !== parentFallback) {
        return null;
      }
    }
    return false;
  }
  function createSubResolver(parentScopes, resolver, prop, value) {
    const rootScopes = resolver._rootScopes;
    const fallback = resolveFallback(resolver._fallback, prop, value);
    const allScopes = [
      ...parentScopes,
      ...rootScopes
    ];
    const set2 = /* @__PURE__ */ new Set();
    set2.add(value);
    let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
    if (key === null) {
      return false;
    }
    if (typeof fallback !== "undefined" && fallback !== prop) {
      key = addScopesFromKey(set2, allScopes, fallback, key, value);
      if (key === null) {
        return false;
      }
    }
    return _createResolver(Array.from(set2), [
      ""
    ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
  }
  function addScopesFromKey(set2, allScopes, key, fallback, item) {
    while (key) {
      key = addScopes(set2, allScopes, key, fallback, item);
    }
    return key;
  }
  function subGetTarget(resolver, prop, value) {
    const parent = resolver._getTarget();
    if (!(prop in parent)) {
      parent[prop] = {};
    }
    const target = parent[prop];
    if (isArray(target) && isObject2(value)) {
      return value;
    }
    return target || {};
  }
  function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
    let value;
    for (const prefix of prefixes) {
      value = _resolve(readKey(prefix, prop), scopes);
      if (typeof value !== "undefined") {
        return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
      }
    }
  }
  function _resolve(key, scopes) {
    for (const scope of scopes) {
      if (!scope) {
        continue;
      }
      const value = scope[key];
      if (typeof value !== "undefined") {
        return value;
      }
    }
  }
  function getKeysFromAllScopes(target) {
    let keys = target._keys;
    if (!keys) {
      keys = target._keys = resolveKeysFromAllScopes(target._scopes);
    }
    return keys;
  }
  function resolveKeysFromAllScopes(scopes) {
    const set2 = /* @__PURE__ */ new Set();
    for (const scope of scopes) {
      for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
        set2.add(key);
      }
    }
    return Array.from(set2);
  }
  function _parseObjectDataRadialScale(meta, data, start, count) {
    const { iScale } = meta;
    const { key = "r" } = this._parsing;
    const parsed = new Array(count);
    let i2, ilen, index2, item;
    for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
      index2 = i2 + start;
      item = data[index2];
      parsed[i2] = {
        r: iScale.parse(resolveObjectKey(item, key), index2)
      };
    }
    return parsed;
  }
  var EPSILON = Number.EPSILON || 1e-14;
  var getPoint = (points, i2) => i2 < points.length && !points[i2].skip && points[i2];
  var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
  function splineCurve(firstPoint, middlePoint, afterPoint, t2) {
    const previous = firstPoint.skip ? middlePoint : firstPoint;
    const current = middlePoint;
    const next = afterPoint.skip ? middlePoint : afterPoint;
    const d01 = distanceBetweenPoints(current, previous);
    const d12 = distanceBetweenPoints(next, current);
    let s01 = d01 / (d01 + d12);
    let s12 = d12 / (d01 + d12);
    s01 = isNaN(s01) ? 0 : s01;
    s12 = isNaN(s12) ? 0 : s12;
    const fa = t2 * s01;
    const fb = t2 * s12;
    return {
      previous: {
        x: current.x - fa * (next.x - previous.x),
        y: current.y - fa * (next.y - previous.y)
      },
      next: {
        x: current.x + fb * (next.x - previous.x),
        y: current.y + fb * (next.y - previous.y)
      }
    };
  }
  function monotoneAdjust(points, deltaK, mK) {
    const pointsLen = points.length;
    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (let i2 = 0; i2 < pointsLen - 1; ++i2) {
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i2 + 1);
      if (!pointCurrent || !pointAfter) {
        continue;
      }
      if (almostEquals(deltaK[i2], 0, EPSILON)) {
        mK[i2] = mK[i2 + 1] = 0;
        continue;
      }
      alphaK = mK[i2] / deltaK[i2];
      betaK = mK[i2 + 1] / deltaK[i2];
      squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
      if (squaredMagnitude <= 9) {
        continue;
      }
      tauK = 3 / Math.sqrt(squaredMagnitude);
      mK[i2] = alphaK * tauK * deltaK[i2];
      mK[i2 + 1] = betaK * tauK * deltaK[i2];
    }
  }
  function monotoneCompute(points, mK, indexAxis = "x") {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    let delta, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (let i2 = 0; i2 < pointsLen; ++i2) {
      pointBefore = pointCurrent;
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i2 + 1);
      if (!pointCurrent) {
        continue;
      }
      const iPixel = pointCurrent[indexAxis];
      const vPixel = pointCurrent[valueAxis];
      if (pointBefore) {
        delta = (iPixel - pointBefore[indexAxis]) / 3;
        pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
        pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i2];
      }
      if (pointAfter) {
        delta = (pointAfter[indexAxis] - iPixel) / 3;
        pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
        pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i2];
      }
    }
  }
  function splineCurveMonotone(points, indexAxis = "x") {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    const deltaK = Array(pointsLen).fill(0);
    const mK = Array(pointsLen);
    let i2, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (i2 = 0; i2 < pointsLen; ++i2) {
      pointBefore = pointCurrent;
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i2 + 1);
      if (!pointCurrent) {
        continue;
      }
      if (pointAfter) {
        const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
        deltaK[i2] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
      }
      mK[i2] = !pointBefore ? deltaK[i2] : !pointAfter ? deltaK[i2 - 1] : sign(deltaK[i2 - 1]) !== sign(deltaK[i2]) ? 0 : (deltaK[i2 - 1] + deltaK[i2]) / 2;
    }
    monotoneAdjust(points, deltaK, mK);
    monotoneCompute(points, mK, indexAxis);
  }
  function capControlPoint(pt, min, max2) {
    return Math.max(Math.min(pt, max2), min);
  }
  function capBezierPoints(points, area) {
    let i2, ilen, point, inArea, inAreaPrev;
    let inAreaNext = _isPointInArea(points[0], area);
    for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
      inAreaPrev = inArea;
      inArea = inAreaNext;
      inAreaNext = i2 < ilen - 1 && _isPointInArea(points[i2 + 1], area);
      if (!inArea) {
        continue;
      }
      point = points[i2];
      if (inAreaPrev) {
        point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
        point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
      }
      if (inAreaNext) {
        point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
        point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
      }
    }
  }
  function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
    let i2, ilen, point, controlPoints;
    if (options.spanGaps) {
      points = points.filter((pt) => !pt.skip);
    }
    if (options.cubicInterpolationMode === "monotone") {
      splineCurveMonotone(points, indexAxis);
    } else {
      let prev = loop ? points[points.length - 1] : points[0];
      for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
        point = points[i2];
        controlPoints = splineCurve(prev, point, points[Math.min(i2 + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
        point.cp1x = controlPoints.previous.x;
        point.cp1y = controlPoints.previous.y;
        point.cp2x = controlPoints.next.x;
        point.cp2y = controlPoints.next.y;
        prev = point;
      }
    }
    if (options.capBezierPoints) {
      capBezierPoints(points, area);
    }
  }
  function _isDomSupported() {
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function _getParentNode(domNode) {
    let parent = domNode.parentNode;
    if (parent && parent.toString() === "[object ShadowRoot]") {
      parent = parent.host;
    }
    return parent;
  }
  function parseMaxStyle(styleValue, node, parentProperty) {
    let valueInPixels;
    if (typeof styleValue === "string") {
      valueInPixels = parseInt(styleValue, 10);
      if (styleValue.indexOf("%") !== -1) {
        valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
      }
    } else {
      valueInPixels = styleValue;
    }
    return valueInPixels;
  }
  var getComputedStyle2 = (element) => element.ownerDocument.defaultView.getComputedStyle(element, null);
  function getStyle(el, property) {
    return getComputedStyle2(el).getPropertyValue(property);
  }
  var positions = [
    "top",
    "right",
    "bottom",
    "left"
  ];
  function getPositionedStyle(styles, style, suffix) {
    const result = {};
    suffix = suffix ? "-" + suffix : "";
    for (let i2 = 0; i2 < 4; i2++) {
      const pos = positions[i2];
      result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
    }
    result.width = result.left + result.right;
    result.height = result.top + result.bottom;
    return result;
  }
  var useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
  function getCanvasPosition(e2, canvas) {
    const touches = e2.touches;
    const source = touches && touches.length ? touches[0] : e2;
    const { offsetX, offsetY } = source;
    let box = false;
    let x, y;
    if (useOffsetPos(offsetX, offsetY, e2.target)) {
      x = offsetX;
      y = offsetY;
    } else {
      const rect = canvas.getBoundingClientRect();
      x = source.clientX - rect.left;
      y = source.clientY - rect.top;
      box = true;
    }
    return {
      x,
      y,
      box
    };
  }
  function getRelativePosition(event, chart) {
    if ("native" in event) {
      return event;
    }
    const { canvas, currentDevicePixelRatio } = chart;
    const style = getComputedStyle2(canvas);
    const borderBox = style.boxSizing === "border-box";
    const paddings = getPositionedStyle(style, "padding");
    const borders = getPositionedStyle(style, "border", "width");
    const { x, y, box } = getCanvasPosition(event, canvas);
    const xOffset = paddings.left + (box && borders.left);
    const yOffset = paddings.top + (box && borders.top);
    let { width, height } = chart;
    if (borderBox) {
      width -= paddings.width + borders.width;
      height -= paddings.height + borders.height;
    }
    return {
      x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
      y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
    };
  }
  function getContainerSize(canvas, width, height) {
    let maxWidth, maxHeight;
    if (width === void 0 || height === void 0) {
      const container = canvas && _getParentNode(canvas);
      if (!container) {
        width = canvas.clientWidth;
        height = canvas.clientHeight;
      } else {
        const rect = container.getBoundingClientRect();
        const containerStyle = getComputedStyle2(container);
        const containerBorder = getPositionedStyle(containerStyle, "border", "width");
        const containerPadding = getPositionedStyle(containerStyle, "padding");
        width = rect.width - containerPadding.width - containerBorder.width;
        height = rect.height - containerPadding.height - containerBorder.height;
        maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
        maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
      }
    }
    return {
      width,
      height,
      maxWidth: maxWidth || INFINITY,
      maxHeight: maxHeight || INFINITY
    };
  }
  var round1 = (v) => Math.round(v * 10) / 10;
  function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
    const style = getComputedStyle2(canvas);
    const margins = getPositionedStyle(style, "margin");
    const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
    const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
    let { width, height } = containerSize;
    if (style.boxSizing === "content-box") {
      const borders = getPositionedStyle(style, "border", "width");
      const paddings = getPositionedStyle(style, "padding");
      width -= paddings.width + borders.width;
      height -= paddings.height + borders.height;
    }
    width = Math.max(0, width - margins.width);
    height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
    if (width && !height) {
      height = round1(width / 2);
    }
    const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
    if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
      height = containerSize.height;
      width = round1(Math.floor(height * aspectRatio));
    }
    return {
      width,
      height
    };
  }
  function retinaScale(chart, forceRatio, forceStyle) {
    const pixelRatio = forceRatio || 1;
    const deviceHeight = Math.floor(chart.height * pixelRatio);
    const deviceWidth = Math.floor(chart.width * pixelRatio);
    chart.height = Math.floor(chart.height);
    chart.width = Math.floor(chart.width);
    const canvas = chart.canvas;
    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
      canvas.style.height = `${chart.height}px`;
      canvas.style.width = `${chart.width}px`;
    }
    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
      chart.currentDevicePixelRatio = pixelRatio;
      canvas.height = deviceHeight;
      canvas.width = deviceWidth;
      chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
      return true;
    }
    return false;
  }
  var supportsEventListenerOptions = function() {
    let passiveSupported = false;
    try {
      const options = {
        get passive() {
          passiveSupported = true;
          return false;
        }
      };
      if (_isDomSupported()) {
        window.addEventListener("test", null, options);
        window.removeEventListener("test", null, options);
      }
    } catch (e2) {
    }
    return passiveSupported;
  }();
  function readUsedSize(element, property) {
    const value = getStyle(element, property);
    const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
    return matches ? +matches[1] : void 0;
  }
  function _pointInLine(p1, p2, t2, mode) {
    return {
      x: p1.x + t2 * (p2.x - p1.x),
      y: p1.y + t2 * (p2.y - p1.y)
    };
  }
  function _steppedInterpolation(p1, p2, t2, mode) {
    return {
      x: p1.x + t2 * (p2.x - p1.x),
      y: mode === "middle" ? t2 < 0.5 ? p1.y : p2.y : mode === "after" ? t2 < 1 ? p1.y : p2.y : t2 > 0 ? p2.y : p1.y
    };
  }
  function _bezierInterpolation(p1, p2, t2, mode) {
    const cp1 = {
      x: p1.cp2x,
      y: p1.cp2y
    };
    const cp2 = {
      x: p2.cp1x,
      y: p2.cp1y
    };
    const a2 = _pointInLine(p1, cp1, t2);
    const b = _pointInLine(cp1, cp2, t2);
    const c2 = _pointInLine(cp2, p2, t2);
    const d2 = _pointInLine(a2, b, t2);
    const e2 = _pointInLine(b, c2, t2);
    return _pointInLine(d2, e2, t2);
  }
  var getRightToLeftAdapter = function(rectX, width) {
    return {
      x(x) {
        return rectX + rectX + width - x;
      },
      setWidth(w) {
        width = w;
      },
      textAlign(align) {
        if (align === "center") {
          return align;
        }
        return align === "right" ? "left" : "right";
      },
      xPlus(x, value) {
        return x - value;
      },
      leftForLtr(x, itemWidth) {
        return x - itemWidth;
      }
    };
  };
  var getLeftToRightAdapter = function() {
    return {
      x(x) {
        return x;
      },
      setWidth(w) {
      },
      textAlign(align) {
        return align;
      },
      xPlus(x, value) {
        return x + value;
      },
      leftForLtr(x, _itemWidth) {
        return x;
      }
    };
  };
  function getRtlAdapter(rtl, rectX, width) {
    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
  }
  function overrideTextDirection(ctx, direction) {
    let style, original;
    if (direction === "ltr" || direction === "rtl") {
      style = ctx.canvas.style;
      original = [
        style.getPropertyValue("direction"),
        style.getPropertyPriority("direction")
      ];
      style.setProperty("direction", direction, "important");
      ctx.prevTextDirection = original;
    }
  }
  function restoreTextDirection(ctx, original) {
    if (original !== void 0) {
      delete ctx.prevTextDirection;
      ctx.canvas.style.setProperty("direction", original[0], original[1]);
    }
  }
  function propertyFn(property) {
    if (property === "angle") {
      return {
        between: _angleBetween,
        compare: _angleDiff,
        normalize: _normalizeAngle
      };
    }
    return {
      between: _isBetween,
      compare: (a2, b) => a2 - b,
      normalize: (x) => x
    };
  }
  function normalizeSegment({ start, end, count, loop, style }) {
    return {
      start: start % count,
      end: end % count,
      loop: loop && (end - start + 1) % count === 0,
      style
    };
  }
  function getSegment(segment, points, bounds) {
    const { property, start: startBound, end: endBound } = bounds;
    const { between, normalize } = propertyFn(property);
    const count = points.length;
    let { start, end, loop } = segment;
    let i2, ilen;
    if (loop) {
      start += count;
      end += count;
      for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
        if (!between(normalize(points[start % count][property]), startBound, endBound)) {
          break;
        }
        start--;
        end--;
      }
      start %= count;
      end %= count;
    }
    if (end < start) {
      end += count;
    }
    return {
      start,
      end,
      loop,
      style: segment.style
    };
  }
  function _boundSegment(segment, points, bounds) {
    if (!bounds) {
      return [
        segment
      ];
    }
    const { property, start: startBound, end: endBound } = bounds;
    const count = points.length;
    const { compare, between, normalize } = propertyFn(property);
    const { start, end, loop, style } = getSegment(segment, points, bounds);
    const result = [];
    let inside = false;
    let subStart = null;
    let value, point, prevValue;
    const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
    const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
    const shouldStart = () => inside || startIsBefore();
    const shouldStop = () => !inside || endIsBefore();
    for (let i2 = start, prev = start; i2 <= end; ++i2) {
      point = points[i2 % count];
      if (point.skip) {
        continue;
      }
      value = normalize(point[property]);
      if (value === prevValue) {
        continue;
      }
      inside = between(value, startBound, endBound);
      if (subStart === null && shouldStart()) {
        subStart = compare(value, startBound) === 0 ? i2 : prev;
      }
      if (subStart !== null && shouldStop()) {
        result.push(normalizeSegment({
          start: subStart,
          end: i2,
          loop,
          count,
          style
        }));
        subStart = null;
      }
      prev = i2;
      prevValue = value;
    }
    if (subStart !== null) {
      result.push(normalizeSegment({
        start: subStart,
        end,
        loop,
        count,
        style
      }));
    }
    return result;
  }
  function _boundSegments(line, bounds) {
    const result = [];
    const segments = line.segments;
    for (let i2 = 0; i2 < segments.length; i2++) {
      const sub = _boundSegment(segments[i2], line.points, bounds);
      if (sub.length) {
        result.push(...sub);
      }
    }
    return result;
  }
  function findStartAndEnd(points, count, loop, spanGaps) {
    let start = 0;
    let end = count - 1;
    if (loop && !spanGaps) {
      while (start < count && !points[start].skip) {
        start++;
      }
    }
    while (start < count && points[start].skip) {
      start++;
    }
    start %= count;
    if (loop) {
      end += start;
    }
    while (end > start && points[end % count].skip) {
      end--;
    }
    end %= count;
    return {
      start,
      end
    };
  }
  function solidSegments(points, start, max2, loop) {
    const count = points.length;
    const result = [];
    let last = start;
    let prev = points[start];
    let end;
    for (end = start + 1; end <= max2; ++end) {
      const cur = points[end % count];
      if (cur.skip || cur.stop) {
        if (!prev.skip) {
          loop = false;
          result.push({
            start: start % count,
            end: (end - 1) % count,
            loop
          });
          start = last = cur.stop ? end : null;
        }
      } else {
        last = end;
        if (prev.skip) {
          start = end;
        }
      }
      prev = cur;
    }
    if (last !== null) {
      result.push({
        start: start % count,
        end: last % count,
        loop
      });
    }
    return result;
  }
  function _computeSegments(line, segmentOptions) {
    const points = line.points;
    const spanGaps = line.options.spanGaps;
    const count = points.length;
    if (!count) {
      return [];
    }
    const loop = !!line._loop;
    const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
    if (spanGaps === true) {
      return splitByStyles(line, [
        {
          start,
          end,
          loop
        }
      ], points, segmentOptions);
    }
    const max2 = end < start ? end + count : end;
    const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
    return splitByStyles(line, solidSegments(points, start, max2, completeLoop), points, segmentOptions);
  }
  function splitByStyles(line, segments, points, segmentOptions) {
    if (!segmentOptions || !segmentOptions.setContext || !points) {
      return segments;
    }
    return doSplitByStyles(line, segments, points, segmentOptions);
  }
  function doSplitByStyles(line, segments, points, segmentOptions) {
    const chartContext = line._chart.getContext();
    const baseStyle = readStyle(line.options);
    const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
    const count = points.length;
    const result = [];
    let prevStyle = baseStyle;
    let start = segments[0].start;
    let i2 = start;
    function addStyle(s2, e2, l2, st) {
      const dir = spanGaps ? -1 : 1;
      if (s2 === e2) {
        return;
      }
      s2 += count;
      while (points[s2 % count].skip) {
        s2 -= dir;
      }
      while (points[e2 % count].skip) {
        e2 += dir;
      }
      if (s2 % count !== e2 % count) {
        result.push({
          start: s2 % count,
          end: e2 % count,
          loop: l2,
          style: st
        });
        prevStyle = st;
        start = e2 % count;
      }
    }
    for (const segment of segments) {
      start = spanGaps ? start : segment.start;
      let prev = points[start % count];
      let style;
      for (i2 = start + 1; i2 <= segment.end; i2++) {
        const pt = points[i2 % count];
        style = readStyle(segmentOptions.setContext(createContext(chartContext, {
          type: "segment",
          p0: prev,
          p1: pt,
          p0DataIndex: (i2 - 1) % count,
          p1DataIndex: i2 % count,
          datasetIndex
        })));
        if (styleChanged(style, prevStyle)) {
          addStyle(start, i2 - 1, segment.loop, prevStyle);
        }
        prev = pt;
        prevStyle = style;
      }
      if (start < i2 - 1) {
        addStyle(start, i2 - 1, segment.loop, prevStyle);
      }
    }
    return result;
  }
  function readStyle(options) {
    return {
      backgroundColor: options.backgroundColor,
      borderCapStyle: options.borderCapStyle,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderJoinStyle: options.borderJoinStyle,
      borderWidth: options.borderWidth,
      borderColor: options.borderColor
    };
  }
  function styleChanged(style, prevStyle) {
    if (!prevStyle) {
      return false;
    }
    const cache = [];
    const replacer = function(key, value) {
      if (!isPatternOrGradient(value)) {
        return value;
      }
      if (!cache.includes(value)) {
        cache.push(value);
      }
      return cache.indexOf(value);
    };
    return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
  }

  // node_modules/chart.js/dist/chart.js
  var Animator = class {
    constructor() {
      this._request = null;
      this._charts = /* @__PURE__ */ new Map();
      this._running = false;
      this._lastDate = void 0;
    }
    _notify(chart, anims, date, type) {
      const callbacks = anims.listeners[type];
      const numSteps = anims.duration;
      callbacks.forEach((fn) => fn({
        chart,
        initial: anims.initial,
        numSteps,
        currentStep: Math.min(date - anims.start, numSteps)
      }));
    }
    _refresh() {
      if (this._request) {
        return;
      }
      this._running = true;
      this._request = requestAnimFrame.call(window, () => {
        this._update();
        this._request = null;
        if (this._running) {
          this._refresh();
        }
      });
    }
    _update(date = Date.now()) {
      let remaining = 0;
      this._charts.forEach((anims, chart) => {
        if (!anims.running || !anims.items.length) {
          return;
        }
        const items = anims.items;
        let i2 = items.length - 1;
        let draw2 = false;
        let item;
        for (; i2 >= 0; --i2) {
          item = items[i2];
          if (item._active) {
            if (item._total > anims.duration) {
              anims.duration = item._total;
            }
            item.tick(date);
            draw2 = true;
          } else {
            items[i2] = items[items.length - 1];
            items.pop();
          }
        }
        if (draw2) {
          chart.draw();
          this._notify(chart, anims, date, "progress");
        }
        if (!items.length) {
          anims.running = false;
          this._notify(chart, anims, date, "complete");
          anims.initial = false;
        }
        remaining += items.length;
      });
      this._lastDate = date;
      if (remaining === 0) {
        this._running = false;
      }
    }
    _getAnims(chart) {
      const charts = this._charts;
      let anims = charts.get(chart);
      if (!anims) {
        anims = {
          running: false,
          initial: true,
          items: [],
          listeners: {
            complete: [],
            progress: []
          }
        };
        charts.set(chart, anims);
      }
      return anims;
    }
    listen(chart, event, cb) {
      this._getAnims(chart).listeners[event].push(cb);
    }
    add(chart, items) {
      if (!items || !items.length) {
        return;
      }
      this._getAnims(chart).items.push(...items);
    }
    has(chart) {
      return this._getAnims(chart).items.length > 0;
    }
    start(chart) {
      const anims = this._charts.get(chart);
      if (!anims) {
        return;
      }
      anims.running = true;
      anims.start = Date.now();
      anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
      this._refresh();
    }
    running(chart) {
      if (!this._running) {
        return false;
      }
      const anims = this._charts.get(chart);
      if (!anims || !anims.running || !anims.items.length) {
        return false;
      }
      return true;
    }
    stop(chart) {
      const anims = this._charts.get(chart);
      if (!anims || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i2 = items.length - 1;
      for (; i2 >= 0; --i2) {
        items[i2].cancel();
      }
      anims.items = [];
      this._notify(chart, anims, Date.now(), "complete");
    }
    remove(chart) {
      return this._charts.delete(chart);
    }
  };
  var animator = /* @__PURE__ */ new Animator();
  var transparent = "transparent";
  var interpolators = {
    boolean(from2, to2, factor) {
      return factor > 0.5 ? to2 : from2;
    },
    color(from2, to2, factor) {
      const c0 = color(from2 || transparent);
      const c1 = c0.valid && color(to2 || transparent);
      return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
    },
    number(from2, to2, factor) {
      return from2 + (to2 - from2) * factor;
    }
  };
  var Animation = class {
    constructor(cfg, target, prop, to2) {
      const currentValue = target[prop];
      to2 = resolve([
        cfg.to,
        to2,
        currentValue,
        cfg.from
      ]);
      const from2 = resolve([
        cfg.from,
        currentValue,
        to2
      ]);
      this._active = true;
      this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
      this._easing = effects[cfg.easing] || effects.linear;
      this._start = Math.floor(Date.now() + (cfg.delay || 0));
      this._duration = this._total = Math.floor(cfg.duration);
      this._loop = !!cfg.loop;
      this._target = target;
      this._prop = prop;
      this._from = from2;
      this._to = to2;
      this._promises = void 0;
    }
    active() {
      return this._active;
    }
    update(cfg, to2, date) {
      if (this._active) {
        this._notify(false);
        const currentValue = this._target[this._prop];
        const elapsed = date - this._start;
        const remain = this._duration - elapsed;
        this._start = date;
        this._duration = Math.floor(Math.max(remain, cfg.duration));
        this._total += elapsed;
        this._loop = !!cfg.loop;
        this._to = resolve([
          cfg.to,
          to2,
          currentValue,
          cfg.from
        ]);
        this._from = resolve([
          cfg.from,
          currentValue,
          to2
        ]);
      }
    }
    cancel() {
      if (this._active) {
        this.tick(Date.now());
        this._active = false;
        this._notify(false);
      }
    }
    tick(date) {
      const elapsed = date - this._start;
      const duration = this._duration;
      const prop = this._prop;
      const from2 = this._from;
      const loop = this._loop;
      const to2 = this._to;
      let factor;
      this._active = from2 !== to2 && (loop || elapsed < duration);
      if (!this._active) {
        this._target[prop] = to2;
        this._notify(true);
        return;
      }
      if (elapsed < 0) {
        this._target[prop] = from2;
        return;
      }
      factor = elapsed / duration % 2;
      factor = loop && factor > 1 ? 2 - factor : factor;
      factor = this._easing(Math.min(1, Math.max(0, factor)));
      this._target[prop] = this._fn(from2, to2, factor);
    }
    wait() {
      const promises = this._promises || (this._promises = []);
      return new Promise((res, rej) => {
        promises.push({
          res,
          rej
        });
      });
    }
    _notify(resolved) {
      const method = resolved ? "res" : "rej";
      const promises = this._promises || [];
      for (let i2 = 0; i2 < promises.length; i2++) {
        promises[i2][method]();
      }
    }
  };
  var Animations = class {
    constructor(chart, config) {
      this._chart = chart;
      this._properties = /* @__PURE__ */ new Map();
      this.configure(config);
    }
    configure(config) {
      if (!isObject2(config)) {
        return;
      }
      const animationOptions = Object.keys(defaults.animation);
      const animatedProps = this._properties;
      Object.getOwnPropertyNames(config).forEach((key) => {
        const cfg = config[key];
        if (!isObject2(cfg)) {
          return;
        }
        const resolved = {};
        for (const option of animationOptions) {
          resolved[option] = cfg[option];
        }
        (isArray(cfg.properties) && cfg.properties || [
          key
        ]).forEach((prop) => {
          if (prop === key || !animatedProps.has(prop)) {
            animatedProps.set(prop, resolved);
          }
        });
      });
    }
    _animateOptions(target, values) {
      const newOptions = values.options;
      const options = resolveTargetOptions(target, newOptions);
      if (!options) {
        return [];
      }
      const animations = this._createAnimations(options, newOptions);
      if (newOptions.$shared) {
        awaitAll(target.options.$animations, newOptions).then(() => {
          target.options = newOptions;
        }, () => {
        });
      }
      return animations;
    }
    _createAnimations(target, values) {
      const animatedProps = this._properties;
      const animations = [];
      const running = target.$animations || (target.$animations = {});
      const props = Object.keys(values);
      const date = Date.now();
      let i2;
      for (i2 = props.length - 1; i2 >= 0; --i2) {
        const prop = props[i2];
        if (prop.charAt(0) === "$") {
          continue;
        }
        if (prop === "options") {
          animations.push(...this._animateOptions(target, values));
          continue;
        }
        const value = values[prop];
        let animation = running[prop];
        const cfg = animatedProps.get(prop);
        if (animation) {
          if (cfg && animation.active()) {
            animation.update(cfg, value, date);
            continue;
          } else {
            animation.cancel();
          }
        }
        if (!cfg || !cfg.duration) {
          target[prop] = value;
          continue;
        }
        running[prop] = animation = new Animation(cfg, target, prop, value);
        animations.push(animation);
      }
      return animations;
    }
    update(target, values) {
      if (this._properties.size === 0) {
        Object.assign(target, values);
        return;
      }
      const animations = this._createAnimations(target, values);
      if (animations.length) {
        animator.add(this._chart, animations);
        return true;
      }
    }
  };
  function awaitAll(animations, properties) {
    const running = [];
    const keys = Object.keys(properties);
    for (let i2 = 0; i2 < keys.length; i2++) {
      const anim = animations[keys[i2]];
      if (anim && anim.active()) {
        running.push(anim.wait());
      }
    }
    return Promise.all(running);
  }
  function resolveTargetOptions(target, newOptions) {
    if (!newOptions) {
      return;
    }
    let options = target.options;
    if (!options) {
      target.options = newOptions;
      return;
    }
    if (options.$shared) {
      target.options = options = Object.assign({}, options, {
        $shared: false,
        $animations: {}
      });
    }
    return options;
  }
  function scaleClip(scale, allowedOverflow) {
    const opts = scale && scale.options || {};
    const reverse = opts.reverse;
    const min = opts.min === void 0 ? allowedOverflow : 0;
    const max2 = opts.max === void 0 ? allowedOverflow : 0;
    return {
      start: reverse ? max2 : min,
      end: reverse ? min : max2
    };
  }
  function defaultClip(xScale, yScale, allowedOverflow) {
    if (allowedOverflow === false) {
      return false;
    }
    const x = scaleClip(xScale, allowedOverflow);
    const y = scaleClip(yScale, allowedOverflow);
    return {
      top: y.end,
      right: x.end,
      bottom: y.start,
      left: x.start
    };
  }
  function toClip(value) {
    let t2, r2, b, l2;
    if (isObject2(value)) {
      t2 = value.top;
      r2 = value.right;
      b = value.bottom;
      l2 = value.left;
    } else {
      t2 = r2 = b = l2 = value;
    }
    return {
      top: t2,
      right: r2,
      bottom: b,
      left: l2,
      disabled: value === false
    };
  }
  function getSortedDatasetIndices(chart, filterVisible) {
    const keys = [];
    const metasets = chart._getSortedDatasetMetas(filterVisible);
    let i2, ilen;
    for (i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
      keys.push(metasets[i2].index);
    }
    return keys;
  }
  function applyStack(stack, value, dsIndex, options = {}) {
    const keys = stack.keys;
    const singleMode = options.mode === "single";
    let i2, ilen, datasetIndex, otherValue;
    if (value === null) {
      return;
    }
    let found = false;
    for (i2 = 0, ilen = keys.length; i2 < ilen; ++i2) {
      datasetIndex = +keys[i2];
      if (datasetIndex === dsIndex) {
        found = true;
        if (options.all) {
          continue;
        }
        break;
      }
      otherValue = stack.values[datasetIndex];
      if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
        value += otherValue;
      }
    }
    if (!found && !options.all) {
      return 0;
    }
    return value;
  }
  function convertObjectDataToArray(data, meta) {
    const { iScale, vScale } = meta;
    const iAxisKey = iScale.axis === "x" ? "x" : "y";
    const vAxisKey = vScale.axis === "x" ? "x" : "y";
    const keys = Object.keys(data);
    const adata = new Array(keys.length);
    let i2, ilen, key;
    for (i2 = 0, ilen = keys.length; i2 < ilen; ++i2) {
      key = keys[i2];
      adata[i2] = {
        [iAxisKey]: key,
        [vAxisKey]: data[key]
      };
    }
    return adata;
  }
  function isStacked(scale, meta) {
    const stacked = scale && scale.options.stacked;
    return stacked || stacked === void 0 && meta.stack !== void 0;
  }
  function getStackKey(indexScale, valueScale, meta) {
    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
  }
  function getUserBounds(scale) {
    const { min, max: max2, minDefined, maxDefined } = scale.getUserBounds();
    return {
      min: minDefined ? min : Number.NEGATIVE_INFINITY,
      max: maxDefined ? max2 : Number.POSITIVE_INFINITY
    };
  }
  function getOrCreateStack(stacks, stackKey, indexValue) {
    const subStack = stacks[stackKey] || (stacks[stackKey] = {});
    return subStack[indexValue] || (subStack[indexValue] = {});
  }
  function getLastIndexInStack(stack, vScale, positive, type) {
    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
      const value = stack[meta.index];
      if (positive && value > 0 || !positive && value < 0) {
        return meta.index;
      }
    }
    return null;
  }
  function updateStacks(controller, parsed) {
    const { chart, _cachedMeta: meta } = controller;
    const stacks = chart._stacks || (chart._stacks = {});
    const { iScale, vScale, index: datasetIndex } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const key = getStackKey(iScale, vScale, meta);
    const ilen = parsed.length;
    let stack;
    for (let i2 = 0; i2 < ilen; ++i2) {
      const item = parsed[i2];
      const { [iAxis]: index2, [vAxis]: value } = item;
      const itemStacks = item._stacks || (item._stacks = {});
      stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
      stack[datasetIndex] = value;
      stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
      stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
      const visualValues = stack._visualValues || (stack._visualValues = {});
      visualValues[datasetIndex] = value;
    }
  }
  function getFirstScaleId(chart, axis) {
    const scales2 = chart.scales;
    return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
  }
  function createDatasetContext(parent, index2) {
    return createContext(parent, {
      active: false,
      dataset: void 0,
      datasetIndex: index2,
      index: index2,
      mode: "default",
      type: "dataset"
    });
  }
  function createDataContext(parent, index2, element) {
    return createContext(parent, {
      active: false,
      dataIndex: index2,
      parsed: void 0,
      raw: void 0,
      element,
      index: index2,
      mode: "default",
      type: "data"
    });
  }
  function clearStacks(meta, items) {
    const datasetIndex = meta.controller.index;
    const axis = meta.vScale && meta.vScale.axis;
    if (!axis) {
      return;
    }
    items = items || meta._parsed;
    for (const parsed of items) {
      const stacks = parsed._stacks;
      if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
        return;
      }
      delete stacks[axis][datasetIndex];
      if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {
        delete stacks[axis]._visualValues[datasetIndex];
      }
    }
  }
  var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
  var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
  var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
    keys: getSortedDatasetIndices(chart, true),
    values: null
  };
  var DatasetController = class {
    constructor(chart, datasetIndex) {
      this.chart = chart;
      this._ctx = chart.ctx;
      this.index = datasetIndex;
      this._cachedDataOpts = {};
      this._cachedMeta = this.getMeta();
      this._type = this._cachedMeta.type;
      this.options = void 0;
      this._parsing = false;
      this._data = void 0;
      this._objectData = void 0;
      this._sharedOptions = void 0;
      this._drawStart = void 0;
      this._drawCount = void 0;
      this.enableOptionSharing = false;
      this.supportsDecimation = false;
      this.$context = void 0;
      this._syncList = [];
      this.datasetElementType = new.target.datasetElementType;
      this.dataElementType = new.target.dataElementType;
      this.initialize();
    }
    initialize() {
      const meta = this._cachedMeta;
      this.configure();
      this.linkScales();
      meta._stacked = isStacked(meta.vScale, meta);
      this.addElements();
      if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
        console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
      }
    }
    updateIndex(datasetIndex) {
      if (this.index !== datasetIndex) {
        clearStacks(this._cachedMeta);
      }
      this.index = datasetIndex;
    }
    linkScales() {
      const chart = this.chart;
      const meta = this._cachedMeta;
      const dataset = this.getDataset();
      const chooseId = (axis, x, y, r2) => axis === "x" ? x : axis === "r" ? r2 : y;
      const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
      const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
      const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
      const indexAxis = meta.indexAxis;
      const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
      const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
      meta.xScale = this.getScaleForId(xid);
      meta.yScale = this.getScaleForId(yid);
      meta.rScale = this.getScaleForId(rid);
      meta.iScale = this.getScaleForId(iid);
      meta.vScale = this.getScaleForId(vid);
    }
    getDataset() {
      return this.chart.data.datasets[this.index];
    }
    getMeta() {
      return this.chart.getDatasetMeta(this.index);
    }
    getScaleForId(scaleID) {
      return this.chart.scales[scaleID];
    }
    _getOtherScale(scale) {
      const meta = this._cachedMeta;
      return scale === meta.iScale ? meta.vScale : meta.iScale;
    }
    reset() {
      this._update("reset");
    }
    _destroy() {
      const meta = this._cachedMeta;
      if (this._data) {
        unlistenArrayEvents(this._data, this);
      }
      if (meta._stacked) {
        clearStacks(meta);
      }
    }
    _dataCheck() {
      const dataset = this.getDataset();
      const data = dataset.data || (dataset.data = []);
      const _data = this._data;
      if (isObject2(data)) {
        const meta = this._cachedMeta;
        this._data = convertObjectDataToArray(data, meta);
      } else if (_data !== data) {
        if (_data) {
          unlistenArrayEvents(_data, this);
          const meta = this._cachedMeta;
          clearStacks(meta);
          meta._parsed = [];
        }
        if (data && Object.isExtensible(data)) {
          listenArrayEvents(data, this);
        }
        this._syncList = [];
        this._data = data;
      }
    }
    addElements() {
      const meta = this._cachedMeta;
      this._dataCheck();
      if (this.datasetElementType) {
        meta.dataset = new this.datasetElementType();
      }
    }
    buildOrUpdateElements(resetNewElements) {
      const meta = this._cachedMeta;
      const dataset = this.getDataset();
      let stackChanged = false;
      this._dataCheck();
      const oldStacked = meta._stacked;
      meta._stacked = isStacked(meta.vScale, meta);
      if (meta.stack !== dataset.stack) {
        stackChanged = true;
        clearStacks(meta);
        meta.stack = dataset.stack;
      }
      this._resyncElements(resetNewElements);
      if (stackChanged || oldStacked !== meta._stacked) {
        updateStacks(this, meta._parsed);
        meta._stacked = isStacked(meta.vScale, meta);
      }
    }
    configure() {
      const config = this.chart.config;
      const scopeKeys = config.datasetScopeKeys(this._type);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
      this.options = config.createResolver(scopes, this.getContext());
      this._parsing = this.options.parsing;
      this._cachedDataOpts = {};
    }
    parse(start, count) {
      const { _cachedMeta: meta, _data: data } = this;
      const { iScale, _stacked } = meta;
      const iAxis = iScale.axis;
      let sorted = start === 0 && count === data.length ? true : meta._sorted;
      let prev = start > 0 && meta._parsed[start - 1];
      let i2, cur, parsed;
      if (this._parsing === false) {
        meta._parsed = data;
        meta._sorted = true;
        parsed = data;
      } else {
        if (isArray(data[start])) {
          parsed = this.parseArrayData(meta, data, start, count);
        } else if (isObject2(data[start])) {
          parsed = this.parseObjectData(meta, data, start, count);
        } else {
          parsed = this.parsePrimitiveData(meta, data, start, count);
        }
        const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
        for (i2 = 0; i2 < count; ++i2) {
          meta._parsed[i2 + start] = cur = parsed[i2];
          if (sorted) {
            if (isNotInOrderComparedToPrev()) {
              sorted = false;
            }
            prev = cur;
          }
        }
        meta._sorted = sorted;
      }
      if (_stacked) {
        updateStacks(this, parsed);
      }
    }
    parsePrimitiveData(meta, data, start, count) {
      const { iScale, vScale } = meta;
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const labels = iScale.getLabels();
      const singleScale = iScale === vScale;
      const parsed = new Array(count);
      let i2, ilen, index2;
      for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
        index2 = i2 + start;
        parsed[i2] = {
          [iAxis]: singleScale || iScale.parse(labels[index2], index2),
          [vAxis]: vScale.parse(data[index2], index2)
        };
      }
      return parsed;
    }
    parseArrayData(meta, data, start, count) {
      const { xScale, yScale } = meta;
      const parsed = new Array(count);
      let i2, ilen, index2, item;
      for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
        index2 = i2 + start;
        item = data[index2];
        parsed[i2] = {
          x: xScale.parse(item[0], index2),
          y: yScale.parse(item[1], index2)
        };
      }
      return parsed;
    }
    parseObjectData(meta, data, start, count) {
      const { xScale, yScale } = meta;
      const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
      const parsed = new Array(count);
      let i2, ilen, index2, item;
      for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
        index2 = i2 + start;
        item = data[index2];
        parsed[i2] = {
          x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
          y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
        };
      }
      return parsed;
    }
    getParsed(index2) {
      return this._cachedMeta._parsed[index2];
    }
    getDataElement(index2) {
      return this._cachedMeta.data[index2];
    }
    applyStack(scale, parsed, mode) {
      const chart = this.chart;
      const meta = this._cachedMeta;
      const value = parsed[scale.axis];
      const stack = {
        keys: getSortedDatasetIndices(chart, true),
        values: parsed._stacks[scale.axis]._visualValues
      };
      return applyStack(stack, value, meta.index, {
        mode
      });
    }
    updateRangeFromParsed(range2, scale, parsed, stack) {
      const parsedValue = parsed[scale.axis];
      let value = parsedValue === null ? NaN : parsedValue;
      const values = stack && parsed._stacks[scale.axis];
      if (stack && values) {
        stack.values = values;
        value = applyStack(stack, parsedValue, this._cachedMeta.index);
      }
      range2.min = Math.min(range2.min, value);
      range2.max = Math.max(range2.max, value);
    }
    getMinMax(scale, canStack) {
      const meta = this._cachedMeta;
      const _parsed = meta._parsed;
      const sorted = meta._sorted && scale === meta.iScale;
      const ilen = _parsed.length;
      const otherScale = this._getOtherScale(scale);
      const stack = createStack(canStack, meta, this.chart);
      const range2 = {
        min: Number.POSITIVE_INFINITY,
        max: Number.NEGATIVE_INFINITY
      };
      const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
      let i2, parsed;
      function _skip() {
        parsed = _parsed[i2];
        const otherValue = parsed[otherScale.axis];
        return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
      }
      for (i2 = 0; i2 < ilen; ++i2) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range2, scale, parsed, stack);
        if (sorted) {
          break;
        }
      }
      if (sorted) {
        for (i2 = ilen - 1; i2 >= 0; --i2) {
          if (_skip()) {
            continue;
          }
          this.updateRangeFromParsed(range2, scale, parsed, stack);
          break;
        }
      }
      return range2;
    }
    getAllParsedValues(scale) {
      const parsed = this._cachedMeta._parsed;
      const values = [];
      let i2, ilen, value;
      for (i2 = 0, ilen = parsed.length; i2 < ilen; ++i2) {
        value = parsed[i2][scale.axis];
        if (isNumberFinite(value)) {
          values.push(value);
        }
      }
      return values;
    }
    getMaxOverflow() {
      return false;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const iScale = meta.iScale;
      const vScale = meta.vScale;
      const parsed = this.getParsed(index2);
      return {
        label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
        value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
      };
    }
    _update(mode) {
      const meta = this._cachedMeta;
      this.update(mode || "default");
      meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
    }
    update(mode) {
    }
    draw() {
      const ctx = this._ctx;
      const chart = this.chart;
      const meta = this._cachedMeta;
      const elements2 = meta.data || [];
      const area = chart.chartArea;
      const active = [];
      const start = this._drawStart || 0;
      const count = this._drawCount || elements2.length - start;
      const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
      let i2;
      if (meta.dataset) {
        meta.dataset.draw(ctx, area, start, count);
      }
      for (i2 = start; i2 < start + count; ++i2) {
        const element = elements2[i2];
        if (element.hidden) {
          continue;
        }
        if (element.active && drawActiveElementsOnTop) {
          active.push(element);
        } else {
          element.draw(ctx, area);
        }
      }
      for (i2 = 0; i2 < active.length; ++i2) {
        active[i2].draw(ctx, area);
      }
    }
    getStyle(index2, active) {
      const mode = active ? "active" : "default";
      return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
    }
    getContext(index2, active, mode) {
      const dataset = this.getDataset();
      let context;
      if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
        const element = this._cachedMeta.data[index2];
        context = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));
        context.parsed = this.getParsed(index2);
        context.raw = dataset.data[index2];
        context.index = context.dataIndex = index2;
      } else {
        context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
        context.dataset = dataset;
        context.index = context.datasetIndex = this.index;
      }
      context.active = !!active;
      context.mode = mode;
      return context;
    }
    resolveDatasetElementOptions(mode) {
      return this._resolveElementOptions(this.datasetElementType.id, mode);
    }
    resolveDataElementOptions(index2, mode) {
      return this._resolveElementOptions(this.dataElementType.id, mode, index2);
    }
    _resolveElementOptions(elementType, mode = "default", index2) {
      const active = mode === "active";
      const cache = this._cachedDataOpts;
      const cacheKey = elementType + "-" + mode;
      const cached = cache[cacheKey];
      const sharing = this.enableOptionSharing && defined(index2);
      if (cached) {
        return cloneIfNotShared(cached, sharing);
      }
      const config = this.chart.config;
      const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
      const prefixes = active ? [
        `${elementType}Hover`,
        "hover",
        elementType,
        ""
      ] : [
        elementType,
        ""
      ];
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      const names2 = Object.keys(defaults.elements[elementType]);
      const context = () => this.getContext(index2, active, mode);
      const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
      if (values.$shared) {
        values.$shared = sharing;
        cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
      }
      return values;
    }
    _resolveAnimations(index2, transition, active) {
      const chart = this.chart;
      const cache = this._cachedDataOpts;
      const cacheKey = `animation-${transition}`;
      const cached = cache[cacheKey];
      if (cached) {
        return cached;
      }
      let options;
      if (chart.options.animation !== false) {
        const config = this.chart.config;
        const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
        options = config.createResolver(scopes, this.getContext(index2, active, transition));
      }
      const animations = new Animations(chart, options && options.animations);
      if (options && options._cacheable) {
        cache[cacheKey] = Object.freeze(animations);
      }
      return animations;
    }
    getSharedOptions(options) {
      if (!options.$shared) {
        return;
      }
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
    }
    includeOptions(mode, sharedOptions) {
      return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
    }
    _getSharedOptions(start, mode) {
      const firstOpts = this.resolveDataElementOptions(start, mode);
      const previouslySharedOptions = this._sharedOptions;
      const sharedOptions = this.getSharedOptions(firstOpts);
      const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
      this.updateSharedOptions(sharedOptions, mode, firstOpts);
      return {
        sharedOptions,
        includeOptions
      };
    }
    updateElement(element, index2, properties, mode) {
      if (isDirectUpdateMode(mode)) {
        Object.assign(element, properties);
      } else {
        this._resolveAnimations(index2, mode).update(element, properties);
      }
    }
    updateSharedOptions(sharedOptions, mode, newOptions) {
      if (sharedOptions && !isDirectUpdateMode(mode)) {
        this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
      }
    }
    _setStyle(element, index2, mode, active) {
      element.active = active;
      const options = this.getStyle(index2, active);
      this._resolveAnimations(index2, mode, active).update(element, {
        options: !active && this.getSharedOptions(options) || options
      });
    }
    removeHoverStyle(element, datasetIndex, index2) {
      this._setStyle(element, index2, "active", false);
    }
    setHoverStyle(element, datasetIndex, index2) {
      this._setStyle(element, index2, "active", true);
    }
    _removeDatasetHoverStyle() {
      const element = this._cachedMeta.dataset;
      if (element) {
        this._setStyle(element, void 0, "active", false);
      }
    }
    _setDatasetHoverStyle() {
      const element = this._cachedMeta.dataset;
      if (element) {
        this._setStyle(element, void 0, "active", true);
      }
    }
    _resyncElements(resetNewElements) {
      const data = this._data;
      const elements2 = this._cachedMeta.data;
      for (const [method, arg1, arg2] of this._syncList) {
        this[method](arg1, arg2);
      }
      this._syncList = [];
      const numMeta = elements2.length;
      const numData = data.length;
      const count = Math.min(numData, numMeta);
      if (count) {
        this.parse(0, count);
      }
      if (numData > numMeta) {
        this._insertElements(numMeta, numData - numMeta, resetNewElements);
      } else if (numData < numMeta) {
        this._removeElements(numData, numMeta - numData);
      }
    }
    _insertElements(start, count, resetNewElements = true) {
      const meta = this._cachedMeta;
      const data = meta.data;
      const end = start + count;
      let i2;
      const move = (arr) => {
        arr.length += count;
        for (i2 = arr.length - 1; i2 >= end; i2--) {
          arr[i2] = arr[i2 - count];
        }
      };
      move(data);
      for (i2 = start; i2 < end; ++i2) {
        data[i2] = new this.dataElementType();
      }
      if (this._parsing) {
        move(meta._parsed);
      }
      this.parse(start, count);
      if (resetNewElements) {
        this.updateElements(data, start, count, "reset");
      }
    }
    updateElements(element, start, count, mode) {
    }
    _removeElements(start, count) {
      const meta = this._cachedMeta;
      if (this._parsing) {
        const removed = meta._parsed.splice(start, count);
        if (meta._stacked) {
          clearStacks(meta, removed);
        }
      }
      meta.data.splice(start, count);
    }
    _sync(args) {
      if (this._parsing) {
        this._syncList.push(args);
      } else {
        const [method, arg1, arg2] = args;
        this[method](arg1, arg2);
      }
      this.chart._dataChanges.push([
        this.index,
        ...args
      ]);
    }
    _onDataPush() {
      const count = arguments.length;
      this._sync([
        "_insertElements",
        this.getDataset().data.length - count,
        count
      ]);
    }
    _onDataPop() {
      this._sync([
        "_removeElements",
        this._cachedMeta.data.length - 1,
        1
      ]);
    }
    _onDataShift() {
      this._sync([
        "_removeElements",
        0,
        1
      ]);
    }
    _onDataSplice(start, count) {
      if (count) {
        this._sync([
          "_removeElements",
          start,
          count
        ]);
      }
      const newCount = arguments.length - 2;
      if (newCount) {
        this._sync([
          "_insertElements",
          start,
          newCount
        ]);
      }
    }
    _onDataUnshift() {
      this._sync([
        "_insertElements",
        0,
        arguments.length
      ]);
    }
  };
  __publicField(DatasetController, "defaults", {});
  __publicField(DatasetController, "datasetElementType", null);
  __publicField(DatasetController, "dataElementType", null);
  function getAllScaleValues(scale, type) {
    if (!scale._cache.$bar) {
      const visibleMetas = scale.getMatchingVisibleMetas(type);
      let values = [];
      for (let i2 = 0, ilen = visibleMetas.length; i2 < ilen; i2++) {
        values = values.concat(visibleMetas[i2].controller.getAllParsedValues(scale));
      }
      scale._cache.$bar = _arrayUnique(values.sort((a2, b) => a2 - b));
    }
    return scale._cache.$bar;
  }
  function computeMinSampleSize(meta) {
    const scale = meta.iScale;
    const values = getAllScaleValues(scale, meta.type);
    let min = scale._length;
    let i2, ilen, curr, prev;
    const updateMinAndPrev = () => {
      if (curr === 32767 || curr === -32768) {
        return;
      }
      if (defined(prev)) {
        min = Math.min(min, Math.abs(curr - prev) || min);
      }
      prev = curr;
    };
    for (i2 = 0, ilen = values.length; i2 < ilen; ++i2) {
      curr = scale.getPixelForValue(values[i2]);
      updateMinAndPrev();
    }
    prev = void 0;
    for (i2 = 0, ilen = scale.ticks.length; i2 < ilen; ++i2) {
      curr = scale.getPixelForTick(i2);
      updateMinAndPrev();
    }
    return min;
  }
  function computeFitCategoryTraits(index2, ruler, options, stackCount) {
    const thickness = options.barThickness;
    let size, ratio;
    if (isNullOrUndef(thickness)) {
      size = ruler.min * options.categoryPercentage;
      ratio = options.barPercentage;
    } else {
      size = thickness * stackCount;
      ratio = 1;
    }
    return {
      chunk: size / stackCount,
      ratio,
      start: ruler.pixels[index2] - size / 2
    };
  }
  function computeFlexCategoryTraits(index2, ruler, options, stackCount) {
    const pixels = ruler.pixels;
    const curr = pixels[index2];
    let prev = index2 > 0 ? pixels[index2 - 1] : null;
    let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
    const percent = options.categoryPercentage;
    if (prev === null) {
      prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
    }
    if (next === null) {
      next = curr + curr - prev;
    }
    const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
    const size = Math.abs(next - prev) / 2 * percent;
    return {
      chunk: size / stackCount,
      ratio: options.barPercentage,
      start
    };
  }
  function parseFloatBar(entry, item, vScale, i2) {
    const startValue = vScale.parse(entry[0], i2);
    const endValue = vScale.parse(entry[1], i2);
    const min = Math.min(startValue, endValue);
    const max2 = Math.max(startValue, endValue);
    let barStart = min;
    let barEnd = max2;
    if (Math.abs(min) > Math.abs(max2)) {
      barStart = max2;
      barEnd = min;
    }
    item[vScale.axis] = barEnd;
    item._custom = {
      barStart,
      barEnd,
      start: startValue,
      end: endValue,
      min,
      max: max2
    };
  }
  function parseValue(entry, item, vScale, i2) {
    if (isArray(entry)) {
      parseFloatBar(entry, item, vScale, i2);
    } else {
      item[vScale.axis] = vScale.parse(entry, i2);
    }
    return item;
  }
  function parseArrayOrPrimitive(meta, data, start, count) {
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = [];
    let i2, ilen, item, entry;
    for (i2 = start, ilen = start + count; i2 < ilen; ++i2) {
      entry = data[i2];
      item = {};
      item[iScale.axis] = singleScale || iScale.parse(labels[i2], i2);
      parsed.push(parseValue(entry, item, vScale, i2));
    }
    return parsed;
  }
  function isFloatBar(custom) {
    return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
  }
  function barSign(size, vScale, actualBase) {
    if (size !== 0) {
      return sign(size);
    }
    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
  }
  function borderProps(properties) {
    let reverse, start, end, top2, bottom2;
    if (properties.horizontal) {
      reverse = properties.base > properties.x;
      start = "left";
      end = "right";
    } else {
      reverse = properties.base < properties.y;
      start = "bottom";
      end = "top";
    }
    if (reverse) {
      top2 = "end";
      bottom2 = "start";
    } else {
      top2 = "start";
      bottom2 = "end";
    }
    return {
      start,
      end,
      reverse,
      top: top2,
      bottom: bottom2
    };
  }
  function setBorderSkipped(properties, options, stack, index2) {
    let edge = options.borderSkipped;
    const res = {};
    if (!edge) {
      properties.borderSkipped = res;
      return;
    }
    if (edge === true) {
      properties.borderSkipped = {
        top: true,
        right: true,
        bottom: true,
        left: true
      };
      return;
    }
    const { start, end, reverse, top: top2, bottom: bottom2 } = borderProps(properties);
    if (edge === "middle" && stack) {
      properties.enableBorderRadius = true;
      if ((stack._top || 0) === index2) {
        edge = top2;
      } else if ((stack._bottom || 0) === index2) {
        edge = bottom2;
      } else {
        res[parseEdge(bottom2, start, end, reverse)] = true;
        edge = top2;
      }
    }
    res[parseEdge(edge, start, end, reverse)] = true;
    properties.borderSkipped = res;
  }
  function parseEdge(edge, a2, b, reverse) {
    if (reverse) {
      edge = swap(edge, a2, b);
      edge = startEnd(edge, b, a2);
    } else {
      edge = startEnd(edge, a2, b);
    }
    return edge;
  }
  function swap(orig, v1, v2) {
    return orig === v1 ? v2 : orig === v2 ? v1 : orig;
  }
  function startEnd(v, start, end) {
    return v === "start" ? start : v === "end" ? end : v;
  }
  function setInflateAmount(properties, { inflateAmount }, ratio) {
    properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
  }
  var BarController = class extends DatasetController {
    parsePrimitiveData(meta, data, start, count) {
      return parseArrayOrPrimitive(meta, data, start, count);
    }
    parseArrayData(meta, data, start, count) {
      return parseArrayOrPrimitive(meta, data, start, count);
    }
    parseObjectData(meta, data, start, count) {
      const { iScale, vScale } = meta;
      const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
      const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
      const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
      const parsed = [];
      let i2, ilen, item, obj;
      for (i2 = start, ilen = start + count; i2 < ilen; ++i2) {
        obj = data[i2];
        item = {};
        item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i2);
        parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i2));
      }
      return parsed;
    }
    updateRangeFromParsed(range2, scale, parsed, stack) {
      super.updateRangeFromParsed(range2, scale, parsed, stack);
      const custom = parsed._custom;
      if (custom && scale === this._cachedMeta.vScale) {
        range2.min = Math.min(range2.min, custom.min);
        range2.max = Math.max(range2.max, custom.max);
      }
    }
    getMaxOverflow() {
      return 0;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const { iScale, vScale } = meta;
      const parsed = this.getParsed(index2);
      const custom = parsed._custom;
      const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
      return {
        label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
        value
      };
    }
    initialize() {
      this.enableOptionSharing = true;
      super.initialize();
      const meta = this._cachedMeta;
      meta.stack = this.getDataset().stack;
    }
    update(mode) {
      const meta = this._cachedMeta;
      this.updateElements(meta.data, 0, meta.data.length, mode);
    }
    updateElements(bars, start, count, mode) {
      const reset = mode === "reset";
      const { index: index2, _cachedMeta: { vScale } } = this;
      const base = vScale.getBasePixel();
      const horizontal = vScale.isHorizontal();
      const ruler = this._getRuler();
      const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
      for (let i2 = start; i2 < start + count; i2++) {
        const parsed = this.getParsed(i2);
        const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
          base,
          head: base
        } : this._calculateBarValuePixels(i2);
        const ipixels = this._calculateBarIndexPixels(i2, ruler);
        const stack = (parsed._stacks || {})[vScale.axis];
        const properties = {
          horizontal,
          base: vpixels.base,
          enableBorderRadius: !stack || isFloatBar(parsed._custom) || index2 === stack._top || index2 === stack._bottom,
          x: horizontal ? vpixels.head : ipixels.center,
          y: horizontal ? ipixels.center : vpixels.head,
          height: horizontal ? ipixels.size : Math.abs(vpixels.size),
          width: horizontal ? Math.abs(vpixels.size) : ipixels.size
        };
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i2, bars[i2].active ? "active" : mode);
        }
        const options = properties.options || bars[i2].options;
        setBorderSkipped(properties, options, stack, index2);
        setInflateAmount(properties, options, ruler.ratio);
        this.updateElement(bars[i2], i2, properties, mode);
      }
    }
    _getStacks(last, dataIndex) {
      const { iScale } = this._cachedMeta;
      const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
      const stacked = iScale.options.stacked;
      const stacks = [];
      const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);
      const iScaleValue = currentParsed && currentParsed[iScale.axis];
      const skipNull = (meta) => {
        const parsed = meta._parsed.find((item) => item[iScale.axis] === iScaleValue);
        const val = parsed && parsed[meta.vScale.axis];
        if (isNullOrUndef(val) || isNaN(val)) {
          return true;
        }
      };
      for (const meta of metasets) {
        if (dataIndex !== void 0 && skipNull(meta)) {
          continue;
        }
        if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
          stacks.push(meta.stack);
        }
        if (meta.index === last) {
          break;
        }
      }
      if (!stacks.length) {
        stacks.push(void 0);
      }
      return stacks;
    }
    _getStackCount(index2) {
      return this._getStacks(void 0, index2).length;
    }
    _getStackIndex(datasetIndex, name, dataIndex) {
      const stacks = this._getStacks(datasetIndex, dataIndex);
      const index2 = name !== void 0 ? stacks.indexOf(name) : -1;
      return index2 === -1 ? stacks.length - 1 : index2;
    }
    _getRuler() {
      const opts = this.options;
      const meta = this._cachedMeta;
      const iScale = meta.iScale;
      const pixels = [];
      let i2, ilen;
      for (i2 = 0, ilen = meta.data.length; i2 < ilen; ++i2) {
        pixels.push(iScale.getPixelForValue(this.getParsed(i2)[iScale.axis], i2));
      }
      const barThickness = opts.barThickness;
      const min = barThickness || computeMinSampleSize(meta);
      return {
        min,
        pixels,
        start: iScale._startPixel,
        end: iScale._endPixel,
        stackCount: this._getStackCount(),
        scale: iScale,
        grouped: opts.grouped,
        ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
      };
    }
    _calculateBarValuePixels(index2) {
      const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;
      const actualBase = baseValue || 0;
      const parsed = this.getParsed(index2);
      const custom = parsed._custom;
      const floating = isFloatBar(custom);
      let value = parsed[vScale.axis];
      let start = 0;
      let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
      let head, size;
      if (length !== value) {
        start = length - value;
        length = value;
      }
      if (floating) {
        value = custom.barStart;
        length = custom.barEnd - custom.barStart;
        if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
          start = 0;
        }
        start += value;
      }
      const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
      let base = vScale.getPixelForValue(startValue);
      if (this.chart.getDataVisibility(index2)) {
        head = vScale.getPixelForValue(start + length);
      } else {
        head = base;
      }
      size = head - base;
      if (Math.abs(size) < minBarLength) {
        size = barSign(size, vScale, actualBase) * minBarLength;
        if (value === actualBase) {
          base -= size / 2;
        }
        const startPixel = vScale.getPixelForDecimal(0);
        const endPixel = vScale.getPixelForDecimal(1);
        const min = Math.min(startPixel, endPixel);
        const max2 = Math.max(startPixel, endPixel);
        base = Math.max(Math.min(base, max2), min);
        head = base + size;
        if (_stacked && !floating) {
          parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
        }
      }
      if (base === vScale.getPixelForValue(actualBase)) {
        const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
        base += halfGrid;
        size -= halfGrid;
      }
      return {
        size,
        base,
        head,
        center: head + size / 2
      };
    }
    _calculateBarIndexPixels(index2, ruler) {
      const scale = ruler.scale;
      const options = this.options;
      const skipNull = options.skipNull;
      const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
      let center, size;
      if (ruler.grouped) {
        const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;
        const range2 = options.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options, stackCount) : computeFitCategoryTraits(index2, ruler, options, stackCount);
        const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0);
        center = range2.start + range2.chunk * stackIndex + range2.chunk / 2;
        size = Math.min(maxBarThickness, range2.chunk * range2.ratio);
      } else {
        center = scale.getPixelForValue(this.getParsed(index2)[scale.axis], index2);
        size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
      }
      return {
        base: center - size / 2,
        head: center + size / 2,
        center,
        size
      };
    }
    draw() {
      const meta = this._cachedMeta;
      const vScale = meta.vScale;
      const rects = meta.data;
      const ilen = rects.length;
      let i2 = 0;
      for (; i2 < ilen; ++i2) {
        if (this.getParsed(i2)[vScale.axis] !== null && !rects[i2].hidden) {
          rects[i2].draw(this._ctx);
        }
      }
    }
  };
  __publicField(BarController, "id", "bar");
  __publicField(BarController, "defaults", {
    datasetElementType: false,
    dataElementType: "bar",
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    grouped: true,
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "base",
          "width",
          "height"
        ]
      }
    }
  });
  __publicField(BarController, "overrides", {
    scales: {
      _index_: {
        type: "category",
        offset: true,
        grid: {
          offset: true
        }
      },
      _value_: {
        type: "linear",
        beginAtZero: true
      }
    }
  });
  var BubbleController = class extends DatasetController {
    initialize() {
      this.enableOptionSharing = true;
      super.initialize();
    }
    parsePrimitiveData(meta, data, start, count) {
      const parsed = super.parsePrimitiveData(meta, data, start, count);
      for (let i2 = 0; i2 < parsed.length; i2++) {
        parsed[i2]._custom = this.resolveDataElementOptions(i2 + start).radius;
      }
      return parsed;
    }
    parseArrayData(meta, data, start, count) {
      const parsed = super.parseArrayData(meta, data, start, count);
      for (let i2 = 0; i2 < parsed.length; i2++) {
        const item = data[start + i2];
        parsed[i2]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i2 + start).radius);
      }
      return parsed;
    }
    parseObjectData(meta, data, start, count) {
      const parsed = super.parseObjectData(meta, data, start, count);
      for (let i2 = 0; i2 < parsed.length; i2++) {
        const item = data[start + i2];
        parsed[i2]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i2 + start).radius);
      }
      return parsed;
    }
    getMaxOverflow() {
      const data = this._cachedMeta.data;
      let max2 = 0;
      for (let i2 = data.length - 1; i2 >= 0; --i2) {
        max2 = Math.max(max2, data[i2].size(this.resolveDataElementOptions(i2)) / 2);
      }
      return max2 > 0 && max2;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const labels = this.chart.data.labels || [];
      const { xScale, yScale } = meta;
      const parsed = this.getParsed(index2);
      const x = xScale.getLabelForValue(parsed.x);
      const y = yScale.getLabelForValue(parsed.y);
      const r2 = parsed._custom;
      return {
        label: labels[index2] || "",
        value: "(" + x + ", " + y + (r2 ? ", " + r2 : "") + ")"
      };
    }
    update(mode) {
      const points = this._cachedMeta.data;
      this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale } = this._cachedMeta;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      for (let i2 = start; i2 < start + count; i2++) {
        const point = points[i2];
        const parsed = !reset && this.getParsed(i2);
        const properties = {};
        const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
        const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
        properties.skip = isNaN(iPixel) || isNaN(vPixel);
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i2, point.active ? "active" : mode);
          if (reset) {
            properties.options.radius = 0;
          }
        }
        this.updateElement(point, i2, properties, mode);
      }
    }
    resolveDataElementOptions(index2, mode) {
      const parsed = this.getParsed(index2);
      let values = super.resolveDataElementOptions(index2, mode);
      if (values.$shared) {
        values = Object.assign({}, values, {
          $shared: false
        });
      }
      const radius = values.radius;
      if (mode !== "active") {
        values.radius = 0;
      }
      values.radius += valueOrDefault(parsed && parsed._custom, radius);
      return values;
    }
  };
  __publicField(BubbleController, "id", "bubble");
  __publicField(BubbleController, "defaults", {
    datasetElementType: false,
    dataElementType: "point",
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "borderWidth",
          "radius"
        ]
      }
    }
  });
  __publicField(BubbleController, "overrides", {
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    }
  });
  function getRatioAndOffset(rotation, circumference, cutout) {
    let ratioX = 1;
    let ratioY = 1;
    let offsetX = 0;
    let offsetY = 0;
    if (circumference < TAU) {
      const startAngle = rotation;
      const endAngle = startAngle + circumference;
      const startX = Math.cos(startAngle);
      const startY = Math.sin(startAngle);
      const endX = Math.cos(endAngle);
      const endY = Math.sin(endAngle);
      const calcMax = (angle, a2, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a2, a2 * cutout, b, b * cutout);
      const calcMin = (angle, a2, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a2, a2 * cutout, b, b * cutout);
      const maxX = calcMax(0, startX, endX);
      const maxY = calcMax(HALF_PI, startY, endY);
      const minX = calcMin(PI, startX, endX);
      const minY = calcMin(PI + HALF_PI, startY, endY);
      ratioX = (maxX - minX) / 2;
      ratioY = (maxY - minY) / 2;
      offsetX = -(maxX + minX) / 2;
      offsetY = -(maxY + minY) / 2;
    }
    return {
      ratioX,
      ratioY,
      offsetX,
      offsetY
    };
  }
  var DoughnutController = class extends DatasetController {
    constructor(chart, datasetIndex) {
      super(chart, datasetIndex);
      this.enableOptionSharing = true;
      this.innerRadius = void 0;
      this.outerRadius = void 0;
      this.offsetX = void 0;
      this.offsetY = void 0;
    }
    linkScales() {
    }
    parse(start, count) {
      const data = this.getDataset().data;
      const meta = this._cachedMeta;
      if (this._parsing === false) {
        meta._parsed = data;
      } else {
        let getter = (i3) => +data[i3];
        if (isObject2(data[start])) {
          const { key = "value" } = this._parsing;
          getter = (i3) => +resolveObjectKey(data[i3], key);
        }
        let i2, ilen;
        for (i2 = start, ilen = start + count; i2 < ilen; ++i2) {
          meta._parsed[i2] = getter(i2);
        }
      }
    }
    _getRotation() {
      return toRadians(this.options.rotation - 90);
    }
    _getCircumference() {
      return toRadians(this.options.circumference);
    }
    _getRotationExtents() {
      let min = TAU;
      let max2 = -TAU;
      for (let i2 = 0; i2 < this.chart.data.datasets.length; ++i2) {
        if (this.chart.isDatasetVisible(i2) && this.chart.getDatasetMeta(i2).type === this._type) {
          const controller = this.chart.getDatasetMeta(i2).controller;
          const rotation = controller._getRotation();
          const circumference = controller._getCircumference();
          min = Math.min(min, rotation);
          max2 = Math.max(max2, rotation + circumference);
        }
      }
      return {
        rotation: min,
        circumference: max2 - min
      };
    }
    update(mode) {
      const chart = this.chart;
      const { chartArea } = chart;
      const meta = this._cachedMeta;
      const arcs = meta.data;
      const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
      const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
      const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
      const chartWeight = this._getRingWeight(this.index);
      const { circumference, rotation } = this._getRotationExtents();
      const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
      const maxWidth = (chartArea.width - spacing) / ratioX;
      const maxHeight = (chartArea.height - spacing) / ratioY;
      const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
      const outerRadius = toDimension(this.options.radius, maxRadius);
      const innerRadius = Math.max(outerRadius * cutout, 0);
      const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
      this.offsetX = offsetX * outerRadius;
      this.offsetY = offsetY * outerRadius;
      meta.total = this.calculateTotal();
      this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
      this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
      this.updateElements(arcs, 0, arcs.length, mode);
    }
    _circumference(i2, reset) {
      const opts = this.options;
      const meta = this._cachedMeta;
      const circumference = this._getCircumference();
      if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i2) || meta._parsed[i2] === null || meta.data[i2].hidden) {
        return 0;
      }
      return this.calculateCircumference(meta._parsed[i2] * circumference / TAU);
    }
    updateElements(arcs, start, count, mode) {
      const reset = mode === "reset";
      const chart = this.chart;
      const chartArea = chart.chartArea;
      const opts = chart.options;
      const animationOpts = opts.animation;
      const centerX = (chartArea.left + chartArea.right) / 2;
      const centerY = (chartArea.top + chartArea.bottom) / 2;
      const animateScale = reset && animationOpts.animateScale;
      const innerRadius = animateScale ? 0 : this.innerRadius;
      const outerRadius = animateScale ? 0 : this.outerRadius;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
      let startAngle = this._getRotation();
      let i2;
      for (i2 = 0; i2 < start; ++i2) {
        startAngle += this._circumference(i2, reset);
      }
      for (i2 = start; i2 < start + count; ++i2) {
        const circumference = this._circumference(i2, reset);
        const arc = arcs[i2];
        const properties = {
          x: centerX + this.offsetX,
          y: centerY + this.offsetY,
          startAngle,
          endAngle: startAngle + circumference,
          circumference,
          outerRadius,
          innerRadius
        };
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i2, arc.active ? "active" : mode);
        }
        startAngle += circumference;
        this.updateElement(arc, i2, properties, mode);
      }
    }
    calculateTotal() {
      const meta = this._cachedMeta;
      const metaData = meta.data;
      let total = 0;
      let i2;
      for (i2 = 0; i2 < metaData.length; i2++) {
        const value = meta._parsed[i2];
        if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i2) && !metaData[i2].hidden) {
          total += Math.abs(value);
        }
      }
      return total;
    }
    calculateCircumference(value) {
      const total = this._cachedMeta.total;
      if (total > 0 && !isNaN(value)) {
        return TAU * (Math.abs(value) / total);
      }
      return 0;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const chart = this.chart;
      const labels = chart.data.labels || [];
      const value = formatNumber(meta._parsed[index2], chart.options.locale);
      return {
        label: labels[index2] || "",
        value
      };
    }
    getMaxBorderWidth(arcs) {
      let max2 = 0;
      const chart = this.chart;
      let i2, ilen, meta, controller, options;
      if (!arcs) {
        for (i2 = 0, ilen = chart.data.datasets.length; i2 < ilen; ++i2) {
          if (chart.isDatasetVisible(i2)) {
            meta = chart.getDatasetMeta(i2);
            arcs = meta.data;
            controller = meta.controller;
            break;
          }
        }
      }
      if (!arcs) {
        return 0;
      }
      for (i2 = 0, ilen = arcs.length; i2 < ilen; ++i2) {
        options = controller.resolveDataElementOptions(i2);
        if (options.borderAlign !== "inner") {
          max2 = Math.max(max2, options.borderWidth || 0, options.hoverBorderWidth || 0);
        }
      }
      return max2;
    }
    getMaxOffset(arcs) {
      let max2 = 0;
      for (let i2 = 0, ilen = arcs.length; i2 < ilen; ++i2) {
        const options = this.resolveDataElementOptions(i2);
        max2 = Math.max(max2, options.offset || 0, options.hoverOffset || 0);
      }
      return max2;
    }
    _getRingWeightOffset(datasetIndex) {
      let ringWeightOffset = 0;
      for (let i2 = 0; i2 < datasetIndex; ++i2) {
        if (this.chart.isDatasetVisible(i2)) {
          ringWeightOffset += this._getRingWeight(i2);
        }
      }
      return ringWeightOffset;
    }
    _getRingWeight(datasetIndex) {
      return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
    }
    _getVisibleDatasetWeightTotal() {
      return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
    }
  };
  __publicField(DoughnutController, "id", "doughnut");
  __publicField(DoughnutController, "defaults", {
    datasetElementType: false,
    dataElementType: "arc",
    animation: {
      animateRotate: true,
      animateScale: false
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "circumference",
          "endAngle",
          "innerRadius",
          "outerRadius",
          "startAngle",
          "x",
          "y",
          "offset",
          "borderWidth",
          "spacing"
        ]
      }
    },
    cutout: "50%",
    rotation: 0,
    circumference: 360,
    radius: "100%",
    spacing: 0,
    indexAxis: "r"
  });
  __publicField(DoughnutController, "descriptors", {
    _scriptable: (name) => name !== "spacing",
    _indexable: (name) => name !== "spacing" && !name.startsWith("borderDash") && !name.startsWith("hoverBorderDash")
  });
  __publicField(DoughnutController, "overrides", {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(chart) {
            const data = chart.data;
            if (data.labels.length && data.datasets.length) {
              const { labels: { pointStyle, color: color2 } } = chart.legend.options;
              return data.labels.map((label, i2) => {
                const meta = chart.getDatasetMeta(0);
                const style = meta.controller.getStyle(i2);
                return {
                  text: label,
                  fillStyle: style.backgroundColor,
                  strokeStyle: style.borderColor,
                  fontColor: color2,
                  lineWidth: style.borderWidth,
                  pointStyle,
                  hidden: !chart.getDataVisibility(i2),
                  index: i2
                };
              });
            }
            return [];
          }
        },
        onClick(e2, legendItem, legend) {
          legend.chart.toggleDataVisibility(legendItem.index);
          legend.chart.update();
        }
      }
    }
  });
  var LineController = class extends DatasetController {
    initialize() {
      this.enableOptionSharing = true;
      this.supportsDecimation = true;
      super.initialize();
    }
    update(mode) {
      const meta = this._cachedMeta;
      const { dataset: line, data: points = [], _dataset } = meta;
      const animationsDisabled = this.chart._animationsDisabled;
      let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
      this._drawStart = start;
      this._drawCount = count;
      if (_scaleRangesChanged(meta)) {
        start = 0;
        count = points.length;
      }
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      options.segment = this.options.segment;
      this.updateElement(line, void 0, {
        animated: !animationsDisabled,
        options
      }, mode);
      this.updateElements(points, start, count, mode);
    }
    updateElements(points, start, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const { spanGaps, segment } = this.options;
      const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
      const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
      const end = start + count;
      const pointsCount = points.length;
      let prevParsed = start > 0 && this.getParsed(start - 1);
      for (let i2 = 0; i2 < pointsCount; ++i2) {
        const point = points[i2];
        const properties = directUpdate ? point : {};
        if (i2 < start || i2 >= end) {
          properties.skip = true;
          continue;
        }
        const parsed = this.getParsed(i2);
        const nullData = isNullOrUndef(parsed[vAxis]);
        const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i2);
        const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i2);
        properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
        properties.stop = i2 > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
        if (segment) {
          properties.parsed = parsed;
          properties.raw = _dataset.data[i2];
        }
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i2, point.active ? "active" : mode);
        }
        if (!directUpdate) {
          this.updateElement(point, i2, properties, mode);
        }
        prevParsed = parsed;
      }
    }
    getMaxOverflow() {
      const meta = this._cachedMeta;
      const dataset = meta.dataset;
      const border = dataset.options && dataset.options.borderWidth || 0;
      const data = meta.data || [];
      if (!data.length) {
        return border;
      }
      const firstPoint = data[0].size(this.resolveDataElementOptions(0));
      const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
      return Math.max(border, firstPoint, lastPoint) / 2;
    }
    draw() {
      const meta = this._cachedMeta;
      meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
      super.draw();
    }
  };
  __publicField(LineController, "id", "line");
  __publicField(LineController, "defaults", {
    datasetElementType: "line",
    dataElementType: "point",
    showLine: true,
    spanGaps: false
  });
  __publicField(LineController, "overrides", {
    scales: {
      _index_: {
        type: "category"
      },
      _value_: {
        type: "linear"
      }
    }
  });
  var PolarAreaController = class extends DatasetController {
    constructor(chart, datasetIndex) {
      super(chart, datasetIndex);
      this.innerRadius = void 0;
      this.outerRadius = void 0;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const chart = this.chart;
      const labels = chart.data.labels || [];
      const value = formatNumber(meta._parsed[index2].r, chart.options.locale);
      return {
        label: labels[index2] || "",
        value
      };
    }
    parseObjectData(meta, data, start, count) {
      return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
    }
    update(mode) {
      const arcs = this._cachedMeta.data;
      this._updateRadius();
      this.updateElements(arcs, 0, arcs.length, mode);
    }
    getMinMax() {
      const meta = this._cachedMeta;
      const range2 = {
        min: Number.POSITIVE_INFINITY,
        max: Number.NEGATIVE_INFINITY
      };
      meta.data.forEach((element, index2) => {
        const parsed = this.getParsed(index2).r;
        if (!isNaN(parsed) && this.chart.getDataVisibility(index2)) {
          if (parsed < range2.min) {
            range2.min = parsed;
          }
          if (parsed > range2.max) {
            range2.max = parsed;
          }
        }
      });
      return range2;
    }
    _updateRadius() {
      const chart = this.chart;
      const chartArea = chart.chartArea;
      const opts = chart.options;
      const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
      const outerRadius = Math.max(minSize / 2, 0);
      const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
      const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
      this.outerRadius = outerRadius - radiusLength * this.index;
      this.innerRadius = this.outerRadius - radiusLength;
    }
    updateElements(arcs, start, count, mode) {
      const reset = mode === "reset";
      const chart = this.chart;
      const opts = chart.options;
      const animationOpts = opts.animation;
      const scale = this._cachedMeta.rScale;
      const centerX = scale.xCenter;
      const centerY = scale.yCenter;
      const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
      let angle = datasetStartAngle;
      let i2;
      const defaultAngle = 360 / this.countVisibleElements();
      for (i2 = 0; i2 < start; ++i2) {
        angle += this._computeAngle(i2, mode, defaultAngle);
      }
      for (i2 = start; i2 < start + count; i2++) {
        const arc = arcs[i2];
        let startAngle = angle;
        let endAngle = angle + this._computeAngle(i2, mode, defaultAngle);
        let outerRadius = chart.getDataVisibility(i2) ? scale.getDistanceFromCenterForValue(this.getParsed(i2).r) : 0;
        angle = endAngle;
        if (reset) {
          if (animationOpts.animateScale) {
            outerRadius = 0;
          }
          if (animationOpts.animateRotate) {
            startAngle = endAngle = datasetStartAngle;
          }
        }
        const properties = {
          x: centerX,
          y: centerY,
          innerRadius: 0,
          outerRadius,
          startAngle,
          endAngle,
          options: this.resolveDataElementOptions(i2, arc.active ? "active" : mode)
        };
        this.updateElement(arc, i2, properties, mode);
      }
    }
    countVisibleElements() {
      const meta = this._cachedMeta;
      let count = 0;
      meta.data.forEach((element, index2) => {
        if (!isNaN(this.getParsed(index2).r) && this.chart.getDataVisibility(index2)) {
          count++;
        }
      });
      return count;
    }
    _computeAngle(index2, mode, defaultAngle) {
      return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
    }
  };
  __publicField(PolarAreaController, "id", "polarArea");
  __publicField(PolarAreaController, "defaults", {
    dataElementType: "arc",
    animation: {
      animateRotate: true,
      animateScale: true
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "startAngle",
          "endAngle",
          "innerRadius",
          "outerRadius"
        ]
      }
    },
    indexAxis: "r",
    startAngle: 0
  });
  __publicField(PolarAreaController, "overrides", {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(chart) {
            const data = chart.data;
            if (data.labels.length && data.datasets.length) {
              const { labels: { pointStyle, color: color2 } } = chart.legend.options;
              return data.labels.map((label, i2) => {
                const meta = chart.getDatasetMeta(0);
                const style = meta.controller.getStyle(i2);
                return {
                  text: label,
                  fillStyle: style.backgroundColor,
                  strokeStyle: style.borderColor,
                  fontColor: color2,
                  lineWidth: style.borderWidth,
                  pointStyle,
                  hidden: !chart.getDataVisibility(i2),
                  index: i2
                };
              });
            }
            return [];
          }
        },
        onClick(e2, legendItem, legend) {
          legend.chart.toggleDataVisibility(legendItem.index);
          legend.chart.update();
        }
      }
    },
    scales: {
      r: {
        type: "radialLinear",
        angleLines: {
          display: false
        },
        beginAtZero: true,
        grid: {
          circular: true
        },
        pointLabels: {
          display: false
        },
        startAngle: 0
      }
    }
  });
  var PieController = class extends DoughnutController {
  };
  __publicField(PieController, "id", "pie");
  __publicField(PieController, "defaults", {
    cutout: 0,
    rotation: 0,
    circumference: 360,
    radius: "100%"
  });
  var RadarController = class extends DatasetController {
    getLabelAndValue(index2) {
      const vScale = this._cachedMeta.vScale;
      const parsed = this.getParsed(index2);
      return {
        label: vScale.getLabels()[index2],
        value: "" + vScale.getLabelForValue(parsed[vScale.axis])
      };
    }
    parseObjectData(meta, data, start, count) {
      return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
    }
    update(mode) {
      const meta = this._cachedMeta;
      const line = meta.dataset;
      const points = meta.data || [];
      const labels = meta.iScale.getLabels();
      line.points = points;
      if (mode !== "resize") {
        const options = this.resolveDatasetElementOptions(mode);
        if (!this.options.showLine) {
          options.borderWidth = 0;
        }
        const properties = {
          _loop: true,
          _fullLoop: labels.length === points.length,
          options
        };
        this.updateElement(line, void 0, properties, mode);
      }
      this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start, count, mode) {
      const scale = this._cachedMeta.rScale;
      const reset = mode === "reset";
      for (let i2 = start; i2 < start + count; i2++) {
        const point = points[i2];
        const options = this.resolveDataElementOptions(i2, point.active ? "active" : mode);
        const pointPosition = scale.getPointPositionForValue(i2, this.getParsed(i2).r);
        const x = reset ? scale.xCenter : pointPosition.x;
        const y = reset ? scale.yCenter : pointPosition.y;
        const properties = {
          x,
          y,
          angle: pointPosition.angle,
          skip: isNaN(x) || isNaN(y),
          options
        };
        this.updateElement(point, i2, properties, mode);
      }
    }
  };
  __publicField(RadarController, "id", "radar");
  __publicField(RadarController, "defaults", {
    datasetElementType: "line",
    dataElementType: "point",
    indexAxis: "r",
    showLine: true,
    elements: {
      line: {
        fill: "start"
      }
    }
  });
  __publicField(RadarController, "overrides", {
    aspectRatio: 1,
    scales: {
      r: {
        type: "radialLinear"
      }
    }
  });
  var ScatterController = class extends DatasetController {
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const labels = this.chart.data.labels || [];
      const { xScale, yScale } = meta;
      const parsed = this.getParsed(index2);
      const x = xScale.getLabelForValue(parsed.x);
      const y = yScale.getLabelForValue(parsed.y);
      return {
        label: labels[index2] || "",
        value: "(" + x + ", " + y + ")"
      };
    }
    update(mode) {
      const meta = this._cachedMeta;
      const { data: points = [] } = meta;
      const animationsDisabled = this.chart._animationsDisabled;
      let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
      this._drawStart = start;
      this._drawCount = count;
      if (_scaleRangesChanged(meta)) {
        start = 0;
        count = points.length;
      }
      if (this.options.showLine) {
        if (!this.datasetElementType) {
          this.addElements();
        }
        const { dataset: line, _dataset } = meta;
        line._chart = this.chart;
        line._datasetIndex = this.index;
        line._decimated = !!_dataset._decimated;
        line.points = points;
        const options = this.resolveDatasetElementOptions(mode);
        options.segment = this.options.segment;
        this.updateElement(line, void 0, {
          animated: !animationsDisabled,
          options
        }, mode);
      } else if (this.datasetElementType) {
        delete meta.dataset;
        this.datasetElementType = false;
      }
      this.updateElements(points, start, count, mode);
    }
    addElements() {
      const { showLine } = this.options;
      if (!this.datasetElementType && showLine) {
        this.datasetElementType = this.chart.registry.getElement("line");
      }
      super.addElements();
    }
    updateElements(points, start, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
      const firstOpts = this.resolveDataElementOptions(start, mode);
      const sharedOptions = this.getSharedOptions(firstOpts);
      const includeOptions = this.includeOptions(mode, sharedOptions);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const { spanGaps, segment } = this.options;
      const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
      const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
      let prevParsed = start > 0 && this.getParsed(start - 1);
      for (let i2 = start; i2 < start + count; ++i2) {
        const point = points[i2];
        const parsed = this.getParsed(i2);
        const properties = directUpdate ? point : {};
        const nullData = isNullOrUndef(parsed[vAxis]);
        const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i2);
        const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i2);
        properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
        properties.stop = i2 > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
        if (segment) {
          properties.parsed = parsed;
          properties.raw = _dataset.data[i2];
        }
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i2, point.active ? "active" : mode);
        }
        if (!directUpdate) {
          this.updateElement(point, i2, properties, mode);
        }
        prevParsed = parsed;
      }
      this.updateSharedOptions(sharedOptions, mode, firstOpts);
    }
    getMaxOverflow() {
      const meta = this._cachedMeta;
      const data = meta.data || [];
      if (!this.options.showLine) {
        let max2 = 0;
        for (let i2 = data.length - 1; i2 >= 0; --i2) {
          max2 = Math.max(max2, data[i2].size(this.resolveDataElementOptions(i2)) / 2);
        }
        return max2 > 0 && max2;
      }
      const dataset = meta.dataset;
      const border = dataset.options && dataset.options.borderWidth || 0;
      if (!data.length) {
        return border;
      }
      const firstPoint = data[0].size(this.resolveDataElementOptions(0));
      const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
      return Math.max(border, firstPoint, lastPoint) / 2;
    }
  };
  __publicField(ScatterController, "id", "scatter");
  __publicField(ScatterController, "defaults", {
    datasetElementType: false,
    dataElementType: "point",
    showLine: false,
    fill: false
  });
  __publicField(ScatterController, "overrides", {
    interaction: {
      mode: "point"
    },
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    }
  });
  var controllers = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    BarController,
    BubbleController,
    DoughnutController,
    LineController,
    PieController,
    PolarAreaController,
    RadarController,
    ScatterController
  });
  function abstract() {
    throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
  }
  var DateAdapterBase = class {
    constructor(options) {
      __publicField(this, "options");
      this.options = options || {};
    }
    /**
    * Override default date adapter methods.
    * Accepts type parameter to define options type.
    * @example
    * Chart._adapters._date.override<{myAdapterOption: string}>({
    *   init() {
    *     console.log(this.options.myAdapterOption);
    *   }
    * })
    */
    static override(members) {
      Object.assign(DateAdapterBase.prototype, members);
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    init() {
    }
    formats() {
      return abstract();
    }
    parse() {
      return abstract();
    }
    format() {
      return abstract();
    }
    add() {
      return abstract();
    }
    diff() {
      return abstract();
    }
    startOf() {
      return abstract();
    }
    endOf() {
      return abstract();
    }
  };
  var adapters = {
    _date: DateAdapterBase
  };
  function binarySearch(metaset, axis, value, intersect) {
    const { controller, data, _sorted } = metaset;
    const iScale = controller._cachedMeta.iScale;
    if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
      const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
      if (!intersect) {
        return lookupMethod(data, axis, value);
      } else if (controller._sharedOptions) {
        const el = data[0];
        const range2 = typeof el.getRange === "function" && el.getRange(axis);
        if (range2) {
          const start = lookupMethod(data, axis, value - range2);
          const end = lookupMethod(data, axis, value + range2);
          return {
            lo: start.lo,
            hi: end.hi
          };
        }
      }
    }
    return {
      lo: 0,
      hi: data.length - 1
    };
  }
  function evaluateInteractionItems(chart, axis, position, handler, intersect) {
    const metasets = chart.getSortedVisibleDatasetMetas();
    const value = position[axis];
    for (let i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
      const { index: index2, data } = metasets[i2];
      const { lo, hi } = binarySearch(metasets[i2], axis, value, intersect);
      for (let j = lo; j <= hi; ++j) {
        const element = data[j];
        if (!element.skip) {
          handler(element, index2, j);
        }
      }
    }
  }
  function getDistanceMetricForAxis(axis) {
    const useX = axis.indexOf("x") !== -1;
    const useY = axis.indexOf("y") !== -1;
    return function(pt1, pt2) {
      const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
      const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
      return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    };
  }
  function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
    const items = [];
    if (!includeInvisible && !chart.isPointInArea(position)) {
      return items;
    }
    const evaluationFunc = function(element, datasetIndex, index2) {
      if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
        return;
      }
      if (element.inRange(position.x, position.y, useFinalPosition)) {
        items.push({
          element,
          datasetIndex,
          index: index2
        });
      }
    };
    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
    return items;
  }
  function getNearestRadialItems(chart, position, axis, useFinalPosition) {
    let items = [];
    function evaluationFunc(element, datasetIndex, index2) {
      const { startAngle, endAngle } = element.getProps([
        "startAngle",
        "endAngle"
      ], useFinalPosition);
      const { angle } = getAngleFromPoint(element, {
        x: position.x,
        y: position.y
      });
      if (_angleBetween(angle, startAngle, endAngle)) {
        items.push({
          element,
          datasetIndex,
          index: index2
        });
      }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
  }
  function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    let items = [];
    const distanceMetric = getDistanceMetricForAxis(axis);
    let minDistance = Number.POSITIVE_INFINITY;
    function evaluationFunc(element, datasetIndex, index2) {
      const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
      if (intersect && !inRange2) {
        return;
      }
      const center = element.getCenterPoint(useFinalPosition);
      const pointInArea = !!includeInvisible || chart.isPointInArea(center);
      if (!pointInArea && !inRange2) {
        return;
      }
      const distance = distanceMetric(position, center);
      if (distance < minDistance) {
        items = [
          {
            element,
            datasetIndex,
            index: index2
          }
        ];
        minDistance = distance;
      } else if (distance === minDistance) {
        items.push({
          element,
          datasetIndex,
          index: index2
        });
      }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
  }
  function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    if (!includeInvisible && !chart.isPointInArea(position)) {
      return [];
    }
    return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
  }
  function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
    const items = [];
    const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
    let intersectsItem = false;
    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index2) => {
      if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {
        items.push({
          element,
          datasetIndex,
          index: index2
        });
        intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
      }
    });
    if (intersect && !intersectsItem) {
      return [];
    }
    return items;
  }
  var Interaction = {
    evaluateInteractionItems,
    modes: {
      index(chart, e2, options, useFinalPosition) {
        const position = getRelativePosition(e2, chart);
        const axis = options.axis || "x";
        const includeInvisible = options.includeInvisible || false;
        const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
        const elements2 = [];
        if (!items.length) {
          return [];
        }
        chart.getSortedVisibleDatasetMetas().forEach((meta) => {
          const index2 = items[0].index;
          const element = meta.data[index2];
          if (element && !element.skip) {
            elements2.push({
              element,
              datasetIndex: meta.index,
              index: index2
            });
          }
        });
        return elements2;
      },
      dataset(chart, e2, options, useFinalPosition) {
        const position = getRelativePosition(e2, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
        if (items.length > 0) {
          const datasetIndex = items[0].datasetIndex;
          const data = chart.getDatasetMeta(datasetIndex).data;
          items = [];
          for (let i2 = 0; i2 < data.length; ++i2) {
            items.push({
              element: data[i2],
              datasetIndex,
              index: i2
            });
          }
        }
        return items;
      },
      point(chart, e2, options, useFinalPosition) {
        const position = getRelativePosition(e2, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
      },
      nearest(chart, e2, options, useFinalPosition) {
        const position = getRelativePosition(e2, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
      },
      x(chart, e2, options, useFinalPosition) {
        const position = getRelativePosition(e2, chart);
        return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
      },
      y(chart, e2, options, useFinalPosition) {
        const position = getRelativePosition(e2, chart);
        return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
      }
    }
  };
  var STATIC_POSITIONS = [
    "left",
    "top",
    "right",
    "bottom"
  ];
  function filterByPosition(array, position) {
    return array.filter((v) => v.pos === position);
  }
  function filterDynamicPositionByAxis(array, axis) {
    return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
  }
  function sortByWeight(array, reverse) {
    return array.sort((a2, b) => {
      const v0 = reverse ? b : a2;
      const v1 = reverse ? a2 : b;
      return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
    });
  }
  function wrapBoxes(boxes) {
    const layoutBoxes = [];
    let i2, ilen, box, pos, stack, stackWeight;
    for (i2 = 0, ilen = (boxes || []).length; i2 < ilen; ++i2) {
      box = boxes[i2];
      ({ position: pos, options: { stack, stackWeight = 1 } } = box);
      layoutBoxes.push({
        index: i2,
        box,
        pos,
        horizontal: box.isHorizontal(),
        weight: box.weight,
        stack: stack && pos + stack,
        stackWeight
      });
    }
    return layoutBoxes;
  }
  function buildStacks(layouts2) {
    const stacks = {};
    for (const wrap of layouts2) {
      const { stack, pos, stackWeight } = wrap;
      if (!stack || !STATIC_POSITIONS.includes(pos)) {
        continue;
      }
      const _stack = stacks[stack] || (stacks[stack] = {
        count: 0,
        placed: 0,
        weight: 0,
        size: 0
      });
      _stack.count++;
      _stack.weight += stackWeight;
    }
    return stacks;
  }
  function setLayoutDims(layouts2, params) {
    const stacks = buildStacks(layouts2);
    const { vBoxMaxWidth, hBoxMaxHeight } = params;
    let i2, ilen, layout;
    for (i2 = 0, ilen = layouts2.length; i2 < ilen; ++i2) {
      layout = layouts2[i2];
      const { fullSize } = layout.box;
      const stack = stacks[layout.stack];
      const factor = stack && layout.stackWeight / stack.weight;
      if (layout.horizontal) {
        layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
        layout.height = hBoxMaxHeight;
      } else {
        layout.width = vBoxMaxWidth;
        layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
      }
    }
    return stacks;
  }
  function buildLayoutBoxes(boxes) {
    const layoutBoxes = wrapBoxes(boxes);
    const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
    const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
    const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
    const top2 = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
    const bottom2 = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
    return {
      fullSize,
      leftAndTop: left.concat(top2),
      rightAndBottom: right.concat(centerVertical).concat(bottom2).concat(centerHorizontal),
      chartArea: filterByPosition(layoutBoxes, "chartArea"),
      vertical: left.concat(right).concat(centerVertical),
      horizontal: top2.concat(bottom2).concat(centerHorizontal)
    };
  }
  function getCombinedMax(maxPadding, chartArea, a2, b) {
    return Math.max(maxPadding[a2], chartArea[a2]) + Math.max(maxPadding[b], chartArea[b]);
  }
  function updateMaxPadding(maxPadding, boxPadding) {
    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
  }
  function updateDims(chartArea, params, layout, stacks) {
    const { pos, box } = layout;
    const maxPadding = chartArea.maxPadding;
    if (!isObject2(pos)) {
      if (layout.size) {
        chartArea[pos] -= layout.size;
      }
      const stack = stacks[layout.stack] || {
        size: 0,
        count: 1
      };
      stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
      layout.size = stack.size / stack.count;
      chartArea[pos] += layout.size;
    }
    if (box.getPadding) {
      updateMaxPadding(maxPadding, box.getPadding());
    }
    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
    const widthChanged = newWidth !== chartArea.w;
    const heightChanged = newHeight !== chartArea.h;
    chartArea.w = newWidth;
    chartArea.h = newHeight;
    return layout.horizontal ? {
      same: widthChanged,
      other: heightChanged
    } : {
      same: heightChanged,
      other: widthChanged
    };
  }
  function handleMaxPadding(chartArea) {
    const maxPadding = chartArea.maxPadding;
    function updatePos(pos) {
      const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
      chartArea[pos] += change;
      return change;
    }
    chartArea.y += updatePos("top");
    chartArea.x += updatePos("left");
    updatePos("right");
    updatePos("bottom");
  }
  function getMargins(horizontal, chartArea) {
    const maxPadding = chartArea.maxPadding;
    function marginForPositions(positions2) {
      const margin = {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      };
      positions2.forEach((pos) => {
        margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
      });
      return margin;
    }
    return horizontal ? marginForPositions([
      "left",
      "right"
    ]) : marginForPositions([
      "top",
      "bottom"
    ]);
  }
  function fitBoxes(boxes, chartArea, params, stacks) {
    const refitBoxes = [];
    let i2, ilen, layout, box, refit, changed;
    for (i2 = 0, ilen = boxes.length, refit = 0; i2 < ilen; ++i2) {
      layout = boxes[i2];
      box = layout.box;
      box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
      const { same, other } = updateDims(chartArea, params, layout, stacks);
      refit |= same && refitBoxes.length;
      changed = changed || other;
      if (!box.fullSize) {
        refitBoxes.push(layout);
      }
    }
    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
  }
  function setBoxDims(box, left, top2, width, height) {
    box.top = top2;
    box.left = left;
    box.right = left + width;
    box.bottom = top2 + height;
    box.width = width;
    box.height = height;
  }
  function placeBoxes(boxes, chartArea, params, stacks) {
    const userPadding = params.padding;
    let { x, y } = chartArea;
    for (const layout of boxes) {
      const box = layout.box;
      const stack = stacks[layout.stack] || {
        count: 1,
        placed: 0,
        weight: 1
      };
      const weight = layout.stackWeight / stack.weight || 1;
      if (layout.horizontal) {
        const width = chartArea.w * weight;
        const height = stack.size || box.height;
        if (defined(stack.start)) {
          y = stack.start;
        }
        if (box.fullSize) {
          setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
        } else {
          setBoxDims(box, chartArea.left + stack.placed, y, width, height);
        }
        stack.start = y;
        stack.placed += width;
        y = box.bottom;
      } else {
        const height = chartArea.h * weight;
        const width = stack.size || box.width;
        if (defined(stack.start)) {
          x = stack.start;
        }
        if (box.fullSize) {
          setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
        } else {
          setBoxDims(box, x, chartArea.top + stack.placed, width, height);
        }
        stack.start = x;
        stack.placed += height;
        x = box.right;
      }
    }
    chartArea.x = x;
    chartArea.y = y;
  }
  var layouts = {
    addBox(chart, item) {
      if (!chart.boxes) {
        chart.boxes = [];
      }
      item.fullSize = item.fullSize || false;
      item.position = item.position || "top";
      item.weight = item.weight || 0;
      item._layers = item._layers || function() {
        return [
          {
            z: 0,
            draw(chartArea) {
              item.draw(chartArea);
            }
          }
        ];
      };
      chart.boxes.push(item);
    },
    removeBox(chart, layoutItem) {
      const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
      if (index2 !== -1) {
        chart.boxes.splice(index2, 1);
      }
    },
    configure(chart, item, options) {
      item.fullSize = options.fullSize;
      item.position = options.position;
      item.weight = options.weight;
    },
    update(chart, width, height, minPadding) {
      if (!chart) {
        return;
      }
      const padding = toPadding(chart.options.layout.padding);
      const availableWidth = Math.max(width - padding.width, 0);
      const availableHeight = Math.max(height - padding.height, 0);
      const boxes = buildLayoutBoxes(chart.boxes);
      const verticalBoxes = boxes.vertical;
      const horizontalBoxes = boxes.horizontal;
      each(chart.boxes, (box) => {
        if (typeof box.beforeLayout === "function") {
          box.beforeLayout();
        }
      });
      const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
      const params = Object.freeze({
        outerWidth: width,
        outerHeight: height,
        padding,
        availableWidth,
        availableHeight,
        vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
        hBoxMaxHeight: availableHeight / 2
      });
      const maxPadding = Object.assign({}, padding);
      updateMaxPadding(maxPadding, toPadding(minPadding));
      const chartArea = Object.assign({
        maxPadding,
        w: availableWidth,
        h: availableHeight,
        x: padding.left,
        y: padding.top
      }, padding);
      const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
      fitBoxes(boxes.fullSize, chartArea, params, stacks);
      fitBoxes(verticalBoxes, chartArea, params, stacks);
      if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
        fitBoxes(verticalBoxes, chartArea, params, stacks);
      }
      handleMaxPadding(chartArea);
      placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
      chartArea.x += chartArea.w;
      chartArea.y += chartArea.h;
      placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
      chart.chartArea = {
        left: chartArea.left,
        top: chartArea.top,
        right: chartArea.left + chartArea.w,
        bottom: chartArea.top + chartArea.h,
        height: chartArea.h,
        width: chartArea.w
      };
      each(boxes.chartArea, (layout) => {
        const box = layout.box;
        Object.assign(box, chart.chartArea);
        box.update(chartArea.w, chartArea.h, {
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        });
      });
    }
  };
  var BasePlatform = class {
    acquireContext(canvas, aspectRatio) {
    }
    releaseContext(context) {
      return false;
    }
    addEventListener(chart, type, listener) {
    }
    removeEventListener(chart, type, listener) {
    }
    getDevicePixelRatio() {
      return 1;
    }
    getMaximumSize(element, width, height, aspectRatio) {
      width = Math.max(0, width || element.width);
      height = height || element.height;
      return {
        width,
        height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
      };
    }
    isAttached(canvas) {
      return true;
    }
    updateConfig(config) {
    }
  };
  var BasicPlatform = class extends BasePlatform {
    acquireContext(item) {
      return item && item.getContext && item.getContext("2d") || null;
    }
    updateConfig(config) {
      config.options.animation = false;
    }
  };
  var EXPANDO_KEY = "$chartjs";
  var EVENT_TYPES = {
    touchstart: "mousedown",
    touchmove: "mousemove",
    touchend: "mouseup",
    pointerenter: "mouseenter",
    pointerdown: "mousedown",
    pointermove: "mousemove",
    pointerup: "mouseup",
    pointerleave: "mouseout",
    pointerout: "mouseout"
  };
  var isNullOrEmpty = (value) => value === null || value === "";
  function initCanvas(canvas, aspectRatio) {
    const style = canvas.style;
    const renderHeight = canvas.getAttribute("height");
    const renderWidth = canvas.getAttribute("width");
    canvas[EXPANDO_KEY] = {
      initial: {
        height: renderHeight,
        width: renderWidth,
        style: {
          display: style.display,
          height: style.height,
          width: style.width
        }
      }
    };
    style.display = style.display || "block";
    style.boxSizing = style.boxSizing || "border-box";
    if (isNullOrEmpty(renderWidth)) {
      const displayWidth = readUsedSize(canvas, "width");
      if (displayWidth !== void 0) {
        canvas.width = displayWidth;
      }
    }
    if (isNullOrEmpty(renderHeight)) {
      if (canvas.style.height === "") {
        canvas.height = canvas.width / (aspectRatio || 2);
      } else {
        const displayHeight = readUsedSize(canvas, "height");
        if (displayHeight !== void 0) {
          canvas.height = displayHeight;
        }
      }
    }
    return canvas;
  }
  var eventListenerOptions = supportsEventListenerOptions ? {
    passive: true
  } : false;
  function addListener(node, type, listener) {
    if (node) {
      node.addEventListener(type, listener, eventListenerOptions);
    }
  }
  function removeListener(chart, type, listener) {
    if (chart && chart.canvas) {
      chart.canvas.removeEventListener(type, listener, eventListenerOptions);
    }
  }
  function fromNativeEvent(event, chart) {
    const type = EVENT_TYPES[event.type] || event.type;
    const { x, y } = getRelativePosition(event, chart);
    return {
      type,
      chart,
      native: event,
      x: x !== void 0 ? x : null,
      y: y !== void 0 ? y : null
    };
  }
  function nodeListContains(nodeList, canvas) {
    for (const node of nodeList) {
      if (node === canvas || node.contains(canvas)) {
        return true;
      }
    }
  }
  function createAttachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries) => {
      let trigger = false;
      for (const entry of entries) {
        trigger = trigger || nodeListContains(entry.addedNodes, canvas);
        trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
      }
      if (trigger) {
        listener();
      }
    });
    observer.observe(document, {
      childList: true,
      subtree: true
    });
    return observer;
  }
  function createDetachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries) => {
      let trigger = false;
      for (const entry of entries) {
        trigger = trigger || nodeListContains(entry.removedNodes, canvas);
        trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
      }
      if (trigger) {
        listener();
      }
    });
    observer.observe(document, {
      childList: true,
      subtree: true
    });
    return observer;
  }
  var drpListeningCharts = /* @__PURE__ */ new Map();
  var oldDevicePixelRatio = 0;
  function onWindowResize() {
    const dpr = window.devicePixelRatio;
    if (dpr === oldDevicePixelRatio) {
      return;
    }
    oldDevicePixelRatio = dpr;
    drpListeningCharts.forEach((resize, chart) => {
      if (chart.currentDevicePixelRatio !== dpr) {
        resize();
      }
    });
  }
  function listenDevicePixelRatioChanges(chart, resize) {
    if (!drpListeningCharts.size) {
      window.addEventListener("resize", onWindowResize);
    }
    drpListeningCharts.set(chart, resize);
  }
  function unlistenDevicePixelRatioChanges(chart) {
    drpListeningCharts.delete(chart);
    if (!drpListeningCharts.size) {
      window.removeEventListener("resize", onWindowResize);
    }
  }
  function createResizeObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const container = canvas && _getParentNode(canvas);
    if (!container) {
      return;
    }
    const resize = throttled((width, height) => {
      const w = container.clientWidth;
      listener(width, height);
      if (w < container.clientWidth) {
        listener();
      }
    }, window);
    const observer = new ResizeObserver((entries) => {
      const entry = entries[0];
      const width = entry.contentRect.width;
      const height = entry.contentRect.height;
      if (width === 0 && height === 0) {
        return;
      }
      resize(width, height);
    });
    observer.observe(container);
    listenDevicePixelRatioChanges(chart, resize);
    return observer;
  }
  function releaseObserver(chart, type, observer) {
    if (observer) {
      observer.disconnect();
    }
    if (type === "resize") {
      unlistenDevicePixelRatioChanges(chart);
    }
  }
  function createProxyAndListen(chart, type, listener) {
    const canvas = chart.canvas;
    const proxy = throttled((event) => {
      if (chart.ctx !== null) {
        listener(fromNativeEvent(event, chart));
      }
    }, chart);
    addListener(canvas, type, proxy);
    return proxy;
  }
  var DomPlatform = class extends BasePlatform {
    acquireContext(canvas, aspectRatio) {
      const context = canvas && canvas.getContext && canvas.getContext("2d");
      if (context && context.canvas === canvas) {
        initCanvas(canvas, aspectRatio);
        return context;
      }
      return null;
    }
    releaseContext(context) {
      const canvas = context.canvas;
      if (!canvas[EXPANDO_KEY]) {
        return false;
      }
      const initial = canvas[EXPANDO_KEY].initial;
      [
        "height",
        "width"
      ].forEach((prop) => {
        const value = initial[prop];
        if (isNullOrUndef(value)) {
          canvas.removeAttribute(prop);
        } else {
          canvas.setAttribute(prop, value);
        }
      });
      const style = initial.style || {};
      Object.keys(style).forEach((key) => {
        canvas.style[key] = style[key];
      });
      canvas.width = canvas.width;
      delete canvas[EXPANDO_KEY];
      return true;
    }
    addEventListener(chart, type, listener) {
      this.removeEventListener(chart, type);
      const proxies = chart.$proxies || (chart.$proxies = {});
      const handlers = {
        attach: createAttachObserver,
        detach: createDetachObserver,
        resize: createResizeObserver
      };
      const handler = handlers[type] || createProxyAndListen;
      proxies[type] = handler(chart, type, listener);
    }
    removeEventListener(chart, type) {
      const proxies = chart.$proxies || (chart.$proxies = {});
      const proxy = proxies[type];
      if (!proxy) {
        return;
      }
      const handlers = {
        attach: releaseObserver,
        detach: releaseObserver,
        resize: releaseObserver
      };
      const handler = handlers[type] || removeListener;
      handler(chart, type, proxy);
      proxies[type] = void 0;
    }
    getDevicePixelRatio() {
      return window.devicePixelRatio;
    }
    getMaximumSize(canvas, width, height, aspectRatio) {
      return getMaximumSize(canvas, width, height, aspectRatio);
    }
    isAttached(canvas) {
      const container = canvas && _getParentNode(canvas);
      return !!(container && container.isConnected);
    }
  };
  function _detectPlatform(canvas) {
    if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
      return BasicPlatform;
    }
    return DomPlatform;
  }
  var Element = class {
    constructor() {
      __publicField(this, "x");
      __publicField(this, "y");
      __publicField(this, "active", false);
      __publicField(this, "options");
      __publicField(this, "$animations");
    }
    tooltipPosition(useFinalPosition) {
      const { x, y } = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      return {
        x,
        y
      };
    }
    hasValue() {
      return isNumber(this.x) && isNumber(this.y);
    }
    getProps(props, final) {
      const anims = this.$animations;
      if (!final || !anims) {
        return this;
      }
      const ret = {};
      props.forEach((prop) => {
        ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
      });
      return ret;
    }
  };
  __publicField(Element, "defaults", {});
  __publicField(Element, "defaultRoutes");
  function autoSkip(scale, ticks) {
    const tickOpts = scale.options.ticks;
    const determinedMaxTicks = determineMaxTicks(scale);
    const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
    const numMajorIndices = majorIndices.length;
    const first = majorIndices[0];
    const last = majorIndices[numMajorIndices - 1];
    const newTicks = [];
    if (numMajorIndices > ticksLimit) {
      skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
      return newTicks;
    }
    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
    if (numMajorIndices > 0) {
      let i2, ilen;
      const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
      skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
      for (i2 = 0, ilen = numMajorIndices - 1; i2 < ilen; i2++) {
        skip(ticks, newTicks, spacing, majorIndices[i2], majorIndices[i2 + 1]);
      }
      skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
      return newTicks;
    }
    skip(ticks, newTicks, spacing);
    return newTicks;
  }
  function determineMaxTicks(scale) {
    const offset = scale.options.offset;
    const tickLength = scale._tickSize();
    const maxScale = scale._length / tickLength + (offset ? 0 : 1);
    const maxChart = scale._maxLength / tickLength;
    return Math.floor(Math.min(maxScale, maxChart));
  }
  function calculateSpacing(majorIndices, ticks, ticksLimit) {
    const evenMajorSpacing = getEvenSpacing(majorIndices);
    const spacing = ticks.length / ticksLimit;
    if (!evenMajorSpacing) {
      return Math.max(spacing, 1);
    }
    const factors = _factorize(evenMajorSpacing);
    for (let i2 = 0, ilen = factors.length - 1; i2 < ilen; i2++) {
      const factor = factors[i2];
      if (factor > spacing) {
        return factor;
      }
    }
    return Math.max(spacing, 1);
  }
  function getMajorIndices(ticks) {
    const result = [];
    let i2, ilen;
    for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
      if (ticks[i2].major) {
        result.push(i2);
      }
    }
    return result;
  }
  function skipMajors(ticks, newTicks, majorIndices, spacing) {
    let count = 0;
    let next = majorIndices[0];
    let i2;
    spacing = Math.ceil(spacing);
    for (i2 = 0; i2 < ticks.length; i2++) {
      if (i2 === next) {
        newTicks.push(ticks[i2]);
        count++;
        next = majorIndices[count * spacing];
      }
    }
  }
  function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
    const start = valueOrDefault(majorStart, 0);
    const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
    let count = 0;
    let length, i2, next;
    spacing = Math.ceil(spacing);
    if (majorEnd) {
      length = majorEnd - majorStart;
      spacing = length / Math.floor(length / spacing);
    }
    next = start;
    while (next < 0) {
      count++;
      next = Math.round(start + count * spacing);
    }
    for (i2 = Math.max(start, 0); i2 < end; i2++) {
      if (i2 === next) {
        newTicks.push(ticks[i2]);
        count++;
        next = Math.round(start + count * spacing);
      }
    }
  }
  function getEvenSpacing(arr) {
    const len = arr.length;
    let i2, diff;
    if (len < 2) {
      return false;
    }
    for (diff = arr[0], i2 = 1; i2 < len; ++i2) {
      if (arr[i2] - arr[i2 - 1] !== diff) {
        return false;
      }
    }
    return diff;
  }
  var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
  var offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
  var getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
  function sample(arr, numItems) {
    const result = [];
    const increment = arr.length / numItems;
    const len = arr.length;
    let i2 = 0;
    for (; i2 < len; i2 += increment) {
      result.push(arr[Math.floor(i2)]);
    }
    return result;
  }
  function getPixelForGridLine(scale, index2, offsetGridLines) {
    const length = scale.ticks.length;
    const validIndex2 = Math.min(index2, length - 1);
    const start = scale._startPixel;
    const end = scale._endPixel;
    const epsilon = 1e-6;
    let lineValue = scale.getPixelForTick(validIndex2);
    let offset;
    if (offsetGridLines) {
      if (length === 1) {
        offset = Math.max(lineValue - start, end - lineValue);
      } else if (index2 === 0) {
        offset = (scale.getPixelForTick(1) - lineValue) / 2;
      } else {
        offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
      }
      lineValue += validIndex2 < index2 ? offset : -offset;
      if (lineValue < start - epsilon || lineValue > end + epsilon) {
        return;
      }
    }
    return lineValue;
  }
  function garbageCollect(caches, length) {
    each(caches, (cache) => {
      const gc = cache.gc;
      const gcLen = gc.length / 2;
      let i2;
      if (gcLen > length) {
        for (i2 = 0; i2 < gcLen; ++i2) {
          delete cache.data[gc[i2]];
        }
        gc.splice(0, gcLen);
      }
    });
  }
  function getTickMarkLength(options) {
    return options.drawTicks ? options.tickLength : 0;
  }
  function getTitleHeight(options, fallback) {
    if (!options.display) {
      return 0;
    }
    const font = toFont(options.font, fallback);
    const padding = toPadding(options.padding);
    const lines = isArray(options.text) ? options.text.length : 1;
    return lines * font.lineHeight + padding.height;
  }
  function createScaleContext(parent, scale) {
    return createContext(parent, {
      scale,
      type: "scale"
    });
  }
  function createTickContext(parent, index2, tick) {
    return createContext(parent, {
      tick,
      index: index2,
      type: "tick"
    });
  }
  function titleAlign(align, position, reverse) {
    let ret = _toLeftRightCenter(align);
    if (reverse && position !== "right" || !reverse && position === "right") {
      ret = reverseAlign(ret);
    }
    return ret;
  }
  function titleArgs(scale, offset, position, align) {
    const { top: top2, left, bottom: bottom2, right, chart } = scale;
    const { chartArea, scales: scales2 } = chart;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    const height = bottom2 - top2;
    const width = right - left;
    if (scale.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      if (isObject2(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;
      } else if (position === "center") {
        titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
      } else {
        titleY = offsetFromEdge(scale, position, offset);
      }
      maxWidth = right - left;
    } else {
      if (isObject2(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset;
      } else if (position === "center") {
        titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
      } else {
        titleX = offsetFromEdge(scale, position, offset);
      }
      titleY = _alignStartEnd(align, bottom2, top2);
      rotation = position === "left" ? -HALF_PI : HALF_PI;
    }
    return {
      titleX,
      titleY,
      maxWidth,
      rotation
    };
  }
  var Scale = class extends Element {
    constructor(cfg) {
      super();
      this.id = cfg.id;
      this.type = cfg.type;
      this.options = void 0;
      this.ctx = cfg.ctx;
      this.chart = cfg.chart;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.width = void 0;
      this.height = void 0;
      this._margins = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      this.maxWidth = void 0;
      this.maxHeight = void 0;
      this.paddingTop = void 0;
      this.paddingBottom = void 0;
      this.paddingLeft = void 0;
      this.paddingRight = void 0;
      this.axis = void 0;
      this.labelRotation = void 0;
      this.min = void 0;
      this.max = void 0;
      this._range = void 0;
      this.ticks = [];
      this._gridLineItems = null;
      this._labelItems = null;
      this._labelSizes = null;
      this._length = 0;
      this._maxLength = 0;
      this._longestTextCache = {};
      this._startPixel = void 0;
      this._endPixel = void 0;
      this._reversePixels = false;
      this._userMax = void 0;
      this._userMin = void 0;
      this._suggestedMax = void 0;
      this._suggestedMin = void 0;
      this._ticksLength = 0;
      this._borderValue = 0;
      this._cache = {};
      this._dataLimitsCached = false;
      this.$context = void 0;
    }
    init(options) {
      this.options = options.setContext(this.getContext());
      this.axis = options.axis;
      this._userMin = this.parse(options.min);
      this._userMax = this.parse(options.max);
      this._suggestedMin = this.parse(options.suggestedMin);
      this._suggestedMax = this.parse(options.suggestedMax);
    }
    parse(raw, index2) {
      return raw;
    }
    getUserBounds() {
      let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
      _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
      _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
      _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
      _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
      return {
        min: finiteOrDefault(_userMin, _suggestedMin),
        max: finiteOrDefault(_userMax, _suggestedMax),
        minDefined: isNumberFinite(_userMin),
        maxDefined: isNumberFinite(_userMax)
      };
    }
    getMinMax(canStack) {
      let { min, max: max2, minDefined, maxDefined } = this.getUserBounds();
      let range2;
      if (minDefined && maxDefined) {
        return {
          min,
          max: max2
        };
      }
      const metas = this.getMatchingVisibleMetas();
      for (let i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
        range2 = metas[i2].controller.getMinMax(this, canStack);
        if (!minDefined) {
          min = Math.min(min, range2.min);
        }
        if (!maxDefined) {
          max2 = Math.max(max2, range2.max);
        }
      }
      min = maxDefined && min > max2 ? max2 : min;
      max2 = minDefined && min > max2 ? min : max2;
      return {
        min: finiteOrDefault(min, finiteOrDefault(max2, min)),
        max: finiteOrDefault(max2, finiteOrDefault(min, max2))
      };
    }
    getPadding() {
      return {
        left: this.paddingLeft || 0,
        top: this.paddingTop || 0,
        right: this.paddingRight || 0,
        bottom: this.paddingBottom || 0
      };
    }
    getTicks() {
      return this.ticks;
    }
    getLabels() {
      const data = this.chart.data;
      return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
    }
    getLabelItems(chartArea = this.chart.chartArea) {
      const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
      return items;
    }
    beforeLayout() {
      this._cache = {};
      this._dataLimitsCached = false;
    }
    beforeUpdate() {
      callback(this.options.beforeUpdate, [
        this
      ]);
    }
    update(maxWidth, maxHeight, margins) {
      const { beginAtZero, grace, ticks: tickOpts } = this.options;
      const sampleSize = tickOpts.sampleSize;
      this.beforeUpdate();
      this.maxWidth = maxWidth;
      this.maxHeight = maxHeight;
      this._margins = margins = Object.assign({
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }, margins);
      this.ticks = null;
      this._labelSizes = null;
      this._gridLineItems = null;
      this._labelItems = null;
      this.beforeSetDimensions();
      this.setDimensions();
      this.afterSetDimensions();
      this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
      if (!this._dataLimitsCached) {
        this.beforeDataLimits();
        this.determineDataLimits();
        this.afterDataLimits();
        this._range = _addGrace(this, grace, beginAtZero);
        this._dataLimitsCached = true;
      }
      this.beforeBuildTicks();
      this.ticks = this.buildTicks() || [];
      this.afterBuildTicks();
      const samplingEnabled = sampleSize < this.ticks.length;
      this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
      this.configure();
      this.beforeCalculateLabelRotation();
      this.calculateLabelRotation();
      this.afterCalculateLabelRotation();
      if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
        this.ticks = autoSkip(this, this.ticks);
        this._labelSizes = null;
        this.afterAutoSkip();
      }
      if (samplingEnabled) {
        this._convertTicksToLabels(this.ticks);
      }
      this.beforeFit();
      this.fit();
      this.afterFit();
      this.afterUpdate();
    }
    configure() {
      let reversePixels = this.options.reverse;
      let startPixel, endPixel;
      if (this.isHorizontal()) {
        startPixel = this.left;
        endPixel = this.right;
      } else {
        startPixel = this.top;
        endPixel = this.bottom;
        reversePixels = !reversePixels;
      }
      this._startPixel = startPixel;
      this._endPixel = endPixel;
      this._reversePixels = reversePixels;
      this._length = endPixel - startPixel;
      this._alignToPixels = this.options.alignToPixels;
    }
    afterUpdate() {
      callback(this.options.afterUpdate, [
        this
      ]);
    }
    beforeSetDimensions() {
      callback(this.options.beforeSetDimensions, [
        this
      ]);
    }
    setDimensions() {
      if (this.isHorizontal()) {
        this.width = this.maxWidth;
        this.left = 0;
        this.right = this.width;
      } else {
        this.height = this.maxHeight;
        this.top = 0;
        this.bottom = this.height;
      }
      this.paddingLeft = 0;
      this.paddingTop = 0;
      this.paddingRight = 0;
      this.paddingBottom = 0;
    }
    afterSetDimensions() {
      callback(this.options.afterSetDimensions, [
        this
      ]);
    }
    _callHooks(name) {
      this.chart.notifyPlugins(name, this.getContext());
      callback(this.options[name], [
        this
      ]);
    }
    beforeDataLimits() {
      this._callHooks("beforeDataLimits");
    }
    determineDataLimits() {
    }
    afterDataLimits() {
      this._callHooks("afterDataLimits");
    }
    beforeBuildTicks() {
      this._callHooks("beforeBuildTicks");
    }
    buildTicks() {
      return [];
    }
    afterBuildTicks() {
      this._callHooks("afterBuildTicks");
    }
    beforeTickToLabelConversion() {
      callback(this.options.beforeTickToLabelConversion, [
        this
      ]);
    }
    generateTickLabels(ticks) {
      const tickOpts = this.options.ticks;
      let i2, ilen, tick;
      for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
        tick = ticks[i2];
        tick.label = callback(tickOpts.callback, [
          tick.value,
          i2,
          ticks
        ], this);
      }
    }
    afterTickToLabelConversion() {
      callback(this.options.afterTickToLabelConversion, [
        this
      ]);
    }
    beforeCalculateLabelRotation() {
      callback(this.options.beforeCalculateLabelRotation, [
        this
      ]);
    }
    calculateLabelRotation() {
      const options = this.options;
      const tickOpts = options.ticks;
      const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
      const minRotation = tickOpts.minRotation || 0;
      const maxRotation = tickOpts.maxRotation;
      let labelRotation = minRotation;
      let tickWidth, maxHeight, maxLabelDiagonal;
      if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
        this.labelRotation = minRotation;
        return;
      }
      const labelSizes = this._getLabelSizes();
      const maxLabelWidth = labelSizes.widest.width;
      const maxLabelHeight = labelSizes.highest.height;
      const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
      tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
      if (maxLabelWidth + 6 > tickWidth) {
        tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
        maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
        maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
        labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
        labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
      }
      this.labelRotation = labelRotation;
    }
    afterCalculateLabelRotation() {
      callback(this.options.afterCalculateLabelRotation, [
        this
      ]);
    }
    afterAutoSkip() {
    }
    beforeFit() {
      callback(this.options.beforeFit, [
        this
      ]);
    }
    fit() {
      const minSize = {
        width: 0,
        height: 0
      };
      const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
      const display = this._isVisible();
      const isHorizontal = this.isHorizontal();
      if (display) {
        const titleHeight = getTitleHeight(titleOpts, chart.options.font);
        if (isHorizontal) {
          minSize.width = this.maxWidth;
          minSize.height = getTickMarkLength(gridOpts) + titleHeight;
        } else {
          minSize.height = this.maxHeight;
          minSize.width = getTickMarkLength(gridOpts) + titleHeight;
        }
        if (tickOpts.display && this.ticks.length) {
          const { first, last, widest, highest } = this._getLabelSizes();
          const tickPadding = tickOpts.padding * 2;
          const angleRadians = toRadians(this.labelRotation);
          const cos = Math.cos(angleRadians);
          const sin = Math.sin(angleRadians);
          if (isHorizontal) {
            const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
            minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
          } else {
            const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
            minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
          }
          this._calculatePadding(first, last, sin, cos);
        }
      }
      this._handleMargins();
      if (isHorizontal) {
        this.width = this._length = chart.width - this._margins.left - this._margins.right;
        this.height = minSize.height;
      } else {
        this.width = minSize.width;
        this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
      }
    }
    _calculatePadding(first, last, sin, cos) {
      const { ticks: { align, padding }, position } = this.options;
      const isRotated = this.labelRotation !== 0;
      const labelsBelowTicks = position !== "top" && this.axis === "x";
      if (this.isHorizontal()) {
        const offsetLeft = this.getPixelForTick(0) - this.left;
        const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
        let paddingLeft = 0;
        let paddingRight = 0;
        if (isRotated) {
          if (labelsBelowTicks) {
            paddingLeft = cos * first.width;
            paddingRight = sin * last.height;
          } else {
            paddingLeft = sin * first.height;
            paddingRight = cos * last.width;
          }
        } else if (align === "start") {
          paddingRight = last.width;
        } else if (align === "end") {
          paddingLeft = first.width;
        } else if (align !== "inner") {
          paddingLeft = first.width / 2;
          paddingRight = last.width / 2;
        }
        this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
        this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
      } else {
        let paddingTop = last.height / 2;
        let paddingBottom = first.height / 2;
        if (align === "start") {
          paddingTop = 0;
          paddingBottom = first.height;
        } else if (align === "end") {
          paddingTop = last.height;
          paddingBottom = 0;
        }
        this.paddingTop = paddingTop + padding;
        this.paddingBottom = paddingBottom + padding;
      }
    }
    _handleMargins() {
      if (this._margins) {
        this._margins.left = Math.max(this.paddingLeft, this._margins.left);
        this._margins.top = Math.max(this.paddingTop, this._margins.top);
        this._margins.right = Math.max(this.paddingRight, this._margins.right);
        this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
      }
    }
    afterFit() {
      callback(this.options.afterFit, [
        this
      ]);
    }
    isHorizontal() {
      const { axis, position } = this.options;
      return position === "top" || position === "bottom" || axis === "x";
    }
    isFullSize() {
      return this.options.fullSize;
    }
    _convertTicksToLabels(ticks) {
      this.beforeTickToLabelConversion();
      this.generateTickLabels(ticks);
      let i2, ilen;
      for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
        if (isNullOrUndef(ticks[i2].label)) {
          ticks.splice(i2, 1);
          ilen--;
          i2--;
        }
      }
      this.afterTickToLabelConversion();
    }
    _getLabelSizes() {
      let labelSizes = this._labelSizes;
      if (!labelSizes) {
        const sampleSize = this.options.ticks.sampleSize;
        let ticks = this.ticks;
        if (sampleSize < ticks.length) {
          ticks = sample(ticks, sampleSize);
        }
        this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
      }
      return labelSizes;
    }
    _computeLabelSizes(ticks, length, maxTicksLimit) {
      const { ctx, _longestTextCache: caches } = this;
      const widths = [];
      const heights = [];
      const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
      let widestLabelSize = 0;
      let highestLabelSize = 0;
      let i2, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
      for (i2 = 0; i2 < length; i2 += increment) {
        label = ticks[i2].label;
        tickFont = this._resolveTickFontOptions(i2);
        ctx.font = fontString = tickFont.string;
        cache = caches[fontString] = caches[fontString] || {
          data: {},
          gc: []
        };
        lineHeight = tickFont.lineHeight;
        width = height = 0;
        if (!isNullOrUndef(label) && !isArray(label)) {
          width = _measureText(ctx, cache.data, cache.gc, width, label);
          height = lineHeight;
        } else if (isArray(label)) {
          for (j = 0, jlen = label.length; j < jlen; ++j) {
            nestedLabel = label[j];
            if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
              width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
              height += lineHeight;
            }
          }
        }
        widths.push(width);
        heights.push(height);
        widestLabelSize = Math.max(width, widestLabelSize);
        highestLabelSize = Math.max(height, highestLabelSize);
      }
      garbageCollect(caches, length);
      const widest = widths.indexOf(widestLabelSize);
      const highest = heights.indexOf(highestLabelSize);
      const valueAt = (idx) => ({
        width: widths[idx] || 0,
        height: heights[idx] || 0
      });
      return {
        first: valueAt(0),
        last: valueAt(length - 1),
        widest: valueAt(widest),
        highest: valueAt(highest),
        widths,
        heights
      };
    }
    getLabelForValue(value) {
      return value;
    }
    getPixelForValue(value, index2) {
      return NaN;
    }
    getValueForPixel(pixel) {
    }
    getPixelForTick(index2) {
      const ticks = this.ticks;
      if (index2 < 0 || index2 > ticks.length - 1) {
        return null;
      }
      return this.getPixelForValue(ticks[index2].value);
    }
    getPixelForDecimal(decimal) {
      if (this._reversePixels) {
        decimal = 1 - decimal;
      }
      const pixel = this._startPixel + decimal * this._length;
      return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
    }
    getDecimalForPixel(pixel) {
      const decimal = (pixel - this._startPixel) / this._length;
      return this._reversePixels ? 1 - decimal : decimal;
    }
    getBasePixel() {
      return this.getPixelForValue(this.getBaseValue());
    }
    getBaseValue() {
      const { min, max: max2 } = this;
      return min < 0 && max2 < 0 ? max2 : min > 0 && max2 > 0 ? min : 0;
    }
    getContext(index2) {
      const ticks = this.ticks || [];
      if (index2 >= 0 && index2 < ticks.length) {
        const tick = ticks[index2];
        return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
      }
      return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
    }
    _tickSize() {
      const optionTicks = this.options.ticks;
      const rot = toRadians(this.labelRotation);
      const cos = Math.abs(Math.cos(rot));
      const sin = Math.abs(Math.sin(rot));
      const labelSizes = this._getLabelSizes();
      const padding = optionTicks.autoSkipPadding || 0;
      const w = labelSizes ? labelSizes.widest.width + padding : 0;
      const h3 = labelSizes ? labelSizes.highest.height + padding : 0;
      return this.isHorizontal() ? h3 * cos > w * sin ? w / cos : h3 / sin : h3 * sin < w * cos ? h3 / cos : w / sin;
    }
    _isVisible() {
      const display = this.options.display;
      if (display !== "auto") {
        return !!display;
      }
      return this.getMatchingVisibleMetas().length > 0;
    }
    _computeGridLineItems(chartArea) {
      const axis = this.axis;
      const chart = this.chart;
      const options = this.options;
      const { grid, position, border } = options;
      const offset = grid.offset;
      const isHorizontal = this.isHorizontal();
      const ticks = this.ticks;
      const ticksLength = ticks.length + (offset ? 1 : 0);
      const tl = getTickMarkLength(grid);
      const items = [];
      const borderOpts = border.setContext(this.getContext());
      const axisWidth = borderOpts.display ? borderOpts.width : 0;
      const axisHalfWidth = axisWidth / 2;
      const alignBorderValue = function(pixel) {
        return _alignPixel(chart, pixel, axisWidth);
      };
      let borderValue, i2, lineValue, alignedLineValue;
      let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
      if (position === "top") {
        borderValue = alignBorderValue(this.bottom);
        ty1 = this.bottom - tl;
        ty2 = borderValue - axisHalfWidth;
        y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
        y2 = chartArea.bottom;
      } else if (position === "bottom") {
        borderValue = alignBorderValue(this.top);
        y1 = chartArea.top;
        y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
        ty1 = borderValue + axisHalfWidth;
        ty2 = this.top + tl;
      } else if (position === "left") {
        borderValue = alignBorderValue(this.right);
        tx1 = this.right - tl;
        tx2 = borderValue - axisHalfWidth;
        x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
        x2 = chartArea.right;
      } else if (position === "right") {
        borderValue = alignBorderValue(this.left);
        x1 = chartArea.left;
        x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
        tx1 = borderValue + axisHalfWidth;
        tx2 = this.left + tl;
      } else if (axis === "x") {
        if (position === "center") {
          borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
        } else if (isObject2(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
        }
        y1 = chartArea.top;
        y2 = chartArea.bottom;
        ty1 = borderValue + axisHalfWidth;
        ty2 = ty1 + tl;
      } else if (axis === "y") {
        if (position === "center") {
          borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
        } else if (isObject2(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
        }
        tx1 = borderValue - axisHalfWidth;
        tx2 = tx1 - tl;
        x1 = chartArea.left;
        x2 = chartArea.right;
      }
      const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
      const step = Math.max(1, Math.ceil(ticksLength / limit));
      for (i2 = 0; i2 < ticksLength; i2 += step) {
        const context = this.getContext(i2);
        const optsAtIndex = grid.setContext(context);
        const optsAtIndexBorder = border.setContext(context);
        const lineWidth = optsAtIndex.lineWidth;
        const lineColor = optsAtIndex.color;
        const borderDash = optsAtIndexBorder.dash || [];
        const borderDashOffset = optsAtIndexBorder.dashOffset;
        const tickWidth = optsAtIndex.tickWidth;
        const tickColor = optsAtIndex.tickColor;
        const tickBorderDash = optsAtIndex.tickBorderDash || [];
        const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
        lineValue = getPixelForGridLine(this, i2, offset);
        if (lineValue === void 0) {
          continue;
        }
        alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
        if (isHorizontal) {
          tx1 = tx2 = x1 = x2 = alignedLineValue;
        } else {
          ty1 = ty2 = y1 = y2 = alignedLineValue;
        }
        items.push({
          tx1,
          ty1,
          tx2,
          ty2,
          x1,
          y1,
          x2,
          y2,
          width: lineWidth,
          color: lineColor,
          borderDash,
          borderDashOffset,
          tickWidth,
          tickColor,
          tickBorderDash,
          tickBorderDashOffset
        });
      }
      this._ticksLength = ticksLength;
      this._borderValue = borderValue;
      return items;
    }
    _computeLabelItems(chartArea) {
      const axis = this.axis;
      const options = this.options;
      const { position, ticks: optionTicks } = options;
      const isHorizontal = this.isHorizontal();
      const ticks = this.ticks;
      const { align, crossAlign, padding, mirror } = optionTicks;
      const tl = getTickMarkLength(options.grid);
      const tickAndPadding = tl + padding;
      const hTickAndPadding = mirror ? -padding : tickAndPadding;
      const rotation = -toRadians(this.labelRotation);
      const items = [];
      let i2, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
      let textBaseline = "middle";
      if (position === "top") {
        y = this.bottom - hTickAndPadding;
        textAlign = this._getXAxisLabelAlignment();
      } else if (position === "bottom") {
        y = this.top + hTickAndPadding;
        textAlign = this._getXAxisLabelAlignment();
      } else if (position === "left") {
        const ret = this._getYAxisLabelAlignment(tl);
        textAlign = ret.textAlign;
        x = ret.x;
      } else if (position === "right") {
        const ret = this._getYAxisLabelAlignment(tl);
        textAlign = ret.textAlign;
        x = ret.x;
      } else if (axis === "x") {
        if (position === "center") {
          y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
        } else if (isObject2(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
        }
        textAlign = this._getXAxisLabelAlignment();
      } else if (axis === "y") {
        if (position === "center") {
          x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
        } else if (isObject2(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          x = this.chart.scales[positionAxisID].getPixelForValue(value);
        }
        textAlign = this._getYAxisLabelAlignment(tl).textAlign;
      }
      if (axis === "y") {
        if (align === "start") {
          textBaseline = "top";
        } else if (align === "end") {
          textBaseline = "bottom";
        }
      }
      const labelSizes = this._getLabelSizes();
      for (i2 = 0, ilen = ticks.length; i2 < ilen; ++i2) {
        tick = ticks[i2];
        label = tick.label;
        const optsAtIndex = optionTicks.setContext(this.getContext(i2));
        pixel = this.getPixelForTick(i2) + optionTicks.labelOffset;
        font = this._resolveTickFontOptions(i2);
        lineHeight = font.lineHeight;
        lineCount = isArray(label) ? label.length : 1;
        const halfCount = lineCount / 2;
        const color2 = optsAtIndex.color;
        const strokeColor = optsAtIndex.textStrokeColor;
        const strokeWidth = optsAtIndex.textStrokeWidth;
        let tickTextAlign = textAlign;
        if (isHorizontal) {
          x = pixel;
          if (textAlign === "inner") {
            if (i2 === ilen - 1) {
              tickTextAlign = !this.options.reverse ? "right" : "left";
            } else if (i2 === 0) {
              tickTextAlign = !this.options.reverse ? "left" : "right";
            } else {
              tickTextAlign = "center";
            }
          }
          if (position === "top") {
            if (crossAlign === "near" || rotation !== 0) {
              textOffset = -lineCount * lineHeight + lineHeight / 2;
            } else if (crossAlign === "center") {
              textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
            } else {
              textOffset = -labelSizes.highest.height + lineHeight / 2;
            }
          } else {
            if (crossAlign === "near" || rotation !== 0) {
              textOffset = lineHeight / 2;
            } else if (crossAlign === "center") {
              textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
            } else {
              textOffset = labelSizes.highest.height - lineCount * lineHeight;
            }
          }
          if (mirror) {
            textOffset *= -1;
          }
          if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
            x += lineHeight / 2 * Math.sin(rotation);
          }
        } else {
          y = pixel;
          textOffset = (1 - lineCount) * lineHeight / 2;
        }
        let backdrop;
        if (optsAtIndex.showLabelBackdrop) {
          const labelPadding = toPadding(optsAtIndex.backdropPadding);
          const height = labelSizes.heights[i2];
          const width = labelSizes.widths[i2];
          let top2 = textOffset - labelPadding.top;
          let left = 0 - labelPadding.left;
          switch (textBaseline) {
            case "middle":
              top2 -= height / 2;
              break;
            case "bottom":
              top2 -= height;
              break;
          }
          switch (textAlign) {
            case "center":
              left -= width / 2;
              break;
            case "right":
              left -= width;
              break;
            case "inner":
              if (i2 === ilen - 1) {
                left -= width;
              } else if (i2 > 0) {
                left -= width / 2;
              }
              break;
          }
          backdrop = {
            left,
            top: top2,
            width: width + labelPadding.width,
            height: height + labelPadding.height,
            color: optsAtIndex.backdropColor
          };
        }
        items.push({
          label,
          font,
          textOffset,
          options: {
            rotation,
            color: color2,
            strokeColor,
            strokeWidth,
            textAlign: tickTextAlign,
            textBaseline,
            translation: [
              x,
              y
            ],
            backdrop
          }
        });
      }
      return items;
    }
    _getXAxisLabelAlignment() {
      const { position, ticks } = this.options;
      const rotation = -toRadians(this.labelRotation);
      if (rotation) {
        return position === "top" ? "left" : "right";
      }
      let align = "center";
      if (ticks.align === "start") {
        align = "left";
      } else if (ticks.align === "end") {
        align = "right";
      } else if (ticks.align === "inner") {
        align = "inner";
      }
      return align;
    }
    _getYAxisLabelAlignment(tl) {
      const { position, ticks: { crossAlign, mirror, padding } } = this.options;
      const labelSizes = this._getLabelSizes();
      const tickAndPadding = tl + padding;
      const widest = labelSizes.widest.width;
      let textAlign;
      let x;
      if (position === "left") {
        if (mirror) {
          x = this.right + padding;
          if (crossAlign === "near") {
            textAlign = "left";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x += widest / 2;
          } else {
            textAlign = "right";
            x += widest;
          }
        } else {
          x = this.right - tickAndPadding;
          if (crossAlign === "near") {
            textAlign = "right";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x -= widest / 2;
          } else {
            textAlign = "left";
            x = this.left;
          }
        }
      } else if (position === "right") {
        if (mirror) {
          x = this.left + padding;
          if (crossAlign === "near") {
            textAlign = "right";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x -= widest / 2;
          } else {
            textAlign = "left";
            x -= widest;
          }
        } else {
          x = this.left + tickAndPadding;
          if (crossAlign === "near") {
            textAlign = "left";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x += widest / 2;
          } else {
            textAlign = "right";
            x = this.right;
          }
        }
      } else {
        textAlign = "right";
      }
      return {
        textAlign,
        x
      };
    }
    _computeLabelArea() {
      if (this.options.ticks.mirror) {
        return;
      }
      const chart = this.chart;
      const position = this.options.position;
      if (position === "left" || position === "right") {
        return {
          top: 0,
          left: this.left,
          bottom: chart.height,
          right: this.right
        };
      }
      if (position === "top" || position === "bottom") {
        return {
          top: this.top,
          left: 0,
          bottom: this.bottom,
          right: chart.width
        };
      }
    }
    drawBackground() {
      const { ctx, options: { backgroundColor }, left, top: top2, width, height } = this;
      if (backgroundColor) {
        ctx.save();
        ctx.fillStyle = backgroundColor;
        ctx.fillRect(left, top2, width, height);
        ctx.restore();
      }
    }
    getLineWidthForValue(value) {
      const grid = this.options.grid;
      if (!this._isVisible() || !grid.display) {
        return 0;
      }
      const ticks = this.ticks;
      const index2 = ticks.findIndex((t2) => t2.value === value);
      if (index2 >= 0) {
        const opts = grid.setContext(this.getContext(index2));
        return opts.lineWidth;
      }
      return 0;
    }
    drawGrid(chartArea) {
      const grid = this.options.grid;
      const ctx = this.ctx;
      const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
      let i2, ilen;
      const drawLine = (p1, p2, style) => {
        if (!style.width || !style.color) {
          return;
        }
        ctx.save();
        ctx.lineWidth = style.width;
        ctx.strokeStyle = style.color;
        ctx.setLineDash(style.borderDash || []);
        ctx.lineDashOffset = style.borderDashOffset;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
        ctx.restore();
      };
      if (grid.display) {
        for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
          const item = items[i2];
          if (grid.drawOnChartArea) {
            drawLine({
              x: item.x1,
              y: item.y1
            }, {
              x: item.x2,
              y: item.y2
            }, item);
          }
          if (grid.drawTicks) {
            drawLine({
              x: item.tx1,
              y: item.ty1
            }, {
              x: item.tx2,
              y: item.ty2
            }, {
              color: item.tickColor,
              width: item.tickWidth,
              borderDash: item.tickBorderDash,
              borderDashOffset: item.tickBorderDashOffset
            });
          }
        }
      }
    }
    drawBorder() {
      const { chart, ctx, options: { border, grid } } = this;
      const borderOpts = border.setContext(this.getContext());
      const axisWidth = border.display ? borderOpts.width : 0;
      if (!axisWidth) {
        return;
      }
      const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
      const borderValue = this._borderValue;
      let x1, x2, y1, y2;
      if (this.isHorizontal()) {
        x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
        x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
        y1 = y2 = borderValue;
      } else {
        y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
        y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
        x1 = x2 = borderValue;
      }
      ctx.save();
      ctx.lineWidth = borderOpts.width;
      ctx.strokeStyle = borderOpts.color;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      ctx.restore();
    }
    drawLabels(chartArea) {
      const optionTicks = this.options.ticks;
      if (!optionTicks.display) {
        return;
      }
      const ctx = this.ctx;
      const area = this._computeLabelArea();
      if (area) {
        clipArea(ctx, area);
      }
      const items = this.getLabelItems(chartArea);
      for (const item of items) {
        const renderTextOptions = item.options;
        const tickFont = item.font;
        const label = item.label;
        const y = item.textOffset;
        renderText(ctx, label, 0, y, tickFont, renderTextOptions);
      }
      if (area) {
        unclipArea(ctx);
      }
    }
    drawTitle() {
      const { ctx, options: { position, title, reverse } } = this;
      if (!title.display) {
        return;
      }
      const font = toFont(title.font);
      const padding = toPadding(title.padding);
      const align = title.align;
      let offset = font.lineHeight / 2;
      if (position === "bottom" || position === "center" || isObject2(position)) {
        offset += padding.bottom;
        if (isArray(title.text)) {
          offset += font.lineHeight * (title.text.length - 1);
        }
      } else {
        offset += padding.top;
      }
      const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
      renderText(ctx, title.text, 0, 0, font, {
        color: title.color,
        maxWidth,
        rotation,
        textAlign: titleAlign(align, position, reverse),
        textBaseline: "middle",
        translation: [
          titleX,
          titleY
        ]
      });
    }
    draw(chartArea) {
      if (!this._isVisible()) {
        return;
      }
      this.drawBackground();
      this.drawGrid(chartArea);
      this.drawBorder();
      this.drawTitle();
      this.drawLabels(chartArea);
    }
    _layers() {
      const opts = this.options;
      const tz = opts.ticks && opts.ticks.z || 0;
      const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
      const bz = valueOrDefault(opts.border && opts.border.z, 0);
      if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
        return [
          {
            z: tz,
            draw: (chartArea) => {
              this.draw(chartArea);
            }
          }
        ];
      }
      return [
        {
          z: gz,
          draw: (chartArea) => {
            this.drawBackground();
            this.drawGrid(chartArea);
            this.drawTitle();
          }
        },
        {
          z: bz,
          draw: () => {
            this.drawBorder();
          }
        },
        {
          z: tz,
          draw: (chartArea) => {
            this.drawLabels(chartArea);
          }
        }
      ];
    }
    getMatchingVisibleMetas(type) {
      const metas = this.chart.getSortedVisibleDatasetMetas();
      const axisID = this.axis + "AxisID";
      const result = [];
      let i2, ilen;
      for (i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
        const meta = metas[i2];
        if (meta[axisID] === this.id && (!type || meta.type === type)) {
          result.push(meta);
        }
      }
      return result;
    }
    _resolveTickFontOptions(index2) {
      const opts = this.options.ticks.setContext(this.getContext(index2));
      return toFont(opts.font);
    }
    _maxDigits() {
      const fontSize = this._resolveTickFontOptions(0).lineHeight;
      return (this.isHorizontal() ? this.width : this.height) / fontSize;
    }
  };
  var TypedRegistry = class {
    constructor(type, scope, override) {
      this.type = type;
      this.scope = scope;
      this.override = override;
      this.items = /* @__PURE__ */ Object.create(null);
    }
    isForType(type) {
      return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
    }
    register(item) {
      const proto = Object.getPrototypeOf(item);
      let parentScope;
      if (isIChartComponent(proto)) {
        parentScope = this.register(proto);
      }
      const items = this.items;
      const id = item.id;
      const scope = this.scope + "." + id;
      if (!id) {
        throw new Error("class does not have id: " + item);
      }
      if (id in items) {
        return scope;
      }
      items[id] = item;
      registerDefaults(item, scope, parentScope);
      if (this.override) {
        defaults.override(item.id, item.overrides);
      }
      return scope;
    }
    get(id) {
      return this.items[id];
    }
    unregister(item) {
      const items = this.items;
      const id = item.id;
      const scope = this.scope;
      if (id in items) {
        delete items[id];
      }
      if (scope && id in defaults[scope]) {
        delete defaults[scope][id];
        if (this.override) {
          delete overrides[id];
        }
      }
    }
  };
  function registerDefaults(item, scope, parentScope) {
    const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
      parentScope ? defaults.get(parentScope) : {},
      defaults.get(scope),
      item.defaults
    ]);
    defaults.set(scope, itemDefaults);
    if (item.defaultRoutes) {
      routeDefaults(scope, item.defaultRoutes);
    }
    if (item.descriptors) {
      defaults.describe(scope, item.descriptors);
    }
  }
  function routeDefaults(scope, routes) {
    Object.keys(routes).forEach((property) => {
      const propertyParts = property.split(".");
      const sourceName = propertyParts.pop();
      const sourceScope = [
        scope
      ].concat(propertyParts).join(".");
      const parts = routes[property].split(".");
      const targetName = parts.pop();
      const targetScope = parts.join(".");
      defaults.route(sourceScope, sourceName, targetScope, targetName);
    });
  }
  function isIChartComponent(proto) {
    return "id" in proto && "defaults" in proto;
  }
  var Registry = class {
    constructor() {
      this.controllers = new TypedRegistry(DatasetController, "datasets", true);
      this.elements = new TypedRegistry(Element, "elements");
      this.plugins = new TypedRegistry(Object, "plugins");
      this.scales = new TypedRegistry(Scale, "scales");
      this._typedRegistries = [
        this.controllers,
        this.scales,
        this.elements
      ];
    }
    add(...args) {
      this._each("register", args);
    }
    remove(...args) {
      this._each("unregister", args);
    }
    addControllers(...args) {
      this._each("register", args, this.controllers);
    }
    addElements(...args) {
      this._each("register", args, this.elements);
    }
    addPlugins(...args) {
      this._each("register", args, this.plugins);
    }
    addScales(...args) {
      this._each("register", args, this.scales);
    }
    getController(id) {
      return this._get(id, this.controllers, "controller");
    }
    getElement(id) {
      return this._get(id, this.elements, "element");
    }
    getPlugin(id) {
      return this._get(id, this.plugins, "plugin");
    }
    getScale(id) {
      return this._get(id, this.scales, "scale");
    }
    removeControllers(...args) {
      this._each("unregister", args, this.controllers);
    }
    removeElements(...args) {
      this._each("unregister", args, this.elements);
    }
    removePlugins(...args) {
      this._each("unregister", args, this.plugins);
    }
    removeScales(...args) {
      this._each("unregister", args, this.scales);
    }
    _each(method, args, typedRegistry) {
      [
        ...args
      ].forEach((arg) => {
        const reg = typedRegistry || this._getRegistryForType(arg);
        if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
          this._exec(method, reg, arg);
        } else {
          each(arg, (item) => {
            const itemReg = typedRegistry || this._getRegistryForType(item);
            this._exec(method, itemReg, item);
          });
        }
      });
    }
    _exec(method, registry2, component) {
      const camelMethod = _capitalize(method);
      callback(component["before" + camelMethod], [], component);
      registry2[method](component);
      callback(component["after" + camelMethod], [], component);
    }
    _getRegistryForType(type) {
      for (let i2 = 0; i2 < this._typedRegistries.length; i2++) {
        const reg = this._typedRegistries[i2];
        if (reg.isForType(type)) {
          return reg;
        }
      }
      return this.plugins;
    }
    _get(id, typedRegistry, type) {
      const item = typedRegistry.get(id);
      if (item === void 0) {
        throw new Error('"' + id + '" is not a registered ' + type + ".");
      }
      return item;
    }
  };
  var registry = /* @__PURE__ */ new Registry();
  var PluginService = class {
    constructor() {
      this._init = [];
    }
    notify(chart, hook, args, filter) {
      if (hook === "beforeInit") {
        this._init = this._createDescriptors(chart, true);
        this._notify(this._init, chart, "install");
      }
      const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
      const result = this._notify(descriptors2, chart, hook, args);
      if (hook === "afterDestroy") {
        this._notify(descriptors2, chart, "stop");
        this._notify(this._init, chart, "uninstall");
      }
      return result;
    }
    _notify(descriptors2, chart, hook, args) {
      args = args || {};
      for (const descriptor of descriptors2) {
        const plugin = descriptor.plugin;
        const method = plugin[hook];
        const params = [
          chart,
          args,
          descriptor.options
        ];
        if (callback(method, params, plugin) === false && args.cancelable) {
          return false;
        }
      }
      return true;
    }
    invalidate() {
      if (!isNullOrUndef(this._cache)) {
        this._oldCache = this._cache;
        this._cache = void 0;
      }
    }
    _descriptors(chart) {
      if (this._cache) {
        return this._cache;
      }
      const descriptors2 = this._cache = this._createDescriptors(chart);
      this._notifyStateChanges(chart);
      return descriptors2;
    }
    _createDescriptors(chart, all) {
      const config = chart && chart.config;
      const options = valueOrDefault(config.options && config.options.plugins, {});
      const plugins2 = allPlugins(config);
      return options === false && !all ? [] : createDescriptors(chart, plugins2, options, all);
    }
    _notifyStateChanges(chart) {
      const previousDescriptors = this._oldCache || [];
      const descriptors2 = this._cache;
      const diff = (a2, b) => a2.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
      this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
      this._notify(diff(descriptors2, previousDescriptors), chart, "start");
    }
  };
  function allPlugins(config) {
    const localIds = {};
    const plugins2 = [];
    const keys = Object.keys(registry.plugins.items);
    for (let i2 = 0; i2 < keys.length; i2++) {
      plugins2.push(registry.getPlugin(keys[i2]));
    }
    const local = config.plugins || [];
    for (let i2 = 0; i2 < local.length; i2++) {
      const plugin = local[i2];
      if (plugins2.indexOf(plugin) === -1) {
        plugins2.push(plugin);
        localIds[plugin.id] = true;
      }
    }
    return {
      plugins: plugins2,
      localIds
    };
  }
  function getOpts(options, all) {
    if (!all && options === false) {
      return null;
    }
    if (options === true) {
      return {};
    }
    return options;
  }
  function createDescriptors(chart, { plugins: plugins2, localIds }, options, all) {
    const result = [];
    const context = chart.getContext();
    for (const plugin of plugins2) {
      const id = plugin.id;
      const opts = getOpts(options[id], all);
      if (opts === null) {
        continue;
      }
      result.push({
        plugin,
        options: pluginOpts(chart.config, {
          plugin,
          local: localIds[id]
        }, opts, context)
      });
    }
    return result;
  }
  function pluginOpts(config, { plugin, local }, opts, context) {
    const keys = config.pluginScopeKeys(plugin);
    const scopes = config.getOptionScopes(opts, keys);
    if (local && plugin.defaults) {
      scopes.push(plugin.defaults);
    }
    return config.createResolver(scopes, context, [
      ""
    ], {
      scriptable: false,
      indexable: false,
      allKeys: true
    });
  }
  function getIndexAxis(type, options) {
    const datasetDefaults = defaults.datasets[type] || {};
    const datasetOptions = (options.datasets || {})[type] || {};
    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
  }
  function getAxisFromDefaultScaleID(id, indexAxis) {
    let axis = id;
    if (id === "_index_") {
      axis = indexAxis;
    } else if (id === "_value_") {
      axis = indexAxis === "x" ? "y" : "x";
    }
    return axis;
  }
  function getDefaultScaleIDFromAxis(axis, indexAxis) {
    return axis === indexAxis ? "_index_" : "_value_";
  }
  function idMatchesAxis(id) {
    if (id === "x" || id === "y" || id === "r") {
      return id;
    }
  }
  function axisFromPosition(position) {
    if (position === "top" || position === "bottom") {
      return "x";
    }
    if (position === "left" || position === "right") {
      return "y";
    }
  }
  function determineAxis(id, ...scaleOptions) {
    if (idMatchesAxis(id)) {
      return id;
    }
    for (const opts of scaleOptions) {
      const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
      if (axis) {
        return axis;
      }
    }
    throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
  }
  function getAxisFromDataset(id, axis, dataset) {
    if (dataset[axis + "AxisID"] === id) {
      return {
        axis
      };
    }
  }
  function retrieveAxisFromDatasets(id, config) {
    if (config.data && config.data.datasets) {
      const boundDs = config.data.datasets.filter((d2) => d2.xAxisID === id || d2.yAxisID === id);
      if (boundDs.length) {
        return getAxisFromDataset(id, "x", boundDs[0]) || getAxisFromDataset(id, "y", boundDs[0]);
      }
    }
    return {};
  }
  function mergeScaleConfig(config, options) {
    const chartDefaults = overrides[config.type] || {
      scales: {}
    };
    const configScales = options.scales || {};
    const chartIndexAxis = getIndexAxis(config.type, options);
    const scales2 = /* @__PURE__ */ Object.create(null);
    Object.keys(configScales).forEach((id) => {
      const scaleConf = configScales[id];
      if (!isObject2(scaleConf)) {
        return console.error(`Invalid scale configuration for scale: ${id}`);
      }
      if (scaleConf._proxy) {
        return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
      }
      const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);
      const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
      const defaultScaleOptions = chartDefaults.scales || {};
      scales2[id] = mergeIf(/* @__PURE__ */ Object.create(null), [
        {
          axis
        },
        scaleConf,
        defaultScaleOptions[axis],
        defaultScaleOptions[defaultId]
      ]);
    });
    config.data.datasets.forEach((dataset) => {
      const type = dataset.type || config.type;
      const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
      const datasetDefaults = overrides[type] || {};
      const defaultScaleOptions = datasetDefaults.scales || {};
      Object.keys(defaultScaleOptions).forEach((defaultID) => {
        const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
        const id = dataset[axis + "AxisID"] || axis;
        scales2[id] = scales2[id] || /* @__PURE__ */ Object.create(null);
        mergeIf(scales2[id], [
          {
            axis
          },
          configScales[id],
          defaultScaleOptions[defaultID]
        ]);
      });
    });
    Object.keys(scales2).forEach((key) => {
      const scale = scales2[key];
      mergeIf(scale, [
        defaults.scales[scale.type],
        defaults.scale
      ]);
    });
    return scales2;
  }
  function initOptions(config) {
    const options = config.options || (config.options = {});
    options.plugins = valueOrDefault(options.plugins, {});
    options.scales = mergeScaleConfig(config, options);
  }
  function initData(data) {
    data = data || {};
    data.datasets = data.datasets || [];
    data.labels = data.labels || [];
    return data;
  }
  function initConfig(config) {
    config = config || {};
    config.data = initData(config.data);
    initOptions(config);
    return config;
  }
  var keyCache = /* @__PURE__ */ new Map();
  var keysCached = /* @__PURE__ */ new Set();
  function cachedKeys(cacheKey, generate) {
    let keys = keyCache.get(cacheKey);
    if (!keys) {
      keys = generate();
      keyCache.set(cacheKey, keys);
      keysCached.add(keys);
    }
    return keys;
  }
  var addIfFound = (set2, obj, key) => {
    const opts = resolveObjectKey(obj, key);
    if (opts !== void 0) {
      set2.add(opts);
    }
  };
  var Config = class {
    constructor(config) {
      this._config = initConfig(config);
      this._scopeCache = /* @__PURE__ */ new Map();
      this._resolverCache = /* @__PURE__ */ new Map();
    }
    get platform() {
      return this._config.platform;
    }
    get type() {
      return this._config.type;
    }
    set type(type) {
      this._config.type = type;
    }
    get data() {
      return this._config.data;
    }
    set data(data) {
      this._config.data = initData(data);
    }
    get options() {
      return this._config.options;
    }
    set options(options) {
      this._config.options = options;
    }
    get plugins() {
      return this._config.plugins;
    }
    update() {
      const config = this._config;
      this.clearCache();
      initOptions(config);
    }
    clearCache() {
      this._scopeCache.clear();
      this._resolverCache.clear();
    }
    datasetScopeKeys(datasetType) {
      return cachedKeys(datasetType, () => [
        [
          `datasets.${datasetType}`,
          ""
        ]
      ]);
    }
    datasetAnimationScopeKeys(datasetType, transition) {
      return cachedKeys(`${datasetType}.transition.${transition}`, () => [
        [
          `datasets.${datasetType}.transitions.${transition}`,
          `transitions.${transition}`
        ],
        [
          `datasets.${datasetType}`,
          ""
        ]
      ]);
    }
    datasetElementScopeKeys(datasetType, elementType) {
      return cachedKeys(`${datasetType}-${elementType}`, () => [
        [
          `datasets.${datasetType}.elements.${elementType}`,
          `datasets.${datasetType}`,
          `elements.${elementType}`,
          ""
        ]
      ]);
    }
    pluginScopeKeys(plugin) {
      const id = plugin.id;
      const type = this.type;
      return cachedKeys(`${type}-plugin-${id}`, () => [
        [
          `plugins.${id}`,
          ...plugin.additionalOptionScopes || []
        ]
      ]);
    }
    _cachedScopes(mainScope, resetCache) {
      const _scopeCache = this._scopeCache;
      let cache = _scopeCache.get(mainScope);
      if (!cache || resetCache) {
        cache = /* @__PURE__ */ new Map();
        _scopeCache.set(mainScope, cache);
      }
      return cache;
    }
    getOptionScopes(mainScope, keyLists, resetCache) {
      const { options, type } = this;
      const cache = this._cachedScopes(mainScope, resetCache);
      const cached = cache.get(keyLists);
      if (cached) {
        return cached;
      }
      const scopes = /* @__PURE__ */ new Set();
      keyLists.forEach((keys) => {
        if (mainScope) {
          scopes.add(mainScope);
          keys.forEach((key) => addIfFound(scopes, mainScope, key));
        }
        keys.forEach((key) => addIfFound(scopes, options, key));
        keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
        keys.forEach((key) => addIfFound(scopes, defaults, key));
        keys.forEach((key) => addIfFound(scopes, descriptors, key));
      });
      const array = Array.from(scopes);
      if (array.length === 0) {
        array.push(/* @__PURE__ */ Object.create(null));
      }
      if (keysCached.has(keyLists)) {
        cache.set(keyLists, array);
      }
      return array;
    }
    chartOptionScopes() {
      const { options, type } = this;
      return [
        options,
        overrides[type] || {},
        defaults.datasets[type] || {},
        {
          type
        },
        defaults,
        descriptors
      ];
    }
    resolveNamedOptions(scopes, names2, context, prefixes = [
      ""
    ]) {
      const result = {
        $shared: true
      };
      const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
      let options = resolver;
      if (needContext(resolver, names2)) {
        result.$shared = false;
        context = isFunction(context) ? context() : context;
        const subResolver = this.createResolver(scopes, context, subPrefixes);
        options = _attachContext(resolver, context, subResolver);
      }
      for (const prop of names2) {
        result[prop] = options[prop];
      }
      return result;
    }
    createResolver(scopes, context, prefixes = [
      ""
    ], descriptorDefaults) {
      const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
      return isObject2(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
    }
  };
  function getResolver(resolverCache, scopes, prefixes) {
    let cache = resolverCache.get(scopes);
    if (!cache) {
      cache = /* @__PURE__ */ new Map();
      resolverCache.set(scopes, cache);
    }
    const cacheKey = prefixes.join();
    let cached = cache.get(cacheKey);
    if (!cached) {
      const resolver = _createResolver(scopes, prefixes);
      cached = {
        resolver,
        subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
      };
      cache.set(cacheKey, cached);
    }
    return cached;
  }
  var hasFunction = (value) => isObject2(value) && Object.getOwnPropertyNames(value).some((key) => isFunction(value[key]));
  function needContext(proxy, names2) {
    const { isScriptable, isIndexable } = _descriptors(proxy);
    for (const prop of names2) {
      const scriptable = isScriptable(prop);
      const indexable = isIndexable(prop);
      const value = (indexable || scriptable) && proxy[prop];
      if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
        return true;
      }
    }
    return false;
  }
  var version = "4.4.7";
  var KNOWN_POSITIONS = [
    "top",
    "bottom",
    "left",
    "right",
    "chartArea"
  ];
  function positionIsHorizontal(position, axis) {
    return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
  }
  function compare2Level(l1, l2) {
    return function(a2, b) {
      return a2[l1] === b[l1] ? a2[l2] - b[l2] : a2[l1] - b[l1];
    };
  }
  function onAnimationsComplete(context) {
    const chart = context.chart;
    const animationOptions = chart.options.animation;
    chart.notifyPlugins("afterRender");
    callback(animationOptions && animationOptions.onComplete, [
      context
    ], chart);
  }
  function onAnimationProgress(context) {
    const chart = context.chart;
    const animationOptions = chart.options.animation;
    callback(animationOptions && animationOptions.onProgress, [
      context
    ], chart);
  }
  function getCanvas(item) {
    if (_isDomSupported() && typeof item === "string") {
      item = document.getElementById(item);
    } else if (item && item.length) {
      item = item[0];
    }
    if (item && item.canvas) {
      item = item.canvas;
    }
    return item;
  }
  var instances = {};
  var getChart = (key) => {
    const canvas = getCanvas(key);
    return Object.values(instances).filter((c2) => c2.canvas === canvas).pop();
  };
  function moveNumericKeys(obj, start, move) {
    const keys = Object.keys(obj);
    for (const key of keys) {
      const intKey = +key;
      if (intKey >= start) {
        const value = obj[key];
        delete obj[key];
        if (move > 0 || intKey > start) {
          obj[intKey + move] = value;
        }
      }
    }
  }
  function determineLastEvent(e2, lastEvent, inChartArea, isClick) {
    if (!inChartArea || e2.type === "mouseout") {
      return null;
    }
    if (isClick) {
      return lastEvent;
    }
    return e2;
  }
  function getSizeForArea(scale, chartArea, field) {
    return scale.options.clip ? scale[field] : chartArea[field];
  }
  function getDatasetArea(meta, chartArea) {
    const { xScale, yScale } = meta;
    if (xScale && yScale) {
      return {
        left: getSizeForArea(xScale, chartArea, "left"),
        right: getSizeForArea(xScale, chartArea, "right"),
        top: getSizeForArea(yScale, chartArea, "top"),
        bottom: getSizeForArea(yScale, chartArea, "bottom")
      };
    }
    return chartArea;
  }
  var Chart = class {
    static register(...items) {
      registry.add(...items);
      invalidatePlugins();
    }
    static unregister(...items) {
      registry.remove(...items);
      invalidatePlugins();
    }
    constructor(item, userConfig) {
      const config = this.config = new Config(userConfig);
      const initialCanvas = getCanvas(item);
      const existingChart = getChart(initialCanvas);
      if (existingChart) {
        throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
      }
      const options = config.createResolver(config.chartOptionScopes(), this.getContext());
      this.platform = new (config.platform || _detectPlatform(initialCanvas))();
      this.platform.updateConfig(config);
      const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
      const canvas = context && context.canvas;
      const height = canvas && canvas.height;
      const width = canvas && canvas.width;
      this.id = uid();
      this.ctx = context;
      this.canvas = canvas;
      this.width = width;
      this.height = height;
      this._options = options;
      this._aspectRatio = this.aspectRatio;
      this._layers = [];
      this._metasets = [];
      this._stacks = void 0;
      this.boxes = [];
      this.currentDevicePixelRatio = void 0;
      this.chartArea = void 0;
      this._active = [];
      this._lastEvent = void 0;
      this._listeners = {};
      this._responsiveListeners = void 0;
      this._sortedMetasets = [];
      this.scales = {};
      this._plugins = new PluginService();
      this.$proxies = {};
      this._hiddenIndices = {};
      this.attached = false;
      this._animationsDisabled = void 0;
      this.$context = void 0;
      this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
      this._dataChanges = [];
      instances[this.id] = this;
      if (!context || !canvas) {
        console.error("Failed to create chart: can't acquire context from the given item");
        return;
      }
      animator.listen(this, "complete", onAnimationsComplete);
      animator.listen(this, "progress", onAnimationProgress);
      this._initialize();
      if (this.attached) {
        this.update();
      }
    }
    get aspectRatio() {
      const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
      if (!isNullOrUndef(aspectRatio)) {
        return aspectRatio;
      }
      if (maintainAspectRatio && _aspectRatio) {
        return _aspectRatio;
      }
      return height ? width / height : null;
    }
    get data() {
      return this.config.data;
    }
    set data(data) {
      this.config.data = data;
    }
    get options() {
      return this._options;
    }
    set options(options) {
      this.config.options = options;
    }
    get registry() {
      return registry;
    }
    _initialize() {
      this.notifyPlugins("beforeInit");
      if (this.options.responsive) {
        this.resize();
      } else {
        retinaScale(this, this.options.devicePixelRatio);
      }
      this.bindEvents();
      this.notifyPlugins("afterInit");
      return this;
    }
    clear() {
      clearCanvas(this.canvas, this.ctx);
      return this;
    }
    stop() {
      animator.stop(this);
      return this;
    }
    resize(width, height) {
      if (!animator.running(this)) {
        this._resize(width, height);
      } else {
        this._resizeBeforeDraw = {
          width,
          height
        };
      }
    }
    _resize(width, height) {
      const options = this.options;
      const canvas = this.canvas;
      const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
      const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
      const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
      const mode = this.width ? "resize" : "attach";
      this.width = newSize.width;
      this.height = newSize.height;
      this._aspectRatio = this.aspectRatio;
      if (!retinaScale(this, newRatio, true)) {
        return;
      }
      this.notifyPlugins("resize", {
        size: newSize
      });
      callback(options.onResize, [
        this,
        newSize
      ], this);
      if (this.attached) {
        if (this._doResize(mode)) {
          this.render();
        }
      }
    }
    ensureScalesHaveIDs() {
      const options = this.options;
      const scalesOptions = options.scales || {};
      each(scalesOptions, (axisOptions, axisID) => {
        axisOptions.id = axisID;
      });
    }
    buildOrUpdateScales() {
      const options = this.options;
      const scaleOpts = options.scales;
      const scales2 = this.scales;
      const updated = Object.keys(scales2).reduce((obj, id) => {
        obj[id] = false;
        return obj;
      }, {});
      let items = [];
      if (scaleOpts) {
        items = items.concat(Object.keys(scaleOpts).map((id) => {
          const scaleOptions = scaleOpts[id];
          const axis = determineAxis(id, scaleOptions);
          const isRadial = axis === "r";
          const isHorizontal = axis === "x";
          return {
            options: scaleOptions,
            dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
            dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
          };
        }));
      }
      each(items, (item) => {
        const scaleOptions = item.options;
        const id = scaleOptions.id;
        const axis = determineAxis(id, scaleOptions);
        const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
        if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
          scaleOptions.position = item.dposition;
        }
        updated[id] = true;
        let scale = null;
        if (id in scales2 && scales2[id].type === scaleType) {
          scale = scales2[id];
        } else {
          const scaleClass = registry.getScale(scaleType);
          scale = new scaleClass({
            id,
            type: scaleType,
            ctx: this.ctx,
            chart: this
          });
          scales2[scale.id] = scale;
        }
        scale.init(scaleOptions, options);
      });
      each(updated, (hasUpdated, id) => {
        if (!hasUpdated) {
          delete scales2[id];
        }
      });
      each(scales2, (scale) => {
        layouts.configure(this, scale, scale.options);
        layouts.addBox(this, scale);
      });
    }
    _updateMetasets() {
      const metasets = this._metasets;
      const numData = this.data.datasets.length;
      const numMeta = metasets.length;
      metasets.sort((a2, b) => a2.index - b.index);
      if (numMeta > numData) {
        for (let i2 = numData; i2 < numMeta; ++i2) {
          this._destroyDatasetMeta(i2);
        }
        metasets.splice(numData, numMeta - numData);
      }
      this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
    }
    _removeUnreferencedMetasets() {
      const { _metasets: metasets, data: { datasets } } = this;
      if (metasets.length > datasets.length) {
        delete this._stacks;
      }
      metasets.forEach((meta, index2) => {
        if (datasets.filter((x) => x === meta._dataset).length === 0) {
          this._destroyDatasetMeta(index2);
        }
      });
    }
    buildOrUpdateControllers() {
      const newControllers = [];
      const datasets = this.data.datasets;
      let i2, ilen;
      this._removeUnreferencedMetasets();
      for (i2 = 0, ilen = datasets.length; i2 < ilen; i2++) {
        const dataset = datasets[i2];
        let meta = this.getDatasetMeta(i2);
        const type = dataset.type || this.config.type;
        if (meta.type && meta.type !== type) {
          this._destroyDatasetMeta(i2);
          meta = this.getDatasetMeta(i2);
        }
        meta.type = type;
        meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
        meta.order = dataset.order || 0;
        meta.index = i2;
        meta.label = "" + dataset.label;
        meta.visible = this.isDatasetVisible(i2);
        if (meta.controller) {
          meta.controller.updateIndex(i2);
          meta.controller.linkScales();
        } else {
          const ControllerClass = registry.getController(type);
          const { datasetElementType, dataElementType } = defaults.datasets[type];
          Object.assign(ControllerClass, {
            dataElementType: registry.getElement(dataElementType),
            datasetElementType: datasetElementType && registry.getElement(datasetElementType)
          });
          meta.controller = new ControllerClass(this, i2);
          newControllers.push(meta.controller);
        }
      }
      this._updateMetasets();
      return newControllers;
    }
    _resetElements() {
      each(this.data.datasets, (dataset, datasetIndex) => {
        this.getDatasetMeta(datasetIndex).controller.reset();
      }, this);
    }
    reset() {
      this._resetElements();
      this.notifyPlugins("reset");
    }
    update(mode) {
      const config = this.config;
      config.update();
      const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
      const animsDisabled = this._animationsDisabled = !options.animation;
      this._updateScales();
      this._checkEventBindings();
      this._updateHiddenIndices();
      this._plugins.invalidate();
      if (this.notifyPlugins("beforeUpdate", {
        mode,
        cancelable: true
      }) === false) {
        return;
      }
      const newControllers = this.buildOrUpdateControllers();
      this.notifyPlugins("beforeElementsUpdate");
      let minPadding = 0;
      for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; i2++) {
        const { controller } = this.getDatasetMeta(i2);
        const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
        controller.buildOrUpdateElements(reset);
        minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
      }
      minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
      this._updateLayout(minPadding);
      if (!animsDisabled) {
        each(newControllers, (controller) => {
          controller.reset();
        });
      }
      this._updateDatasets(mode);
      this.notifyPlugins("afterUpdate", {
        mode
      });
      this._layers.sort(compare2Level("z", "_idx"));
      const { _active, _lastEvent } = this;
      if (_lastEvent) {
        this._eventHandler(_lastEvent, true);
      } else if (_active.length) {
        this._updateHoverStyles(_active, _active, true);
      }
      this.render();
    }
    _updateScales() {
      each(this.scales, (scale) => {
        layouts.removeBox(this, scale);
      });
      this.ensureScalesHaveIDs();
      this.buildOrUpdateScales();
    }
    _checkEventBindings() {
      const options = this.options;
      const existingEvents = new Set(Object.keys(this._listeners));
      const newEvents = new Set(options.events);
      if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
        this.unbindEvents();
        this.bindEvents();
      }
    }
    _updateHiddenIndices() {
      const { _hiddenIndices } = this;
      const changes = this._getUniformDataChanges() || [];
      for (const { method, start, count } of changes) {
        const move = method === "_removeElements" ? -count : count;
        moveNumericKeys(_hiddenIndices, start, move);
      }
    }
    _getUniformDataChanges() {
      const _dataChanges = this._dataChanges;
      if (!_dataChanges || !_dataChanges.length) {
        return;
      }
      this._dataChanges = [];
      const datasetCount = this.data.datasets.length;
      const makeSet = (idx) => new Set(_dataChanges.filter((c2) => c2[0] === idx).map((c2, i2) => i2 + "," + c2.splice(1).join(",")));
      const changeSet = makeSet(0);
      for (let i2 = 1; i2 < datasetCount; i2++) {
        if (!setsEqual(changeSet, makeSet(i2))) {
          return;
        }
      }
      return Array.from(changeSet).map((c2) => c2.split(",")).map((a2) => ({
        method: a2[1],
        start: +a2[2],
        count: +a2[3]
      }));
    }
    _updateLayout(minPadding) {
      if (this.notifyPlugins("beforeLayout", {
        cancelable: true
      }) === false) {
        return;
      }
      layouts.update(this, this.width, this.height, minPadding);
      const area = this.chartArea;
      const noArea = area.width <= 0 || area.height <= 0;
      this._layers = [];
      each(this.boxes, (box) => {
        if (noArea && box.position === "chartArea") {
          return;
        }
        if (box.configure) {
          box.configure();
        }
        this._layers.push(...box._layers());
      }, this);
      this._layers.forEach((item, index2) => {
        item._idx = index2;
      });
      this.notifyPlugins("afterLayout");
    }
    _updateDatasets(mode) {
      if (this.notifyPlugins("beforeDatasetsUpdate", {
        mode,
        cancelable: true
      }) === false) {
        return;
      }
      for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
        this.getDatasetMeta(i2).controller.configure();
      }
      for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
        this._updateDataset(i2, isFunction(mode) ? mode({
          datasetIndex: i2
        }) : mode);
      }
      this.notifyPlugins("afterDatasetsUpdate", {
        mode
      });
    }
    _updateDataset(index2, mode) {
      const meta = this.getDatasetMeta(index2);
      const args = {
        meta,
        index: index2,
        mode,
        cancelable: true
      };
      if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
        return;
      }
      meta.controller._update(mode);
      args.cancelable = false;
      this.notifyPlugins("afterDatasetUpdate", args);
    }
    render() {
      if (this.notifyPlugins("beforeRender", {
        cancelable: true
      }) === false) {
        return;
      }
      if (animator.has(this)) {
        if (this.attached && !animator.running(this)) {
          animator.start(this);
        }
      } else {
        this.draw();
        onAnimationsComplete({
          chart: this
        });
      }
    }
    draw() {
      let i2;
      if (this._resizeBeforeDraw) {
        const { width, height } = this._resizeBeforeDraw;
        this._resizeBeforeDraw = null;
        this._resize(width, height);
      }
      this.clear();
      if (this.width <= 0 || this.height <= 0) {
        return;
      }
      if (this.notifyPlugins("beforeDraw", {
        cancelable: true
      }) === false) {
        return;
      }
      const layers = this._layers;
      for (i2 = 0; i2 < layers.length && layers[i2].z <= 0; ++i2) {
        layers[i2].draw(this.chartArea);
      }
      this._drawDatasets();
      for (; i2 < layers.length; ++i2) {
        layers[i2].draw(this.chartArea);
      }
      this.notifyPlugins("afterDraw");
    }
    _getSortedDatasetMetas(filterVisible) {
      const metasets = this._sortedMetasets;
      const result = [];
      let i2, ilen;
      for (i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
        const meta = metasets[i2];
        if (!filterVisible || meta.visible) {
          result.push(meta);
        }
      }
      return result;
    }
    getSortedVisibleDatasetMetas() {
      return this._getSortedDatasetMetas(true);
    }
    _drawDatasets() {
      if (this.notifyPlugins("beforeDatasetsDraw", {
        cancelable: true
      }) === false) {
        return;
      }
      const metasets = this.getSortedVisibleDatasetMetas();
      for (let i2 = metasets.length - 1; i2 >= 0; --i2) {
        this._drawDataset(metasets[i2]);
      }
      this.notifyPlugins("afterDatasetsDraw");
    }
    _drawDataset(meta) {
      const ctx = this.ctx;
      const clip = meta._clip;
      const useClip = !clip.disabled;
      const area = getDatasetArea(meta, this.chartArea);
      const args = {
        meta,
        index: meta.index,
        cancelable: true
      };
      if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
        return;
      }
      if (useClip) {
        clipArea(ctx, {
          left: clip.left === false ? 0 : area.left - clip.left,
          right: clip.right === false ? this.width : area.right + clip.right,
          top: clip.top === false ? 0 : area.top - clip.top,
          bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
        });
      }
      meta.controller.draw();
      if (useClip) {
        unclipArea(ctx);
      }
      args.cancelable = false;
      this.notifyPlugins("afterDatasetDraw", args);
    }
    isPointInArea(point) {
      return _isPointInArea(point, this.chartArea, this._minPadding);
    }
    getElementsAtEventForMode(e2, mode, options, useFinalPosition) {
      const method = Interaction.modes[mode];
      if (typeof method === "function") {
        return method(this, e2, options, useFinalPosition);
      }
      return [];
    }
    getDatasetMeta(datasetIndex) {
      const dataset = this.data.datasets[datasetIndex];
      const metasets = this._metasets;
      let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
      if (!meta) {
        meta = {
          type: null,
          data: [],
          dataset: null,
          controller: null,
          hidden: null,
          xAxisID: null,
          yAxisID: null,
          order: dataset && dataset.order || 0,
          index: datasetIndex,
          _dataset: dataset,
          _parsed: [],
          _sorted: false
        };
        metasets.push(meta);
      }
      return meta;
    }
    getContext() {
      return this.$context || (this.$context = createContext(null, {
        chart: this,
        type: "chart"
      }));
    }
    getVisibleDatasetCount() {
      return this.getSortedVisibleDatasetMetas().length;
    }
    isDatasetVisible(datasetIndex) {
      const dataset = this.data.datasets[datasetIndex];
      if (!dataset) {
        return false;
      }
      const meta = this.getDatasetMeta(datasetIndex);
      return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
    }
    setDatasetVisibility(datasetIndex, visible) {
      const meta = this.getDatasetMeta(datasetIndex);
      meta.hidden = !visible;
    }
    toggleDataVisibility(index2) {
      this._hiddenIndices[index2] = !this._hiddenIndices[index2];
    }
    getDataVisibility(index2) {
      return !this._hiddenIndices[index2];
    }
    _updateVisibility(datasetIndex, dataIndex, visible) {
      const mode = visible ? "show" : "hide";
      const meta = this.getDatasetMeta(datasetIndex);
      const anims = meta.controller._resolveAnimations(void 0, mode);
      if (defined(dataIndex)) {
        meta.data[dataIndex].hidden = !visible;
        this.update();
      } else {
        this.setDatasetVisibility(datasetIndex, visible);
        anims.update(meta, {
          visible
        });
        this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
      }
    }
    hide(datasetIndex, dataIndex) {
      this._updateVisibility(datasetIndex, dataIndex, false);
    }
    show(datasetIndex, dataIndex) {
      this._updateVisibility(datasetIndex, dataIndex, true);
    }
    _destroyDatasetMeta(datasetIndex) {
      const meta = this._metasets[datasetIndex];
      if (meta && meta.controller) {
        meta.controller._destroy();
      }
      delete this._metasets[datasetIndex];
    }
    _stop() {
      let i2, ilen;
      this.stop();
      animator.remove(this);
      for (i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
        this._destroyDatasetMeta(i2);
      }
    }
    destroy() {
      this.notifyPlugins("beforeDestroy");
      const { canvas, ctx } = this;
      this._stop();
      this.config.clearCache();
      if (canvas) {
        this.unbindEvents();
        clearCanvas(canvas, ctx);
        this.platform.releaseContext(ctx);
        this.canvas = null;
        this.ctx = null;
      }
      delete instances[this.id];
      this.notifyPlugins("afterDestroy");
    }
    toBase64Image(...args) {
      return this.canvas.toDataURL(...args);
    }
    bindEvents() {
      this.bindUserEvents();
      if (this.options.responsive) {
        this.bindResponsiveEvents();
      } else {
        this.attached = true;
      }
    }
    bindUserEvents() {
      const listeners = this._listeners;
      const platform = this.platform;
      const _add = (type, listener2) => {
        platform.addEventListener(this, type, listener2);
        listeners[type] = listener2;
      };
      const listener = (e2, x, y) => {
        e2.offsetX = x;
        e2.offsetY = y;
        this._eventHandler(e2);
      };
      each(this.options.events, (type) => _add(type, listener));
    }
    bindResponsiveEvents() {
      if (!this._responsiveListeners) {
        this._responsiveListeners = {};
      }
      const listeners = this._responsiveListeners;
      const platform = this.platform;
      const _add = (type, listener2) => {
        platform.addEventListener(this, type, listener2);
        listeners[type] = listener2;
      };
      const _remove = (type, listener2) => {
        if (listeners[type]) {
          platform.removeEventListener(this, type, listener2);
          delete listeners[type];
        }
      };
      const listener = (width, height) => {
        if (this.canvas) {
          this.resize(width, height);
        }
      };
      let detached;
      const attached = () => {
        _remove("attach", attached);
        this.attached = true;
        this.resize();
        _add("resize", listener);
        _add("detach", detached);
      };
      detached = () => {
        this.attached = false;
        _remove("resize", listener);
        this._stop();
        this._resize(0, 0);
        _add("attach", attached);
      };
      if (platform.isAttached(this.canvas)) {
        attached();
      } else {
        detached();
      }
    }
    unbindEvents() {
      each(this._listeners, (listener, type) => {
        this.platform.removeEventListener(this, type, listener);
      });
      this._listeners = {};
      each(this._responsiveListeners, (listener, type) => {
        this.platform.removeEventListener(this, type, listener);
      });
      this._responsiveListeners = void 0;
    }
    updateHoverStyle(items, mode, enabled) {
      const prefix = enabled ? "set" : "remove";
      let meta, item, i2, ilen;
      if (mode === "dataset") {
        meta = this.getDatasetMeta(items[0].datasetIndex);
        meta.controller["_" + prefix + "DatasetHoverStyle"]();
      }
      for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
        item = items[i2];
        const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
        if (controller) {
          controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
        }
      }
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(activeElements) {
      const lastActive = this._active || [];
      const active = activeElements.map(({ datasetIndex, index: index2 }) => {
        const meta = this.getDatasetMeta(datasetIndex);
        if (!meta) {
          throw new Error("No dataset found at index " + datasetIndex);
        }
        return {
          datasetIndex,
          element: meta.data[index2],
          index: index2
        };
      });
      const changed = !_elementsEqual(active, lastActive);
      if (changed) {
        this._active = active;
        this._lastEvent = null;
        this._updateHoverStyles(active, lastActive);
      }
    }
    notifyPlugins(hook, args, filter) {
      return this._plugins.notify(this, hook, args, filter);
    }
    isPluginEnabled(pluginId) {
      return this._plugins._cache.filter((p) => p.plugin.id === pluginId).length === 1;
    }
    _updateHoverStyles(active, lastActive, replay) {
      const hoverOptions = this.options.hover;
      const diff = (a2, b) => a2.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
      const deactivated = diff(lastActive, active);
      const activated = replay ? active : diff(active, lastActive);
      if (deactivated.length) {
        this.updateHoverStyle(deactivated, hoverOptions.mode, false);
      }
      if (activated.length && hoverOptions.mode) {
        this.updateHoverStyle(activated, hoverOptions.mode, true);
      }
    }
    _eventHandler(e2, replay) {
      const args = {
        event: e2,
        replay,
        cancelable: true,
        inChartArea: this.isPointInArea(e2)
      };
      const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e2.native.type);
      if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
        return;
      }
      const changed = this._handleEvent(e2, replay, args.inChartArea);
      args.cancelable = false;
      this.notifyPlugins("afterEvent", args, eventFilter);
      if (changed || args.changed) {
        this.render();
      }
      return this;
    }
    _handleEvent(e2, replay, inChartArea) {
      const { _active: lastActive = [], options } = this;
      const useFinalPosition = replay;
      const active = this._getActiveElements(e2, lastActive, inChartArea, useFinalPosition);
      const isClick = _isClickEvent(e2);
      const lastEvent = determineLastEvent(e2, this._lastEvent, inChartArea, isClick);
      if (inChartArea) {
        this._lastEvent = null;
        callback(options.onHover, [
          e2,
          active,
          this
        ], this);
        if (isClick) {
          callback(options.onClick, [
            e2,
            active,
            this
          ], this);
        }
      }
      const changed = !_elementsEqual(active, lastActive);
      if (changed || replay) {
        this._active = active;
        this._updateHoverStyles(active, lastActive, replay);
      }
      this._lastEvent = lastEvent;
      return changed;
    }
    _getActiveElements(e2, lastActive, inChartArea, useFinalPosition) {
      if (e2.type === "mouseout") {
        return [];
      }
      if (!inChartArea) {
        return lastActive;
      }
      const hoverOptions = this.options.hover;
      return this.getElementsAtEventForMode(e2, hoverOptions.mode, hoverOptions, useFinalPosition);
    }
  };
  __publicField(Chart, "defaults", defaults);
  __publicField(Chart, "instances", instances);
  __publicField(Chart, "overrides", overrides);
  __publicField(Chart, "registry", registry);
  __publicField(Chart, "version", version);
  __publicField(Chart, "getChart", getChart);
  function invalidatePlugins() {
    return each(Chart.instances, (chart) => chart._plugins.invalidate());
  }
  function clipArc(ctx, element, endAngle) {
    const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
    let angleMargin = pixelMargin / outerRadius;
    ctx.beginPath();
    ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
    if (innerRadius > pixelMargin) {
      angleMargin = pixelMargin / innerRadius;
      ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
    } else {
      ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
    }
    ctx.closePath();
    ctx.clip();
  }
  function toRadiusCorners(value) {
    return _readValueToProps(value, [
      "outerStart",
      "outerEnd",
      "innerStart",
      "innerEnd"
    ]);
  }
  function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
    const o2 = toRadiusCorners(arc.options.borderRadius);
    const halfThickness = (outerRadius - innerRadius) / 2;
    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
    const computeOuterLimit = (val) => {
      const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
      return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
    };
    return {
      outerStart: computeOuterLimit(o2.outerStart),
      outerEnd: computeOuterLimit(o2.outerEnd),
      innerStart: _limitValue(o2.innerStart, 0, innerLimit),
      innerEnd: _limitValue(o2.innerEnd, 0, innerLimit)
    };
  }
  function rThetaToXY(r2, theta, x, y) {
    return {
      x: x + r2 * Math.cos(theta),
      y: y + r2 * Math.sin(theta)
    };
  }
  function pathArc(ctx, element, offset, spacing, end, circular) {
    const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;
    const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
    const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
    let spacingOffset = 0;
    const alpha2 = end - start;
    if (spacing) {
      const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
      const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
      const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
      const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
      spacingOffset = (alpha2 - adjustedAngle) / 2;
    }
    const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
    const angleOffset = (alpha2 - beta) / 2;
    const startAngle = start + angleOffset + spacingOffset;
    const endAngle = end - angleOffset - spacingOffset;
    const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
    const outerStartAdjustedRadius = outerRadius - outerStart;
    const outerEndAdjustedRadius = outerRadius - outerEnd;
    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
    const innerStartAdjustedRadius = innerRadius + innerStart;
    const innerEndAdjustedRadius = innerRadius + innerEnd;
    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
    ctx.beginPath();
    if (circular) {
      const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
      ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
      ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
      if (outerEnd > 0) {
        const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
      }
      const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
      ctx.lineTo(p4.x, p4.y);
      if (innerEnd > 0) {
        const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
      }
      const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
      ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
      ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
      if (innerStart > 0) {
        const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
      }
      const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
      ctx.lineTo(p8.x, p8.y);
      if (outerStart > 0) {
        const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
      }
    } else {
      ctx.moveTo(x, y);
      const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
      const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
      ctx.lineTo(outerStartX, outerStartY);
      const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
      const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
      ctx.lineTo(outerEndX, outerEndY);
    }
    ctx.closePath();
  }
  function drawArc(ctx, element, offset, spacing, circular) {
    const { fullCircles, startAngle, circumference } = element;
    let endAngle = element.endAngle;
    if (fullCircles) {
      pathArc(ctx, element, offset, spacing, endAngle, circular);
      for (let i2 = 0; i2 < fullCircles; ++i2) {
        ctx.fill();
      }
      if (!isNaN(circumference)) {
        endAngle = startAngle + (circumference % TAU || TAU);
      }
    }
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    ctx.fill();
    return endAngle;
  }
  function drawBorder(ctx, element, offset, spacing, circular) {
    const { fullCircles, startAngle, circumference, options } = element;
    const { borderWidth, borderJoinStyle, borderDash, borderDashOffset } = options;
    const inner = options.borderAlign === "inner";
    if (!borderWidth) {
      return;
    }
    ctx.setLineDash(borderDash || []);
    ctx.lineDashOffset = borderDashOffset;
    if (inner) {
      ctx.lineWidth = borderWidth * 2;
      ctx.lineJoin = borderJoinStyle || "round";
    } else {
      ctx.lineWidth = borderWidth;
      ctx.lineJoin = borderJoinStyle || "bevel";
    }
    let endAngle = element.endAngle;
    if (fullCircles) {
      pathArc(ctx, element, offset, spacing, endAngle, circular);
      for (let i2 = 0; i2 < fullCircles; ++i2) {
        ctx.stroke();
      }
      if (!isNaN(circumference)) {
        endAngle = startAngle + (circumference % TAU || TAU);
      }
    }
    if (inner) {
      clipArc(ctx, element, endAngle);
    }
    if (!fullCircles) {
      pathArc(ctx, element, offset, spacing, endAngle, circular);
      ctx.stroke();
    }
  }
  var ArcElement = class extends Element {
    constructor(cfg) {
      super();
      __publicField(this, "circumference");
      __publicField(this, "endAngle");
      __publicField(this, "fullCircles");
      __publicField(this, "innerRadius");
      __publicField(this, "outerRadius");
      __publicField(this, "pixelMargin");
      __publicField(this, "startAngle");
      this.options = void 0;
      this.circumference = void 0;
      this.startAngle = void 0;
      this.endAngle = void 0;
      this.innerRadius = void 0;
      this.outerRadius = void 0;
      this.pixelMargin = 0;
      this.fullCircles = 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    inRange(chartX, chartY, useFinalPosition) {
      const point = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      const { angle, distance } = getAngleFromPoint(point, {
        x: chartX,
        y: chartY
      });
      const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "circumference"
      ], useFinalPosition);
      const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
      const _circumference = valueOrDefault(circumference, endAngle - startAngle);
      const nonZeroBetween = _angleBetween(angle, startAngle, endAngle) && startAngle !== endAngle;
      const betweenAngles = _circumference >= TAU || nonZeroBetween;
      const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
      return betweenAngles && withinRadius;
    }
    getCenterPoint(useFinalPosition) {
      const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ], useFinalPosition);
      const { offset, spacing } = this.options;
      const halfAngle = (startAngle + endAngle) / 2;
      const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
      return {
        x: x + Math.cos(halfAngle) * halfRadius,
        y: y + Math.sin(halfAngle) * halfRadius
      };
    }
    tooltipPosition(useFinalPosition) {
      return this.getCenterPoint(useFinalPosition);
    }
    draw(ctx) {
      const { options, circumference } = this;
      const offset = (options.offset || 0) / 4;
      const spacing = (options.spacing || 0) / 2;
      const circular = options.circular;
      this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
      this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
      if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
        return;
      }
      ctx.save();
      const halfAngle = (this.startAngle + this.endAngle) / 2;
      ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
      const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
      const radiusOffset = offset * fix;
      ctx.fillStyle = options.backgroundColor;
      ctx.strokeStyle = options.borderColor;
      drawArc(ctx, this, radiusOffset, spacing, circular);
      drawBorder(ctx, this, radiusOffset, spacing, circular);
      ctx.restore();
    }
  };
  __publicField(ArcElement, "id", "arc");
  __publicField(ArcElement, "defaults", {
    borderAlign: "center",
    borderColor: "#fff",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: void 0,
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    spacing: 0,
    angle: void 0,
    circular: true
  });
  __publicField(ArcElement, "defaultRoutes", {
    backgroundColor: "backgroundColor"
  });
  __publicField(ArcElement, "descriptors", {
    _scriptable: true,
    _indexable: (name) => name !== "borderDash"
  });
  function setStyle(ctx, options, style = options) {
    ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
    ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
    ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
    ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
    ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
    ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
  }
  function lineTo(ctx, previous, target) {
    ctx.lineTo(target.x, target.y);
  }
  function getLineMethod(options) {
    if (options.stepped) {
      return _steppedLineTo;
    }
    if (options.tension || options.cubicInterpolationMode === "monotone") {
      return _bezierCurveTo;
    }
    return lineTo;
  }
  function pathVars(points, segment, params = {}) {
    const count = points.length;
    const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
    const { start: segmentStart, end: segmentEnd } = segment;
    const start = Math.max(paramsStart, segmentStart);
    const end = Math.min(paramsEnd, segmentEnd);
    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
    return {
      count,
      start,
      loop: segment.loop,
      ilen: end < start && !outside ? count + end - start : end - start
    };
  }
  function pathSegment(ctx, line, segment, params) {
    const { points, options } = line;
    const { count, start, loop, ilen } = pathVars(points, segment, params);
    const lineMethod = getLineMethod(options);
    let { move = true, reverse } = params || {};
    let i2, point, prev;
    for (i2 = 0; i2 <= ilen; ++i2) {
      point = points[(start + (reverse ? ilen - i2 : i2)) % count];
      if (point.skip) {
        continue;
      } else if (move) {
        ctx.moveTo(point.x, point.y);
        move = false;
      } else {
        lineMethod(ctx, prev, point, reverse, options.stepped);
      }
      prev = point;
    }
    if (loop) {
      point = points[(start + (reverse ? ilen : 0)) % count];
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    return !!loop;
  }
  function fastPathSegment(ctx, line, segment, params) {
    const points = line.points;
    const { count, start, ilen } = pathVars(points, segment, params);
    const { move = true, reverse } = params || {};
    let avgX = 0;
    let countX = 0;
    let i2, point, prevX, minY, maxY, lastY;
    const pointIndex = (index2) => (start + (reverse ? ilen - index2 : index2)) % count;
    const drawX = () => {
      if (minY !== maxY) {
        ctx.lineTo(avgX, maxY);
        ctx.lineTo(avgX, minY);
        ctx.lineTo(avgX, lastY);
      }
    };
    if (move) {
      point = points[pointIndex(0)];
      ctx.moveTo(point.x, point.y);
    }
    for (i2 = 0; i2 <= ilen; ++i2) {
      point = points[pointIndex(i2)];
      if (point.skip) {
        continue;
      }
      const x = point.x;
      const y = point.y;
      const truncX = x | 0;
      if (truncX === prevX) {
        if (y < minY) {
          minY = y;
        } else if (y > maxY) {
          maxY = y;
        }
        avgX = (countX * avgX + x) / ++countX;
      } else {
        drawX();
        ctx.lineTo(x, y);
        prevX = truncX;
        countX = 0;
        minY = maxY = y;
      }
      lastY = y;
    }
    drawX();
  }
  function _getSegmentMethod(line) {
    const opts = line.options;
    const borderDash = opts.borderDash && opts.borderDash.length;
    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
    return useFastPath ? fastPathSegment : pathSegment;
  }
  function _getInterpolationMethod(options) {
    if (options.stepped) {
      return _steppedInterpolation;
    }
    if (options.tension || options.cubicInterpolationMode === "monotone") {
      return _bezierInterpolation;
    }
    return _pointInLine;
  }
  function strokePathWithCache(ctx, line, start, count) {
    let path = line._path;
    if (!path) {
      path = line._path = new Path2D();
      if (line.path(path, start, count)) {
        path.closePath();
      }
    }
    setStyle(ctx, line.options);
    ctx.stroke(path);
  }
  function strokePathDirect(ctx, line, start, count) {
    const { segments, options } = line;
    const segmentMethod = _getSegmentMethod(line);
    for (const segment of segments) {
      setStyle(ctx, options, segment.style);
      ctx.beginPath();
      if (segmentMethod(ctx, line, segment, {
        start,
        end: start + count - 1
      })) {
        ctx.closePath();
      }
      ctx.stroke();
    }
  }
  var usePath2D = typeof Path2D === "function";
  function draw(ctx, line, start, count) {
    if (usePath2D && !line.options.segment) {
      strokePathWithCache(ctx, line, start, count);
    } else {
      strokePathDirect(ctx, line, start, count);
    }
  }
  var LineElement = class extends Element {
    constructor(cfg) {
      super();
      this.animated = true;
      this.options = void 0;
      this._chart = void 0;
      this._loop = void 0;
      this._fullLoop = void 0;
      this._path = void 0;
      this._points = void 0;
      this._segments = void 0;
      this._decimated = false;
      this._pointsUpdated = false;
      this._datasetIndex = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    updateControlPoints(chartArea, indexAxis) {
      const options = this.options;
      if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
        const loop = options.spanGaps ? this._loop : this._fullLoop;
        _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
        this._pointsUpdated = true;
      }
    }
    set points(points) {
      this._points = points;
      delete this._segments;
      delete this._path;
      this._pointsUpdated = false;
    }
    get points() {
      return this._points;
    }
    get segments() {
      return this._segments || (this._segments = _computeSegments(this, this.options.segment));
    }
    first() {
      const segments = this.segments;
      const points = this.points;
      return segments.length && points[segments[0].start];
    }
    last() {
      const segments = this.segments;
      const points = this.points;
      const count = segments.length;
      return count && points[segments[count - 1].end];
    }
    interpolate(point, property) {
      const options = this.options;
      const value = point[property];
      const points = this.points;
      const segments = _boundSegments(this, {
        property,
        start: value,
        end: value
      });
      if (!segments.length) {
        return;
      }
      const result = [];
      const _interpolate = _getInterpolationMethod(options);
      let i2, ilen;
      for (i2 = 0, ilen = segments.length; i2 < ilen; ++i2) {
        const { start, end } = segments[i2];
        const p1 = points[start];
        const p2 = points[end];
        if (p1 === p2) {
          result.push(p1);
          continue;
        }
        const t2 = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
        const interpolated = _interpolate(p1, p2, t2, options.stepped);
        interpolated[property] = point[property];
        result.push(interpolated);
      }
      return result.length === 1 ? result[0] : result;
    }
    pathSegment(ctx, segment, params) {
      const segmentMethod = _getSegmentMethod(this);
      return segmentMethod(ctx, this, segment, params);
    }
    path(ctx, start, count) {
      const segments = this.segments;
      const segmentMethod = _getSegmentMethod(this);
      let loop = this._loop;
      start = start || 0;
      count = count || this.points.length - start;
      for (const segment of segments) {
        loop &= segmentMethod(ctx, this, segment, {
          start,
          end: start + count - 1
        });
      }
      return !!loop;
    }
    draw(ctx, chartArea, start, count) {
      const options = this.options || {};
      const points = this.points || [];
      if (points.length && options.borderWidth) {
        ctx.save();
        draw(ctx, this, start, count);
        ctx.restore();
      }
      if (this.animated) {
        this._pointsUpdated = false;
        this._path = void 0;
      }
    }
  };
  __publicField(LineElement, "id", "line");
  __publicField(LineElement, "defaults", {
    borderCapStyle: "butt",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: "miter",
    borderWidth: 3,
    capBezierPoints: true,
    cubicInterpolationMode: "default",
    fill: false,
    spanGaps: false,
    stepped: false,
    tension: 0
  });
  __publicField(LineElement, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  });
  __publicField(LineElement, "descriptors", {
    _scriptable: true,
    _indexable: (name) => name !== "borderDash" && name !== "fill"
  });
  function inRange$1(el, pos, axis, useFinalPosition) {
    const options = el.options;
    const { [axis]: value } = el.getProps([
      axis
    ], useFinalPosition);
    return Math.abs(pos - value) < options.radius + options.hitRadius;
  }
  var PointElement = class extends Element {
    constructor(cfg) {
      super();
      __publicField(this, "parsed");
      __publicField(this, "skip");
      __publicField(this, "stop");
      this.options = void 0;
      this.parsed = void 0;
      this.skip = void 0;
      this.stop = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    inRange(mouseX, mouseY, useFinalPosition) {
      const options = this.options;
      const { x, y } = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
    }
    inXRange(mouseX, useFinalPosition) {
      return inRange$1(this, mouseX, "x", useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
      return inRange$1(this, mouseY, "y", useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
      const { x, y } = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      return {
        x,
        y
      };
    }
    size(options) {
      options = options || this.options || {};
      let radius = options.radius || 0;
      radius = Math.max(radius, radius && options.hoverRadius || 0);
      const borderWidth = radius && options.borderWidth || 0;
      return (radius + borderWidth) * 2;
    }
    draw(ctx, area) {
      const options = this.options;
      if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
        return;
      }
      ctx.strokeStyle = options.borderColor;
      ctx.lineWidth = options.borderWidth;
      ctx.fillStyle = options.backgroundColor;
      drawPoint(ctx, options, this.x, this.y);
    }
    getRange() {
      const options = this.options || {};
      return options.radius + options.hitRadius;
    }
  };
  __publicField(PointElement, "id", "point");
  /**
  * @type {any}
  */
  __publicField(PointElement, "defaults", {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: "circle",
    radius: 3,
    rotation: 0
  });
  /**
  * @type {any}
  */
  __publicField(PointElement, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  });
  function getBarBounds(bar, useFinalPosition) {
    const { x, y, base, width, height } = bar.getProps([
      "x",
      "y",
      "base",
      "width",
      "height"
    ], useFinalPosition);
    let left, right, top2, bottom2, half;
    if (bar.horizontal) {
      half = height / 2;
      left = Math.min(x, base);
      right = Math.max(x, base);
      top2 = y - half;
      bottom2 = y + half;
    } else {
      half = width / 2;
      left = x - half;
      right = x + half;
      top2 = Math.min(y, base);
      bottom2 = Math.max(y, base);
    }
    return {
      left,
      top: top2,
      right,
      bottom: bottom2
    };
  }
  function skipOrLimit(skip2, value, min, max2) {
    return skip2 ? 0 : _limitValue(value, min, max2);
  }
  function parseBorderWidth(bar, maxW, maxH) {
    const value = bar.options.borderWidth;
    const skip2 = bar.borderSkipped;
    const o2 = toTRBL(value);
    return {
      t: skipOrLimit(skip2.top, o2.top, 0, maxH),
      r: skipOrLimit(skip2.right, o2.right, 0, maxW),
      b: skipOrLimit(skip2.bottom, o2.bottom, 0, maxH),
      l: skipOrLimit(skip2.left, o2.left, 0, maxW)
    };
  }
  function parseBorderRadius(bar, maxW, maxH) {
    const { enableBorderRadius } = bar.getProps([
      "enableBorderRadius"
    ]);
    const value = bar.options.borderRadius;
    const o2 = toTRBLCorners(value);
    const maxR = Math.min(maxW, maxH);
    const skip2 = bar.borderSkipped;
    const enableBorder = enableBorderRadius || isObject2(value);
    return {
      topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o2.topLeft, 0, maxR),
      topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o2.topRight, 0, maxR),
      bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o2.bottomLeft, 0, maxR),
      bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o2.bottomRight, 0, maxR)
    };
  }
  function boundingRects(bar) {
    const bounds = getBarBounds(bar);
    const width = bounds.right - bounds.left;
    const height = bounds.bottom - bounds.top;
    const border = parseBorderWidth(bar, width / 2, height / 2);
    const radius = parseBorderRadius(bar, width / 2, height / 2);
    return {
      outer: {
        x: bounds.left,
        y: bounds.top,
        w: width,
        h: height,
        radius
      },
      inner: {
        x: bounds.left + border.l,
        y: bounds.top + border.t,
        w: width - border.l - border.r,
        h: height - border.t - border.b,
        radius: {
          topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
          topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
          bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
          bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
        }
      }
    };
  }
  function inRange(bar, x, y, useFinalPosition) {
    const skipX = x === null;
    const skipY = y === null;
    const skipBoth = skipX && skipY;
    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
    return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
  }
  function hasRadius(radius) {
    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
  }
  function addNormalRectPath(ctx, rect) {
    ctx.rect(rect.x, rect.y, rect.w, rect.h);
  }
  function inflateRect(rect, amount, refRect = {}) {
    const x = rect.x !== refRect.x ? -amount : 0;
    const y = rect.y !== refRect.y ? -amount : 0;
    const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
    const h3 = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
    return {
      x: rect.x + x,
      y: rect.y + y,
      w: rect.w + w,
      h: rect.h + h3,
      radius: rect.radius
    };
  }
  var BarElement = class extends Element {
    constructor(cfg) {
      super();
      this.options = void 0;
      this.horizontal = void 0;
      this.base = void 0;
      this.width = void 0;
      this.height = void 0;
      this.inflateAmount = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    draw(ctx) {
      const { inflateAmount, options: { borderColor, backgroundColor } } = this;
      const { inner, outer } = boundingRects(this);
      const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
      ctx.save();
      if (outer.w !== inner.w || outer.h !== inner.h) {
        ctx.beginPath();
        addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
        ctx.clip();
        addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
        ctx.fillStyle = borderColor;
        ctx.fill("evenodd");
      }
      ctx.beginPath();
      addRectPath(ctx, inflateRect(inner, inflateAmount));
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
    inRange(mouseX, mouseY, useFinalPosition) {
      return inRange(this, mouseX, mouseY, useFinalPosition);
    }
    inXRange(mouseX, useFinalPosition) {
      return inRange(this, mouseX, null, useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
      return inRange(this, null, mouseY, useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
      const { x, y, base, horizontal } = this.getProps([
        "x",
        "y",
        "base",
        "horizontal"
      ], useFinalPosition);
      return {
        x: horizontal ? (x + base) / 2 : x,
        y: horizontal ? y : (y + base) / 2
      };
    }
    getRange(axis) {
      return axis === "x" ? this.width / 2 : this.height / 2;
    }
  };
  __publicField(BarElement, "id", "bar");
  __publicField(BarElement, "defaults", {
    borderSkipped: "start",
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: "auto",
    pointStyle: void 0
  });
  __publicField(BarElement, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  });
  var elements = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ArcElement,
    BarElement,
    LineElement,
    PointElement
  });
  var BORDER_COLORS = [
    "rgb(54, 162, 235)",
    "rgb(255, 99, 132)",
    "rgb(255, 159, 64)",
    "rgb(255, 205, 86)",
    "rgb(75, 192, 192)",
    "rgb(153, 102, 255)",
    "rgb(201, 203, 207)"
    // grey
  ];
  var BACKGROUND_COLORS = /* @__PURE__ */ BORDER_COLORS.map((color2) => color2.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
  function getBorderColor(i2) {
    return BORDER_COLORS[i2 % BORDER_COLORS.length];
  }
  function getBackgroundColor(i2) {
    return BACKGROUND_COLORS[i2 % BACKGROUND_COLORS.length];
  }
  function colorizeDefaultDataset(dataset, i2) {
    dataset.borderColor = getBorderColor(i2);
    dataset.backgroundColor = getBackgroundColor(i2);
    return ++i2;
  }
  function colorizeDoughnutDataset(dataset, i2) {
    dataset.backgroundColor = dataset.data.map(() => getBorderColor(i2++));
    return i2;
  }
  function colorizePolarAreaDataset(dataset, i2) {
    dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i2++));
    return i2;
  }
  function getColorizer(chart) {
    let i2 = 0;
    return (dataset, datasetIndex) => {
      const controller = chart.getDatasetMeta(datasetIndex).controller;
      if (controller instanceof DoughnutController) {
        i2 = colorizeDoughnutDataset(dataset, i2);
      } else if (controller instanceof PolarAreaController) {
        i2 = colorizePolarAreaDataset(dataset, i2);
      } else if (controller) {
        i2 = colorizeDefaultDataset(dataset, i2);
      }
    };
  }
  function containsColorsDefinitions(descriptors2) {
    let k;
    for (k in descriptors2) {
      if (descriptors2[k].borderColor || descriptors2[k].backgroundColor) {
        return true;
      }
    }
    return false;
  }
  function containsColorsDefinition(descriptor) {
    return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
  }
  function containsDefaultColorsDefenitions() {
    return defaults.borderColor !== "rgba(0,0,0,0.1)" || defaults.backgroundColor !== "rgba(0,0,0,0.1)";
  }
  var plugin_colors = {
    id: "colors",
    defaults: {
      enabled: true,
      forceOverride: false
    },
    beforeLayout(chart, _args, options) {
      if (!options.enabled) {
        return;
      }
      const { data: { datasets }, options: chartOptions } = chart.config;
      const { elements: elements2 } = chartOptions;
      const containsColorDefenition = containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements2 && containsColorsDefinitions(elements2) || containsDefaultColorsDefenitions();
      if (!options.forceOverride && containsColorDefenition) {
        return;
      }
      const colorizer = getColorizer(chart);
      datasets.forEach(colorizer);
    }
  };
  function lttbDecimation(data, start, count, availableWidth, options) {
    const samples = options.samples || availableWidth;
    if (samples >= count) {
      return data.slice(start, start + count);
    }
    const decimated = [];
    const bucketWidth = (count - 2) / (samples - 2);
    let sampledIndex = 0;
    const endIndex = start + count - 1;
    let a2 = start;
    let i2, maxAreaPoint, maxArea, area, nextA;
    decimated[sampledIndex++] = data[a2];
    for (i2 = 0; i2 < samples - 2; i2++) {
      let avgX = 0;
      let avgY = 0;
      let j;
      const avgRangeStart = Math.floor((i2 + 1) * bucketWidth) + 1 + start;
      const avgRangeEnd = Math.min(Math.floor((i2 + 2) * bucketWidth) + 1, count) + start;
      const avgRangeLength = avgRangeEnd - avgRangeStart;
      for (j = avgRangeStart; j < avgRangeEnd; j++) {
        avgX += data[j].x;
        avgY += data[j].y;
      }
      avgX /= avgRangeLength;
      avgY /= avgRangeLength;
      const rangeOffs = Math.floor(i2 * bucketWidth) + 1 + start;
      const rangeTo = Math.min(Math.floor((i2 + 1) * bucketWidth) + 1, count) + start;
      const { x: pointAx, y: pointAy } = data[a2];
      maxArea = area = -1;
      for (j = rangeOffs; j < rangeTo; j++) {
        area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
        if (area > maxArea) {
          maxArea = area;
          maxAreaPoint = data[j];
          nextA = j;
        }
      }
      decimated[sampledIndex++] = maxAreaPoint;
      a2 = nextA;
    }
    decimated[sampledIndex++] = data[endIndex];
    return decimated;
  }
  function minMaxDecimation(data, start, count, availableWidth) {
    let avgX = 0;
    let countX = 0;
    let i2, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
    const decimated = [];
    const endIndex = start + count - 1;
    const xMin = data[start].x;
    const xMax = data[endIndex].x;
    const dx = xMax - xMin;
    for (i2 = start; i2 < start + count; ++i2) {
      point = data[i2];
      x = (point.x - xMin) / dx * availableWidth;
      y = point.y;
      const truncX = x | 0;
      if (truncX === prevX) {
        if (y < minY) {
          minY = y;
          minIndex = i2;
        } else if (y > maxY) {
          maxY = y;
          maxIndex = i2;
        }
        avgX = (countX * avgX + point.x) / ++countX;
      } else {
        const lastIndex = i2 - 1;
        if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
          const intermediateIndex1 = Math.min(minIndex, maxIndex);
          const intermediateIndex2 = Math.max(minIndex, maxIndex);
          if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
            decimated.push(__spreadProps(__spreadValues({}, data[intermediateIndex1]), {
              x: avgX
            }));
          }
          if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
            decimated.push(__spreadProps(__spreadValues({}, data[intermediateIndex2]), {
              x: avgX
            }));
          }
        }
        if (i2 > 0 && lastIndex !== startIndex) {
          decimated.push(data[lastIndex]);
        }
        decimated.push(point);
        prevX = truncX;
        countX = 0;
        minY = maxY = y;
        minIndex = maxIndex = startIndex = i2;
      }
    }
    return decimated;
  }
  function cleanDecimatedDataset(dataset) {
    if (dataset._decimated) {
      const data = dataset._data;
      delete dataset._decimated;
      delete dataset._data;
      Object.defineProperty(dataset, "data", {
        configurable: true,
        enumerable: true,
        writable: true,
        value: data
      });
    }
  }
  function cleanDecimatedData(chart) {
    chart.data.datasets.forEach((dataset) => {
      cleanDecimatedDataset(dataset);
    });
  }
  function getStartAndCountOfVisiblePointsSimplified(meta, points) {
    const pointCount = points.length;
    let start = 0;
    let count;
    const { iScale } = meta;
    const { min, max: max2, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(_lookupByKey(points, iScale.axis, max2).hi + 1, start, pointCount) - start;
    } else {
      count = pointCount - start;
    }
    return {
      start,
      count
    };
  }
  var plugin_decimation = {
    id: "decimation",
    defaults: {
      algorithm: "min-max",
      enabled: false
    },
    beforeElementsUpdate: (chart, args, options) => {
      if (!options.enabled) {
        cleanDecimatedData(chart);
        return;
      }
      const availableWidth = chart.width;
      chart.data.datasets.forEach((dataset, datasetIndex) => {
        const { _data, indexAxis } = dataset;
        const meta = chart.getDatasetMeta(datasetIndex);
        const data = _data || dataset.data;
        if (resolve([
          indexAxis,
          chart.options.indexAxis
        ]) === "y") {
          return;
        }
        if (!meta.controller.supportsDecimation) {
          return;
        }
        const xAxis = chart.scales[meta.xAxisID];
        if (xAxis.type !== "linear" && xAxis.type !== "time") {
          return;
        }
        if (chart.options.parsing) {
          return;
        }
        let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
        const threshold = options.threshold || 4 * availableWidth;
        if (count <= threshold) {
          cleanDecimatedDataset(dataset);
          return;
        }
        if (isNullOrUndef(_data)) {
          dataset._data = data;
          delete dataset.data;
          Object.defineProperty(dataset, "data", {
            configurable: true,
            enumerable: true,
            get: function() {
              return this._decimated;
            },
            set: function(d2) {
              this._data = d2;
            }
          });
        }
        let decimated;
        switch (options.algorithm) {
          case "lttb":
            decimated = lttbDecimation(data, start, count, availableWidth, options);
            break;
          case "min-max":
            decimated = minMaxDecimation(data, start, count, availableWidth);
            break;
          default:
            throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
        }
        dataset._decimated = decimated;
      });
    },
    destroy(chart) {
      cleanDecimatedData(chart);
    }
  };
  function _segments(line, target, property) {
    const segments = line.segments;
    const points = line.points;
    const tpoints = target.points;
    const parts = [];
    for (const segment of segments) {
      let { start, end } = segment;
      end = _findSegmentEnd(start, end, points);
      const bounds = _getBounds(property, points[start], points[end], segment.loop);
      if (!target.segments) {
        parts.push({
          source: segment,
          target: bounds,
          start: points[start],
          end: points[end]
        });
        continue;
      }
      const targetSegments = _boundSegments(target, bounds);
      for (const tgt of targetSegments) {
        const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
        const fillSources = _boundSegment(segment, points, subBounds);
        for (const fillSource of fillSources) {
          parts.push({
            source: fillSource,
            target: tgt,
            start: {
              [property]: _getEdge(bounds, subBounds, "start", Math.max)
            },
            end: {
              [property]: _getEdge(bounds, subBounds, "end", Math.min)
            }
          });
        }
      }
    }
    return parts;
  }
  function _getBounds(property, first, last, loop) {
    if (loop) {
      return;
    }
    let start = first[property];
    let end = last[property];
    if (property === "angle") {
      start = _normalizeAngle(start);
      end = _normalizeAngle(end);
    }
    return {
      property,
      start,
      end
    };
  }
  function _pointsFromSegments(boundary, line) {
    const { x = null, y = null } = boundary || {};
    const linePoints = line.points;
    const points = [];
    line.segments.forEach(({ start, end }) => {
      end = _findSegmentEnd(start, end, linePoints);
      const first = linePoints[start];
      const last = linePoints[end];
      if (y !== null) {
        points.push({
          x: first.x,
          y
        });
        points.push({
          x: last.x,
          y
        });
      } else if (x !== null) {
        points.push({
          x,
          y: first.y
        });
        points.push({
          x,
          y: last.y
        });
      }
    });
    return points;
  }
  function _findSegmentEnd(start, end, points) {
    for (; end > start; end--) {
      const point = points[end];
      if (!isNaN(point.x) && !isNaN(point.y)) {
        break;
      }
    }
    return end;
  }
  function _getEdge(a2, b, prop, fn) {
    if (a2 && b) {
      return fn(a2[prop], b[prop]);
    }
    return a2 ? a2[prop] : b ? b[prop] : 0;
  }
  function _createBoundaryLine(boundary, line) {
    let points = [];
    let _loop = false;
    if (isArray(boundary)) {
      _loop = true;
      points = boundary;
    } else {
      points = _pointsFromSegments(boundary, line);
    }
    return points.length ? new LineElement({
      points,
      options: {
        tension: 0
      },
      _loop,
      _fullLoop: _loop
    }) : null;
  }
  function _shouldApplyFill(source) {
    return source && source.fill !== false;
  }
  function _resolveTarget(sources, index2, propagate) {
    const source = sources[index2];
    let fill2 = source.fill;
    const visited = [
      index2
    ];
    let target;
    if (!propagate) {
      return fill2;
    }
    while (fill2 !== false && visited.indexOf(fill2) === -1) {
      if (!isNumberFinite(fill2)) {
        return fill2;
      }
      target = sources[fill2];
      if (!target) {
        return false;
      }
      if (target.visible) {
        return fill2;
      }
      visited.push(fill2);
      fill2 = target.fill;
    }
    return false;
  }
  function _decodeFill(line, index2, count) {
    const fill2 = parseFillOption(line);
    if (isObject2(fill2)) {
      return isNaN(fill2.value) ? false : fill2;
    }
    let target = parseFloat(fill2);
    if (isNumberFinite(target) && Math.floor(target) === target) {
      return decodeTargetIndex(fill2[0], index2, target, count);
    }
    return [
      "origin",
      "start",
      "end",
      "stack",
      "shape"
    ].indexOf(fill2) >= 0 && fill2;
  }
  function decodeTargetIndex(firstCh, index2, target, count) {
    if (firstCh === "-" || firstCh === "+") {
      target = index2 + target;
    }
    if (target === index2 || target < 0 || target >= count) {
      return false;
    }
    return target;
  }
  function _getTargetPixel(fill2, scale) {
    let pixel = null;
    if (fill2 === "start") {
      pixel = scale.bottom;
    } else if (fill2 === "end") {
      pixel = scale.top;
    } else if (isObject2(fill2)) {
      pixel = scale.getPixelForValue(fill2.value);
    } else if (scale.getBasePixel) {
      pixel = scale.getBasePixel();
    }
    return pixel;
  }
  function _getTargetValue(fill2, scale, startValue) {
    let value;
    if (fill2 === "start") {
      value = startValue;
    } else if (fill2 === "end") {
      value = scale.options.reverse ? scale.min : scale.max;
    } else if (isObject2(fill2)) {
      value = fill2.value;
    } else {
      value = scale.getBaseValue();
    }
    return value;
  }
  function parseFillOption(line) {
    const options = line.options;
    const fillOption = options.fill;
    let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
    if (fill2 === void 0) {
      fill2 = !!options.backgroundColor;
    }
    if (fill2 === false || fill2 === null) {
      return false;
    }
    if (fill2 === true) {
      return "origin";
    }
    return fill2;
  }
  function _buildStackLine(source) {
    const { scale, index: index2, line } = source;
    const points = [];
    const segments = line.segments;
    const sourcePoints = line.points;
    const linesBelow = getLinesBelow(scale, index2);
    linesBelow.push(_createBoundaryLine({
      x: null,
      y: scale.bottom
    }, line));
    for (let i2 = 0; i2 < segments.length; i2++) {
      const segment = segments[i2];
      for (let j = segment.start; j <= segment.end; j++) {
        addPointsBelow(points, sourcePoints[j], linesBelow);
      }
    }
    return new LineElement({
      points,
      options: {}
    });
  }
  function getLinesBelow(scale, index2) {
    const below = [];
    const metas = scale.getMatchingVisibleMetas("line");
    for (let i2 = 0; i2 < metas.length; i2++) {
      const meta = metas[i2];
      if (meta.index === index2) {
        break;
      }
      if (!meta.hidden) {
        below.unshift(meta.dataset);
      }
    }
    return below;
  }
  function addPointsBelow(points, sourcePoint, linesBelow) {
    const postponed = [];
    for (let j = 0; j < linesBelow.length; j++) {
      const line = linesBelow[j];
      const { first, last, point } = findPoint(line, sourcePoint, "x");
      if (!point || first && last) {
        continue;
      }
      if (first) {
        postponed.unshift(point);
      } else {
        points.push(point);
        if (!last) {
          break;
        }
      }
    }
    points.push(...postponed);
  }
  function findPoint(line, sourcePoint, property) {
    const point = line.interpolate(sourcePoint, property);
    if (!point) {
      return {};
    }
    const pointValue = point[property];
    const segments = line.segments;
    const linePoints = line.points;
    let first = false;
    let last = false;
    for (let i2 = 0; i2 < segments.length; i2++) {
      const segment = segments[i2];
      const firstValue = linePoints[segment.start][property];
      const lastValue = linePoints[segment.end][property];
      if (_isBetween(pointValue, firstValue, lastValue)) {
        first = pointValue === firstValue;
        last = pointValue === lastValue;
        break;
      }
    }
    return {
      first,
      last,
      point
    };
  }
  var simpleArc = class {
    constructor(opts) {
      this.x = opts.x;
      this.y = opts.y;
      this.radius = opts.radius;
    }
    pathSegment(ctx, bounds, opts) {
      const { x, y, radius } = this;
      bounds = bounds || {
        start: 0,
        end: TAU
      };
      ctx.arc(x, y, radius, bounds.end, bounds.start, true);
      return !opts.bounds;
    }
    interpolate(point) {
      const { x, y, radius } = this;
      const angle = point.angle;
      return {
        x: x + Math.cos(angle) * radius,
        y: y + Math.sin(angle) * radius,
        angle
      };
    }
  };
  function _getTarget(source) {
    const { chart, fill: fill2, line } = source;
    if (isNumberFinite(fill2)) {
      return getLineByIndex(chart, fill2);
    }
    if (fill2 === "stack") {
      return _buildStackLine(source);
    }
    if (fill2 === "shape") {
      return true;
    }
    const boundary = computeBoundary(source);
    if (boundary instanceof simpleArc) {
      return boundary;
    }
    return _createBoundaryLine(boundary, line);
  }
  function getLineByIndex(chart, index2) {
    const meta = chart.getDatasetMeta(index2);
    const visible = meta && chart.isDatasetVisible(index2);
    return visible ? meta.dataset : null;
  }
  function computeBoundary(source) {
    const scale = source.scale || {};
    if (scale.getPointPositionForValue) {
      return computeCircularBoundary(source);
    }
    return computeLinearBoundary(source);
  }
  function computeLinearBoundary(source) {
    const { scale = {}, fill: fill2 } = source;
    const pixel = _getTargetPixel(fill2, scale);
    if (isNumberFinite(pixel)) {
      const horizontal = scale.isHorizontal();
      return {
        x: horizontal ? pixel : null,
        y: horizontal ? null : pixel
      };
    }
    return null;
  }
  function computeCircularBoundary(source) {
    const { scale, fill: fill2 } = source;
    const options = scale.options;
    const length = scale.getLabels().length;
    const start = options.reverse ? scale.max : scale.min;
    const value = _getTargetValue(fill2, scale, start);
    const target = [];
    if (options.grid.circular) {
      const center = scale.getPointPositionForValue(0, start);
      return new simpleArc({
        x: center.x,
        y: center.y,
        radius: scale.getDistanceFromCenterForValue(value)
      });
    }
    for (let i2 = 0; i2 < length; ++i2) {
      target.push(scale.getPointPositionForValue(i2, value));
    }
    return target;
  }
  function _drawfill(ctx, source, area) {
    const target = _getTarget(source);
    const { line, scale, axis } = source;
    const lineOpts = line.options;
    const fillOption = lineOpts.fill;
    const color2 = lineOpts.backgroundColor;
    const { above = color2, below = color2 } = fillOption || {};
    if (target && line.points.length) {
      clipArea(ctx, area);
      doFill(ctx, {
        line,
        target,
        above,
        below,
        area,
        scale,
        axis
      });
      unclipArea(ctx);
    }
  }
  function doFill(ctx, cfg) {
    const { line, target, above, below, area, scale } = cfg;
    const property = line._loop ? "angle" : cfg.axis;
    ctx.save();
    if (property === "x" && below !== above) {
      clipVertical(ctx, target, area.top);
      fill(ctx, {
        line,
        target,
        color: above,
        scale,
        property
      });
      ctx.restore();
      ctx.save();
      clipVertical(ctx, target, area.bottom);
    }
    fill(ctx, {
      line,
      target,
      color: below,
      scale,
      property
    });
    ctx.restore();
  }
  function clipVertical(ctx, target, clipY) {
    const { segments, points } = target;
    let first = true;
    let lineLoop = false;
    ctx.beginPath();
    for (const segment of segments) {
      const { start, end } = segment;
      const firstPoint = points[start];
      const lastPoint = points[_findSegmentEnd(start, end, points)];
      if (first) {
        ctx.moveTo(firstPoint.x, firstPoint.y);
        first = false;
      } else {
        ctx.lineTo(firstPoint.x, clipY);
        ctx.lineTo(firstPoint.x, firstPoint.y);
      }
      lineLoop = !!target.pathSegment(ctx, segment, {
        move: lineLoop
      });
      if (lineLoop) {
        ctx.closePath();
      } else {
        ctx.lineTo(lastPoint.x, clipY);
      }
    }
    ctx.lineTo(target.first().x, clipY);
    ctx.closePath();
    ctx.clip();
  }
  function fill(ctx, cfg) {
    const { line, target, property, color: color2, scale } = cfg;
    const segments = _segments(line, target, property);
    for (const { source: src, target: tgt, start, end } of segments) {
      const { style: { backgroundColor = color2 } = {} } = src;
      const notShape = target !== true;
      ctx.save();
      ctx.fillStyle = backgroundColor;
      clipBounds(ctx, scale, notShape && _getBounds(property, start, end));
      ctx.beginPath();
      const lineLoop = !!line.pathSegment(ctx, src);
      let loop;
      if (notShape) {
        if (lineLoop) {
          ctx.closePath();
        } else {
          interpolatedLineTo(ctx, target, end, property);
        }
        const targetLoop = !!target.pathSegment(ctx, tgt, {
          move: lineLoop,
          reverse: true
        });
        loop = lineLoop && targetLoop;
        if (!loop) {
          interpolatedLineTo(ctx, target, start, property);
        }
      }
      ctx.closePath();
      ctx.fill(loop ? "evenodd" : "nonzero");
      ctx.restore();
    }
  }
  function clipBounds(ctx, scale, bounds) {
    const { top: top2, bottom: bottom2 } = scale.chart.chartArea;
    const { property, start, end } = bounds || {};
    if (property === "x") {
      ctx.beginPath();
      ctx.rect(start, top2, end - start, bottom2 - top2);
      ctx.clip();
    }
  }
  function interpolatedLineTo(ctx, target, point, property) {
    const interpolatedPoint = target.interpolate(point, property);
    if (interpolatedPoint) {
      ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
    }
  }
  var index = {
    id: "filler",
    afterDatasetsUpdate(chart, _args, options) {
      const count = (chart.data.datasets || []).length;
      const sources = [];
      let meta, i2, line, source;
      for (i2 = 0; i2 < count; ++i2) {
        meta = chart.getDatasetMeta(i2);
        line = meta.dataset;
        source = null;
        if (line && line.options && line instanceof LineElement) {
          source = {
            visible: chart.isDatasetVisible(i2),
            index: i2,
            fill: _decodeFill(line, i2, count),
            chart,
            axis: meta.controller.options.indexAxis,
            scale: meta.vScale,
            line
          };
        }
        meta.$filler = source;
        sources.push(source);
      }
      for (i2 = 0; i2 < count; ++i2) {
        source = sources[i2];
        if (!source || source.fill === false) {
          continue;
        }
        source.fill = _resolveTarget(sources, i2, options.propagate);
      }
    },
    beforeDraw(chart, _args, options) {
      const draw2 = options.drawTime === "beforeDraw";
      const metasets = chart.getSortedVisibleDatasetMetas();
      const area = chart.chartArea;
      for (let i2 = metasets.length - 1; i2 >= 0; --i2) {
        const source = metasets[i2].$filler;
        if (!source) {
          continue;
        }
        source.line.updateControlPoints(area, source.axis);
        if (draw2 && source.fill) {
          _drawfill(chart.ctx, source, area);
        }
      }
    },
    beforeDatasetsDraw(chart, _args, options) {
      if (options.drawTime !== "beforeDatasetsDraw") {
        return;
      }
      const metasets = chart.getSortedVisibleDatasetMetas();
      for (let i2 = metasets.length - 1; i2 >= 0; --i2) {
        const source = metasets[i2].$filler;
        if (_shouldApplyFill(source)) {
          _drawfill(chart.ctx, source, chart.chartArea);
        }
      }
    },
    beforeDatasetDraw(chart, args, options) {
      const source = args.meta.$filler;
      if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
        return;
      }
      _drawfill(chart.ctx, source, chart.chartArea);
    },
    defaults: {
      propagate: true,
      drawTime: "beforeDatasetDraw"
    }
  };
  var getBoxSize = (labelOpts, fontSize) => {
    let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
    if (labelOpts.usePointStyle) {
      boxHeight = Math.min(boxHeight, fontSize);
      boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
    }
    return {
      boxWidth,
      boxHeight,
      itemHeight: Math.max(fontSize, boxHeight)
    };
  };
  var itemsEqual = (a2, b) => a2 !== null && b !== null && a2.datasetIndex === b.datasetIndex && a2.index === b.index;
  var Legend = class extends Element {
    constructor(config) {
      super();
      this._added = false;
      this.legendHitBoxes = [];
      this._hoveredItem = null;
      this.doughnutMode = false;
      this.chart = config.chart;
      this.options = config.options;
      this.ctx = config.ctx;
      this.legendItems = void 0;
      this.columnSizes = void 0;
      this.lineWidths = void 0;
      this.maxHeight = void 0;
      this.maxWidth = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.height = void 0;
      this.width = void 0;
      this._margins = void 0;
      this.position = void 0;
      this.weight = void 0;
      this.fullSize = void 0;
    }
    update(maxWidth, maxHeight, margins) {
      this.maxWidth = maxWidth;
      this.maxHeight = maxHeight;
      this._margins = margins;
      this.setDimensions();
      this.buildLabels();
      this.fit();
    }
    setDimensions() {
      if (this.isHorizontal()) {
        this.width = this.maxWidth;
        this.left = this._margins.left;
        this.right = this.width;
      } else {
        this.height = this.maxHeight;
        this.top = this._margins.top;
        this.bottom = this.height;
      }
    }
    buildLabels() {
      const labelOpts = this.options.labels || {};
      let legendItems = callback(labelOpts.generateLabels, [
        this.chart
      ], this) || [];
      if (labelOpts.filter) {
        legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
      }
      if (labelOpts.sort) {
        legendItems = legendItems.sort((a2, b) => labelOpts.sort(a2, b, this.chart.data));
      }
      if (this.options.reverse) {
        legendItems.reverse();
      }
      this.legendItems = legendItems;
    }
    fit() {
      const { options, ctx } = this;
      if (!options.display) {
        this.width = this.height = 0;
        return;
      }
      const labelOpts = options.labels;
      const labelFont = toFont(labelOpts.font);
      const fontSize = labelFont.size;
      const titleHeight = this._computeTitleHeight();
      const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
      let width, height;
      ctx.font = labelFont.string;
      if (this.isHorizontal()) {
        width = this.maxWidth;
        height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
      } else {
        height = this.maxHeight;
        width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
      }
      this.width = Math.min(width, options.maxWidth || this.maxWidth);
      this.height = Math.min(height, options.maxHeight || this.maxHeight);
    }
    _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
      const { ctx, maxWidth, options: { labels: { padding } } } = this;
      const hitboxes = this.legendHitBoxes = [];
      const lineWidths = this.lineWidths = [
        0
      ];
      const lineHeight = itemHeight + padding;
      let totalHeight = titleHeight;
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      let row = -1;
      let top2 = -lineHeight;
      this.legendItems.forEach((legendItem, i2) => {
        const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
        if (i2 === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
          totalHeight += lineHeight;
          lineWidths[lineWidths.length - (i2 > 0 ? 0 : 1)] = 0;
          top2 += lineHeight;
          row++;
        }
        hitboxes[i2] = {
          left: 0,
          top: top2,
          row,
          width: itemWidth,
          height: itemHeight
        };
        lineWidths[lineWidths.length - 1] += itemWidth + padding;
      });
      return totalHeight;
    }
    _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
      const { ctx, maxHeight, options: { labels: { padding } } } = this;
      const hitboxes = this.legendHitBoxes = [];
      const columnSizes = this.columnSizes = [];
      const heightLimit = maxHeight - titleHeight;
      let totalWidth = padding;
      let currentColWidth = 0;
      let currentColHeight = 0;
      let left = 0;
      let col = 0;
      this.legendItems.forEach((legendItem, i2) => {
        const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
        if (i2 > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
          totalWidth += currentColWidth + padding;
          columnSizes.push({
            width: currentColWidth,
            height: currentColHeight
          });
          left += currentColWidth + padding;
          col++;
          currentColWidth = currentColHeight = 0;
        }
        hitboxes[i2] = {
          left,
          top: currentColHeight,
          col,
          width: itemWidth,
          height: itemHeight
        };
        currentColWidth = Math.max(currentColWidth, itemWidth);
        currentColHeight += itemHeight + padding;
      });
      totalWidth += currentColWidth;
      columnSizes.push({
        width: currentColWidth,
        height: currentColHeight
      });
      return totalWidth;
    }
    adjustHitBoxes() {
      if (!this.options.display) {
        return;
      }
      const titleHeight = this._computeTitleHeight();
      const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
      const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
      if (this.isHorizontal()) {
        let row = 0;
        let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        for (const hitbox of hitboxes) {
          if (row !== hitbox.row) {
            row = hitbox.row;
            left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
          }
          hitbox.top += this.top + titleHeight + padding;
          hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
          left += hitbox.width + padding;
        }
      } else {
        let col = 0;
        let top2 = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        for (const hitbox of hitboxes) {
          if (hitbox.col !== col) {
            col = hitbox.col;
            top2 = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
          }
          hitbox.top = top2;
          hitbox.left += this.left + padding;
          hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
          top2 += hitbox.height + padding;
        }
      }
    }
    isHorizontal() {
      return this.options.position === "top" || this.options.position === "bottom";
    }
    draw() {
      if (this.options.display) {
        const ctx = this.ctx;
        clipArea(ctx, this);
        this._draw();
        unclipArea(ctx);
      }
    }
    _draw() {
      const { options: opts, columnSizes, lineWidths, ctx } = this;
      const { align, labels: labelOpts } = opts;
      const defaultColor = defaults.color;
      const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
      const labelFont = toFont(labelOpts.font);
      const { padding } = labelOpts;
      const fontSize = labelFont.size;
      const halfFontSize = fontSize / 2;
      let cursor;
      this.drawTitle();
      ctx.textAlign = rtlHelper.textAlign("left");
      ctx.textBaseline = "middle";
      ctx.lineWidth = 0.5;
      ctx.font = labelFont.string;
      const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
      const drawLegendBox = function(x, y, legendItem) {
        if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
          return;
        }
        ctx.save();
        const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
        ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
        ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
        ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
        ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
        ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
        if (labelOpts.usePointStyle) {
          const drawOptions = {
            radius: boxHeight * Math.SQRT2 / 2,
            pointStyle: legendItem.pointStyle,
            rotation: legendItem.rotation,
            borderWidth: lineWidth
          };
          const centerX = rtlHelper.xPlus(x, boxWidth / 2);
          const centerY = y + halfFontSize;
          drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
        } else {
          const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
          const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
          const borderRadius = toTRBLCorners(legendItem.borderRadius);
          ctx.beginPath();
          if (Object.values(borderRadius).some((v) => v !== 0)) {
            addRoundedRectPath(ctx, {
              x: xBoxLeft,
              y: yBoxTop,
              w: boxWidth,
              h: boxHeight,
              radius: borderRadius
            });
          } else {
            ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
          }
          ctx.fill();
          if (lineWidth !== 0) {
            ctx.stroke();
          }
        }
        ctx.restore();
      };
      const fillText = function(x, y, legendItem) {
        renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
          strikethrough: legendItem.hidden,
          textAlign: rtlHelper.textAlign(legendItem.textAlign)
        });
      };
      const isHorizontal = this.isHorizontal();
      const titleHeight = this._computeTitleHeight();
      if (isHorizontal) {
        cursor = {
          x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
          y: this.top + padding + titleHeight,
          line: 0
        };
      } else {
        cursor = {
          x: this.left + padding,
          y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
          line: 0
        };
      }
      overrideTextDirection(this.ctx, opts.textDirection);
      const lineHeight = itemHeight + padding;
      this.legendItems.forEach((legendItem, i2) => {
        ctx.strokeStyle = legendItem.fontColor;
        ctx.fillStyle = legendItem.fontColor;
        const textWidth = ctx.measureText(legendItem.text).width;
        const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
        const width = boxWidth + halfFontSize + textWidth;
        let x = cursor.x;
        let y = cursor.y;
        rtlHelper.setWidth(this.width);
        if (isHorizontal) {
          if (i2 > 0 && x + width + padding > this.right) {
            y = cursor.y += lineHeight;
            cursor.line++;
            x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
          }
        } else if (i2 > 0 && y + lineHeight > this.bottom) {
          x = cursor.x = x + columnSizes[cursor.line].width + padding;
          cursor.line++;
          y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
        }
        const realX = rtlHelper.x(x);
        drawLegendBox(realX, y, legendItem);
        x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
        fillText(rtlHelper.x(x), y, legendItem);
        if (isHorizontal) {
          cursor.x += width + padding;
        } else if (typeof legendItem.text !== "string") {
          const fontLineHeight = labelFont.lineHeight;
          cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
        } else {
          cursor.y += lineHeight;
        }
      });
      restoreTextDirection(this.ctx, opts.textDirection);
    }
    drawTitle() {
      const opts = this.options;
      const titleOpts = opts.title;
      const titleFont = toFont(titleOpts.font);
      const titlePadding = toPadding(titleOpts.padding);
      if (!titleOpts.display) {
        return;
      }
      const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
      const ctx = this.ctx;
      const position = titleOpts.position;
      const halfFontSize = titleFont.size / 2;
      const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
      let y;
      let left = this.left;
      let maxWidth = this.width;
      if (this.isHorizontal()) {
        maxWidth = Math.max(...this.lineWidths);
        y = this.top + topPaddingPlusHalfFontSize;
        left = _alignStartEnd(opts.align, left, this.right - maxWidth);
      } else {
        const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
        y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
      }
      const x = _alignStartEnd(position, left, left + maxWidth);
      ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
      ctx.textBaseline = "middle";
      ctx.strokeStyle = titleOpts.color;
      ctx.fillStyle = titleOpts.color;
      ctx.font = titleFont.string;
      renderText(ctx, titleOpts.text, x, y, titleFont);
    }
    _computeTitleHeight() {
      const titleOpts = this.options.title;
      const titleFont = toFont(titleOpts.font);
      const titlePadding = toPadding(titleOpts.padding);
      return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
    }
    _getLegendItemAt(x, y) {
      let i2, hitBox, lh;
      if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
        lh = this.legendHitBoxes;
        for (i2 = 0; i2 < lh.length; ++i2) {
          hitBox = lh[i2];
          if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
            return this.legendItems[i2];
          }
        }
      }
      return null;
    }
    handleEvent(e2) {
      const opts = this.options;
      if (!isListened(e2.type, opts)) {
        return;
      }
      const hoveredItem = this._getLegendItemAt(e2.x, e2.y);
      if (e2.type === "mousemove" || e2.type === "mouseout") {
        const previous = this._hoveredItem;
        const sameItem = itemsEqual(previous, hoveredItem);
        if (previous && !sameItem) {
          callback(opts.onLeave, [
            e2,
            previous,
            this
          ], this);
        }
        this._hoveredItem = hoveredItem;
        if (hoveredItem && !sameItem) {
          callback(opts.onHover, [
            e2,
            hoveredItem,
            this
          ], this);
        }
      } else if (hoveredItem) {
        callback(opts.onClick, [
          e2,
          hoveredItem,
          this
        ], this);
      }
    }
  };
  function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
    const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
    const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
    return {
      itemWidth,
      itemHeight
    };
  }
  function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
    let legendItemText = legendItem.text;
    if (legendItemText && typeof legendItemText !== "string") {
      legendItemText = legendItemText.reduce((a2, b) => a2.length > b.length ? a2 : b);
    }
    return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
  }
  function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
    let itemHeight = _itemHeight;
    if (typeof legendItem.text !== "string") {
      itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
    }
    return itemHeight;
  }
  function calculateLegendItemHeight(legendItem, fontLineHeight) {
    const labelHeight = legendItem.text ? legendItem.text.length : 0;
    return fontLineHeight * labelHeight;
  }
  function isListened(type, opts) {
    if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
      return true;
    }
    if (opts.onClick && (type === "click" || type === "mouseup")) {
      return true;
    }
    return false;
  }
  var plugin_legend = {
    id: "legend",
    _element: Legend,
    start(chart, _args, options) {
      const legend = chart.legend = new Legend({
        ctx: chart.ctx,
        options,
        chart
      });
      layouts.configure(chart, legend, options);
      layouts.addBox(chart, legend);
    },
    stop(chart) {
      layouts.removeBox(chart, chart.legend);
      delete chart.legend;
    },
    beforeUpdate(chart, _args, options) {
      const legend = chart.legend;
      layouts.configure(chart, legend, options);
      legend.options = options;
    },
    afterUpdate(chart) {
      const legend = chart.legend;
      legend.buildLabels();
      legend.adjustHitBoxes();
    },
    afterEvent(chart, args) {
      if (!args.replay) {
        chart.legend.handleEvent(args.event);
      }
    },
    defaults: {
      display: true,
      position: "top",
      align: "center",
      fullSize: true,
      reverse: false,
      weight: 1e3,
      onClick(e2, legendItem, legend) {
        const index2 = legendItem.datasetIndex;
        const ci = legend.chart;
        if (ci.isDatasetVisible(index2)) {
          ci.hide(index2);
          legendItem.hidden = true;
        } else {
          ci.show(index2);
          legendItem.hidden = false;
        }
      },
      onHover: null,
      onLeave: null,
      labels: {
        color: (ctx) => ctx.chart.options.color,
        boxWidth: 40,
        padding: 10,
        generateLabels(chart) {
          const datasets = chart.data.datasets;
          const { labels: { usePointStyle, pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
          return chart._getSortedDatasetMetas().map((meta) => {
            const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
            const borderWidth = toPadding(style.borderWidth);
            return {
              text: datasets[meta.index].label,
              fillStyle: style.backgroundColor,
              fontColor: color2,
              hidden: !meta.visible,
              lineCap: style.borderCapStyle,
              lineDash: style.borderDash,
              lineDashOffset: style.borderDashOffset,
              lineJoin: style.borderJoinStyle,
              lineWidth: (borderWidth.width + borderWidth.height) / 4,
              strokeStyle: style.borderColor,
              pointStyle: pointStyle || style.pointStyle,
              rotation: style.rotation,
              textAlign: textAlign || style.textAlign,
              borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
              datasetIndex: meta.index
            };
          }, this);
        }
      },
      title: {
        color: (ctx) => ctx.chart.options.color,
        display: false,
        position: "center",
        text: ""
      }
    },
    descriptors: {
      _scriptable: (name) => !name.startsWith("on"),
      labels: {
        _scriptable: (name) => ![
          "generateLabels",
          "filter",
          "sort"
        ].includes(name)
      }
    }
  };
  var Title = class extends Element {
    constructor(config) {
      super();
      this.chart = config.chart;
      this.options = config.options;
      this.ctx = config.ctx;
      this._padding = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.width = void 0;
      this.height = void 0;
      this.position = void 0;
      this.weight = void 0;
      this.fullSize = void 0;
    }
    update(maxWidth, maxHeight) {
      const opts = this.options;
      this.left = 0;
      this.top = 0;
      if (!opts.display) {
        this.width = this.height = this.right = this.bottom = 0;
        return;
      }
      this.width = this.right = maxWidth;
      this.height = this.bottom = maxHeight;
      const lineCount = isArray(opts.text) ? opts.text.length : 1;
      this._padding = toPadding(opts.padding);
      const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
      if (this.isHorizontal()) {
        this.height = textSize;
      } else {
        this.width = textSize;
      }
    }
    isHorizontal() {
      const pos = this.options.position;
      return pos === "top" || pos === "bottom";
    }
    _drawArgs(offset) {
      const { top: top2, left, bottom: bottom2, right, options } = this;
      const align = options.align;
      let rotation = 0;
      let maxWidth, titleX, titleY;
      if (this.isHorizontal()) {
        titleX = _alignStartEnd(align, left, right);
        titleY = top2 + offset;
        maxWidth = right - left;
      } else {
        if (options.position === "left") {
          titleX = left + offset;
          titleY = _alignStartEnd(align, bottom2, top2);
          rotation = PI * -0.5;
        } else {
          titleX = right - offset;
          titleY = _alignStartEnd(align, top2, bottom2);
          rotation = PI * 0.5;
        }
        maxWidth = bottom2 - top2;
      }
      return {
        titleX,
        titleY,
        maxWidth,
        rotation
      };
    }
    draw() {
      const ctx = this.ctx;
      const opts = this.options;
      if (!opts.display) {
        return;
      }
      const fontOpts = toFont(opts.font);
      const lineHeight = fontOpts.lineHeight;
      const offset = lineHeight / 2 + this._padding.top;
      const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
      renderText(ctx, opts.text, 0, 0, fontOpts, {
        color: opts.color,
        maxWidth,
        rotation,
        textAlign: _toLeftRightCenter(opts.align),
        textBaseline: "middle",
        translation: [
          titleX,
          titleY
        ]
      });
    }
  };
  function createTitle(chart, titleOpts) {
    const title = new Title({
      ctx: chart.ctx,
      options: titleOpts,
      chart
    });
    layouts.configure(chart, title, titleOpts);
    layouts.addBox(chart, title);
    chart.titleBlock = title;
  }
  var plugin_title = {
    id: "title",
    _element: Title,
    start(chart, _args, options) {
      createTitle(chart, options);
    },
    stop(chart) {
      const titleBlock = chart.titleBlock;
      layouts.removeBox(chart, titleBlock);
      delete chart.titleBlock;
    },
    beforeUpdate(chart, _args, options) {
      const title = chart.titleBlock;
      layouts.configure(chart, title, options);
      title.options = options;
    },
    defaults: {
      align: "center",
      display: false,
      font: {
        weight: "bold"
      },
      fullSize: true,
      padding: 10,
      position: "top",
      text: "",
      weight: 2e3
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: true,
      _indexable: false
    }
  };
  var map2 = /* @__PURE__ */ new WeakMap();
  var plugin_subtitle = {
    id: "subtitle",
    start(chart, _args, options) {
      const title = new Title({
        ctx: chart.ctx,
        options,
        chart
      });
      layouts.configure(chart, title, options);
      layouts.addBox(chart, title);
      map2.set(chart, title);
    },
    stop(chart) {
      layouts.removeBox(chart, map2.get(chart));
      map2.delete(chart);
    },
    beforeUpdate(chart, _args, options) {
      const title = map2.get(chart);
      layouts.configure(chart, title, options);
      title.options = options;
    },
    defaults: {
      align: "center",
      display: false,
      font: {
        weight: "normal"
      },
      fullSize: true,
      padding: 0,
      position: "top",
      text: "",
      weight: 1500
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: true,
      _indexable: false
    }
  };
  var positioners = {
    average(items) {
      if (!items.length) {
        return false;
      }
      let i2, len;
      let xSet = /* @__PURE__ */ new Set();
      let y = 0;
      let count = 0;
      for (i2 = 0, len = items.length; i2 < len; ++i2) {
        const el = items[i2].element;
        if (el && el.hasValue()) {
          const pos = el.tooltipPosition();
          xSet.add(pos.x);
          y += pos.y;
          ++count;
        }
      }
      if (count === 0 || xSet.size === 0) {
        return false;
      }
      const xAverage = [
        ...xSet
      ].reduce((a2, b) => a2 + b) / xSet.size;
      return {
        x: xAverage,
        y: y / count
      };
    },
    nearest(items, eventPosition) {
      if (!items.length) {
        return false;
      }
      let x = eventPosition.x;
      let y = eventPosition.y;
      let minDistance = Number.POSITIVE_INFINITY;
      let i2, len, nearestElement;
      for (i2 = 0, len = items.length; i2 < len; ++i2) {
        const el = items[i2].element;
        if (el && el.hasValue()) {
          const center = el.getCenterPoint();
          const d2 = distanceBetweenPoints(eventPosition, center);
          if (d2 < minDistance) {
            minDistance = d2;
            nearestElement = el;
          }
        }
      }
      if (nearestElement) {
        const tp = nearestElement.tooltipPosition();
        x = tp.x;
        y = tp.y;
      }
      return {
        x,
        y
      };
    }
  };
  function pushOrConcat(base, toPush) {
    if (toPush) {
      if (isArray(toPush)) {
        Array.prototype.push.apply(base, toPush);
      } else {
        base.push(toPush);
      }
    }
    return base;
  }
  function splitNewlines(str) {
    if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
      return str.split("\n");
    }
    return str;
  }
  function createTooltipItem(chart, item) {
    const { element, datasetIndex, index: index2 } = item;
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    const { label, value } = controller.getLabelAndValue(index2);
    return {
      chart,
      label,
      parsed: controller.getParsed(index2),
      raw: chart.data.datasets[datasetIndex].data[index2],
      formattedValue: value,
      dataset: controller.getDataset(),
      dataIndex: index2,
      datasetIndex,
      element
    };
  }
  function getTooltipSize(tooltip, options) {
    const ctx = tooltip.chart.ctx;
    const { body, footer, title } = tooltip;
    const { boxWidth, boxHeight } = options;
    const bodyFont = toFont(options.bodyFont);
    const titleFont = toFont(options.titleFont);
    const footerFont = toFont(options.footerFont);
    const titleLineCount = title.length;
    const footerLineCount = footer.length;
    const bodyLineItemCount = body.length;
    const padding = toPadding(options.padding);
    let height = padding.height;
    let width = 0;
    let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
    if (titleLineCount) {
      height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
    }
    if (combinedBodyLength) {
      const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
      height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
    }
    if (footerLineCount) {
      height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
    }
    let widthPadding = 0;
    const maxLineWidth = function(line) {
      width = Math.max(width, ctx.measureText(line).width + widthPadding);
    };
    ctx.save();
    ctx.font = titleFont.string;
    each(tooltip.title, maxLineWidth);
    ctx.font = bodyFont.string;
    each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
    each(body, (bodyItem) => {
      each(bodyItem.before, maxLineWidth);
      each(bodyItem.lines, maxLineWidth);
      each(bodyItem.after, maxLineWidth);
    });
    widthPadding = 0;
    ctx.font = footerFont.string;
    each(tooltip.footer, maxLineWidth);
    ctx.restore();
    width += padding.width;
    return {
      width,
      height
    };
  }
  function determineYAlign(chart, size) {
    const { y, height } = size;
    if (y < height / 2) {
      return "top";
    } else if (y > chart.height - height / 2) {
      return "bottom";
    }
    return "center";
  }
  function doesNotFitWithAlign(xAlign, chart, options, size) {
    const { x, width } = size;
    const caret = options.caretSize + options.caretPadding;
    if (xAlign === "left" && x + width + caret > chart.width) {
      return true;
    }
    if (xAlign === "right" && x - width - caret < 0) {
      return true;
    }
  }
  function determineXAlign(chart, options, size, yAlign) {
    const { x, width } = size;
    const { width: chartWidth, chartArea: { left, right } } = chart;
    let xAlign = "center";
    if (yAlign === "center") {
      xAlign = x <= (left + right) / 2 ? "left" : "right";
    } else if (x <= width / 2) {
      xAlign = "left";
    } else if (x >= chartWidth - width / 2) {
      xAlign = "right";
    }
    if (doesNotFitWithAlign(xAlign, chart, options, size)) {
      xAlign = "center";
    }
    return xAlign;
  }
  function determineAlignment(chart, options, size) {
    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
    return {
      xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
      yAlign
    };
  }
  function alignX(size, xAlign) {
    let { x, width } = size;
    if (xAlign === "right") {
      x -= width;
    } else if (xAlign === "center") {
      x -= width / 2;
    }
    return x;
  }
  function alignY(size, yAlign, paddingAndSize) {
    let { y, height } = size;
    if (yAlign === "top") {
      y += paddingAndSize;
    } else if (yAlign === "bottom") {
      y -= height + paddingAndSize;
    } else {
      y -= height / 2;
    }
    return y;
  }
  function getBackgroundPoint(options, size, alignment, chart) {
    const { caretSize, caretPadding, cornerRadius } = options;
    const { xAlign, yAlign } = alignment;
    const paddingAndSize = caretSize + caretPadding;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    let x = alignX(size, xAlign);
    const y = alignY(size, yAlign, paddingAndSize);
    if (yAlign === "center") {
      if (xAlign === "left") {
        x += paddingAndSize;
      } else if (xAlign === "right") {
        x -= paddingAndSize;
      }
    } else if (xAlign === "left") {
      x -= Math.max(topLeft, bottomLeft) + caretSize;
    } else if (xAlign === "right") {
      x += Math.max(topRight, bottomRight) + caretSize;
    }
    return {
      x: _limitValue(x, 0, chart.width - size.width),
      y: _limitValue(y, 0, chart.height - size.height)
    };
  }
  function getAlignedX(tooltip, align, options) {
    const padding = toPadding(options.padding);
    return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
  }
  function getBeforeAfterBodyLines(callback2) {
    return pushOrConcat([], splitNewlines(callback2));
  }
  function createTooltipContext(parent, tooltip, tooltipItems) {
    return createContext(parent, {
      tooltip,
      tooltipItems,
      type: "tooltip"
    });
  }
  function overrideCallbacks(callbacks, context) {
    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
    return override ? callbacks.override(override) : callbacks;
  }
  var defaultCallbacks = {
    beforeTitle: noop2,
    title(tooltipItems) {
      if (tooltipItems.length > 0) {
        const item = tooltipItems[0];
        const labels = item.chart.data.labels;
        const labelCount = labels ? labels.length : 0;
        if (this && this.options && this.options.mode === "dataset") {
          return item.dataset.label || "";
        } else if (item.label) {
          return item.label;
        } else if (labelCount > 0 && item.dataIndex < labelCount) {
          return labels[item.dataIndex];
        }
      }
      return "";
    },
    afterTitle: noop2,
    beforeBody: noop2,
    beforeLabel: noop2,
    label(tooltipItem) {
      if (this && this.options && this.options.mode === "dataset") {
        return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
      }
      let label = tooltipItem.dataset.label || "";
      if (label) {
        label += ": ";
      }
      const value = tooltipItem.formattedValue;
      if (!isNullOrUndef(value)) {
        label += value;
      }
      return label;
    },
    labelColor(tooltipItem) {
      const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
      const options = meta.controller.getStyle(tooltipItem.dataIndex);
      return {
        borderColor: options.borderColor,
        backgroundColor: options.backgroundColor,
        borderWidth: options.borderWidth,
        borderDash: options.borderDash,
        borderDashOffset: options.borderDashOffset,
        borderRadius: 0
      };
    },
    labelTextColor() {
      return this.options.bodyColor;
    },
    labelPointStyle(tooltipItem) {
      const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
      const options = meta.controller.getStyle(tooltipItem.dataIndex);
      return {
        pointStyle: options.pointStyle,
        rotation: options.rotation
      };
    },
    afterLabel: noop2,
    afterBody: noop2,
    beforeFooter: noop2,
    footer: noop2,
    afterFooter: noop2
  };
  function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
    const result = callbacks[name].call(ctx, arg);
    if (typeof result === "undefined") {
      return defaultCallbacks[name].call(ctx, arg);
    }
    return result;
  }
  var Tooltip = class extends Element {
    constructor(config) {
      super();
      this.opacity = 0;
      this._active = [];
      this._eventPosition = void 0;
      this._size = void 0;
      this._cachedAnimations = void 0;
      this._tooltipItems = [];
      this.$animations = void 0;
      this.$context = void 0;
      this.chart = config.chart;
      this.options = config.options;
      this.dataPoints = void 0;
      this.title = void 0;
      this.beforeBody = void 0;
      this.body = void 0;
      this.afterBody = void 0;
      this.footer = void 0;
      this.xAlign = void 0;
      this.yAlign = void 0;
      this.x = void 0;
      this.y = void 0;
      this.height = void 0;
      this.width = void 0;
      this.caretX = void 0;
      this.caretY = void 0;
      this.labelColors = void 0;
      this.labelPointStyles = void 0;
      this.labelTextColors = void 0;
    }
    initialize(options) {
      this.options = options;
      this._cachedAnimations = void 0;
      this.$context = void 0;
    }
    _resolveAnimations() {
      const cached = this._cachedAnimations;
      if (cached) {
        return cached;
      }
      const chart = this.chart;
      const options = this.options.setContext(this.getContext());
      const opts = options.enabled && chart.options.animation && options.animations;
      const animations = new Animations(this.chart, opts);
      if (opts._cacheable) {
        this._cachedAnimations = Object.freeze(animations);
      }
      return animations;
    }
    getContext() {
      return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
    }
    getTitle(context, options) {
      const { callbacks } = options;
      const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
      const title = invokeCallbackWithFallback(callbacks, "title", this, context);
      const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
      let lines = [];
      lines = pushOrConcat(lines, splitNewlines(beforeTitle));
      lines = pushOrConcat(lines, splitNewlines(title));
      lines = pushOrConcat(lines, splitNewlines(afterTitle));
      return lines;
    }
    getBeforeBody(tooltipItems, options) {
      return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
    }
    getBody(tooltipItems, options) {
      const { callbacks } = options;
      const bodyItems = [];
      each(tooltipItems, (context) => {
        const bodyItem = {
          before: [],
          lines: [],
          after: []
        };
        const scoped = overrideCallbacks(callbacks, context);
        pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
        pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
        pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
        bodyItems.push(bodyItem);
      });
      return bodyItems;
    }
    getAfterBody(tooltipItems, options) {
      return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
    }
    getFooter(tooltipItems, options) {
      const { callbacks } = options;
      const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
      const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
      const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
      let lines = [];
      lines = pushOrConcat(lines, splitNewlines(beforeFooter));
      lines = pushOrConcat(lines, splitNewlines(footer));
      lines = pushOrConcat(lines, splitNewlines(afterFooter));
      return lines;
    }
    _createItems(options) {
      const active = this._active;
      const data = this.chart.data;
      const labelColors = [];
      const labelPointStyles = [];
      const labelTextColors = [];
      let tooltipItems = [];
      let i2, len;
      for (i2 = 0, len = active.length; i2 < len; ++i2) {
        tooltipItems.push(createTooltipItem(this.chart, active[i2]));
      }
      if (options.filter) {
        tooltipItems = tooltipItems.filter((element, index2, array) => options.filter(element, index2, array, data));
      }
      if (options.itemSort) {
        tooltipItems = tooltipItems.sort((a2, b) => options.itemSort(a2, b, data));
      }
      each(tooltipItems, (context) => {
        const scoped = overrideCallbacks(options.callbacks, context);
        labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
        labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
        labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
      });
      this.labelColors = labelColors;
      this.labelPointStyles = labelPointStyles;
      this.labelTextColors = labelTextColors;
      this.dataPoints = tooltipItems;
      return tooltipItems;
    }
    update(changed, replay) {
      const options = this.options.setContext(this.getContext());
      const active = this._active;
      let properties;
      let tooltipItems = [];
      if (!active.length) {
        if (this.opacity !== 0) {
          properties = {
            opacity: 0
          };
        }
      } else {
        const position = positioners[options.position].call(this, active, this._eventPosition);
        tooltipItems = this._createItems(options);
        this.title = this.getTitle(tooltipItems, options);
        this.beforeBody = this.getBeforeBody(tooltipItems, options);
        this.body = this.getBody(tooltipItems, options);
        this.afterBody = this.getAfterBody(tooltipItems, options);
        this.footer = this.getFooter(tooltipItems, options);
        const size = this._size = getTooltipSize(this, options);
        const positionAndSize = Object.assign({}, position, size);
        const alignment = determineAlignment(this.chart, options, positionAndSize);
        const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        properties = {
          opacity: 1,
          x: backgroundPoint.x,
          y: backgroundPoint.y,
          width: size.width,
          height: size.height,
          caretX: position.x,
          caretY: position.y
        };
      }
      this._tooltipItems = tooltipItems;
      this.$context = void 0;
      if (properties) {
        this._resolveAnimations().update(this, properties);
      }
      if (changed && options.external) {
        options.external.call(this, {
          chart: this.chart,
          tooltip: this,
          replay
        });
      }
    }
    drawCaret(tooltipPoint, ctx, size, options) {
      const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
      ctx.lineTo(caretPosition.x1, caretPosition.y1);
      ctx.lineTo(caretPosition.x2, caretPosition.y2);
      ctx.lineTo(caretPosition.x3, caretPosition.y3);
    }
    getCaretPosition(tooltipPoint, size, options) {
      const { xAlign, yAlign } = this;
      const { caretSize, cornerRadius } = options;
      const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
      const { x: ptX, y: ptY } = tooltipPoint;
      const { width, height } = size;
      let x1, x2, x3, y1, y2, y3;
      if (yAlign === "center") {
        y2 = ptY + height / 2;
        if (xAlign === "left") {
          x1 = ptX;
          x2 = x1 - caretSize;
          y1 = y2 + caretSize;
          y3 = y2 - caretSize;
        } else {
          x1 = ptX + width;
          x2 = x1 + caretSize;
          y1 = y2 - caretSize;
          y3 = y2 + caretSize;
        }
        x3 = x1;
      } else {
        if (xAlign === "left") {
          x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
        } else if (xAlign === "right") {
          x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
        } else {
          x2 = this.caretX;
        }
        if (yAlign === "top") {
          y1 = ptY;
          y2 = y1 - caretSize;
          x1 = x2 - caretSize;
          x3 = x2 + caretSize;
        } else {
          y1 = ptY + height;
          y2 = y1 + caretSize;
          x1 = x2 + caretSize;
          x3 = x2 - caretSize;
        }
        y3 = y1;
      }
      return {
        x1,
        x2,
        x3,
        y1,
        y2,
        y3
      };
    }
    drawTitle(pt, ctx, options) {
      const title = this.title;
      const length = title.length;
      let titleFont, titleSpacing, i2;
      if (length) {
        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
        pt.x = getAlignedX(this, options.titleAlign, options);
        ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
        ctx.textBaseline = "middle";
        titleFont = toFont(options.titleFont);
        titleSpacing = options.titleSpacing;
        ctx.fillStyle = options.titleColor;
        ctx.font = titleFont.string;
        for (i2 = 0; i2 < length; ++i2) {
          ctx.fillText(title[i2], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
          pt.y += titleFont.lineHeight + titleSpacing;
          if (i2 + 1 === length) {
            pt.y += options.titleMarginBottom - titleSpacing;
          }
        }
      }
    }
    _drawColorBox(ctx, pt, i2, rtlHelper, options) {
      const labelColor = this.labelColors[i2];
      const labelPointStyle = this.labelPointStyles[i2];
      const { boxHeight, boxWidth } = options;
      const bodyFont = toFont(options.bodyFont);
      const colorX = getAlignedX(this, "left", options);
      const rtlColorX = rtlHelper.x(colorX);
      const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
      const colorY = pt.y + yOffSet;
      if (options.usePointStyle) {
        const drawOptions = {
          radius: Math.min(boxWidth, boxHeight) / 2,
          pointStyle: labelPointStyle.pointStyle,
          rotation: labelPointStyle.rotation,
          borderWidth: 1
        };
        const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
        const centerY = colorY + boxHeight / 2;
        ctx.strokeStyle = options.multiKeyBackground;
        ctx.fillStyle = options.multiKeyBackground;
        drawPoint(ctx, drawOptions, centerX, centerY);
        ctx.strokeStyle = labelColor.borderColor;
        ctx.fillStyle = labelColor.backgroundColor;
        drawPoint(ctx, drawOptions, centerX, centerY);
      } else {
        ctx.lineWidth = isObject2(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
        ctx.strokeStyle = labelColor.borderColor;
        ctx.setLineDash(labelColor.borderDash || []);
        ctx.lineDashOffset = labelColor.borderDashOffset || 0;
        const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
        const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
        const borderRadius = toTRBLCorners(labelColor.borderRadius);
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          ctx.beginPath();
          ctx.fillStyle = options.multiKeyBackground;
          addRoundedRectPath(ctx, {
            x: outerX,
            y: colorY,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = labelColor.backgroundColor;
          ctx.beginPath();
          addRoundedRectPath(ctx, {
            x: innerX,
            y: colorY + 1,
            w: boxWidth - 2,
            h: boxHeight - 2,
            radius: borderRadius
          });
          ctx.fill();
        } else {
          ctx.fillStyle = options.multiKeyBackground;
          ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
          ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
          ctx.fillStyle = labelColor.backgroundColor;
          ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
        }
      }
      ctx.fillStyle = this.labelTextColors[i2];
    }
    drawBody(pt, ctx, options) {
      const { body } = this;
      const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
      const bodyFont = toFont(options.bodyFont);
      let bodyLineHeight = bodyFont.lineHeight;
      let xLinePadding = 0;
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      const fillLineOfText = function(line) {
        ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
        pt.y += bodyLineHeight + bodySpacing;
      };
      const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
      let bodyItem, textColor, lines, i2, j, ilen, jlen;
      ctx.textAlign = bodyAlign;
      ctx.textBaseline = "middle";
      ctx.font = bodyFont.string;
      pt.x = getAlignedX(this, bodyAlignForCalculation, options);
      ctx.fillStyle = options.bodyColor;
      each(this.beforeBody, fillLineOfText);
      xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
      for (i2 = 0, ilen = body.length; i2 < ilen; ++i2) {
        bodyItem = body[i2];
        textColor = this.labelTextColors[i2];
        ctx.fillStyle = textColor;
        each(bodyItem.before, fillLineOfText);
        lines = bodyItem.lines;
        if (displayColors && lines.length) {
          this._drawColorBox(ctx, pt, i2, rtlHelper, options);
          bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
        }
        for (j = 0, jlen = lines.length; j < jlen; ++j) {
          fillLineOfText(lines[j]);
          bodyLineHeight = bodyFont.lineHeight;
        }
        each(bodyItem.after, fillLineOfText);
      }
      xLinePadding = 0;
      bodyLineHeight = bodyFont.lineHeight;
      each(this.afterBody, fillLineOfText);
      pt.y -= bodySpacing;
    }
    drawFooter(pt, ctx, options) {
      const footer = this.footer;
      const length = footer.length;
      let footerFont, i2;
      if (length) {
        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
        pt.x = getAlignedX(this, options.footerAlign, options);
        pt.y += options.footerMarginTop;
        ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
        ctx.textBaseline = "middle";
        footerFont = toFont(options.footerFont);
        ctx.fillStyle = options.footerColor;
        ctx.font = footerFont.string;
        for (i2 = 0; i2 < length; ++i2) {
          ctx.fillText(footer[i2], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
          pt.y += footerFont.lineHeight + options.footerSpacing;
        }
      }
    }
    drawBackground(pt, ctx, tooltipSize, options) {
      const { xAlign, yAlign } = this;
      const { x, y } = pt;
      const { width, height } = tooltipSize;
      const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
      ctx.fillStyle = options.backgroundColor;
      ctx.strokeStyle = options.borderColor;
      ctx.lineWidth = options.borderWidth;
      ctx.beginPath();
      ctx.moveTo(x + topLeft, y);
      if (yAlign === "top") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x + width - topRight, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
      if (yAlign === "center" && xAlign === "right") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x + width, y + height - bottomRight);
      ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
      if (yAlign === "bottom") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x + bottomLeft, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
      if (yAlign === "center" && xAlign === "left") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x, y + topLeft);
      ctx.quadraticCurveTo(x, y, x + topLeft, y);
      ctx.closePath();
      ctx.fill();
      if (options.borderWidth > 0) {
        ctx.stroke();
      }
    }
    _updateAnimationTarget(options) {
      const chart = this.chart;
      const anims = this.$animations;
      const animX = anims && anims.x;
      const animY = anims && anims.y;
      if (animX || animY) {
        const position = positioners[options.position].call(this, this._active, this._eventPosition);
        if (!position) {
          return;
        }
        const size = this._size = getTooltipSize(this, options);
        const positionAndSize = Object.assign({}, position, this._size);
        const alignment = determineAlignment(chart, options, positionAndSize);
        const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
        if (animX._to !== point.x || animY._to !== point.y) {
          this.xAlign = alignment.xAlign;
          this.yAlign = alignment.yAlign;
          this.width = size.width;
          this.height = size.height;
          this.caretX = position.x;
          this.caretY = position.y;
          this._resolveAnimations().update(this, point);
        }
      }
    }
    _willRender() {
      return !!this.opacity;
    }
    draw(ctx) {
      const options = this.options.setContext(this.getContext());
      let opacity = this.opacity;
      if (!opacity) {
        return;
      }
      this._updateAnimationTarget(options);
      const tooltipSize = {
        width: this.width,
        height: this.height
      };
      const pt = {
        x: this.x,
        y: this.y
      };
      opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
      const padding = toPadding(options.padding);
      const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
      if (options.enabled && hasTooltipContent) {
        ctx.save();
        ctx.globalAlpha = opacity;
        this.drawBackground(pt, ctx, tooltipSize, options);
        overrideTextDirection(ctx, options.textDirection);
        pt.y += padding.top;
        this.drawTitle(pt, ctx, options);
        this.drawBody(pt, ctx, options);
        this.drawFooter(pt, ctx, options);
        restoreTextDirection(ctx, options.textDirection);
        ctx.restore();
      }
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(activeElements, eventPosition) {
      const lastActive = this._active;
      const active = activeElements.map(({ datasetIndex, index: index2 }) => {
        const meta = this.chart.getDatasetMeta(datasetIndex);
        if (!meta) {
          throw new Error("Cannot find a dataset at index " + datasetIndex);
        }
        return {
          datasetIndex,
          element: meta.data[index2],
          index: index2
        };
      });
      const changed = !_elementsEqual(lastActive, active);
      const positionChanged = this._positionChanged(active, eventPosition);
      if (changed || positionChanged) {
        this._active = active;
        this._eventPosition = eventPosition;
        this._ignoreReplayEvents = true;
        this.update(true);
      }
    }
    handleEvent(e2, replay, inChartArea = true) {
      if (replay && this._ignoreReplayEvents) {
        return false;
      }
      this._ignoreReplayEvents = false;
      const options = this.options;
      const lastActive = this._active || [];
      const active = this._getActiveElements(e2, lastActive, replay, inChartArea);
      const positionChanged = this._positionChanged(active, e2);
      const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
      if (changed) {
        this._active = active;
        if (options.enabled || options.external) {
          this._eventPosition = {
            x: e2.x,
            y: e2.y
          };
          this.update(true, replay);
        }
      }
      return changed;
    }
    _getActiveElements(e2, lastActive, replay, inChartArea) {
      const options = this.options;
      if (e2.type === "mouseout") {
        return [];
      }
      if (!inChartArea) {
        return lastActive.filter((i2) => this.chart.data.datasets[i2.datasetIndex] && this.chart.getDatasetMeta(i2.datasetIndex).controller.getParsed(i2.index) !== void 0);
      }
      const active = this.chart.getElementsAtEventForMode(e2, options.mode, options, replay);
      if (options.reverse) {
        active.reverse();
      }
      return active;
    }
    _positionChanged(active, e2) {
      const { caretX, caretY, options } = this;
      const position = positioners[options.position].call(this, active, e2);
      return position !== false && (caretX !== position.x || caretY !== position.y);
    }
  };
  __publicField(Tooltip, "positioners", positioners);
  var plugin_tooltip = {
    id: "tooltip",
    _element: Tooltip,
    positioners,
    afterInit(chart, _args, options) {
      if (options) {
        chart.tooltip = new Tooltip({
          chart,
          options
        });
      }
    },
    beforeUpdate(chart, _args, options) {
      if (chart.tooltip) {
        chart.tooltip.initialize(options);
      }
    },
    reset(chart, _args, options) {
      if (chart.tooltip) {
        chart.tooltip.initialize(options);
      }
    },
    afterDraw(chart) {
      const tooltip = chart.tooltip;
      if (tooltip && tooltip._willRender()) {
        const args = {
          tooltip
        };
        if (chart.notifyPlugins("beforeTooltipDraw", __spreadProps(__spreadValues({}, args), {
          cancelable: true
        })) === false) {
          return;
        }
        tooltip.draw(chart.ctx);
        chart.notifyPlugins("afterTooltipDraw", args);
      }
    },
    afterEvent(chart, args) {
      if (chart.tooltip) {
        const useFinalPosition = args.replay;
        if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
          args.changed = true;
        }
      }
    },
    defaults: {
      enabled: true,
      external: null,
      position: "average",
      backgroundColor: "rgba(0,0,0,0.8)",
      titleColor: "#fff",
      titleFont: {
        weight: "bold"
      },
      titleSpacing: 2,
      titleMarginBottom: 6,
      titleAlign: "left",
      bodyColor: "#fff",
      bodySpacing: 2,
      bodyFont: {},
      bodyAlign: "left",
      footerColor: "#fff",
      footerSpacing: 2,
      footerMarginTop: 6,
      footerFont: {
        weight: "bold"
      },
      footerAlign: "left",
      padding: 6,
      caretPadding: 2,
      caretSize: 5,
      cornerRadius: 6,
      boxHeight: (ctx, opts) => opts.bodyFont.size,
      boxWidth: (ctx, opts) => opts.bodyFont.size,
      multiKeyBackground: "#fff",
      displayColors: true,
      boxPadding: 0,
      borderColor: "rgba(0,0,0,0)",
      borderWidth: 0,
      animation: {
        duration: 400,
        easing: "easeOutQuart"
      },
      animations: {
        numbers: {
          type: "number",
          properties: [
            "x",
            "y",
            "width",
            "height",
            "caretX",
            "caretY"
          ]
        },
        opacity: {
          easing: "linear",
          duration: 200
        }
      },
      callbacks: defaultCallbacks
    },
    defaultRoutes: {
      bodyFont: "font",
      footerFont: "font",
      titleFont: "font"
    },
    descriptors: {
      _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
      _indexable: false,
      callbacks: {
        _scriptable: false,
        _indexable: false
      },
      animation: {
        _fallback: false
      },
      animations: {
        _fallback: "animation"
      }
    },
    additionalOptionScopes: [
      "interaction"
    ]
  };
  var plugins = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    Colors: plugin_colors,
    Decimation: plugin_decimation,
    Filler: index,
    Legend: plugin_legend,
    SubTitle: plugin_subtitle,
    Title: plugin_title,
    Tooltip: plugin_tooltip
  });
  var addIfString = (labels, raw, index2, addedLabels) => {
    if (typeof raw === "string") {
      index2 = labels.push(raw) - 1;
      addedLabels.unshift({
        index: index2,
        label: raw
      });
    } else if (isNaN(raw)) {
      index2 = null;
    }
    return index2;
  };
  function findOrAddLabel(labels, raw, index2, addedLabels) {
    const first = labels.indexOf(raw);
    if (first === -1) {
      return addIfString(labels, raw, index2, addedLabels);
    }
    const last = labels.lastIndexOf(raw);
    return first !== last ? index2 : first;
  }
  var validIndex = (index2, max2) => index2 === null ? null : _limitValue(Math.round(index2), 0, max2);
  function _getLabelForValue(value) {
    const labels = this.getLabels();
    if (value >= 0 && value < labels.length) {
      return labels[value];
    }
    return value;
  }
  var CategoryScale = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this._startValue = void 0;
      this._valueRange = 0;
      this._addedLabels = [];
    }
    init(scaleOptions) {
      const added = this._addedLabels;
      if (added.length) {
        const labels = this.getLabels();
        for (const { index: index2, label } of added) {
          if (labels[index2] === label) {
            labels.splice(index2, 1);
          }
        }
        this._addedLabels = [];
      }
      super.init(scaleOptions);
    }
    parse(raw, index2) {
      if (isNullOrUndef(raw)) {
        return null;
      }
      const labels = this.getLabels();
      index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw), this._addedLabels);
      return validIndex(index2, labels.length - 1);
    }
    determineDataLimits() {
      const { minDefined, maxDefined } = this.getUserBounds();
      let { min, max: max2 } = this.getMinMax(true);
      if (this.options.bounds === "ticks") {
        if (!minDefined) {
          min = 0;
        }
        if (!maxDefined) {
          max2 = this.getLabels().length - 1;
        }
      }
      this.min = min;
      this.max = max2;
    }
    buildTicks() {
      const min = this.min;
      const max2 = this.max;
      const offset = this.options.offset;
      const ticks = [];
      let labels = this.getLabels();
      labels = min === 0 && max2 === labels.length - 1 ? labels : labels.slice(min, max2 + 1);
      this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
      this._startValue = this.min - (offset ? 0.5 : 0);
      for (let value = min; value <= max2; value++) {
        ticks.push({
          value
        });
      }
      return ticks;
    }
    getLabelForValue(value) {
      return _getLabelForValue.call(this, value);
    }
    configure() {
      super.configure();
      if (!this.isHorizontal()) {
        this._reversePixels = !this._reversePixels;
      }
    }
    getPixelForValue(value) {
      if (typeof value !== "number") {
        value = this.parse(value);
      }
      return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getPixelForTick(index2) {
      const ticks = this.ticks;
      if (index2 < 0 || index2 > ticks.length - 1) {
        return null;
      }
      return this.getPixelForValue(ticks[index2].value);
    }
    getValueForPixel(pixel) {
      return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
    }
    getBasePixel() {
      return this.bottom;
    }
  };
  __publicField(CategoryScale, "id", "category");
  __publicField(CategoryScale, "defaults", {
    ticks: {
      callback: _getLabelForValue
    }
  });
  function generateTicks$1(generationOptions, dataRange) {
    const ticks = [];
    const MIN_SPACING = 1e-14;
    const { bounds, step, min, max: max2, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
    const unit = step || 1;
    const maxSpaces = maxTicks - 1;
    const { min: rmin, max: rmax } = dataRange;
    const minDefined = !isNullOrUndef(min);
    const maxDefined = !isNullOrUndef(max2);
    const countDefined = !isNullOrUndef(count);
    const minSpacing = (rmax - rmin) / (maxDigits + 1);
    let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
    let factor, niceMin, niceMax, numSpaces;
    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
      return [
        {
          value: rmin
        },
        {
          value: rmax
        }
      ];
    }
    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
    if (numSpaces > maxSpaces) {
      spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
    }
    if (!isNullOrUndef(precision)) {
      factor = Math.pow(10, precision);
      spacing = Math.ceil(spacing * factor) / factor;
    }
    if (bounds === "ticks") {
      niceMin = Math.floor(rmin / spacing) * spacing;
      niceMax = Math.ceil(rmax / spacing) * spacing;
    } else {
      niceMin = rmin;
      niceMax = rmax;
    }
    if (minDefined && maxDefined && step && almostWhole((max2 - min) / step, spacing / 1e3)) {
      numSpaces = Math.round(Math.min((max2 - min) / spacing, maxTicks));
      spacing = (max2 - min) / numSpaces;
      niceMin = min;
      niceMax = max2;
    } else if (countDefined) {
      niceMin = minDefined ? min : niceMin;
      niceMax = maxDefined ? max2 : niceMax;
      numSpaces = count - 1;
      spacing = (niceMax - niceMin) / numSpaces;
    } else {
      numSpaces = (niceMax - niceMin) / spacing;
      if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
        numSpaces = Math.round(numSpaces);
      } else {
        numSpaces = Math.ceil(numSpaces);
      }
    }
    const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
    factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
    niceMin = Math.round(niceMin * factor) / factor;
    niceMax = Math.round(niceMax * factor) / factor;
    let j = 0;
    if (minDefined) {
      if (includeBounds && niceMin !== min) {
        ticks.push({
          value: min
        });
        if (niceMin < min) {
          j++;
        }
        if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
          j++;
        }
      } else if (niceMin < min) {
        j++;
      }
    }
    for (; j < numSpaces; ++j) {
      const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
      if (maxDefined && tickValue > max2) {
        break;
      }
      ticks.push({
        value: tickValue
      });
    }
    if (maxDefined && includeBounds && niceMax !== max2) {
      if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max2, relativeLabelSize(max2, minSpacing, generationOptions))) {
        ticks[ticks.length - 1].value = max2;
      } else {
        ticks.push({
          value: max2
        });
      }
    } else if (!maxDefined || niceMax === max2) {
      ticks.push({
        value: niceMax
      });
    }
    return ticks;
  }
  function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
    const rad = toRadians(minRotation);
    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
    const length = 0.75 * minSpacing * ("" + value).length;
    return Math.min(minSpacing / ratio, length);
  }
  var LinearScaleBase = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this.start = void 0;
      this.end = void 0;
      this._startValue = void 0;
      this._endValue = void 0;
      this._valueRange = 0;
    }
    parse(raw, index2) {
      if (isNullOrUndef(raw)) {
        return null;
      }
      if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
        return null;
      }
      return +raw;
    }
    handleTickRangeOptions() {
      const { beginAtZero } = this.options;
      const { minDefined, maxDefined } = this.getUserBounds();
      let { min, max: max2 } = this;
      const setMin = (v) => min = minDefined ? min : v;
      const setMax = (v) => max2 = maxDefined ? max2 : v;
      if (beginAtZero) {
        const minSign = sign(min);
        const maxSign = sign(max2);
        if (minSign < 0 && maxSign < 0) {
          setMax(0);
        } else if (minSign > 0 && maxSign > 0) {
          setMin(0);
        }
      }
      if (min === max2) {
        let offset = max2 === 0 ? 1 : Math.abs(max2 * 0.05);
        setMax(max2 + offset);
        if (!beginAtZero) {
          setMin(min - offset);
        }
      }
      this.min = min;
      this.max = max2;
    }
    getTickLimit() {
      const tickOpts = this.options.ticks;
      let { maxTicksLimit, stepSize } = tickOpts;
      let maxTicks;
      if (stepSize) {
        maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
        if (maxTicks > 1e3) {
          console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
          maxTicks = 1e3;
        }
      } else {
        maxTicks = this.computeTickLimit();
        maxTicksLimit = maxTicksLimit || 11;
      }
      if (maxTicksLimit) {
        maxTicks = Math.min(maxTicksLimit, maxTicks);
      }
      return maxTicks;
    }
    computeTickLimit() {
      return Number.POSITIVE_INFINITY;
    }
    buildTicks() {
      const opts = this.options;
      const tickOpts = opts.ticks;
      let maxTicks = this.getTickLimit();
      maxTicks = Math.max(2, maxTicks);
      const numericGeneratorOptions = {
        maxTicks,
        bounds: opts.bounds,
        min: opts.min,
        max: opts.max,
        precision: tickOpts.precision,
        step: tickOpts.stepSize,
        count: tickOpts.count,
        maxDigits: this._maxDigits(),
        horizontal: this.isHorizontal(),
        minRotation: tickOpts.minRotation || 0,
        includeBounds: tickOpts.includeBounds !== false
      };
      const dataRange = this._range || this;
      const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
      if (opts.bounds === "ticks") {
        _setMinAndMaxByKey(ticks, this, "value");
      }
      if (opts.reverse) {
        ticks.reverse();
        this.start = this.max;
        this.end = this.min;
      } else {
        this.start = this.min;
        this.end = this.max;
      }
      return ticks;
    }
    configure() {
      const ticks = this.ticks;
      let start = this.min;
      let end = this.max;
      super.configure();
      if (this.options.offset && ticks.length) {
        const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
        start -= offset;
        end += offset;
      }
      this._startValue = start;
      this._endValue = end;
      this._valueRange = end - start;
    }
    getLabelForValue(value) {
      return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
    }
  };
  var LinearScale = class extends LinearScaleBase {
    determineDataLimits() {
      const { min, max: max2 } = this.getMinMax(true);
      this.min = isNumberFinite(min) ? min : 0;
      this.max = isNumberFinite(max2) ? max2 : 1;
      this.handleTickRangeOptions();
    }
    computeTickLimit() {
      const horizontal = this.isHorizontal();
      const length = horizontal ? this.width : this.height;
      const minRotation = toRadians(this.options.ticks.minRotation);
      const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
      const tickFont = this._resolveTickFontOptions(0);
      return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
    }
    getPixelForValue(value) {
      return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
      return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
    }
  };
  __publicField(LinearScale, "id", "linear");
  __publicField(LinearScale, "defaults", {
    ticks: {
      callback: Ticks.formatters.numeric
    }
  });
  var log10Floor = (v) => Math.floor(log10(v));
  var changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);
  function isMajor(tickVal) {
    const remain = tickVal / Math.pow(10, log10Floor(tickVal));
    return remain === 1;
  }
  function steps(min, max2, rangeExp) {
    const rangeStep = Math.pow(10, rangeExp);
    const start = Math.floor(min / rangeStep);
    const end = Math.ceil(max2 / rangeStep);
    return end - start;
  }
  function startExp(min, max2) {
    const range2 = max2 - min;
    let rangeExp = log10Floor(range2);
    while (steps(min, max2, rangeExp) > 10) {
      rangeExp++;
    }
    while (steps(min, max2, rangeExp) < 10) {
      rangeExp--;
    }
    return Math.min(rangeExp, log10Floor(min));
  }
  function generateTicks(generationOptions, { min, max: max2 }) {
    min = finiteOrDefault(generationOptions.min, min);
    const ticks = [];
    const minExp = log10Floor(min);
    let exp = startExp(min, max2);
    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
    const stepSize = Math.pow(10, exp);
    const base = minExp > exp ? Math.pow(10, minExp) : 0;
    const start = Math.round((min - base) * precision) / precision;
    const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
    let significand = Math.floor((start - offset) / Math.pow(10, exp));
    let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
    while (value < max2) {
      ticks.push({
        value,
        major: isMajor(value),
        significand
      });
      if (significand >= 10) {
        significand = significand < 15 ? 15 : 20;
      } else {
        significand++;
      }
      if (significand >= 20) {
        exp++;
        significand = 2;
        precision = exp >= 0 ? 1 : precision;
      }
      value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
    }
    const lastTick = finiteOrDefault(generationOptions.max, value);
    ticks.push({
      value: lastTick,
      major: isMajor(lastTick),
      significand
    });
    return ticks;
  }
  var LogarithmicScale = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this.start = void 0;
      this.end = void 0;
      this._startValue = void 0;
      this._valueRange = 0;
    }
    parse(raw, index2) {
      const value = LinearScaleBase.prototype.parse.apply(this, [
        raw,
        index2
      ]);
      if (value === 0) {
        this._zero = true;
        return void 0;
      }
      return isNumberFinite(value) && value > 0 ? value : null;
    }
    determineDataLimits() {
      const { min, max: max2 } = this.getMinMax(true);
      this.min = isNumberFinite(min) ? Math.max(0, min) : null;
      this.max = isNumberFinite(max2) ? Math.max(0, max2) : null;
      if (this.options.beginAtZero) {
        this._zero = true;
      }
      if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
        this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
      }
      this.handleTickRangeOptions();
    }
    handleTickRangeOptions() {
      const { minDefined, maxDefined } = this.getUserBounds();
      let min = this.min;
      let max2 = this.max;
      const setMin = (v) => min = minDefined ? min : v;
      const setMax = (v) => max2 = maxDefined ? max2 : v;
      if (min === max2) {
        if (min <= 0) {
          setMin(1);
          setMax(10);
        } else {
          setMin(changeExponent(min, -1));
          setMax(changeExponent(max2, 1));
        }
      }
      if (min <= 0) {
        setMin(changeExponent(max2, -1));
      }
      if (max2 <= 0) {
        setMax(changeExponent(min, 1));
      }
      this.min = min;
      this.max = max2;
    }
    buildTicks() {
      const opts = this.options;
      const generationOptions = {
        min: this._userMin,
        max: this._userMax
      };
      const ticks = generateTicks(generationOptions, this);
      if (opts.bounds === "ticks") {
        _setMinAndMaxByKey(ticks, this, "value");
      }
      if (opts.reverse) {
        ticks.reverse();
        this.start = this.max;
        this.end = this.min;
      } else {
        this.start = this.min;
        this.end = this.max;
      }
      return ticks;
    }
    getLabelForValue(value) {
      return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
    }
    configure() {
      const start = this.min;
      super.configure();
      this._startValue = log10(start);
      this._valueRange = log10(this.max) - log10(start);
    }
    getPixelForValue(value) {
      if (value === void 0 || value === 0) {
        value = this.min;
      }
      if (value === null || isNaN(value)) {
        return NaN;
      }
      return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
      const decimal = this.getDecimalForPixel(pixel);
      return Math.pow(10, this._startValue + decimal * this._valueRange);
    }
  };
  __publicField(LogarithmicScale, "id", "logarithmic");
  __publicField(LogarithmicScale, "defaults", {
    ticks: {
      callback: Ticks.formatters.logarithmic,
      major: {
        enabled: true
      }
    }
  });
  function getTickBackdropHeight(opts) {
    const tickOpts = opts.ticks;
    if (tickOpts.display && opts.display) {
      const padding = toPadding(tickOpts.backdropPadding);
      return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
    }
    return 0;
  }
  function measureLabelSize(ctx, font, label) {
    label = isArray(label) ? label : [
      label
    ];
    return {
      w: _longestText(ctx, font.string, label),
      h: label.length * font.lineHeight
    };
  }
  function determineLimits(angle, pos, size, min, max2) {
    if (angle === min || angle === max2) {
      return {
        start: pos - size / 2,
        end: pos + size / 2
      };
    } else if (angle < min || angle > max2) {
      return {
        start: pos - size,
        end: pos
      };
    }
    return {
      start: pos,
      end: pos + size
    };
  }
  function fitWithPointLabels(scale) {
    const orig = {
      l: scale.left + scale._padding.left,
      r: scale.right - scale._padding.right,
      t: scale.top + scale._padding.top,
      b: scale.bottom - scale._padding.bottom
    };
    const limits = Object.assign({}, orig);
    const labelSizes = [];
    const padding = [];
    const valueCount = scale._pointLabels.length;
    const pointLabelOpts = scale.options.pointLabels;
    const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
    for (let i2 = 0; i2 < valueCount; i2++) {
      const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i2));
      padding[i2] = opts.padding;
      const pointPosition = scale.getPointPosition(i2, scale.drawingArea + padding[i2], additionalAngle);
      const plFont = toFont(opts.font);
      const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i2]);
      labelSizes[i2] = textSize;
      const angleRadians = _normalizeAngle(scale.getIndexAngle(i2) + additionalAngle);
      const angle = Math.round(toDegrees(angleRadians));
      const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
      const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
      updateLimits(limits, orig, angleRadians, hLimits, vLimits);
    }
    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
  }
  function updateLimits(limits, orig, angle, hLimits, vLimits) {
    const sin = Math.abs(Math.sin(angle));
    const cos = Math.abs(Math.cos(angle));
    let x = 0;
    let y = 0;
    if (hLimits.start < orig.l) {
      x = (orig.l - hLimits.start) / sin;
      limits.l = Math.min(limits.l, orig.l - x);
    } else if (hLimits.end > orig.r) {
      x = (hLimits.end - orig.r) / sin;
      limits.r = Math.max(limits.r, orig.r + x);
    }
    if (vLimits.start < orig.t) {
      y = (orig.t - vLimits.start) / cos;
      limits.t = Math.min(limits.t, orig.t - y);
    } else if (vLimits.end > orig.b) {
      y = (vLimits.end - orig.b) / cos;
      limits.b = Math.max(limits.b, orig.b + y);
    }
  }
  function createPointLabelItem(scale, index2, itemOpts) {
    const outerDistance = scale.drawingArea;
    const { extra, additionalAngle, padding, size } = itemOpts;
    const pointLabelPosition = scale.getPointPosition(index2, outerDistance + extra + padding, additionalAngle);
    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
    const y = yForAngle(pointLabelPosition.y, size.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    return {
      visible: true,
      x: pointLabelPosition.x,
      y,
      textAlign,
      left,
      top: y,
      right: left + size.w,
      bottom: y + size.h
    };
  }
  function isNotOverlapped(item, area) {
    if (!area) {
      return true;
    }
    const { left, top: top2, right, bottom: bottom2 } = item;
    const apexesInArea = _isPointInArea({
      x: left,
      y: top2
    }, area) || _isPointInArea({
      x: left,
      y: bottom2
    }, area) || _isPointInArea({
      x: right,
      y: top2
    }, area) || _isPointInArea({
      x: right,
      y: bottom2
    }, area);
    return !apexesInArea;
  }
  function buildPointLabelItems(scale, labelSizes, padding) {
    const items = [];
    const valueCount = scale._pointLabels.length;
    const opts = scale.options;
    const { centerPointLabels, display } = opts.pointLabels;
    const itemOpts = {
      extra: getTickBackdropHeight(opts) / 2,
      additionalAngle: centerPointLabels ? PI / valueCount : 0
    };
    let area;
    for (let i2 = 0; i2 < valueCount; i2++) {
      itemOpts.padding = padding[i2];
      itemOpts.size = labelSizes[i2];
      const item = createPointLabelItem(scale, i2, itemOpts);
      items.push(item);
      if (display === "auto") {
        item.visible = isNotOverlapped(item, area);
        if (item.visible) {
          area = item;
        }
      }
    }
    return items;
  }
  function getTextAlignForAngle(angle) {
    if (angle === 0 || angle === 180) {
      return "center";
    } else if (angle < 180) {
      return "left";
    }
    return "right";
  }
  function leftForTextAlign(x, w, align) {
    if (align === "right") {
      x -= w;
    } else if (align === "center") {
      x -= w / 2;
    }
    return x;
  }
  function yForAngle(y, h3, angle) {
    if (angle === 90 || angle === 270) {
      y -= h3 / 2;
    } else if (angle > 270 || angle < 90) {
      y -= h3;
    }
    return y;
  }
  function drawPointLabelBox(ctx, opts, item) {
    const { left, top: top2, right, bottom: bottom2 } = item;
    const { backdropColor } = opts;
    if (!isNullOrUndef(backdropColor)) {
      const borderRadius = toTRBLCorners(opts.borderRadius);
      const padding = toPadding(opts.backdropPadding);
      ctx.fillStyle = backdropColor;
      const backdropLeft = left - padding.left;
      const backdropTop = top2 - padding.top;
      const backdropWidth = right - left + padding.width;
      const backdropHeight = bottom2 - top2 + padding.height;
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: backdropLeft,
          y: backdropTop,
          w: backdropWidth,
          h: backdropHeight,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
      }
    }
  }
  function drawPointLabels(scale, labelCount) {
    const { ctx, options: { pointLabels } } = scale;
    for (let i2 = labelCount - 1; i2 >= 0; i2--) {
      const item = scale._pointLabelItems[i2];
      if (!item.visible) {
        continue;
      }
      const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i2));
      drawPointLabelBox(ctx, optsAtIndex, item);
      const plFont = toFont(optsAtIndex.font);
      const { x, y, textAlign } = item;
      renderText(ctx, scale._pointLabels[i2], x, y + plFont.lineHeight / 2, plFont, {
        color: optsAtIndex.color,
        textAlign,
        textBaseline: "middle"
      });
    }
  }
  function pathRadiusLine(scale, radius, circular, labelCount) {
    const { ctx } = scale;
    if (circular) {
      ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
    } else {
      let pointPosition = scale.getPointPosition(0, radius);
      ctx.moveTo(pointPosition.x, pointPosition.y);
      for (let i2 = 1; i2 < labelCount; i2++) {
        pointPosition = scale.getPointPosition(i2, radius);
        ctx.lineTo(pointPosition.x, pointPosition.y);
      }
    }
  }
  function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
    const ctx = scale.ctx;
    const circular = gridLineOpts.circular;
    const { color: color2, lineWidth } = gridLineOpts;
    if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
      return;
    }
    ctx.save();
    ctx.strokeStyle = color2;
    ctx.lineWidth = lineWidth;
    ctx.setLineDash(borderOpts.dash || []);
    ctx.lineDashOffset = borderOpts.dashOffset;
    ctx.beginPath();
    pathRadiusLine(scale, radius, circular, labelCount);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
  function createPointLabelContext(parent, index2, label) {
    return createContext(parent, {
      label,
      index: index2,
      type: "pointLabel"
    });
  }
  var RadialLinearScale = class extends LinearScaleBase {
    constructor(cfg) {
      super(cfg);
      this.xCenter = void 0;
      this.yCenter = void 0;
      this.drawingArea = void 0;
      this._pointLabels = [];
      this._pointLabelItems = [];
    }
    setDimensions() {
      const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
      const w = this.width = this.maxWidth - padding.width;
      const h3 = this.height = this.maxHeight - padding.height;
      this.xCenter = Math.floor(this.left + w / 2 + padding.left);
      this.yCenter = Math.floor(this.top + h3 / 2 + padding.top);
      this.drawingArea = Math.floor(Math.min(w, h3) / 2);
    }
    determineDataLimits() {
      const { min, max: max2 } = this.getMinMax(false);
      this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
      this.max = isNumberFinite(max2) && !isNaN(max2) ? max2 : 0;
      this.handleTickRangeOptions();
    }
    computeTickLimit() {
      return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
    }
    generateTickLabels(ticks) {
      LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
      this._pointLabels = this.getLabels().map((value, index2) => {
        const label = callback(this.options.pointLabels.callback, [
          value,
          index2
        ], this);
        return label || label === 0 ? label : "";
      }).filter((v, i2) => this.chart.getDataVisibility(i2));
    }
    fit() {
      const opts = this.options;
      if (opts.display && opts.pointLabels.display) {
        fitWithPointLabels(this);
      } else {
        this.setCenterPoint(0, 0, 0, 0);
      }
    }
    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
      this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
      this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
      this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
    }
    getIndexAngle(index2) {
      const angleMultiplier = TAU / (this._pointLabels.length || 1);
      const startAngle = this.options.startAngle || 0;
      return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
    }
    getDistanceFromCenterForValue(value) {
      if (isNullOrUndef(value)) {
        return NaN;
      }
      const scalingFactor = this.drawingArea / (this.max - this.min);
      if (this.options.reverse) {
        return (this.max - value) * scalingFactor;
      }
      return (value - this.min) * scalingFactor;
    }
    getValueForDistanceFromCenter(distance) {
      if (isNullOrUndef(distance)) {
        return NaN;
      }
      const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
      return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
    }
    getPointLabelContext(index2) {
      const pointLabels = this._pointLabels || [];
      if (index2 >= 0 && index2 < pointLabels.length) {
        const pointLabel = pointLabels[index2];
        return createPointLabelContext(this.getContext(), index2, pointLabel);
      }
    }
    getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {
      const angle = this.getIndexAngle(index2) - HALF_PI + additionalAngle;
      return {
        x: Math.cos(angle) * distanceFromCenter + this.xCenter,
        y: Math.sin(angle) * distanceFromCenter + this.yCenter,
        angle
      };
    }
    getPointPositionForValue(index2, value) {
      return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
    }
    getBasePosition(index2) {
      return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
    }
    getPointLabelPosition(index2) {
      const { left, top: top2, right, bottom: bottom2 } = this._pointLabelItems[index2];
      return {
        left,
        top: top2,
        right,
        bottom: bottom2
      };
    }
    drawBackground() {
      const { backgroundColor, grid: { circular } } = this.options;
      if (backgroundColor) {
        const ctx = this.ctx;
        ctx.save();
        ctx.beginPath();
        pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
        ctx.closePath();
        ctx.fillStyle = backgroundColor;
        ctx.fill();
        ctx.restore();
      }
    }
    drawGrid() {
      const ctx = this.ctx;
      const opts = this.options;
      const { angleLines, grid, border } = opts;
      const labelCount = this._pointLabels.length;
      let i2, offset, position;
      if (opts.pointLabels.display) {
        drawPointLabels(this, labelCount);
      }
      if (grid.display) {
        this.ticks.forEach((tick, index2) => {
          if (index2 !== 0 || index2 === 0 && this.min < 0) {
            offset = this.getDistanceFromCenterForValue(tick.value);
            const context = this.getContext(index2);
            const optsAtIndex = grid.setContext(context);
            const optsAtIndexBorder = border.setContext(context);
            drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
          }
        });
      }
      if (angleLines.display) {
        ctx.save();
        for (i2 = labelCount - 1; i2 >= 0; i2--) {
          const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i2));
          const { color: color2, lineWidth } = optsAtIndex;
          if (!lineWidth || !color2) {
            continue;
          }
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = color2;
          ctx.setLineDash(optsAtIndex.borderDash);
          ctx.lineDashOffset = optsAtIndex.borderDashOffset;
          offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);
          position = this.getPointPosition(i2, offset);
          ctx.beginPath();
          ctx.moveTo(this.xCenter, this.yCenter);
          ctx.lineTo(position.x, position.y);
          ctx.stroke();
        }
        ctx.restore();
      }
    }
    drawBorder() {
    }
    drawLabels() {
      const ctx = this.ctx;
      const opts = this.options;
      const tickOpts = opts.ticks;
      if (!tickOpts.display) {
        return;
      }
      const startAngle = this.getIndexAngle(0);
      let offset, width;
      ctx.save();
      ctx.translate(this.xCenter, this.yCenter);
      ctx.rotate(startAngle);
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      this.ticks.forEach((tick, index2) => {
        if (index2 === 0 && this.min >= 0 && !opts.reverse) {
          return;
        }
        const optsAtIndex = tickOpts.setContext(this.getContext(index2));
        const tickFont = toFont(optsAtIndex.font);
        offset = this.getDistanceFromCenterForValue(this.ticks[index2].value);
        if (optsAtIndex.showLabelBackdrop) {
          ctx.font = tickFont.string;
          width = ctx.measureText(tick.label).width;
          ctx.fillStyle = optsAtIndex.backdropColor;
          const padding = toPadding(optsAtIndex.backdropPadding);
          ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
        }
        renderText(ctx, tick.label, 0, -offset, tickFont, {
          color: optsAtIndex.color,
          strokeColor: optsAtIndex.textStrokeColor,
          strokeWidth: optsAtIndex.textStrokeWidth
        });
      });
      ctx.restore();
    }
    drawTitle() {
    }
  };
  __publicField(RadialLinearScale, "id", "radialLinear");
  __publicField(RadialLinearScale, "defaults", {
    display: true,
    animate: true,
    position: "chartArea",
    angleLines: {
      display: true,
      lineWidth: 1,
      borderDash: [],
      borderDashOffset: 0
    },
    grid: {
      circular: false
    },
    startAngle: 0,
    ticks: {
      showLabelBackdrop: true,
      callback: Ticks.formatters.numeric
    },
    pointLabels: {
      backdropColor: void 0,
      backdropPadding: 2,
      display: true,
      font: {
        size: 10
      },
      callback(label) {
        return label;
      },
      padding: 5,
      centerPointLabels: false
    }
  });
  __publicField(RadialLinearScale, "defaultRoutes", {
    "angleLines.color": "borderColor",
    "pointLabels.color": "color",
    "ticks.color": "color"
  });
  __publicField(RadialLinearScale, "descriptors", {
    angleLines: {
      _fallback: "grid"
    }
  });
  var INTERVALS = {
    millisecond: {
      common: true,
      size: 1,
      steps: 1e3
    },
    second: {
      common: true,
      size: 1e3,
      steps: 60
    },
    minute: {
      common: true,
      size: 6e4,
      steps: 60
    },
    hour: {
      common: true,
      size: 36e5,
      steps: 24
    },
    day: {
      common: true,
      size: 864e5,
      steps: 30
    },
    week: {
      common: false,
      size: 6048e5,
      steps: 4
    },
    month: {
      common: true,
      size: 2628e6,
      steps: 12
    },
    quarter: {
      common: false,
      size: 7884e6,
      steps: 4
    },
    year: {
      common: true,
      size: 3154e7
    }
  };
  var UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
  function sorter(a2, b) {
    return a2 - b;
  }
  function parse(scale, input) {
    if (isNullOrUndef(input)) {
      return null;
    }
    const adapter = scale._adapter;
    const { parser, round: round2, isoWeekday } = scale._parseOpts;
    let value = input;
    if (typeof parser === "function") {
      value = parser(value);
    }
    if (!isNumberFinite(value)) {
      value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
    }
    if (value === null) {
      return null;
    }
    if (round2) {
      value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
    }
    return +value;
  }
  function determineUnitForAutoTicks(minUnit, min, max2, capacity) {
    const ilen = UNITS.length;
    for (let i2 = UNITS.indexOf(minUnit); i2 < ilen - 1; ++i2) {
      const interval = INTERVALS[UNITS[i2]];
      const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
      if (interval.common && Math.ceil((max2 - min) / (factor * interval.size)) <= capacity) {
        return UNITS[i2];
      }
    }
    return UNITS[ilen - 1];
  }
  function determineUnitForFormatting(scale, numTicks, minUnit, min, max2) {
    for (let i2 = UNITS.length - 1; i2 >= UNITS.indexOf(minUnit); i2--) {
      const unit = UNITS[i2];
      if (INTERVALS[unit].common && scale._adapter.diff(max2, min, unit) >= numTicks - 1) {
        return unit;
      }
    }
    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
  }
  function determineMajorUnit(unit) {
    for (let i2 = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i2 < ilen; ++i2) {
      if (INTERVALS[UNITS[i2]].common) {
        return UNITS[i2];
      }
    }
  }
  function addTick(ticks, time, timestamps) {
    if (!timestamps) {
      ticks[time] = true;
    } else if (timestamps.length) {
      const { lo, hi } = _lookup(timestamps, time);
      const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
      ticks[timestamp] = true;
    }
  }
  function setMajorTicks(scale, ticks, map3, majorUnit) {
    const adapter = scale._adapter;
    const first = +adapter.startOf(ticks[0].value, majorUnit);
    const last = ticks[ticks.length - 1].value;
    let major, index2;
    for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
      index2 = map3[major];
      if (index2 >= 0) {
        ticks[index2].major = true;
      }
    }
    return ticks;
  }
  function ticksFromTimestamps(scale, values, majorUnit) {
    const ticks = [];
    const map3 = {};
    const ilen = values.length;
    let i2, value;
    for (i2 = 0; i2 < ilen; ++i2) {
      value = values[i2];
      map3[value] = i2;
      ticks.push({
        value,
        major: false
      });
    }
    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map3, majorUnit);
  }
  var TimeScale = class extends Scale {
    constructor(props) {
      super(props);
      this._cache = {
        data: [],
        labels: [],
        all: []
      };
      this._unit = "day";
      this._majorUnit = void 0;
      this._offsets = {};
      this._normalized = false;
      this._parseOpts = void 0;
    }
    init(scaleOpts, opts = {}) {
      const time = scaleOpts.time || (scaleOpts.time = {});
      const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
      adapter.init(opts);
      mergeIf(time.displayFormats, adapter.formats());
      this._parseOpts = {
        parser: time.parser,
        round: time.round,
        isoWeekday: time.isoWeekday
      };
      super.init(scaleOpts);
      this._normalized = opts.normalized;
    }
    parse(raw, index2) {
      if (raw === void 0) {
        return null;
      }
      return parse(this, raw);
    }
    beforeLayout() {
      super.beforeLayout();
      this._cache = {
        data: [],
        labels: [],
        all: []
      };
    }
    determineDataLimits() {
      const options = this.options;
      const adapter = this._adapter;
      const unit = options.time.unit || "day";
      let { min, max: max2, minDefined, maxDefined } = this.getUserBounds();
      function _applyBounds(bounds) {
        if (!minDefined && !isNaN(bounds.min)) {
          min = Math.min(min, bounds.min);
        }
        if (!maxDefined && !isNaN(bounds.max)) {
          max2 = Math.max(max2, bounds.max);
        }
      }
      if (!minDefined || !maxDefined) {
        _applyBounds(this._getLabelBounds());
        if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
          _applyBounds(this.getMinMax(false));
        }
      }
      min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
      max2 = isNumberFinite(max2) && !isNaN(max2) ? max2 : +adapter.endOf(Date.now(), unit) + 1;
      this.min = Math.min(min, max2 - 1);
      this.max = Math.max(min + 1, max2);
    }
    _getLabelBounds() {
      const arr = this.getLabelTimestamps();
      let min = Number.POSITIVE_INFINITY;
      let max2 = Number.NEGATIVE_INFINITY;
      if (arr.length) {
        min = arr[0];
        max2 = arr[arr.length - 1];
      }
      return {
        min,
        max: max2
      };
    }
    buildTicks() {
      const options = this.options;
      const timeOpts = options.time;
      const tickOpts = options.ticks;
      const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
      if (options.bounds === "ticks" && timestamps.length) {
        this.min = this._userMin || timestamps[0];
        this.max = this._userMax || timestamps[timestamps.length - 1];
      }
      const min = this.min;
      const max2 = this.max;
      const ticks = _filterBetween(timestamps, min, max2);
      this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
      this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
      this.initOffsets(timestamps);
      if (options.reverse) {
        ticks.reverse();
      }
      return ticksFromTimestamps(this, ticks, this._majorUnit);
    }
    afterAutoSkip() {
      if (this.options.offsetAfterAutoskip) {
        this.initOffsets(this.ticks.map((tick) => +tick.value));
      }
    }
    initOffsets(timestamps = []) {
      let start = 0;
      let end = 0;
      let first, last;
      if (this.options.offset && timestamps.length) {
        first = this.getDecimalForValue(timestamps[0]);
        if (timestamps.length === 1) {
          start = 1 - first;
        } else {
          start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
        }
        last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
        if (timestamps.length === 1) {
          end = last;
        } else {
          end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
        }
      }
      const limit = timestamps.length < 3 ? 0.5 : 0.25;
      start = _limitValue(start, 0, limit);
      end = _limitValue(end, 0, limit);
      this._offsets = {
        start,
        end,
        factor: 1 / (start + 1 + end)
      };
    }
    _generate() {
      const adapter = this._adapter;
      const min = this.min;
      const max2 = this.max;
      const options = this.options;
      const timeOpts = options.time;
      const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max2, this._getLabelCapacity(min));
      const stepSize = valueOrDefault(options.ticks.stepSize, 1);
      const weekday = minor === "week" ? timeOpts.isoWeekday : false;
      const hasWeekday = isNumber(weekday) || weekday === true;
      const ticks = {};
      let first = min;
      let time, count;
      if (hasWeekday) {
        first = +adapter.startOf(first, "isoWeek", weekday);
      }
      first = +adapter.startOf(first, hasWeekday ? "day" : minor);
      if (adapter.diff(max2, min, minor) > 1e5 * stepSize) {
        throw new Error(min + " and " + max2 + " are too far apart with stepSize of " + stepSize + " " + minor);
      }
      const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
      for (time = first, count = 0; time < max2; time = +adapter.add(time, stepSize, minor), count++) {
        addTick(ticks, time, timestamps);
      }
      if (time === max2 || options.bounds === "ticks" || count === 1) {
        addTick(ticks, time, timestamps);
      }
      return Object.keys(ticks).sort(sorter).map((x) => +x);
    }
    getLabelForValue(value) {
      const adapter = this._adapter;
      const timeOpts = this.options.time;
      if (timeOpts.tooltipFormat) {
        return adapter.format(value, timeOpts.tooltipFormat);
      }
      return adapter.format(value, timeOpts.displayFormats.datetime);
    }
    format(value, format) {
      const options = this.options;
      const formats = options.time.displayFormats;
      const unit = this._unit;
      const fmt = format || formats[unit];
      return this._adapter.format(value, fmt);
    }
    _tickFormatFunction(time, index2, ticks, format) {
      const options = this.options;
      const formatter = options.ticks.callback;
      if (formatter) {
        return callback(formatter, [
          time,
          index2,
          ticks
        ], this);
      }
      const formats = options.time.displayFormats;
      const unit = this._unit;
      const majorUnit = this._majorUnit;
      const minorFormat = unit && formats[unit];
      const majorFormat = majorUnit && formats[majorUnit];
      const tick = ticks[index2];
      const major = majorUnit && majorFormat && tick && tick.major;
      return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
    }
    generateTickLabels(ticks) {
      let i2, ilen, tick;
      for (i2 = 0, ilen = ticks.length; i2 < ilen; ++i2) {
        tick = ticks[i2];
        tick.label = this._tickFormatFunction(tick.value, i2, ticks);
      }
    }
    getDecimalForValue(value) {
      return value === null ? NaN : (value - this.min) / (this.max - this.min);
    }
    getPixelForValue(value) {
      const offsets = this._offsets;
      const pos = this.getDecimalForValue(value);
      return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
    }
    getValueForPixel(pixel) {
      const offsets = this._offsets;
      const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
      return this.min + pos * (this.max - this.min);
    }
    _getLabelSize(label) {
      const ticksOpts = this.options.ticks;
      const tickLabelWidth = this.ctx.measureText(label).width;
      const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
      const cosRotation = Math.cos(angle);
      const sinRotation = Math.sin(angle);
      const tickFontSize = this._resolveTickFontOptions(0).size;
      return {
        w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
        h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
      };
    }
    _getLabelCapacity(exampleTime) {
      const timeOpts = this.options.time;
      const displayFormats = timeOpts.displayFormats;
      const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
      const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
        exampleTime
      ], this._majorUnit), format);
      const size = this._getLabelSize(exampleLabel);
      const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
      return capacity > 0 ? capacity : 1;
    }
    getDataTimestamps() {
      let timestamps = this._cache.data || [];
      let i2, ilen;
      if (timestamps.length) {
        return timestamps;
      }
      const metas = this.getMatchingVisibleMetas();
      if (this._normalized && metas.length) {
        return this._cache.data = metas[0].controller.getAllParsedValues(this);
      }
      for (i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
        timestamps = timestamps.concat(metas[i2].controller.getAllParsedValues(this));
      }
      return this._cache.data = this.normalize(timestamps);
    }
    getLabelTimestamps() {
      const timestamps = this._cache.labels || [];
      let i2, ilen;
      if (timestamps.length) {
        return timestamps;
      }
      const labels = this.getLabels();
      for (i2 = 0, ilen = labels.length; i2 < ilen; ++i2) {
        timestamps.push(parse(this, labels[i2]));
      }
      return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
    }
    normalize(values) {
      return _arrayUnique(values.sort(sorter));
    }
  };
  __publicField(TimeScale, "id", "time");
  __publicField(TimeScale, "defaults", {
    bounds: "data",
    adapters: {},
    time: {
      parser: false,
      unit: false,
      round: false,
      isoWeekday: false,
      minUnit: "millisecond",
      displayFormats: {}
    },
    ticks: {
      source: "auto",
      callback: false,
      major: {
        enabled: false
      }
    }
  });
  function interpolate2(table, val, reverse) {
    let lo = 0;
    let hi = table.length - 1;
    let prevSource, nextSource, prevTarget, nextTarget;
    if (reverse) {
      if (val >= table[lo].pos && val <= table[hi].pos) {
        ({ lo, hi } = _lookupByKey(table, "pos", val));
      }
      ({ pos: prevSource, time: prevTarget } = table[lo]);
      ({ pos: nextSource, time: nextTarget } = table[hi]);
    } else {
      if (val >= table[lo].time && val <= table[hi].time) {
        ({ lo, hi } = _lookupByKey(table, "time", val));
      }
      ({ time: prevSource, pos: prevTarget } = table[lo]);
      ({ time: nextSource, pos: nextTarget } = table[hi]);
    }
    const span = nextSource - prevSource;
    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
  }
  var TimeSeriesScale = class extends TimeScale {
    constructor(props) {
      super(props);
      this._table = [];
      this._minPos = void 0;
      this._tableRange = void 0;
    }
    initOffsets() {
      const timestamps = this._getTimestampsForTable();
      const table = this._table = this.buildLookupTable(timestamps);
      this._minPos = interpolate2(table, this.min);
      this._tableRange = interpolate2(table, this.max) - this._minPos;
      super.initOffsets(timestamps);
    }
    buildLookupTable(timestamps) {
      const { min, max: max2 } = this;
      const items = [];
      const table = [];
      let i2, ilen, prev, curr, next;
      for (i2 = 0, ilen = timestamps.length; i2 < ilen; ++i2) {
        curr = timestamps[i2];
        if (curr >= min && curr <= max2) {
          items.push(curr);
        }
      }
      if (items.length < 2) {
        return [
          {
            time: min,
            pos: 0
          },
          {
            time: max2,
            pos: 1
          }
        ];
      }
      for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
        next = items[i2 + 1];
        prev = items[i2 - 1];
        curr = items[i2];
        if (Math.round((next + prev) / 2) !== curr) {
          table.push({
            time: curr,
            pos: i2 / (ilen - 1)
          });
        }
      }
      return table;
    }
    _generate() {
      const min = this.min;
      const max2 = this.max;
      let timestamps = super.getDataTimestamps();
      if (!timestamps.includes(min) || !timestamps.length) {
        timestamps.splice(0, 0, min);
      }
      if (!timestamps.includes(max2) || timestamps.length === 1) {
        timestamps.push(max2);
      }
      return timestamps.sort((a2, b) => a2 - b);
    }
    _getTimestampsForTable() {
      let timestamps = this._cache.all || [];
      if (timestamps.length) {
        return timestamps;
      }
      const data = this.getDataTimestamps();
      const label = this.getLabelTimestamps();
      if (data.length && label.length) {
        timestamps = this.normalize(data.concat(label));
      } else {
        timestamps = data.length ? data : label;
      }
      timestamps = this._cache.all = timestamps;
      return timestamps;
    }
    getDecimalForValue(value) {
      return (interpolate2(this._table, value) - this._minPos) / this._tableRange;
    }
    getValueForPixel(pixel) {
      const offsets = this._offsets;
      const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
      return interpolate2(this._table, decimal * this._tableRange + this._minPos, true);
    }
  };
  __publicField(TimeSeriesScale, "id", "timeseries");
  __publicField(TimeSeriesScale, "defaults", TimeScale.defaults);
  var scales = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    CategoryScale,
    LinearScale,
    LogarithmicScale,
    RadialLinearScale,
    TimeScale,
    TimeSeriesScale
  });
  var registerables = [
    controllers,
    elements,
    plugins,
    scales
  ];

  // node_modules/chart.js/auto/auto.js
  Chart.register(...registerables);
  var auto_default = Chart;

  // js/half_gauge.js
  var half_gauge_default = HalfGauge = {
    mounted() {
      let ctx = this.el;
      const lead_max_temperature = this.el.dataset.lead_max_temperature;
      const lead_heat_check = this.el.dataset.lead_heat_check;
      const _title = this.el.dataset.label;
      console.log(lead_heat_check);
      const config = {
        type: "doughnut",
        data: {
          datasets: [
            {
              data: [lead_max_temperature, lead_heat_check - lead_max_temperature],
              backgroundColor: ["#ffa500", "#dddddd"],
              label: _title
            }
          ]
        },
        options: {
          circumference: 180,
          rotation: 270,
          responsive: false,
          // when true it cause error in phoenix.
          maintainAspectRatio: false,
          cutout: "70%",
          layout: {
            padding: 5
          },
          plugins: {
            title: {
              display: true,
              text: _title,
              padding: 4,
              font: "Consolas"
            },
            tooltip: {
              displayColors: false,
              callbacks: {
                label: function(tooltipItem) {
                  if (tooltipItem.dataIndex === 0) {
                    return _t("Value: ") + ledtempValue;
                  }
                  return _t("Max: ") + max;
                }
              }
            },
            // Adding the label in the center of the gauge
            datalabels: {
              display: true,
              formatter: (value, context) => {
                return context.dataIndex === 0 ? "gaugeValue" : "";
              },
              color: "#000",
              font: {
                size: 20,
                weight: "bold"
              }
            }
          },
          aspectRatio: 3.1
        }
      };
      new auto_default(ctx, config);
    }
  };

  // js/letter_gauge.js
  var letter_gauge_default = LetterGauge = {
    mounted() {
      if (!this.el)
        return;
      let ctx = this.el.getContext("2d");
      const score = this.el.dataset.score;
      const maxValue = 10;
      const remainingValue = maxValue - score;
      const _title = this.el.dataset.label;
      const backgroundColor = this.el.dataset.bgcolor;
      const labelValue = score;
      const centerTextPlugin = {
        id: "centerText",
        beforeDraw(chart) {
          const { width } = chart;
          const { top: top2, height } = chart.chartArea;
          const ctx2 = chart.ctx;
          ctx2.save();
          ctx2.font = "29px sans-serif";
          ctx2.fillStyle = "#000";
          ctx2.textAlign = "center";
          ctx2.textBaseline = "middle";
          ctx2.fillText(labelValue, width / 2, top2 + height / 2);
          ctx2.restore();
        }
      };
      const config = {
        type: "doughnut",
        data: {
          datasets: [
            {
              data: [score, remainingValue],
              backgroundColor: [backgroundColor, "#dddddd"]
            }
          ]
        },
        options: {
          aspectRatio: 1.9,
          responsive: false,
          // When true, it causes an error in Phoenix.
          maintainAspectRatio: false,
          cutout: "80%",
          plugins: {
            title: {
              display: true,
              text: _title,
              padding: 0,
              font: "ui-monospace"
            },
            tooltip: {
              enabled: false
            }
          },
          layout: {
            padding: 20
          }
        },
        plugins: [centerTextPlugin]
        // Register the custom plugin
      };
      new auto_default(ctx, config);
    }
  };

  // js/progresss_bar.js
  var progresss_bar_default = ProgressBar = {
    mounted() {
      if (!this.el)
        return;
      let ctx = this.el;
      const progressValue = ctx.dataset.progressvalue;
      const bgcolor = ctx.dataset.bgcolor;
      const maxValue = 9;
      const progressTextPlugin = {
        id: "progressText",
        afterDatasetsDraw(chart) {
          const { ctx: ctx2 } = chart;
          const dataset = chart.data.datasets[0];
          chart.getDatasetMeta(0).data.forEach((bar, index2) => {
            const value = dataset.data[index2];
            ctx2.fillStyle = "white";
            ctx2.font = "12px sans-serif";
            ctx2.textAlign = "center";
            ctx2.textBaseline = "middle";
            ctx2.fillText(`${value}`, bar.x - 20, bar.y);
          });
        }
      };
      const config = {
        type: "bar",
        data: {
          labels: [""],
          // Single bar
          datasets: [
            {
              data: [progressValue],
              backgroundColor: bgcolor,
              borderRadius: 3,
              barPercentage: 1,
              // Full width
              categoryPercentage: 1
              // Full height
            }
          ]
        },
        options: {
          indexAxis: "y",
          // Horizontal bar
          responsive: false,
          maintainAspectRatio: false,
          scales: {
            x: {
              min: 0,
              max: maxValue,
              display: false
              // Hide axis
            },
            y: {
              display: false
              // Hide axis
            }
          },
          plugins: {
            legend: { display: false },
            tooltip: { enabled: false }
          }
        },
        plugins: [progressTextPlugin]
      };
      new auto_default(ctx, config);
    }
  };

  // js/video_player.js
  var video_player_default = VideoPlayer = {
    mounted() {
      const videoElement = this.el;
      const video_path = this.el.dataset.video;
      const sourceElement = videoElement.querySelector("source");
      sourceElement.src = video_path;
      const token = "your_valid_token";
      fetch(video_path, {
        headers: {
          "Authorization": `Bearer ${token}`
        }
      }).then((response) => {
        if (!response.ok) {
          throw new Error("Network response was not ok");
        }
        return response.blob();
      }).then((blob) => {
        const url = URL.createObjectURL(blob);
        sourceElement.src = url;
        videoElement.load();
      }).catch((error) => {
        console.error("There was a problem with the fetch operation:", error);
      });
    }
  };

  // js/control_play.js
  var control_play_default = ControlPlay = {
    mounted() {
      let speechNonscriptedBtn = this.el;
      speechNonscriptedBtn.addEventListener("click", () => {
        const speechNonscriptedDiv = document.getElementById("speech-non-scripted-id");
        const speechscriptedDiv = document.getElementById("speech-scripted-id");
        if (this.el.id == "tab-one") {
          speechNonscriptedDiv.classList.remove("hidden");
          speechscriptedDiv.classList.add("hidden");
        } else {
          speechscriptedDiv.classList.remove("hidden");
          speechNonscriptedDiv.classList.add("hidden");
        }
      });
    }
  };

  // js/scroll_into_video.js
  var scroll_into_video_default = ScrollInto = {
    mounted() {
      const el = this.el;
      el.addEventListener("click", () => {
        el.scrollIntoView({ behavior: "smooth" });
      });
    }
  };

  // js/app.js
  var hooks = {};
  hooks.AudioPlayer = audio_player_default;
  hooks.HalfGauge = half_gauge_default;
  hooks.LetterGauge = letter_gauge_default;
  hooks.ProgressBar = progresss_bar_default;
  hooks.VideoPlayer = video_player_default;
  hooks.ControlPlay = control_play_default;
  hooks.ScrollInto = scroll_into_video_default;
  var csrfToken = document.querySelector("meta[name='csrf-token']").getAttribute("content");
  var liveSocket = new LiveSocket("/live", Socket, {
    hooks,
    longPollFallbackMs: 2500,
    params: { _csrf_token: csrfToken }
  });
  import_topbar.default.config({ barColors: { 0: "#29d" }, shadowColor: "rgba(0, 0, 0, .3)" });
  window.addEventListener("phx:page-loading-start", (_info) => import_topbar.default.show(300));
  window.addEventListener("phx:page-loading-stop", (_info) => import_topbar.default.hide());
  liveSocket.connect();
  window.liveSocket = liveSocket;
})();
/**
 * @license MIT
 * topbar 2.0.0, 2023-02-04
 * https://buunguyen.github.io/topbar
 * Copyright (c) 2021 Buu Nguyen
 */
/*! Bundled license information:

@kurkle/color/dist/color.esm.js:
  (*!
   * @kurkle/color v0.3.4
   * https://github.com/kurkle/color#readme
   * (c) 2024 Jukka Kurkela
   * Released under the MIT License
   *)

chart.js/dist/chunks/helpers.segment.js:
  (*!
   * Chart.js v4.4.7
   * https://www.chartjs.org
   * (c) 2024 Chart.js Contributors
   * Released under the MIT License
   *)

chart.js/dist/chart.js:
  (*!
   * Chart.js v4.4.7
   * https://www.chartjs.org
   * (c) 2024 Chart.js Contributors
   * Released under the MIT License
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vYXNzZXRzL3ZlbmRvci90b3BiYXIuanMiLCAiLi4vLi4vLi4vLi4vLi4vZGVwcy9waG9lbml4X2h0bWwvcHJpdi9zdGF0aWMvcGhvZW5peF9odG1sLmpzIiwgIi4uLy4uLy4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC91dGlscy5qcyIsICIuLi8uLi8uLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvY29uc3RhbnRzLmpzIiwgIi4uLy4uLy4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9wdXNoLmpzIiwgIi4uLy4uLy4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC90aW1lci5qcyIsICIuLi8uLi8uLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvY2hhbm5lbC5qcyIsICIuLi8uLi8uLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvYWpheC5qcyIsICIuLi8uLi8uLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvbG9uZ3BvbGwuanMiLCAiLi4vLi4vLi4vLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L3ByZXNlbmNlLmpzIiwgIi4uLy4uLy4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9zZXJpYWxpemVyLmpzIiwgIi4uLy4uLy4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9zb2NrZXQuanMiLCAiLi4vLi4vLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvY29uc3RhbnRzLmpzIiwgIi4uLy4uLy4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2VudHJ5X3VwbG9hZGVyLmpzIiwgIi4uLy4uLy4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L3V0aWxzLmpzIiwgIi4uLy4uLy4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2Jyb3dzZXIuanMiLCAiLi4vLi4vLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvZG9tLmpzIiwgIi4uLy4uLy4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L3VwbG9hZF9lbnRyeS5qcyIsICIuLi8uLi8uLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9saXZlX3VwbG9hZGVyLmpzIiwgIi4uLy4uLy4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2FyaWEuanMiLCAiLi4vLi4vLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvaG9va3MuanMiLCAiLi4vLi4vLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvZWxlbWVudF9yZWYuanMiLCAiLi4vLi4vLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvZG9tX3Bvc3RfbW9ycGhfcmVzdG9yZXIuanMiLCAiLi4vLi4vLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9ub2RlX21vZHVsZXMvbW9ycGhkb20vZGlzdC9tb3JwaGRvbS1lc20uanMiLCAiLi4vLi4vLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvZG9tX3BhdGNoLmpzIiwgIi4uLy4uLy4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L3JlbmRlcmVkLmpzIiwgIi4uLy4uLy4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2pzLmpzIiwgIi4uLy4uLy4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L3ZpZXdfaG9vay5qcyIsICIuLi8uLi8uLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy92aWV3LmpzIiwgIi4uLy4uLy4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2xpdmVfc29ja2V0LmpzIiwgIi4uLy4uLy4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2luZGV4LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9qcy9hcHAuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy93YXZlc3VyZmVyLmpzL2Rpc3Qvd2F2ZXN1cmZlci5lc20uanMiLCAiLi4vLi4vLi4vYXNzZXRzL2pzL2F1ZGlvX3BsYXllci5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BrdXJrbGUvY29sb3IvZGlzdC9jb2xvci5lc20uanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmNvcmUudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLm1hdGgudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24udHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmV4dHJhcy50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuZWFzaW5nLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jb2xvci50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuYW5pbWF0aW9ucy5kZWZhdWx0cy5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUubGF5b3V0cy5kZWZhdWx0cy5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuaW50bC50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUudGlja3MuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnNjYWxlLmRlZmF1bHRzLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5kZWZhdWx0cy5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jb25maWcudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmN1cnZlLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5kb20udHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmludGVycG9sYXRpb24udHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLnJ0bC50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuc2VnbWVudC5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuYW5pbWF0b3IuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmFuaW1hdGlvbi5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuYW5pbWF0aW9ucy5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5iYXIuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5idWJibGUuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5kb3VnaG51dC5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLmxpbmUuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5wb2xhckFyZWEuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5waWUuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5yYWRhci5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLnNjYXR0ZXIuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmFkYXB0ZXJzLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5pbnRlcmFjdGlvbi5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUubGF5b3V0cy5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbGF0Zm9ybS9wbGF0Zm9ybS5iYXNlLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsYXRmb3JtL3BsYXRmb3JtLmJhc2ljLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsYXRmb3JtL3BsYXRmb3JtLmRvbS5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbGF0Zm9ybS9pbmRleC5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuZWxlbWVudC50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuc2NhbGUuYXV0b3NraXAuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnNjYWxlLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS50eXBlZFJlZ2lzdHJ5LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5yZWdpc3RyeS5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUucGx1Z2lucy5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuY29uZmlnLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5jb250cm9sbGVyLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2VsZW1lbnRzL2VsZW1lbnQuYXJjLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2VsZW1lbnRzL2VsZW1lbnQubGluZS5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9lbGVtZW50cy9lbGVtZW50LnBvaW50LnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2VsZW1lbnRzL2VsZW1lbnQuYmFyLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmNvbG9ycy50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5kZWNpbWF0aW9uLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIuc2VnbWVudC5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLmhlbHBlci5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLm9wdGlvbnMuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci50YXJnZXQuc3RhY2suanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL3NpbXBsZUFyYy5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLnRhcmdldC5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLmRyYXdpbmcuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2luZGV4LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmxlZ2VuZC5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi50aXRsZS5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5zdWJ0aXRsZS5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi50b29sdGlwLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS5jYXRlZ29yeS5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUubGluZWFyYmFzZS5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUubGluZWFyLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS5sb2dhcml0aG1pYy5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUucmFkaWFsTGluZWFyLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS50aW1lLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS50aW1lc2VyaWVzLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2luZGV4LnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvYXV0by9hdXRvLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9qcy9oYWxmX2dhdWdlLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9qcy9sZXR0ZXJfZ2F1Z2UuanMiLCAiLi4vLi4vLi4vYXNzZXRzL2pzL3Byb2dyZXNzc19iYXIuanMiLCAiLi4vLi4vLi4vYXNzZXRzL2pzL3ZpZGVvX3BsYXllci5qcyIsICIuLi8uLi8uLi9hc3NldHMvanMvY29udHJvbF9wbGF5LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9qcy9zY3JvbGxfaW50b192aWRlby5qcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLyoqXG4gKiBAbGljZW5zZSBNSVRcbiAqIHRvcGJhciAyLjAuMCwgMjAyMy0wMi0wNFxuICogaHR0cHM6Ly9idXVuZ3V5ZW4uZ2l0aHViLmlvL3RvcGJhclxuICogQ29weXJpZ2h0IChjKSAyMDIxIEJ1dSBOZ3V5ZW5cbiAqL1xuKGZ1bmN0aW9uICh3aW5kb3csIGRvY3VtZW50KSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC8xNTc5NjcxXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxhc3RUaW1lID0gMDtcbiAgICB2YXIgdmVuZG9ycyA9IFtcIm1zXCIsIFwibW96XCIsIFwid2Via2l0XCIsIFwib1wiXTtcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3gpIHtcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPVxuICAgICAgICB3aW5kb3dbdmVuZG9yc1t4XSArIFwiUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJdO1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID1cbiAgICAgICAgd2luZG93W3ZlbmRvcnNbeF0gKyBcIkNhbmNlbEFuaW1hdGlvbkZyYW1lXCJdIHx8XG4gICAgICAgIHdpbmRvd1t2ZW5kb3JzW3hdICsgXCJDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl07XG4gICAgfVxuICAgIGlmICghd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSlcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGN1cnJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHZhciB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpO1xuICAgICAgICB2YXIgaWQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKTtcbiAgICAgICAgfSwgdGltZVRvQ2FsbCk7XG4gICAgICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9O1xuICAgIGlmICghd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKVxuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICB9O1xuICB9KSgpO1xuXG4gIHZhciBjYW52YXMsXG4gICAgY3VycmVudFByb2dyZXNzLFxuICAgIHNob3dpbmcsXG4gICAgcHJvZ3Jlc3NUaW1lcklkID0gbnVsbCxcbiAgICBmYWRlVGltZXJJZCA9IG51bGwsXG4gICAgZGVsYXlUaW1lcklkID0gbnVsbCxcbiAgICBhZGRFdmVudCA9IGZ1bmN0aW9uIChlbGVtLCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgICBpZiAoZWxlbS5hZGRFdmVudExpc3RlbmVyKSBlbGVtLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgICAgZWxzZSBpZiAoZWxlbS5hdHRhY2hFdmVudCkgZWxlbS5hdHRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBoYW5kbGVyKTtcbiAgICAgIGVsc2UgZWxlbVtcIm9uXCIgKyB0eXBlXSA9IGhhbmRsZXI7XG4gICAgfSxcbiAgICBvcHRpb25zID0ge1xuICAgICAgYXV0b1J1bjogdHJ1ZSxcbiAgICAgIGJhclRoaWNrbmVzczogMyxcbiAgICAgIGJhckNvbG9yczoge1xuICAgICAgICAwOiBcInJnYmEoMjYsICAxODgsIDE1NiwgLjkpXCIsXG4gICAgICAgIFwiLjI1XCI6IFwicmdiYSg1MiwgIDE1MiwgMjE5LCAuOSlcIixcbiAgICAgICAgXCIuNTBcIjogXCJyZ2JhKDI0MSwgMTk2LCAxNSwgIC45KVwiLFxuICAgICAgICBcIi43NVwiOiBcInJnYmEoMjMwLCAxMjYsIDM0LCAgLjkpXCIsXG4gICAgICAgIFwiMS4wXCI6IFwicmdiYSgyMTEsIDg0LCAgMCwgICAuOSlcIixcbiAgICAgIH0sXG4gICAgICBzaGFkb3dCbHVyOiAxMCxcbiAgICAgIHNoYWRvd0NvbG9yOiBcInJnYmEoMCwgICAwLCAgIDAsICAgLjYpXCIsXG4gICAgICBjbGFzc05hbWU6IG51bGwsXG4gICAgfSxcbiAgICByZXBhaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gb3B0aW9ucy5iYXJUaGlja25lc3MgKiA1OyAvLyBuZWVkIHNwYWNlIGZvciBzaGFkb3dcblxuICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjdHguc2hhZG93Qmx1ciA9IG9wdGlvbnMuc2hhZG93Qmx1cjtcbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IG9wdGlvbnMuc2hhZG93Q29sb3I7XG5cbiAgICAgIHZhciBsaW5lR3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgY2FudmFzLndpZHRoLCAwKTtcbiAgICAgIGZvciAodmFyIHN0b3AgaW4gb3B0aW9ucy5iYXJDb2xvcnMpXG4gICAgICAgIGxpbmVHcmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcCwgb3B0aW9ucy5iYXJDb2xvcnNbc3RvcF0pO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYmFyVGhpY2tuZXNzO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbygwLCBvcHRpb25zLmJhclRoaWNrbmVzcyAvIDIpO1xuICAgICAgY3R4LmxpbmVUbyhcbiAgICAgICAgTWF0aC5jZWlsKGN1cnJlbnRQcm9ncmVzcyAqIGNhbnZhcy53aWR0aCksXG4gICAgICAgIG9wdGlvbnMuYmFyVGhpY2tuZXNzIC8gMlxuICAgICAgKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxpbmVHcmFkaWVudDtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9LFxuICAgIGNyZWF0ZUNhbnZhcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICB2YXIgc3R5bGUgPSBjYW52YXMuc3R5bGU7XG4gICAgICBzdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIjtcbiAgICAgIHN0eWxlLnRvcCA9IHN0eWxlLmxlZnQgPSBzdHlsZS5yaWdodCA9IHN0eWxlLm1hcmdpbiA9IHN0eWxlLnBhZGRpbmcgPSAwO1xuICAgICAgc3R5bGUuekluZGV4ID0gMTAwMDAxO1xuICAgICAgc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgaWYgKG9wdGlvbnMuY2xhc3NOYW1lKSBjYW52YXMuY2xhc3NMaXN0LmFkZChvcHRpb25zLmNsYXNzTmFtZSk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICBhZGRFdmVudCh3aW5kb3csIFwicmVzaXplXCIsIHJlcGFpbnQpO1xuICAgIH0sXG4gICAgdG9wYmFyID0ge1xuICAgICAgY29uZmlnOiBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0cylcbiAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSBvcHRpb25zW2tleV0gPSBvcHRzW2tleV07XG4gICAgICB9LFxuICAgICAgc2hvdzogZnVuY3Rpb24gKGRlbGF5KSB7XG4gICAgICAgIGlmIChzaG93aW5nKSByZXR1cm47XG4gICAgICAgIGlmIChkZWxheSkge1xuICAgICAgICAgIGlmIChkZWxheVRpbWVySWQpIHJldHVybjtcbiAgICAgICAgICBkZWxheVRpbWVySWQgPSBzZXRUaW1lb3V0KCgpID0+IHRvcGJhci5zaG93KCksIGRlbGF5KTtcbiAgICAgICAgfSBlbHNlICB7XG4gICAgICAgICAgc2hvd2luZyA9IHRydWU7XG4gICAgICAgICAgaWYgKGZhZGVUaW1lcklkICE9PSBudWxsKSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoZmFkZVRpbWVySWQpO1xuICAgICAgICAgIGlmICghY2FudmFzKSBjcmVhdGVDYW52YXMoKTtcbiAgICAgICAgICBjYW52YXMuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgICAgdG9wYmFyLnByb2dyZXNzKDApO1xuICAgICAgICAgIGlmIChvcHRpb25zLmF1dG9SdW4pIHtcbiAgICAgICAgICAgIChmdW5jdGlvbiBsb29wKCkge1xuICAgICAgICAgICAgICBwcm9ncmVzc1RpbWVySWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgICAgICAgICAgICB0b3BiYXIucHJvZ3Jlc3MoXG4gICAgICAgICAgICAgICAgXCIrXCIgKyAwLjA1ICogTWF0aC5wb3coMSAtIE1hdGguc3FydChjdXJyZW50UHJvZ3Jlc3MpLCAyKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcm9ncmVzczogZnVuY3Rpb24gKHRvKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBjdXJyZW50UHJvZ3Jlc3M7XG4gICAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB0byA9XG4gICAgICAgICAgICAodG8uaW5kZXhPZihcIitcIikgPj0gMCB8fCB0by5pbmRleE9mKFwiLVwiKSA+PSAwXG4gICAgICAgICAgICAgID8gY3VycmVudFByb2dyZXNzXG4gICAgICAgICAgICAgIDogMCkgKyBwYXJzZUZsb2F0KHRvKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UHJvZ3Jlc3MgPSB0byA+IDEgPyAxIDogdG87XG4gICAgICAgIHJlcGFpbnQoKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQcm9ncmVzcztcbiAgICAgIH0sXG4gICAgICBoaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChkZWxheVRpbWVySWQpO1xuICAgICAgICBkZWxheVRpbWVySWQgPSBudWxsO1xuICAgICAgICBpZiAoIXNob3dpbmcpIHJldHVybjtcbiAgICAgICAgc2hvd2luZyA9IGZhbHNlO1xuICAgICAgICBpZiAocHJvZ3Jlc3NUaW1lcklkICE9IG51bGwpIHtcbiAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUocHJvZ3Jlc3NUaW1lcklkKTtcbiAgICAgICAgICBwcm9ncmVzc1RpbWVySWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIChmdW5jdGlvbiBsb29wKCkge1xuICAgICAgICAgIGlmICh0b3BiYXIucHJvZ3Jlc3MoXCIrLjFcIikgPj0gMSkge1xuICAgICAgICAgICAgY2FudmFzLnN0eWxlLm9wYWNpdHkgLT0gMC4wNTtcbiAgICAgICAgICAgIGlmIChjYW52YXMuc3R5bGUub3BhY2l0eSA8PSAwLjA1KSB7XG4gICAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICAgIGZhZGVUaW1lcklkID0gbnVsbDtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmYWRlVGltZXJJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XG4gICAgICAgIH0pKCk7XG4gICAgICB9LFxuICAgIH07XG5cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0b3BiYXI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRvcGJhcjtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRvcGJhciA9IHRvcGJhcjtcbiAgfVxufS5jYWxsKHRoaXMsIHdpbmRvdywgZG9jdW1lbnQpKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgUG9seWZpbGxFdmVudCA9IGV2ZW50Q29uc3RydWN0b3IoKTtcblxuICBmdW5jdGlvbiBldmVudENvbnN0cnVjdG9yKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB3aW5kb3cuQ3VzdG9tRXZlbnQ7XG4gICAgLy8gSUU8PTkgU3VwcG9ydFxuICAgIGZ1bmN0aW9uIEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7YnViYmxlczogZmFsc2UsIGNhbmNlbGFibGU6IGZhbHNlLCBkZXRhaWw6IHVuZGVmaW5lZH07XG4gICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuICAgICAgcmV0dXJuIGV2dDtcbiAgICB9XG4gICAgQ3VzdG9tRXZlbnQucHJvdG90eXBlID0gd2luZG93LkV2ZW50LnByb3RvdHlwZTtcbiAgICByZXR1cm4gQ3VzdG9tRXZlbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZEhpZGRlbklucHV0KG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIGlucHV0LnR5cGUgPSBcImhpZGRlblwiO1xuICAgIGlucHV0Lm5hbWUgPSBuYW1lO1xuICAgIGlucHV0LnZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soZWxlbWVudCwgdGFyZ2V0TW9kaWZpZXJLZXkpIHtcbiAgICB2YXIgdG8gPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdG9cIiksXG4gICAgICAgIG1ldGhvZCA9IGJ1aWxkSGlkZGVuSW5wdXQoXCJfbWV0aG9kXCIsIGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1tZXRob2RcIikpLFxuICAgICAgICBjc3JmID0gYnVpbGRIaWRkZW5JbnB1dChcIl9jc3JmX3Rva2VuXCIsIGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jc3JmXCIpKSxcbiAgICAgICAgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIpLFxuICAgICAgICBzdWJtaXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksXG4gICAgICAgIHRhcmdldCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidGFyZ2V0XCIpO1xuXG4gICAgZm9ybS5tZXRob2QgPSAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1ldGhvZFwiKSA9PT0gXCJnZXRcIikgPyBcImdldFwiIDogXCJwb3N0XCI7XG4gICAgZm9ybS5hY3Rpb24gPSB0bztcbiAgICBmb3JtLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblxuICAgIGlmICh0YXJnZXQpIGZvcm0udGFyZ2V0ID0gdGFyZ2V0O1xuICAgIGVsc2UgaWYgKHRhcmdldE1vZGlmaWVyS2V5KSBmb3JtLnRhcmdldCA9IFwiX2JsYW5rXCI7XG5cbiAgICBmb3JtLmFwcGVuZENoaWxkKGNzcmYpO1xuICAgIGZvcm0uYXBwZW5kQ2hpbGQobWV0aG9kKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xuXG4gICAgLy8gSW5zZXJ0IGEgYnV0dG9uIGFuZCBjbGljayBpdCBpbnN0ZWFkIG9mIHVzaW5nIGBmb3JtLnN1Ym1pdGBcbiAgICAvLyBiZWNhdXNlIHRoZSBgc3VibWl0YCBmdW5jdGlvbiBkb2VzIG5vdCBlbWl0IGEgYHN1Ym1pdGAgZXZlbnQuXG4gICAgc3VibWl0LnR5cGUgPSBcInN1Ym1pdFwiO1xuICAgIGZvcm0uYXBwZW5kQ2hpbGQoc3VibWl0KTtcbiAgICBzdWJtaXQuY2xpY2soKTtcbiAgfVxuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlbGVtZW50ID0gZS50YXJnZXQ7XG4gICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuXG4gICAgd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBwaG9lbml4TGlua0V2ZW50ID0gbmV3IFBvbHlmaWxsRXZlbnQoJ3Bob2VuaXgubGluay5jbGljaycsIHtcbiAgICAgICAgXCJidWJibGVzXCI6IHRydWUsIFwiY2FuY2VsYWJsZVwiOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFlbGVtZW50LmRpc3BhdGNoRXZlbnQocGhvZW5peExpbmtFdmVudCkpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtbWV0aG9kXCIpICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS10b1wiKSkge1xuICAgICAgICBoYW5kbGVDbGljayhlbGVtZW50LCBlLm1ldGFLZXkgfHwgZS5zaGlmdEtleSk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIGZhbHNlKTtcblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGhvZW5peC5saW5rLmNsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbWVzc2FnZSA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtY29uZmlybVwiKTtcbiAgICBpZihtZXNzYWdlICYmICF3aW5kb3cuY29uZmlybShtZXNzYWdlKSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSwgZmFsc2UpO1xufSkoKTtcbiIsICIvLyB3cmFwcyB2YWx1ZSBpbiBjbG9zdXJlIG9yIHJldHVybnMgY2xvc3VyZVxuZXhwb3J0IGxldCBjbG9zdXJlID0gKHZhbHVlKSA9PiB7XG4gIGlmKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKXtcbiAgICByZXR1cm4gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBsZXQgY2xvc3VyZSA9IGZ1bmN0aW9uICgpeyByZXR1cm4gdmFsdWUgfVxuICAgIHJldHVybiBjbG9zdXJlXG4gIH1cbn1cbiIsICJleHBvcnQgY29uc3QgZ2xvYmFsU2VsZiA9IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IG51bGxcbmV4cG9ydCBjb25zdCBwaHhXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogbnVsbFxuZXhwb3J0IGNvbnN0IGdsb2JhbCA9IGdsb2JhbFNlbGYgfHwgcGh4V2luZG93IHx8IGdsb2JhbFxuZXhwb3J0IGNvbnN0IERFRkFVTFRfVlNOID0gXCIyLjAuMFwiXG5leHBvcnQgY29uc3QgU09DS0VUX1NUQVRFUyA9IHtjb25uZWN0aW5nOiAwLCBvcGVuOiAxLCBjbG9zaW5nOiAyLCBjbG9zZWQ6IDN9XG5leHBvcnQgY29uc3QgREVGQVVMVF9USU1FT1VUID0gMTAwMDBcbmV4cG9ydCBjb25zdCBXU19DTE9TRV9OT1JNQUwgPSAxMDAwXG5leHBvcnQgY29uc3QgQ0hBTk5FTF9TVEFURVMgPSB7XG4gIGNsb3NlZDogXCJjbG9zZWRcIixcbiAgZXJyb3JlZDogXCJlcnJvcmVkXCIsXG4gIGpvaW5lZDogXCJqb2luZWRcIixcbiAgam9pbmluZzogXCJqb2luaW5nXCIsXG4gIGxlYXZpbmc6IFwibGVhdmluZ1wiLFxufVxuZXhwb3J0IGNvbnN0IENIQU5ORUxfRVZFTlRTID0ge1xuICBjbG9zZTogXCJwaHhfY2xvc2VcIixcbiAgZXJyb3I6IFwicGh4X2Vycm9yXCIsXG4gIGpvaW46IFwicGh4X2pvaW5cIixcbiAgcmVwbHk6IFwicGh4X3JlcGx5XCIsXG4gIGxlYXZlOiBcInBoeF9sZWF2ZVwiXG59XG5cbmV4cG9ydCBjb25zdCBUUkFOU1BPUlRTID0ge1xuICBsb25ncG9sbDogXCJsb25ncG9sbFwiLFxuICB3ZWJzb2NrZXQ6IFwid2Vic29ja2V0XCJcbn1cbmV4cG9ydCBjb25zdCBYSFJfU1RBVEVTID0ge1xuICBjb21wbGV0ZTogNFxufVxuIiwgIi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIFB1c2hcbiAqIEBwYXJhbSB7Q2hhbm5lbH0gY2hhbm5lbCAtIFRoZSBDaGFubmVsXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgLSBUaGUgZXZlbnQsIGZvciBleGFtcGxlIGBcInBoeF9qb2luXCJgXG4gKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZCAtIFRoZSBwYXlsb2FkLCBmb3IgZXhhbXBsZSBge3VzZXJfaWQ6IDEyM31gXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dCAtIFRoZSBwdXNoIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFB1c2gge1xuICBjb25zdHJ1Y3RvcihjaGFubmVsLCBldmVudCwgcGF5bG9hZCwgdGltZW91dCl7XG4gICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbFxuICAgIHRoaXMuZXZlbnQgPSBldmVudFxuICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQgfHwgZnVuY3Rpb24gKCl7IHJldHVybiB7fSB9XG4gICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBudWxsXG4gICAgdGhpcy50aW1lb3V0ID0gdGltZW91dFxuICAgIHRoaXMudGltZW91dFRpbWVyID0gbnVsbFxuICAgIHRoaXMucmVjSG9va3MgPSBbXVxuICAgIHRoaXMuc2VudCA9IGZhbHNlXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRcbiAgICovXG4gIHJlc2VuZCh0aW1lb3V0KXtcbiAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0XG4gICAgdGhpcy5yZXNldCgpXG4gICAgdGhpcy5zZW5kKClcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKi9cbiAgc2VuZCgpe1xuICAgIGlmKHRoaXMuaGFzUmVjZWl2ZWQoXCJ0aW1lb3V0XCIpKXsgcmV0dXJuIH1cbiAgICB0aGlzLnN0YXJ0VGltZW91dCgpXG4gICAgdGhpcy5zZW50ID0gdHJ1ZVxuICAgIHRoaXMuY2hhbm5lbC5zb2NrZXQucHVzaCh7XG4gICAgICB0b3BpYzogdGhpcy5jaGFubmVsLnRvcGljLFxuICAgICAgZXZlbnQ6IHRoaXMuZXZlbnQsXG4gICAgICBwYXlsb2FkOiB0aGlzLnBheWxvYWQoKSxcbiAgICAgIHJlZjogdGhpcy5yZWYsXG4gICAgICBqb2luX3JlZjogdGhpcy5jaGFubmVsLmpvaW5SZWYoKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHsqfSBzdGF0dXNcbiAgICogQHBhcmFtIHsqfSBjYWxsYmFja1xuICAgKi9cbiAgcmVjZWl2ZShzdGF0dXMsIGNhbGxiYWNrKXtcbiAgICBpZih0aGlzLmhhc1JlY2VpdmVkKHN0YXR1cykpe1xuICAgICAgY2FsbGJhY2sodGhpcy5yZWNlaXZlZFJlc3AucmVzcG9uc2UpXG4gICAgfVxuXG4gICAgdGhpcy5yZWNIb29rcy5wdXNoKHtzdGF0dXMsIGNhbGxiYWNrfSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZXNldCgpe1xuICAgIHRoaXMuY2FuY2VsUmVmRXZlbnQoKVxuICAgIHRoaXMucmVmID0gbnVsbFxuICAgIHRoaXMucmVmRXZlbnQgPSBudWxsXG4gICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBudWxsXG4gICAgdGhpcy5zZW50ID0gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbWF0Y2hSZWNlaXZlKHtzdGF0dXMsIHJlc3BvbnNlLCBfcmVmfSl7XG4gICAgdGhpcy5yZWNIb29rcy5maWx0ZXIoaCA9PiBoLnN0YXR1cyA9PT0gc3RhdHVzKVxuICAgICAgLmZvckVhY2goaCA9PiBoLmNhbGxiYWNrKHJlc3BvbnNlKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2FuY2VsUmVmRXZlbnQoKXtcbiAgICBpZighdGhpcy5yZWZFdmVudCl7IHJldHVybiB9XG4gICAgdGhpcy5jaGFubmVsLm9mZih0aGlzLnJlZkV2ZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYW5jZWxUaW1lb3V0KCl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dFRpbWVyKVxuICAgIHRoaXMudGltZW91dFRpbWVyID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGFydFRpbWVvdXQoKXtcbiAgICBpZih0aGlzLnRpbWVvdXRUaW1lcil7IHRoaXMuY2FuY2VsVGltZW91dCgpIH1cbiAgICB0aGlzLnJlZiA9IHRoaXMuY2hhbm5lbC5zb2NrZXQubWFrZVJlZigpXG4gICAgdGhpcy5yZWZFdmVudCA9IHRoaXMuY2hhbm5lbC5yZXBseUV2ZW50TmFtZSh0aGlzLnJlZilcblxuICAgIHRoaXMuY2hhbm5lbC5vbih0aGlzLnJlZkV2ZW50LCBwYXlsb2FkID0+IHtcbiAgICAgIHRoaXMuY2FuY2VsUmVmRXZlbnQoKVxuICAgICAgdGhpcy5jYW5jZWxUaW1lb3V0KClcbiAgICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gcGF5bG9hZFxuICAgICAgdGhpcy5tYXRjaFJlY2VpdmUocGF5bG9hZClcbiAgICB9KVxuXG4gICAgdGhpcy50aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudHJpZ2dlcihcInRpbWVvdXRcIiwge30pXG4gICAgfSwgdGhpcy50aW1lb3V0KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYXNSZWNlaXZlZChzdGF0dXMpe1xuICAgIHJldHVybiB0aGlzLnJlY2VpdmVkUmVzcCAmJiB0aGlzLnJlY2VpdmVkUmVzcC5zdGF0dXMgPT09IHN0YXR1c1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0cmlnZ2VyKHN0YXR1cywgcmVzcG9uc2Upe1xuICAgIHRoaXMuY2hhbm5lbC50cmlnZ2VyKHRoaXMucmVmRXZlbnQsIHtzdGF0dXMsIHJlc3BvbnNlfSlcbiAgfVxufVxuIiwgIi8qKlxuICpcbiAqIENyZWF0ZXMgYSB0aW1lciB0aGF0IGFjY2VwdHMgYSBgdGltZXJDYWxjYCBmdW5jdGlvbiB0byBwZXJmb3JtXG4gKiBjYWxjdWxhdGVkIHRpbWVvdXQgcmV0cmllcywgc3VjaCBhcyBleHBvbmVudGlhbCBiYWNrb2ZmLlxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgcmVjb25uZWN0VGltZXIgPSBuZXcgVGltZXIoKCkgPT4gdGhpcy5jb25uZWN0KCksIGZ1bmN0aW9uKHRyaWVzKXtcbiAqICAgcmV0dXJuIFsxMDAwLCA1MDAwLCAxMDAwMF1bdHJpZXMgLSAxXSB8fCAxMDAwMFxuICogfSlcbiAqIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDEwMDBcbiAqIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDUwMDBcbiAqIHJlY29ubmVjdFRpbWVyLnJlc2V0KClcbiAqIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDEwMDBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtGdW5jdGlvbn0gdGltZXJDYWxjXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbWVyIHtcbiAgY29uc3RydWN0b3IoY2FsbGJhY2ssIHRpbWVyQ2FsYyl7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgdGhpcy50aW1lckNhbGMgPSB0aW1lckNhbGNcbiAgICB0aGlzLnRpbWVyID0gbnVsbFxuICAgIHRoaXMudHJpZXMgPSAwXG4gIH1cblxuICByZXNldCgpe1xuICAgIHRoaXMudHJpZXMgPSAwXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpXG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VscyBhbnkgcHJldmlvdXMgc2NoZWR1bGVUaW1lb3V0IGFuZCBzY2hlZHVsZXMgY2FsbGJhY2tcbiAgICovXG4gIHNjaGVkdWxlVGltZW91dCgpe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKVxuXG4gICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy50cmllcyA9IHRoaXMudHJpZXMgKyAxXG4gICAgICB0aGlzLmNhbGxiYWNrKClcbiAgICB9LCB0aGlzLnRpbWVyQ2FsYyh0aGlzLnRyaWVzICsgMSkpXG4gIH1cbn1cbiIsICJpbXBvcnQge2Nsb3N1cmV9IGZyb20gXCIuL3V0aWxzXCJcbmltcG9ydCB7XG4gIENIQU5ORUxfRVZFTlRTLFxuICBDSEFOTkVMX1NUQVRFUyxcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IFB1c2ggZnJvbSBcIi4vcHVzaFwiXG5pbXBvcnQgVGltZXIgZnJvbSBcIi4vdGltZXJcIlxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9waWNcbiAqIEBwYXJhbSB7KE9iamVjdHxmdW5jdGlvbil9IHBhcmFtc1xuICogQHBhcmFtIHtTb2NrZXR9IHNvY2tldFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGFubmVsIHtcbiAgY29uc3RydWN0b3IodG9waWMsIHBhcmFtcywgc29ja2V0KXtcbiAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkXG4gICAgdGhpcy50b3BpYyA9IHRvcGljXG4gICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKHBhcmFtcyB8fCB7fSlcbiAgICB0aGlzLnNvY2tldCA9IHNvY2tldFxuICAgIHRoaXMuYmluZGluZ3MgPSBbXVxuICAgIHRoaXMuYmluZGluZ1JlZiA9IDBcbiAgICB0aGlzLnRpbWVvdXQgPSB0aGlzLnNvY2tldC50aW1lb3V0XG4gICAgdGhpcy5qb2luZWRPbmNlID0gZmFsc2VcbiAgICB0aGlzLmpvaW5QdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMuam9pbiwgdGhpcy5wYXJhbXMsIHRoaXMudGltZW91dClcbiAgICB0aGlzLnB1c2hCdWZmZXIgPSBbXVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzID0gW11cblxuICAgIHRoaXMucmVqb2luVGltZXIgPSBuZXcgVGltZXIoKCkgPT4ge1xuICAgICAgaWYodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSl7IHRoaXMucmVqb2luKCkgfVxuICAgIH0sIHRoaXMuc29ja2V0LnJlam9pbkFmdGVyTXMpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZVJlZnMucHVzaCh0aGlzLnNvY2tldC5vbkVycm9yKCgpID0+IHRoaXMucmVqb2luVGltZXIucmVzZXQoKSkpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZVJlZnMucHVzaCh0aGlzLnNvY2tldC5vbk9wZW4oKCkgPT4ge1xuICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpXG4gICAgICBpZih0aGlzLmlzRXJyb3JlZCgpKXsgdGhpcy5yZWpvaW4oKSB9XG4gICAgfSlcbiAgICApXG4gICAgdGhpcy5qb2luUHVzaC5yZWNlaXZlKFwib2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmpvaW5lZFxuICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpXG4gICAgICB0aGlzLnB1c2hCdWZmZXIuZm9yRWFjaChwdXNoRXZlbnQgPT4gcHVzaEV2ZW50LnNlbmQoKSlcbiAgICAgIHRoaXMucHVzaEJ1ZmZlciA9IFtdXG4gICAgfSlcbiAgICB0aGlzLmpvaW5QdXNoLnJlY2VpdmUoXCJlcnJvclwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZFxuICAgICAgaWYodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSl7IHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgfVxuICAgIH0pXG4gICAgdGhpcy5vbkNsb3NlKCgpID0+IHtcbiAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKVxuICAgICAgaWYodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgYGNsb3NlICR7dGhpcy50b3BpY30gJHt0aGlzLmpvaW5SZWYoKX1gKVxuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmNsb3NlZFxuICAgICAgdGhpcy5zb2NrZXQucmVtb3ZlKHRoaXMpXG4gICAgfSlcbiAgICB0aGlzLm9uRXJyb3IocmVhc29uID0+IHtcbiAgICAgIGlmKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKSB0aGlzLnNvY2tldC5sb2coXCJjaGFubmVsXCIsIGBlcnJvciAke3RoaXMudG9waWN9YCwgcmVhc29uKVxuICAgICAgaWYodGhpcy5pc0pvaW5pbmcoKSl7IHRoaXMuam9pblB1c2gucmVzZXQoKSB9XG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZFxuICAgICAgaWYodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSl7IHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgfVxuICAgIH0pXG4gICAgdGhpcy5qb2luUHVzaC5yZWNlaXZlKFwidGltZW91dFwiLCAoKSA9PiB7XG4gICAgICBpZih0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSkgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBgdGltZW91dCAke3RoaXMudG9waWN9ICgke3RoaXMuam9pblJlZigpfSlgLCB0aGlzLmpvaW5QdXNoLnRpbWVvdXQpXG4gICAgICBsZXQgbGVhdmVQdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMubGVhdmUsIGNsb3N1cmUoe30pLCB0aGlzLnRpbWVvdXQpXG4gICAgICBsZWF2ZVB1c2guc2VuZCgpXG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZFxuICAgICAgdGhpcy5qb2luUHVzaC5yZXNldCgpXG4gICAgICBpZih0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKXsgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKSB9XG4gICAgfSlcbiAgICB0aGlzLm9uKENIQU5ORUxfRVZFTlRTLnJlcGx5LCAocGF5bG9hZCwgcmVmKSA9PiB7XG4gICAgICB0aGlzLnRyaWdnZXIodGhpcy5yZXBseUV2ZW50TmFtZShyZWYpLCBwYXlsb2FkKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogSm9pbiB0aGUgY2hhbm5lbFxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHRpbWVvdXRcbiAgICogQHJldHVybnMge1B1c2h9XG4gICAqL1xuICBqb2luKHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpe1xuICAgIGlmKHRoaXMuam9pbmVkT25jZSl7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cmllZCB0byBqb2luIG11bHRpcGxlIHRpbWVzLiAnam9pbicgY2FuIG9ubHkgYmUgY2FsbGVkIGEgc2luZ2xlIHRpbWUgcGVyIGNoYW5uZWwgaW5zdGFuY2VcIilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dFxuICAgICAgdGhpcy5qb2luZWRPbmNlID0gdHJ1ZVxuICAgICAgdGhpcy5yZWpvaW4oKVxuICAgICAgcmV0dXJuIHRoaXMuam9pblB1c2hcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSG9vayBpbnRvIGNoYW5uZWwgY2xvc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uQ2xvc2UoY2FsbGJhY2spe1xuICAgIHRoaXMub24oQ0hBTk5FTF9FVkVOVFMuY2xvc2UsIGNhbGxiYWNrKVxuICB9XG5cbiAgLyoqXG4gICAqIEhvb2sgaW50byBjaGFubmVsIGVycm9yc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25FcnJvcihjYWxsYmFjayl7XG4gICAgcmV0dXJuIHRoaXMub24oQ0hBTk5FTF9FVkVOVFMuZXJyb3IsIHJlYXNvbiA9PiBjYWxsYmFjayhyZWFzb24pKVxuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZXMgb24gY2hhbm5lbCBldmVudHNcbiAgICpcbiAgICogU3Vic2NyaXB0aW9uIHJldHVybnMgYSByZWYgY291bnRlciwgd2hpY2ggY2FuIGJlIHVzZWQgbGF0ZXIgdG9cbiAgICogdW5zdWJzY3JpYmUgdGhlIGV4YWN0IGV2ZW50IGxpc3RlbmVyXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJlZjEgPSBjaGFubmVsLm9uKFwiZXZlbnRcIiwgZG9fc3R1ZmYpXG4gICAqIGNvbnN0IHJlZjIgPSBjaGFubmVsLm9uKFwiZXZlbnRcIiwgZG9fb3RoZXJfc3R1ZmYpXG4gICAqIGNoYW5uZWwub2ZmKFwiZXZlbnRcIiwgcmVmMSlcbiAgICogLy8gU2luY2UgdW5zdWJzY3JpcHRpb24sIGRvX3N0dWZmIHdvbid0IGZpcmUsXG4gICAqIC8vIHdoaWxlIGRvX290aGVyX3N0dWZmIHdpbGwga2VlcCBmaXJpbmcgb24gdGhlIFwiZXZlbnRcIlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge2ludGVnZXJ9IHJlZlxuICAgKi9cbiAgb24oZXZlbnQsIGNhbGxiYWNrKXtcbiAgICBsZXQgcmVmID0gdGhpcy5iaW5kaW5nUmVmKytcbiAgICB0aGlzLmJpbmRpbmdzLnB1c2goe2V2ZW50LCByZWYsIGNhbGxiYWNrfSlcbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmVzIG9mZiBvZiBjaGFubmVsIGV2ZW50c1xuICAgKlxuICAgKiBVc2UgdGhlIHJlZiByZXR1cm5lZCBmcm9tIGEgY2hhbm5lbC5vbigpIHRvIHVuc3Vic2NyaWJlIG9uZVxuICAgKiBoYW5kbGVyLCBvciBwYXNzIG5vdGhpbmcgZm9yIHRoZSByZWYgdG8gdW5zdWJzY3JpYmUgYWxsXG4gICAqIGhhbmRsZXJzIGZvciB0aGUgZ2l2ZW4gZXZlbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFVuc3Vic2NyaWJlIHRoZSBkb19zdHVmZiBoYW5kbGVyXG4gICAqIGNvbnN0IHJlZjEgPSBjaGFubmVsLm9uKFwiZXZlbnRcIiwgZG9fc3R1ZmYpXG4gICAqIGNoYW5uZWwub2ZmKFwiZXZlbnRcIiwgcmVmMSlcbiAgICpcbiAgICogLy8gVW5zdWJzY3JpYmUgYWxsIGhhbmRsZXJzIGZyb20gZXZlbnRcbiAgICogY2hhbm5lbC5vZmYoXCJldmVudFwiKVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSByZWZcbiAgICovXG4gIG9mZihldmVudCwgcmVmKXtcbiAgICB0aGlzLmJpbmRpbmdzID0gdGhpcy5iaW5kaW5ncy5maWx0ZXIoKGJpbmQpID0+IHtcbiAgICAgIHJldHVybiAhKGJpbmQuZXZlbnQgPT09IGV2ZW50ICYmICh0eXBlb2YgcmVmID09PSBcInVuZGVmaW5lZFwiIHx8IHJlZiA9PT0gYmluZC5yZWYpKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhblB1c2goKXsgcmV0dXJuIHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkgJiYgdGhpcy5pc0pvaW5lZCgpIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBtZXNzYWdlIGBldmVudGAgdG8gcGhvZW5peCB3aXRoIHRoZSBwYXlsb2FkIGBwYXlsb2FkYC5cbiAgICogUGhvZW5peCByZWNlaXZlcyB0aGlzIGluIHRoZSBgaGFuZGxlX2luKGV2ZW50LCBwYXlsb2FkLCBzb2NrZXQpYFxuICAgKiBmdW5jdGlvbi4gaWYgcGhvZW5peCByZXBsaWVzIG9yIGl0IHRpbWVzIG91dCAoZGVmYXVsdCAxMDAwMG1zKSxcbiAgICogdGhlbiBvcHRpb25hbGx5IHRoZSByZXBseSBjYW4gYmUgcmVjZWl2ZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNoYW5uZWwucHVzaChcImV2ZW50XCIpXG4gICAqICAgLnJlY2VpdmUoXCJva1wiLCBwYXlsb2FkID0+IGNvbnNvbGUubG9nKFwicGhvZW5peCByZXBsaWVkOlwiLCBwYXlsb2FkKSlcbiAgICogICAucmVjZWl2ZShcImVycm9yXCIsIGVyciA9PiBjb25zb2xlLmxvZyhcInBob2VuaXggZXJyb3JlZFwiLCBlcnIpKVxuICAgKiAgIC5yZWNlaXZlKFwidGltZW91dFwiLCAoKSA9PiBjb25zb2xlLmxvZyhcInRpbWVkIG91dCBwdXNoaW5nXCIpKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lb3V0XVxuICAgKiBAcmV0dXJucyB7UHVzaH1cbiAgICovXG4gIHB1c2goZXZlbnQsIHBheWxvYWQsIHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpe1xuICAgIHBheWxvYWQgPSBwYXlsb2FkIHx8IHt9XG4gICAgaWYoIXRoaXMuam9pbmVkT25jZSl7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHRyaWVkIHRvIHB1c2ggJyR7ZXZlbnR9JyB0byAnJHt0aGlzLnRvcGljfScgYmVmb3JlIGpvaW5pbmcuIFVzZSBjaGFubmVsLmpvaW4oKSBiZWZvcmUgcHVzaGluZyBldmVudHNgKVxuICAgIH1cbiAgICBsZXQgcHVzaEV2ZW50ID0gbmV3IFB1c2godGhpcywgZXZlbnQsIGZ1bmN0aW9uICgpeyByZXR1cm4gcGF5bG9hZCB9LCB0aW1lb3V0KVxuICAgIGlmKHRoaXMuY2FuUHVzaCgpKXtcbiAgICAgIHB1c2hFdmVudC5zZW5kKClcbiAgICB9IGVsc2Uge1xuICAgICAgcHVzaEV2ZW50LnN0YXJ0VGltZW91dCgpXG4gICAgICB0aGlzLnB1c2hCdWZmZXIucHVzaChwdXNoRXZlbnQpXG4gICAgfVxuXG4gICAgcmV0dXJuIHB1c2hFdmVudFxuICB9XG5cbiAgLyoqIExlYXZlcyB0aGUgY2hhbm5lbFxuICAgKlxuICAgKiBVbnN1YnNjcmliZXMgZnJvbSBzZXJ2ZXIgZXZlbnRzLCBhbmRcbiAgICogaW5zdHJ1Y3RzIGNoYW5uZWwgdG8gdGVybWluYXRlIG9uIHNlcnZlclxuICAgKlxuICAgKiBUcmlnZ2VycyBvbkNsb3NlKCkgaG9va3NcbiAgICpcbiAgICogVG8gcmVjZWl2ZSBsZWF2ZSBhY2tub3dsZWRnZW1lbnRzLCB1c2UgdGhlIGByZWNlaXZlYFxuICAgKiBob29rIHRvIGJpbmQgdG8gdGhlIHNlcnZlciBhY2ssIGllOlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjaGFubmVsLmxlYXZlKCkucmVjZWl2ZShcIm9rXCIsICgpID0+IGFsZXJ0KFwibGVmdCFcIikgKVxuICAgKlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHRpbWVvdXRcbiAgICogQHJldHVybnMge1B1c2h9XG4gICAqL1xuICBsZWF2ZSh0aW1lb3V0ID0gdGhpcy50aW1lb3V0KXtcbiAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KClcbiAgICB0aGlzLmpvaW5QdXNoLmNhbmNlbFRpbWVvdXQoKVxuXG4gICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmxlYXZpbmdcbiAgICBsZXQgb25DbG9zZSA9ICgpID0+IHtcbiAgICAgIGlmKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKSB0aGlzLnNvY2tldC5sb2coXCJjaGFubmVsXCIsIGBsZWF2ZSAke3RoaXMudG9waWN9YClcbiAgICAgIHRoaXMudHJpZ2dlcihDSEFOTkVMX0VWRU5UUy5jbG9zZSwgXCJsZWF2ZVwiKVxuICAgIH1cbiAgICBsZXQgbGVhdmVQdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMubGVhdmUsIGNsb3N1cmUoe30pLCB0aW1lb3V0KVxuICAgIGxlYXZlUHVzaC5yZWNlaXZlKFwib2tcIiwgKCkgPT4gb25DbG9zZSgpKVxuICAgICAgLnJlY2VpdmUoXCJ0aW1lb3V0XCIsICgpID0+IG9uQ2xvc2UoKSlcbiAgICBsZWF2ZVB1c2guc2VuZCgpXG4gICAgaWYoIXRoaXMuY2FuUHVzaCgpKXsgbGVhdmVQdXNoLnRyaWdnZXIoXCJva1wiLCB7fSkgfVxuXG4gICAgcmV0dXJuIGxlYXZlUHVzaFxuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRhYmxlIG1lc3NhZ2UgaG9va1xuICAgKlxuICAgKiBSZWNlaXZlcyBhbGwgZXZlbnRzIGZvciBzcGVjaWFsaXplZCBtZXNzYWdlIGhhbmRsaW5nXG4gICAqIGJlZm9yZSBkaXNwYXRjaGluZyB0byB0aGUgY2hhbm5lbCBjYWxsYmFja3MuXG4gICAqXG4gICAqIE11c3QgcmV0dXJuIHRoZSBwYXlsb2FkLCBtb2RpZmllZCBvciB1bm1vZGlmaWVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHJlZlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgb25NZXNzYWdlKF9ldmVudCwgcGF5bG9hZCwgX3JlZil7IHJldHVybiBwYXlsb2FkIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzTWVtYmVyKHRvcGljLCBldmVudCwgcGF5bG9hZCwgam9pblJlZil7XG4gICAgaWYodGhpcy50b3BpYyAhPT0gdG9waWMpeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgaWYoam9pblJlZiAmJiBqb2luUmVmICE9PSB0aGlzLmpvaW5SZWYoKSl7XG4gICAgICBpZih0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSkgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBcImRyb3BwaW5nIG91dGRhdGVkIG1lc3NhZ2VcIiwge3RvcGljLCBldmVudCwgcGF5bG9hZCwgam9pblJlZn0pXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGpvaW5SZWYoKXsgcmV0dXJuIHRoaXMuam9pblB1c2gucmVmIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlam9pbih0aW1lb3V0ID0gdGhpcy50aW1lb3V0KXtcbiAgICBpZih0aGlzLmlzTGVhdmluZygpKXsgcmV0dXJuIH1cbiAgICB0aGlzLnNvY2tldC5sZWF2ZU9wZW5Ub3BpYyh0aGlzLnRvcGljKVxuICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5qb2luaW5nXG4gICAgdGhpcy5qb2luUHVzaC5yZXNlbmQodGltZW91dClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdHJpZ2dlcihldmVudCwgcGF5bG9hZCwgcmVmLCBqb2luUmVmKXtcbiAgICBsZXQgaGFuZGxlZFBheWxvYWQgPSB0aGlzLm9uTWVzc2FnZShldmVudCwgcGF5bG9hZCwgcmVmLCBqb2luUmVmKVxuICAgIGlmKHBheWxvYWQgJiYgIWhhbmRsZWRQYXlsb2FkKXsgdGhyb3cgbmV3IEVycm9yKFwiY2hhbm5lbCBvbk1lc3NhZ2UgY2FsbGJhY2tzIG11c3QgcmV0dXJuIHRoZSBwYXlsb2FkLCBtb2RpZmllZCBvciB1bm1vZGlmaWVkXCIpIH1cblxuICAgIGxldCBldmVudEJpbmRpbmdzID0gdGhpcy5iaW5kaW5ncy5maWx0ZXIoYmluZCA9PiBiaW5kLmV2ZW50ID09PSBldmVudClcblxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBldmVudEJpbmRpbmdzLmxlbmd0aDsgaSsrKXtcbiAgICAgIGxldCBiaW5kID0gZXZlbnRCaW5kaW5nc1tpXVxuICAgICAgYmluZC5jYWxsYmFjayhoYW5kbGVkUGF5bG9hZCwgcmVmLCBqb2luUmVmIHx8IHRoaXMuam9pblJlZigpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVwbHlFdmVudE5hbWUocmVmKXsgcmV0dXJuIGBjaGFuX3JlcGx5XyR7cmVmfWAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNDbG9zZWQoKXsgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmNsb3NlZCB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc0Vycm9yZWQoKXsgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmVycm9yZWQgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNKb2luZWQoKXsgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmpvaW5lZCB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc0pvaW5pbmcoKXsgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmpvaW5pbmcgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNMZWF2aW5nKCl7IHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5sZWF2aW5nIH1cbn1cbiIsICJpbXBvcnQge1xuICBnbG9iYWwsXG4gIFhIUl9TVEFURVNcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWpheCB7XG5cbiAgc3RhdGljIHJlcXVlc3QobWV0aG9kLCBlbmRQb2ludCwgYWNjZXB0LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKXtcbiAgICBpZihnbG9iYWwuWERvbWFpblJlcXVlc3Qpe1xuICAgICAgbGV0IHJlcSA9IG5ldyBnbG9iYWwuWERvbWFpblJlcXVlc3QoKSAvLyBJRTgsIElFOVxuICAgICAgcmV0dXJuIHRoaXMueGRvbWFpblJlcXVlc3QocmVxLCBtZXRob2QsIGVuZFBvaW50LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcmVxID0gbmV3IGdsb2JhbC5YTUxIdHRwUmVxdWVzdCgpIC8vIElFNyssIEZpcmVmb3gsIENocm9tZSwgT3BlcmEsIFNhZmFyaVxuICAgICAgcmV0dXJuIHRoaXMueGhyUmVxdWVzdChyZXEsIG1ldGhvZCwgZW5kUG9pbnQsIGFjY2VwdCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjaylcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgeGRvbWFpblJlcXVlc3QocmVxLCBtZXRob2QsIGVuZFBvaW50LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKXtcbiAgICByZXEudGltZW91dCA9IHRpbWVvdXRcbiAgICByZXEub3BlbihtZXRob2QsIGVuZFBvaW50KVxuICAgIHJlcS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICBsZXQgcmVzcG9uc2UgPSB0aGlzLnBhcnNlSlNPTihyZXEucmVzcG9uc2VUZXh0KVxuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socmVzcG9uc2UpXG4gICAgfVxuICAgIGlmKG9udGltZW91dCl7IHJlcS5vbnRpbWVvdXQgPSBvbnRpbWVvdXQgfVxuXG4gICAgLy8gV29yayBhcm91bmQgYnVnIGluIElFOSB0aGF0IHJlcXVpcmVzIGFuIGF0dGFjaGVkIG9ucHJvZ3Jlc3MgaGFuZGxlclxuICAgIHJlcS5vbnByb2dyZXNzID0gKCkgPT4geyB9XG5cbiAgICByZXEuc2VuZChib2R5KVxuICAgIHJldHVybiByZXFcbiAgfVxuXG4gIHN0YXRpYyB4aHJSZXF1ZXN0KHJlcSwgbWV0aG9kLCBlbmRQb2ludCwgYWNjZXB0LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKXtcbiAgICByZXEub3BlbihtZXRob2QsIGVuZFBvaW50LCB0cnVlKVxuICAgIHJlcS50aW1lb3V0ID0gdGltZW91dFxuICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIGFjY2VwdClcbiAgICByZXEub25lcnJvciA9ICgpID0+IGNhbGxiYWNrICYmIGNhbGxiYWNrKG51bGwpXG4gICAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGlmKHJlcS5yZWFkeVN0YXRlID09PSBYSFJfU1RBVEVTLmNvbXBsZXRlICYmIGNhbGxiYWNrKXtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gdGhpcy5wYXJzZUpTT04ocmVxLnJlc3BvbnNlVGV4dClcbiAgICAgICAgY2FsbGJhY2socmVzcG9uc2UpXG4gICAgICB9XG4gICAgfVxuICAgIGlmKG9udGltZW91dCl7IHJlcS5vbnRpbWVvdXQgPSBvbnRpbWVvdXQgfVxuXG4gICAgcmVxLnNlbmQoYm9keSlcbiAgICByZXR1cm4gcmVxXG4gIH1cblxuICBzdGF0aWMgcGFyc2VKU09OKHJlc3Ape1xuICAgIGlmKCFyZXNwIHx8IHJlc3AgPT09IFwiXCIpeyByZXR1cm4gbnVsbCB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVzcClcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgIGNvbnNvbGUgJiYgY29uc29sZS5sb2coXCJmYWlsZWQgdG8gcGFyc2UgSlNPTiByZXNwb25zZVwiLCByZXNwKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgc2VyaWFsaXplKG9iaiwgcGFyZW50S2V5KXtcbiAgICBsZXQgcXVlcnlTdHIgPSBbXVxuICAgIGZvcih2YXIga2V5IGluIG9iail7XG4gICAgICBpZighT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSl7IGNvbnRpbnVlIH1cbiAgICAgIGxldCBwYXJhbUtleSA9IHBhcmVudEtleSA/IGAke3BhcmVudEtleX1bJHtrZXl9XWAgOiBrZXlcbiAgICAgIGxldCBwYXJhbVZhbCA9IG9ialtrZXldXG4gICAgICBpZih0eXBlb2YgcGFyYW1WYWwgPT09IFwib2JqZWN0XCIpe1xuICAgICAgICBxdWVyeVN0ci5wdXNoKHRoaXMuc2VyaWFsaXplKHBhcmFtVmFsLCBwYXJhbUtleSkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWVyeVN0ci5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChwYXJhbUtleSkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbVZhbCkpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBxdWVyeVN0ci5qb2luKFwiJlwiKVxuICB9XG5cbiAgc3RhdGljIGFwcGVuZFBhcmFtcyh1cmwsIHBhcmFtcyl7XG4gICAgaWYoT2JqZWN0LmtleXMocGFyYW1zKS5sZW5ndGggPT09IDApeyByZXR1cm4gdXJsIH1cblxuICAgIGxldCBwcmVmaXggPSB1cmwubWF0Y2goL1xcPy8pID8gXCImXCIgOiBcIj9cIlxuICAgIHJldHVybiBgJHt1cmx9JHtwcmVmaXh9JHt0aGlzLnNlcmlhbGl6ZShwYXJhbXMpfWBcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIFNPQ0tFVF9TVEFURVMsXG4gIFRSQU5TUE9SVFNcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IEFqYXggZnJvbSBcIi4vYWpheFwiXG5cbmxldCBhcnJheUJ1ZmZlclRvQmFzZTY0ID0gKGJ1ZmZlcikgPT4ge1xuICBsZXQgYmluYXJ5ID0gXCJcIlxuICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheShidWZmZXIpXG4gIGxldCBsZW4gPSBieXRlcy5ieXRlTGVuZ3RoXG4gIGZvcihsZXQgaSA9IDA7IGkgPCBsZW47IGkrKyl7IGJpbmFyeSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKSB9XG4gIHJldHVybiBidG9hKGJpbmFyeSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9uZ1BvbGwge1xuXG4gIGNvbnN0cnVjdG9yKGVuZFBvaW50KXtcbiAgICB0aGlzLmVuZFBvaW50ID0gbnVsbFxuICAgIHRoaXMudG9rZW4gPSBudWxsXG4gICAgdGhpcy5za2lwSGVhcnRiZWF0ID0gdHJ1ZVxuICAgIHRoaXMucmVxcyA9IG5ldyBTZXQoKVxuICAgIHRoaXMuYXdhaXRpbmdCYXRjaEFjayA9IGZhbHNlXG4gICAgdGhpcy5jdXJyZW50QmF0Y2ggPSBudWxsXG4gICAgdGhpcy5jdXJyZW50QmF0Y2hUaW1lciA9IG51bGxcbiAgICB0aGlzLmJhdGNoQnVmZmVyID0gW11cbiAgICB0aGlzLm9ub3BlbiA9IGZ1bmN0aW9uICgpeyB9IC8vIG5vb3BcbiAgICB0aGlzLm9uZXJyb3IgPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgdGhpcy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgdGhpcy5vbmNsb3NlID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgIHRoaXMucG9sbEVuZHBvaW50ID0gdGhpcy5ub3JtYWxpemVFbmRwb2ludChlbmRQb2ludClcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBTT0NLRVRfU1RBVEVTLmNvbm5lY3RpbmdcbiAgICAvLyB3ZSBtdXN0IHdhaXQgZm9yIHRoZSBjYWxsZXIgdG8gZmluaXNoIHNldHRpbmcgdXAgb3VyIGNhbGxiYWNrcyBhbmQgdGltZW91dCBwcm9wZXJ0aWVzXG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnBvbGwoKSwgMClcbiAgfVxuXG4gIG5vcm1hbGl6ZUVuZHBvaW50KGVuZFBvaW50KXtcbiAgICByZXR1cm4gKGVuZFBvaW50XG4gICAgICAucmVwbGFjZShcIndzOi8vXCIsIFwiaHR0cDovL1wiKVxuICAgICAgLnJlcGxhY2UoXCJ3c3M6Ly9cIiwgXCJodHRwczovL1wiKVxuICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cChcIiguKilcXC9cIiArIFRSQU5TUE9SVFMud2Vic29ja2V0KSwgXCIkMS9cIiArIFRSQU5TUE9SVFMubG9uZ3BvbGwpKVxuICB9XG5cbiAgZW5kcG9pbnRVUkwoKXtcbiAgICByZXR1cm4gQWpheC5hcHBlbmRQYXJhbXModGhpcy5wb2xsRW5kcG9pbnQsIHt0b2tlbjogdGhpcy50b2tlbn0pXG4gIH1cblxuICBjbG9zZUFuZFJldHJ5KGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4pe1xuICAgIHRoaXMuY2xvc2UoY29kZSwgcmVhc29uLCB3YXNDbGVhbilcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBTT0NLRVRfU1RBVEVTLmNvbm5lY3RpbmdcbiAgfVxuXG4gIG9udGltZW91dCgpe1xuICAgIHRoaXMub25lcnJvcihcInRpbWVvdXRcIilcbiAgICB0aGlzLmNsb3NlQW5kUmV0cnkoMTAwNSwgXCJ0aW1lb3V0XCIsIGZhbHNlKVxuICB9XG5cbiAgaXNBY3RpdmUoKXsgcmV0dXJuIHRoaXMucmVhZHlTdGF0ZSA9PT0gU09DS0VUX1NUQVRFUy5vcGVuIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nIH1cblxuICBwb2xsKCl7XG4gICAgdGhpcy5hamF4KFwiR0VUXCIsIFwiYXBwbGljYXRpb24vanNvblwiLCBudWxsLCAoKSA9PiB0aGlzLm9udGltZW91dCgpLCByZXNwID0+IHtcbiAgICAgIGlmKHJlc3Ape1xuICAgICAgICB2YXIge3N0YXR1cywgdG9rZW4sIG1lc3NhZ2VzfSA9IHJlc3BcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0dXMgPSAwXG4gICAgICB9XG5cbiAgICAgIHN3aXRjaChzdGF0dXMpe1xuICAgICAgICBjYXNlIDIwMDpcbiAgICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKG1zZyA9PiB7XG4gICAgICAgICAgICAvLyBUYXNrcyBhcmUgd2hhdCB0aGluZ3MgbGlrZSBldmVudCBoYW5kbGVycywgc2V0VGltZW91dCBjYWxsYmFja3MsXG4gICAgICAgICAgICAvLyBwcm9taXNlIHJlc29sdmVzIGFuZCBtb3JlIGFyZSBydW4gd2l0aGluLlxuICAgICAgICAgICAgLy8gSW4gbW9kZXJuIGJyb3dzZXJzLCB0aGVyZSBhcmUgdHdvIGRpZmZlcmVudCBraW5kcyBvZiB0YXNrcyxcbiAgICAgICAgICAgIC8vIG1pY3JvdGFza3MgYW5kIG1hY3JvdGFza3MuXG4gICAgICAgICAgICAvLyBNaWNyb3Rhc2tzIGFyZSBtYWlubHkgdXNlZCBmb3IgUHJvbWlzZXMsIHdoaWxlIG1hY3JvdGFza3MgYXJlXG4gICAgICAgICAgICAvLyB1c2VkIGZvciBldmVyeXRoaW5nIGVsc2UuXG4gICAgICAgICAgICAvLyBNaWNyb3Rhc2tzIGFsd2F5cyBoYXZlIHByaW9yaXR5IG92ZXIgbWFjcm90YXNrcy4gSWYgdGhlIEpTIGVuZ2luZVxuICAgICAgICAgICAgLy8gaXMgbG9va2luZyBmb3IgYSB0YXNrIHRvIHJ1biwgaXQgd2lsbCBhbHdheXMgdHJ5IHRvIGVtcHR5IHRoZVxuICAgICAgICAgICAgLy8gbWljcm90YXNrIHF1ZXVlIGJlZm9yZSBhdHRlbXB0aW5nIHRvIHJ1biBhbnl0aGluZyBmcm9tIHRoZVxuICAgICAgICAgICAgLy8gbWFjcm90YXNrIHF1ZXVlLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEZvciB0aGUgV2ViU29ja2V0IHRyYW5zcG9ydCwgbWVzc2FnZXMgYWx3YXlzIGFycml2ZSBpbiB0aGVpciBvd25cbiAgICAgICAgICAgIC8vIGV2ZW50LiBUaGlzIG1lYW5zIHRoYXQgaWYgYW55IHByb21pc2VzIGFyZSByZXNvbHZlZCBmcm9tIHdpdGhpbixcbiAgICAgICAgICAgIC8vIHRoZWlyIGNhbGxiYWNrcyB3aWxsIGFsd2F5cyBmaW5pc2ggZXhlY3V0aW9uIGJ5IHRoZSB0aW1lIHRoZVxuICAgICAgICAgICAgLy8gbmV4dCBtZXNzYWdlIGV2ZW50IGhhbmRsZXIgaXMgcnVuLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIGVtdWxhdGUgdGhpcyBiZWhhdmlvdXIsIHdlIG5lZWQgdG8gbWFrZSBzdXJlIGVhY2hcbiAgICAgICAgICAgIC8vIG9ubWVzc2FnZSBoYW5kbGVyIGlzIHJ1biB3aXRoaW4gaXRzIG93biBtYWNyb3Rhc2suXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMub25tZXNzYWdlKHtkYXRhOiBtc2d9KSwgMClcbiAgICAgICAgICB9KVxuICAgICAgICAgIHRoaXMucG9sbCgpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyMDQ6XG4gICAgICAgICAgdGhpcy5wb2xsKClcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQxMDpcbiAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBTT0NLRVRfU1RBVEVTLm9wZW5cbiAgICAgICAgICB0aGlzLm9ub3Blbih7fSlcbiAgICAgICAgICB0aGlzLnBvbGwoKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDAzOlxuICAgICAgICAgIHRoaXMub25lcnJvcig0MDMpXG4gICAgICAgICAgdGhpcy5jbG9zZSgxMDA4LCBcImZvcmJpZGRlblwiLCBmYWxzZSlcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgNTAwOlxuICAgICAgICAgIHRoaXMub25lcnJvcig1MDApXG4gICAgICAgICAgdGhpcy5jbG9zZUFuZFJldHJ5KDEwMTEsIFwiaW50ZXJuYWwgc2VydmVyIGVycm9yXCIsIDUwMClcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoYHVuaGFuZGxlZCBwb2xsIHN0YXR1cyAke3N0YXR1c31gKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvLyB3ZSBjb2xsZWN0IGFsbCBwdXNoZXMgd2l0aGluIHRoZSBjdXJyZW50IGV2ZW50IGxvb3AgYnlcbiAgLy8gc2V0VGltZW91dCAwLCB3aGljaCBvcHRpbWl6ZXMgYmFjay10by1iYWNrIHByb2NlZHVyYWxcbiAgLy8gcHVzaGVzIGFnYWluc3QgYW4gZW1wdHkgYnVmZmVyXG5cbiAgc2VuZChib2R5KXtcbiAgICBpZih0eXBlb2YoYm9keSkgIT09IFwic3RyaW5nXCIpeyBib2R5ID0gYXJyYXlCdWZmZXJUb0Jhc2U2NChib2R5KSB9XG4gICAgaWYodGhpcy5jdXJyZW50QmF0Y2gpe1xuICAgICAgdGhpcy5jdXJyZW50QmF0Y2gucHVzaChib2R5KVxuICAgIH0gZWxzZSBpZih0aGlzLmF3YWl0aW5nQmF0Y2hBY2spe1xuICAgICAgdGhpcy5iYXRjaEJ1ZmZlci5wdXNoKGJvZHkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3VycmVudEJhdGNoID0gW2JvZHldXG4gICAgICB0aGlzLmN1cnJlbnRCYXRjaFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuYmF0Y2hTZW5kKHRoaXMuY3VycmVudEJhdGNoKVxuICAgICAgICB0aGlzLmN1cnJlbnRCYXRjaCA9IG51bGxcbiAgICAgIH0sIDApXG4gICAgfVxuICB9XG5cbiAgYmF0Y2hTZW5kKG1lc3NhZ2VzKXtcbiAgICB0aGlzLmF3YWl0aW5nQmF0Y2hBY2sgPSB0cnVlXG4gICAgdGhpcy5hamF4KFwiUE9TVFwiLCBcImFwcGxpY2F0aW9uL3gtbmRqc29uXCIsIG1lc3NhZ2VzLmpvaW4oXCJcXG5cIiksICgpID0+IHRoaXMub25lcnJvcihcInRpbWVvdXRcIiksIHJlc3AgPT4ge1xuICAgICAgdGhpcy5hd2FpdGluZ0JhdGNoQWNrID0gZmFsc2VcbiAgICAgIGlmKCFyZXNwIHx8IHJlc3Auc3RhdHVzICE9PSAyMDApe1xuICAgICAgICB0aGlzLm9uZXJyb3IocmVzcCAmJiByZXNwLnN0YXR1cylcbiAgICAgICAgdGhpcy5jbG9zZUFuZFJldHJ5KDEwMTEsIFwiaW50ZXJuYWwgc2VydmVyIGVycm9yXCIsIGZhbHNlKVxuICAgICAgfSBlbHNlIGlmKHRoaXMuYmF0Y2hCdWZmZXIubGVuZ3RoID4gMCl7XG4gICAgICAgIHRoaXMuYmF0Y2hTZW5kKHRoaXMuYmF0Y2hCdWZmZXIpXG4gICAgICAgIHRoaXMuYmF0Y2hCdWZmZXIgPSBbXVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBjbG9zZShjb2RlLCByZWFzb24sIHdhc0NsZWFuKXtcbiAgICBmb3IobGV0IHJlcSBvZiB0aGlzLnJlcXMpeyByZXEuYWJvcnQoKSB9XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU09DS0VUX1NUQVRFUy5jbG9zZWRcbiAgICBsZXQgb3B0cyA9IE9iamVjdC5hc3NpZ24oe2NvZGU6IDEwMDAsIHJlYXNvbjogdW5kZWZpbmVkLCB3YXNDbGVhbjogdHJ1ZX0sIHtjb2RlLCByZWFzb24sIHdhc0NsZWFufSlcbiAgICB0aGlzLmJhdGNoQnVmZmVyID0gW11cbiAgICBjbGVhclRpbWVvdXQodGhpcy5jdXJyZW50QmF0Y2hUaW1lcilcbiAgICB0aGlzLmN1cnJlbnRCYXRjaFRpbWVyID0gbnVsbFxuICAgIGlmKHR5cGVvZihDbG9zZUV2ZW50KSAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICB0aGlzLm9uY2xvc2UobmV3IENsb3NlRXZlbnQoXCJjbG9zZVwiLCBvcHRzKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbmNsb3NlKG9wdHMpXG4gICAgfVxuICB9XG5cbiAgYWpheChtZXRob2QsIGNvbnRlbnRUeXBlLCBib2R5LCBvbkNhbGxlclRpbWVvdXQsIGNhbGxiYWNrKXtcbiAgICBsZXQgcmVxXG4gICAgbGV0IG9udGltZW91dCA9ICgpID0+IHtcbiAgICAgIHRoaXMucmVxcy5kZWxldGUocmVxKVxuICAgICAgb25DYWxsZXJUaW1lb3V0KClcbiAgICB9XG4gICAgcmVxID0gQWpheC5yZXF1ZXN0KG1ldGhvZCwgdGhpcy5lbmRwb2ludFVSTCgpLCBjb250ZW50VHlwZSwgYm9keSwgdGhpcy50aW1lb3V0LCBvbnRpbWVvdXQsIHJlc3AgPT4ge1xuICAgICAgdGhpcy5yZXFzLmRlbGV0ZShyZXEpXG4gICAgICBpZih0aGlzLmlzQWN0aXZlKCkpeyBjYWxsYmFjayhyZXNwKSB9XG4gICAgfSlcbiAgICB0aGlzLnJlcXMuYWRkKHJlcSlcbiAgfVxufVxuIiwgIi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIFByZXNlbmNlXG4gKiBAcGFyYW0ge0NoYW5uZWx9IGNoYW5uZWwgLSBUaGUgQ2hhbm5lbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgb3B0aW9ucyxcbiAqICAgICAgICBmb3IgZXhhbXBsZSBge2V2ZW50czoge3N0YXRlOiBcInN0YXRlXCIsIGRpZmY6IFwiZGlmZlwifX1gXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByZXNlbmNlIHtcblxuICBjb25zdHJ1Y3RvcihjaGFubmVsLCBvcHRzID0ge30pe1xuICAgIGxldCBldmVudHMgPSBvcHRzLmV2ZW50cyB8fCB7c3RhdGU6IFwicHJlc2VuY2Vfc3RhdGVcIiwgZGlmZjogXCJwcmVzZW5jZV9kaWZmXCJ9XG4gICAgdGhpcy5zdGF0ZSA9IHt9XG4gICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXVxuICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWxcbiAgICB0aGlzLmpvaW5SZWYgPSBudWxsXG4gICAgdGhpcy5jYWxsZXIgPSB7XG4gICAgICBvbkpvaW46IGZ1bmN0aW9uICgpeyB9LFxuICAgICAgb25MZWF2ZTogZnVuY3Rpb24gKCl7IH0sXG4gICAgICBvblN5bmM6IGZ1bmN0aW9uICgpeyB9XG4gICAgfVxuXG4gICAgdGhpcy5jaGFubmVsLm9uKGV2ZW50cy5zdGF0ZSwgbmV3U3RhdGUgPT4ge1xuICAgICAgbGV0IHtvbkpvaW4sIG9uTGVhdmUsIG9uU3luY30gPSB0aGlzLmNhbGxlclxuXG4gICAgICB0aGlzLmpvaW5SZWYgPSB0aGlzLmNoYW5uZWwuam9pblJlZigpXG4gICAgICB0aGlzLnN0YXRlID0gUHJlc2VuY2Uuc3luY1N0YXRlKHRoaXMuc3RhdGUsIG5ld1N0YXRlLCBvbkpvaW4sIG9uTGVhdmUpXG5cbiAgICAgIHRoaXMucGVuZGluZ0RpZmZzLmZvckVhY2goZGlmZiA9PiB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBQcmVzZW5jZS5zeW5jRGlmZih0aGlzLnN0YXRlLCBkaWZmLCBvbkpvaW4sIG9uTGVhdmUpXG4gICAgICB9KVxuICAgICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXVxuICAgICAgb25TeW5jKClcbiAgICB9KVxuXG4gICAgdGhpcy5jaGFubmVsLm9uKGV2ZW50cy5kaWZmLCBkaWZmID0+IHtcbiAgICAgIGxldCB7b25Kb2luLCBvbkxlYXZlLCBvblN5bmN9ID0gdGhpcy5jYWxsZXJcblxuICAgICAgaWYodGhpcy5pblBlbmRpbmdTeW5jU3RhdGUoKSl7XG4gICAgICAgIHRoaXMucGVuZGluZ0RpZmZzLnB1c2goZGlmZilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBQcmVzZW5jZS5zeW5jRGlmZih0aGlzLnN0YXRlLCBkaWZmLCBvbkpvaW4sIG9uTGVhdmUpXG4gICAgICAgIG9uU3luYygpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIG9uSm9pbihjYWxsYmFjayl7IHRoaXMuY2FsbGVyLm9uSm9pbiA9IGNhbGxiYWNrIH1cblxuICBvbkxlYXZlKGNhbGxiYWNrKXsgdGhpcy5jYWxsZXIub25MZWF2ZSA9IGNhbGxiYWNrIH1cblxuICBvblN5bmMoY2FsbGJhY2speyB0aGlzLmNhbGxlci5vblN5bmMgPSBjYWxsYmFjayB9XG5cbiAgbGlzdChieSl7IHJldHVybiBQcmVzZW5jZS5saXN0KHRoaXMuc3RhdGUsIGJ5KSB9XG5cbiAgaW5QZW5kaW5nU3luY1N0YXRlKCl7XG4gICAgcmV0dXJuICF0aGlzLmpvaW5SZWYgfHwgKHRoaXMuam9pblJlZiAhPT0gdGhpcy5jaGFubmVsLmpvaW5SZWYoKSlcbiAgfVxuXG4gIC8vIGxvd2VyLWxldmVsIHB1YmxpYyBzdGF0aWMgQVBJXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gc3luYyB0aGUgbGlzdCBvZiBwcmVzZW5jZXMgb24gdGhlIHNlcnZlclxuICAgKiB3aXRoIHRoZSBjbGllbnQncyBzdGF0ZS4gQW4gb3B0aW9uYWwgYG9uSm9pbmAgYW5kIGBvbkxlYXZlYCBjYWxsYmFjayBjYW5cbiAgICogYmUgcHJvdmlkZWQgdG8gcmVhY3QgdG8gY2hhbmdlcyBpbiB0aGUgY2xpZW50J3MgbG9jYWwgcHJlc2VuY2VzIGFjcm9zc1xuICAgKiBkaXNjb25uZWN0cyBhbmQgcmVjb25uZWN0cyB3aXRoIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcmVzZW5jZX1cbiAgICovXG4gIHN0YXRpYyBzeW5jU3RhdGUoY3VycmVudFN0YXRlLCBuZXdTdGF0ZSwgb25Kb2luLCBvbkxlYXZlKXtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLmNsb25lKGN1cnJlbnRTdGF0ZSlcbiAgICBsZXQgam9pbnMgPSB7fVxuICAgIGxldCBsZWF2ZXMgPSB7fVxuXG4gICAgdGhpcy5tYXAoc3RhdGUsIChrZXksIHByZXNlbmNlKSA9PiB7XG4gICAgICBpZighbmV3U3RhdGVba2V5XSl7XG4gICAgICAgIGxlYXZlc1trZXldID0gcHJlc2VuY2VcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMubWFwKG5ld1N0YXRlLCAoa2V5LCBuZXdQcmVzZW5jZSkgPT4ge1xuICAgICAgbGV0IGN1cnJlbnRQcmVzZW5jZSA9IHN0YXRlW2tleV1cbiAgICAgIGlmKGN1cnJlbnRQcmVzZW5jZSl7XG4gICAgICAgIGxldCBuZXdSZWZzID0gbmV3UHJlc2VuY2UubWV0YXMubWFwKG0gPT4gbS5waHhfcmVmKVxuICAgICAgICBsZXQgY3VyUmVmcyA9IGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5tYXAobSA9PiBtLnBoeF9yZWYpXG4gICAgICAgIGxldCBqb2luZWRNZXRhcyA9IG5ld1ByZXNlbmNlLm1ldGFzLmZpbHRlcihtID0+IGN1clJlZnMuaW5kZXhPZihtLnBoeF9yZWYpIDwgMClcbiAgICAgICAgbGV0IGxlZnRNZXRhcyA9IGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5maWx0ZXIobSA9PiBuZXdSZWZzLmluZGV4T2YobS5waHhfcmVmKSA8IDApXG4gICAgICAgIGlmKGpvaW5lZE1ldGFzLmxlbmd0aCA+IDApe1xuICAgICAgICAgIGpvaW5zW2tleV0gPSBuZXdQcmVzZW5jZVxuICAgICAgICAgIGpvaW5zW2tleV0ubWV0YXMgPSBqb2luZWRNZXRhc1xuICAgICAgICB9XG4gICAgICAgIGlmKGxlZnRNZXRhcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICBsZWF2ZXNba2V5XSA9IHRoaXMuY2xvbmUoY3VycmVudFByZXNlbmNlKVxuICAgICAgICAgIGxlYXZlc1trZXldLm1ldGFzID0gbGVmdE1ldGFzXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGpvaW5zW2tleV0gPSBuZXdQcmVzZW5jZVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHRoaXMuc3luY0RpZmYoc3RhdGUsIHtqb2luczogam9pbnMsIGxlYXZlczogbGVhdmVzfSwgb25Kb2luLCBvbkxlYXZlKVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIFVzZWQgdG8gc3luYyBhIGRpZmYgb2YgcHJlc2VuY2Ugam9pbiBhbmQgbGVhdmVcbiAgICogZXZlbnRzIGZyb20gdGhlIHNlcnZlciwgYXMgdGhleSBoYXBwZW4uIExpa2UgYHN5bmNTdGF0ZWAsIGBzeW5jRGlmZmBcbiAgICogYWNjZXB0cyBvcHRpb25hbCBgb25Kb2luYCBhbmQgYG9uTGVhdmVgIGNhbGxiYWNrcyB0byByZWFjdCB0byBhIHVzZXJcbiAgICogam9pbmluZyBvciBsZWF2aW5nIGZyb20gYSBkZXZpY2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcmVzZW5jZX1cbiAgICovXG4gIHN0YXRpYyBzeW5jRGlmZihzdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKXtcbiAgICBsZXQge2pvaW5zLCBsZWF2ZXN9ID0gdGhpcy5jbG9uZShkaWZmKVxuICAgIGlmKCFvbkpvaW4peyBvbkpvaW4gPSBmdW5jdGlvbiAoKXsgfSB9XG4gICAgaWYoIW9uTGVhdmUpeyBvbkxlYXZlID0gZnVuY3Rpb24gKCl7IH0gfVxuXG4gICAgdGhpcy5tYXAoam9pbnMsIChrZXksIG5ld1ByZXNlbmNlKSA9PiB7XG4gICAgICBsZXQgY3VycmVudFByZXNlbmNlID0gc3RhdGVba2V5XVxuICAgICAgc3RhdGVba2V5XSA9IHRoaXMuY2xvbmUobmV3UHJlc2VuY2UpXG4gICAgICBpZihjdXJyZW50UHJlc2VuY2Upe1xuICAgICAgICBsZXQgam9pbmVkUmVmcyA9IHN0YXRlW2tleV0ubWV0YXMubWFwKG0gPT4gbS5waHhfcmVmKVxuICAgICAgICBsZXQgY3VyTWV0YXMgPSBjdXJyZW50UHJlc2VuY2UubWV0YXMuZmlsdGVyKG0gPT4gam9pbmVkUmVmcy5pbmRleE9mKG0ucGh4X3JlZikgPCAwKVxuICAgICAgICBzdGF0ZVtrZXldLm1ldGFzLnVuc2hpZnQoLi4uY3VyTWV0YXMpXG4gICAgICB9XG4gICAgICBvbkpvaW4oa2V5LCBjdXJyZW50UHJlc2VuY2UsIG5ld1ByZXNlbmNlKVxuICAgIH0pXG4gICAgdGhpcy5tYXAobGVhdmVzLCAoa2V5LCBsZWZ0UHJlc2VuY2UpID0+IHtcbiAgICAgIGxldCBjdXJyZW50UHJlc2VuY2UgPSBzdGF0ZVtrZXldXG4gICAgICBpZighY3VycmVudFByZXNlbmNlKXsgcmV0dXJuIH1cbiAgICAgIGxldCByZWZzVG9SZW1vdmUgPSBsZWZ0UHJlc2VuY2UubWV0YXMubWFwKG0gPT4gbS5waHhfcmVmKVxuICAgICAgY3VycmVudFByZXNlbmNlLm1ldGFzID0gY3VycmVudFByZXNlbmNlLm1ldGFzLmZpbHRlcihwID0+IHtcbiAgICAgICAgcmV0dXJuIHJlZnNUb1JlbW92ZS5pbmRleE9mKHAucGh4X3JlZikgPCAwXG4gICAgICB9KVxuICAgICAgb25MZWF2ZShrZXksIGN1cnJlbnRQcmVzZW5jZSwgbGVmdFByZXNlbmNlKVxuICAgICAgaWYoY3VycmVudFByZXNlbmNlLm1ldGFzLmxlbmd0aCA9PT0gMCl7XG4gICAgICAgIGRlbGV0ZSBzdGF0ZVtrZXldXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gc3RhdGVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcmVzZW5jZXMsIHdpdGggc2VsZWN0ZWQgbWV0YWRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcmVzZW5jZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2hvb3NlclxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJlc2VuY2V9XG4gICAqL1xuICBzdGF0aWMgbGlzdChwcmVzZW5jZXMsIGNob29zZXIpe1xuICAgIGlmKCFjaG9vc2VyKXsgY2hvb3NlciA9IGZ1bmN0aW9uIChrZXksIHByZXMpeyByZXR1cm4gcHJlcyB9IH1cblxuICAgIHJldHVybiB0aGlzLm1hcChwcmVzZW5jZXMsIChrZXksIHByZXNlbmNlKSA9PiB7XG4gICAgICByZXR1cm4gY2hvb3NlcihrZXksIHByZXNlbmNlKVxuICAgIH0pXG4gIH1cblxuICAvLyBwcml2YXRlXG5cbiAgc3RhdGljIG1hcChvYmosIGZ1bmMpe1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLm1hcChrZXkgPT4gZnVuYyhrZXksIG9ialtrZXldKSlcbiAgfVxuXG4gIHN0YXRpYyBjbG9uZShvYmopeyByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKSB9XG59XG4iLCAiLyogVGhlIGRlZmF1bHQgc2VyaWFsaXplciBmb3IgZW5jb2RpbmcgYW5kIGRlY29kaW5nIG1lc3NhZ2VzICovXG5pbXBvcnQge1xuICBDSEFOTkVMX0VWRU5UU1xufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIEhFQURFUl9MRU5HVEg6IDEsXG4gIE1FVEFfTEVOR1RIOiA0LFxuICBLSU5EUzoge3B1c2g6IDAsIHJlcGx5OiAxLCBicm9hZGNhc3Q6IDJ9LFxuXG4gIGVuY29kZShtc2csIGNhbGxiYWNrKXtcbiAgICBpZihtc2cucGF5bG9hZC5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpe1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuYmluYXJ5RW5jb2RlKG1zZykpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYXlsb2FkID0gW21zZy5qb2luX3JlZiwgbXNnLnJlZiwgbXNnLnRvcGljLCBtc2cuZXZlbnQsIG1zZy5wYXlsb2FkXVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKVxuICAgIH1cbiAgfSxcblxuICBkZWNvZGUocmF3UGF5bG9hZCwgY2FsbGJhY2spe1xuICAgIGlmKHJhd1BheWxvYWQuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKXtcbiAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLmJpbmFyeURlY29kZShyYXdQYXlsb2FkKSlcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IFtqb2luX3JlZiwgcmVmLCB0b3BpYywgZXZlbnQsIHBheWxvYWRdID0gSlNPTi5wYXJzZShyYXdQYXlsb2FkKVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKHtqb2luX3JlZiwgcmVmLCB0b3BpYywgZXZlbnQsIHBheWxvYWR9KVxuICAgIH1cbiAgfSxcblxuICAvLyBwcml2YXRlXG5cbiAgYmluYXJ5RW5jb2RlKG1lc3NhZ2Upe1xuICAgIGxldCB7am9pbl9yZWYsIHJlZiwgZXZlbnQsIHRvcGljLCBwYXlsb2FkfSA9IG1lc3NhZ2VcbiAgICBsZXQgbWV0YUxlbmd0aCA9IHRoaXMuTUVUQV9MRU5HVEggKyBqb2luX3JlZi5sZW5ndGggKyByZWYubGVuZ3RoICsgdG9waWMubGVuZ3RoICsgZXZlbnQubGVuZ3RoXG4gICAgbGV0IGhlYWRlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLkhFQURFUl9MRU5HVEggKyBtZXRhTGVuZ3RoKVxuICAgIGxldCB2aWV3ID0gbmV3IERhdGFWaWV3KGhlYWRlcilcbiAgICBsZXQgb2Zmc2V0ID0gMFxuXG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgdGhpcy5LSU5EUy5wdXNoKSAvLyBraW5kXG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgam9pbl9yZWYubGVuZ3RoKVxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIHJlZi5sZW5ndGgpXG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgdG9waWMubGVuZ3RoKVxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGV2ZW50Lmxlbmd0aClcbiAgICBBcnJheS5mcm9tKGpvaW5fcmVmLCBjaGFyID0+IHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNoYXIuY2hhckNvZGVBdCgwKSkpXG4gICAgQXJyYXkuZnJvbShyZWYsIGNoYXIgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSlcbiAgICBBcnJheS5mcm9tKHRvcGljLCBjaGFyID0+IHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNoYXIuY2hhckNvZGVBdCgwKSkpXG4gICAgQXJyYXkuZnJvbShldmVudCwgY2hhciA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKVxuXG4gICAgdmFyIGNvbWJpbmVkID0gbmV3IFVpbnQ4QXJyYXkoaGVhZGVyLmJ5dGVMZW5ndGggKyBwYXlsb2FkLmJ5dGVMZW5ndGgpXG4gICAgY29tYmluZWQuc2V0KG5ldyBVaW50OEFycmF5KGhlYWRlciksIDApXG4gICAgY29tYmluZWQuc2V0KG5ldyBVaW50OEFycmF5KHBheWxvYWQpLCBoZWFkZXIuYnl0ZUxlbmd0aClcblxuICAgIHJldHVybiBjb21iaW5lZC5idWZmZXJcbiAgfSxcblxuICBiaW5hcnlEZWNvZGUoYnVmZmVyKXtcbiAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpXG4gICAgbGV0IGtpbmQgPSB2aWV3LmdldFVpbnQ4KDApXG4gICAgbGV0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKVxuICAgIHN3aXRjaChraW5kKXtcbiAgICAgIGNhc2UgdGhpcy5LSU5EUy5wdXNoOiByZXR1cm4gdGhpcy5kZWNvZGVQdXNoKGJ1ZmZlciwgdmlldywgZGVjb2RlcilcbiAgICAgIGNhc2UgdGhpcy5LSU5EUy5yZXBseTogcmV0dXJuIHRoaXMuZGVjb2RlUmVwbHkoYnVmZmVyLCB2aWV3LCBkZWNvZGVyKVxuICAgICAgY2FzZSB0aGlzLktJTkRTLmJyb2FkY2FzdDogcmV0dXJuIHRoaXMuZGVjb2RlQnJvYWRjYXN0KGJ1ZmZlciwgdmlldywgZGVjb2RlcilcbiAgICB9XG4gIH0sXG5cbiAgZGVjb2RlUHVzaChidWZmZXIsIHZpZXcsIGRlY29kZXIpe1xuICAgIGxldCBqb2luUmVmU2l6ZSA9IHZpZXcuZ2V0VWludDgoMSlcbiAgICBsZXQgdG9waWNTaXplID0gdmlldy5nZXRVaW50OCgyKVxuICAgIGxldCBldmVudFNpemUgPSB2aWV3LmdldFVpbnQ4KDMpXG4gICAgbGV0IG9mZnNldCA9IHRoaXMuSEVBREVSX0xFTkdUSCArIHRoaXMuTUVUQV9MRU5HVEggLSAxIC8vIHB1c2hlcyBoYXZlIG5vIHJlZlxuICAgIGxldCBqb2luUmVmID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgam9pblJlZlNpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIGpvaW5SZWZTaXplXG4gICAgbGV0IHRvcGljID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdG9waWNTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyB0b3BpY1NpemVcbiAgICBsZXQgZXZlbnQgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBldmVudFNpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIGV2ZW50U2l6ZVxuICAgIGxldCBkYXRhID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgcmV0dXJuIHtqb2luX3JlZjogam9pblJlZiwgcmVmOiBudWxsLCB0b3BpYzogdG9waWMsIGV2ZW50OiBldmVudCwgcGF5bG9hZDogZGF0YX1cbiAgfSxcblxuICBkZWNvZGVSZXBseShidWZmZXIsIHZpZXcsIGRlY29kZXIpe1xuICAgIGxldCBqb2luUmVmU2l6ZSA9IHZpZXcuZ2V0VWludDgoMSlcbiAgICBsZXQgcmVmU2l6ZSA9IHZpZXcuZ2V0VWludDgoMilcbiAgICBsZXQgdG9waWNTaXplID0gdmlldy5nZXRVaW50OCgzKVxuICAgIGxldCBldmVudFNpemUgPSB2aWV3LmdldFVpbnQ4KDQpXG4gICAgbGV0IG9mZnNldCA9IHRoaXMuSEVBREVSX0xFTkdUSCArIHRoaXMuTUVUQV9MRU5HVEhcbiAgICBsZXQgam9pblJlZiA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGpvaW5SZWZTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyBqb2luUmVmU2l6ZVxuICAgIGxldCByZWYgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyByZWZTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyByZWZTaXplXG4gICAgbGV0IHRvcGljID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdG9waWNTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyB0b3BpY1NpemVcbiAgICBsZXQgZXZlbnQgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBldmVudFNpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIGV2ZW50U2l6ZVxuICAgIGxldCBkYXRhID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgbGV0IHBheWxvYWQgPSB7c3RhdHVzOiBldmVudCwgcmVzcG9uc2U6IGRhdGF9XG4gICAgcmV0dXJuIHtqb2luX3JlZjogam9pblJlZiwgcmVmOiByZWYsIHRvcGljOiB0b3BpYywgZXZlbnQ6IENIQU5ORUxfRVZFTlRTLnJlcGx5LCBwYXlsb2FkOiBwYXlsb2FkfVxuICB9LFxuXG4gIGRlY29kZUJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpe1xuICAgIGxldCB0b3BpY1NpemUgPSB2aWV3LmdldFVpbnQ4KDEpXG4gICAgbGV0IGV2ZW50U2l6ZSA9IHZpZXcuZ2V0VWludDgoMilcbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5IRUFERVJfTEVOR1RIICsgMlxuICAgIGxldCB0b3BpYyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHRvcGljU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdG9waWNTaXplXG4gICAgbGV0IGV2ZW50ID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgZXZlbnRTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyBldmVudFNpemVcbiAgICBsZXQgZGF0YSA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKVxuXG4gICAgcmV0dXJuIHtqb2luX3JlZjogbnVsbCwgcmVmOiBudWxsLCB0b3BpYzogdG9waWMsIGV2ZW50OiBldmVudCwgcGF5bG9hZDogZGF0YX1cbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIGdsb2JhbCxcbiAgcGh4V2luZG93LFxuICBDSEFOTkVMX0VWRU5UUyxcbiAgREVGQVVMVF9USU1FT1VULFxuICBERUZBVUxUX1ZTTixcbiAgU09DS0VUX1NUQVRFUyxcbiAgVFJBTlNQT1JUUyxcbiAgV1NfQ0xPU0VfTk9STUFMXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG4gIGNsb3N1cmVcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5pbXBvcnQgQWpheCBmcm9tIFwiLi9hamF4XCJcbmltcG9ydCBDaGFubmVsIGZyb20gXCIuL2NoYW5uZWxcIlxuaW1wb3J0IExvbmdQb2xsIGZyb20gXCIuL2xvbmdwb2xsXCJcbmltcG9ydCBTZXJpYWxpemVyIGZyb20gXCIuL3NlcmlhbGl6ZXJcIlxuaW1wb3J0IFRpbWVyIGZyb20gXCIuL3RpbWVyXCJcblxuLyoqIEluaXRpYWxpemVzIHRoZSBTb2NrZXQgKlxuICpcbiAqIEZvciBJRTggc3VwcG9ydCB1c2UgYW4gRVM1LXNoaW0gKGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbSlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5kUG9pbnQgLSBUaGUgc3RyaW5nIFdlYlNvY2tldCBlbmRwb2ludCwgaWUsIGBcIndzOi8vZXhhbXBsZS5jb20vc29ja2V0XCJgLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcIndzczovL2V4YW1wbGUuY29tXCJgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFwiL3NvY2tldFwiYCAoaW5oZXJpdGVkIGhvc3QgJiBwcm90b2NvbClcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBPcHRpb25hbCBjb25maWd1cmF0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy50cmFuc3BvcnRdIC0gVGhlIFdlYnNvY2tldCBUcmFuc3BvcnQsIGZvciBleGFtcGxlIFdlYlNvY2tldCBvciBQaG9lbml4LkxvbmdQb2xsLlxuICpcbiAqIERlZmF1bHRzIHRvIFdlYlNvY2tldCB3aXRoIGF1dG9tYXRpYyBMb25nUG9sbCBmYWxsYmFjayBpZiBXZWJTb2NrZXQgaXMgbm90IGRlZmluZWQuXG4gKiBUbyBmYWxsYmFjayB0byBMb25nUG9sbCB3aGVuIFdlYlNvY2tldCBhdHRlbXB0cyBmYWlsLCB1c2UgYGxvbmdQb2xsRmFsbGJhY2tNczogMjUwMGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMubG9uZ1BvbGxGYWxsYmFja01zXSAtIFRoZSBtaWxsaXNlY29uZCB0aW1lIHRvIGF0dGVtcHQgdGhlIHByaW1hcnkgdHJhbnNwb3J0XG4gKiBiZWZvcmUgZmFsbGluZyBiYWNrIHRvIHRoZSBMb25nUG9sbCB0cmFuc3BvcnQuIERpc2FibGVkIGJ5IGRlZmF1bHQuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMuZGVidWddIC0gV2hlbiB0cnVlLCBlbmFibGVzIGRlYnVnIGxvZ2dpbmcuIERlZmF1bHQgZmFsc2UuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMuZW5jb2RlXSAtIFRoZSBmdW5jdGlvbiB0byBlbmNvZGUgb3V0Z29pbmcgbWVzc2FnZXMuXG4gKlxuICogRGVmYXVsdHMgdG8gSlNPTiBlbmNvZGVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLmRlY29kZV0gLSBUaGUgZnVuY3Rpb24gdG8gZGVjb2RlIGluY29taW5nIG1lc3NhZ2VzLlxuICpcbiAqIERlZmF1bHRzIHRvIEpTT046XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogKHBheWxvYWQsIGNhbGxiYWNrKSA9PiBjYWxsYmFjayhKU09OLnBhcnNlKHBheWxvYWQpKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnRpbWVvdXRdIC0gVGhlIGRlZmF1bHQgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gdHJpZ2dlciBwdXNoIHRpbWVvdXRzLlxuICpcbiAqIERlZmF1bHRzIGBERUZBVUxUX1RJTUVPVVRgXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMuaGVhcnRiZWF0SW50ZXJ2YWxNc10gLSBUaGUgbWlsbGlzZWMgaW50ZXJ2YWwgdG8gc2VuZCBhIGhlYXJ0YmVhdCBtZXNzYWdlXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMucmVjb25uZWN0QWZ0ZXJNc10gLSBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBtaWxsaXNlY1xuICogc29ja2V0IHJlY29ubmVjdCBpbnRlcnZhbC5cbiAqXG4gKiBEZWZhdWx0cyB0byBzdGVwcGVkIGJhY2tvZmYgb2Y6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogZnVuY3Rpb24odHJpZXMpe1xuICogICByZXR1cm4gWzEwLCA1MCwgMTAwLCAxNTAsIDIwMCwgMjUwLCA1MDAsIDEwMDAsIDIwMDBdW3RyaWVzIC0gMV0gfHwgNTAwMFxuICogfVxuICogYGBgYFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5yZWpvaW5BZnRlck1zXSAtIFRoZSBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG1pbGxpc2VjXG4gKiByZWpvaW4gaW50ZXJ2YWwgZm9yIGluZGl2aWR1YWwgY2hhbm5lbHMuXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogZnVuY3Rpb24odHJpZXMpe1xuICogICByZXR1cm4gWzEwMDAsIDIwMDAsIDUwMDBdW3RyaWVzIC0gMV0gfHwgMTAwMDBcbiAqIH1cbiAqIGBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy5sb2dnZXJdIC0gVGhlIG9wdGlvbmFsIGZ1bmN0aW9uIGZvciBzcGVjaWFsaXplZCBsb2dnaW5nLCBpZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBmdW5jdGlvbihraW5kLCBtc2csIGRhdGEpIHtcbiAqICAgY29uc29sZS5sb2coYCR7a2luZH06ICR7bXNnfWAsIGRhdGEpXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMubG9uZ3BvbGxlclRpbWVvdXRdIC0gVGhlIG1heGltdW0gdGltZW91dCBvZiBhIGxvbmcgcG9sbCBBSkFYIHJlcXVlc3QuXG4gKlxuICogRGVmYXVsdHMgdG8gMjBzIChkb3VibGUgdGhlIHNlcnZlciBsb25nIHBvbGwgdGltZXIpLlxuICpcbiAqIEBwYXJhbSB7KE9iamVjdHxmdW5jdGlvbil9IFtvcHRzLnBhcmFtc10gLSBUaGUgb3B0aW9uYWwgcGFyYW1zIHRvIHBhc3Mgd2hlbiBjb25uZWN0aW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmluYXJ5VHlwZV0gLSBUaGUgYmluYXJ5IHR5cGUgdG8gdXNlIGZvciBiaW5hcnkgV2ViU29ja2V0IGZyYW1lcy5cbiAqXG4gKiBEZWZhdWx0cyB0byBcImFycmF5YnVmZmVyXCJcbiAqXG4gKiBAcGFyYW0ge3Zzbn0gW29wdHMudnNuXSAtIFRoZSBzZXJpYWxpemVyJ3MgcHJvdG9jb2wgdmVyc2lvbiB0byBzZW5kIG9uIGNvbm5lY3QuXG4gKlxuICogRGVmYXVsdHMgdG8gREVGQVVMVF9WU04uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLnNlc3Npb25TdG9yYWdlXSAtIEFuIG9wdGlvbmFsIFN0b3JhZ2UgY29tcGF0aWJsZSBvYmplY3RcbiAqIFBob2VuaXggdXNlcyBzZXNzaW9uU3RvcmFnZSBmb3IgbG9uZ3BvbGwgZmFsbGJhY2sgaGlzdG9yeS4gT3ZlcnJpZGluZyB0aGUgc3RvcmUgaXNcbiAqIHVzZWZ1bCB3aGVuIFBob2VuaXggd29uJ3QgaGF2ZSBhY2Nlc3MgdG8gYHNlc3Npb25TdG9yYWdlYC4gRm9yIGV4YW1wbGUsIFRoaXMgY291bGRcbiAqIGhhcHBlbiBpZiBhIHNpdGUgbG9hZHMgYSBjcm9zcy1kb21haW4gY2hhbm5lbCBpbiBhbiBpZnJhbWUuIEV4YW1wbGUgdXNhZ2U6XG4gKlxuICogICAgIGNsYXNzIEluTWVtb3J5U3RvcmFnZSB7XG4gKiAgICAgICBjb25zdHJ1Y3RvcigpIHsgdGhpcy5zdG9yYWdlID0ge30gfVxuICogICAgICAgZ2V0SXRlbShrZXlOYW1lKSB7IHJldHVybiB0aGlzLnN0b3JhZ2Vba2V5TmFtZV0gfHwgbnVsbCB9XG4gKiAgICAgICByZW1vdmVJdGVtKGtleU5hbWUpIHsgZGVsZXRlIHRoaXMuc3RvcmFnZVtrZXlOYW1lXSB9XG4gKiAgICAgICBzZXRJdGVtKGtleU5hbWUsIGtleVZhbHVlKSB7IHRoaXMuc3RvcmFnZVtrZXlOYW1lXSA9IGtleVZhbHVlIH1cbiAqICAgICB9XG4gKlxuKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNvY2tldCB7XG4gIGNvbnN0cnVjdG9yKGVuZFBvaW50LCBvcHRzID0ge30pe1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MgPSB7b3BlbjogW10sIGNsb3NlOiBbXSwgZXJyb3I6IFtdLCBtZXNzYWdlOiBbXX1cbiAgICB0aGlzLmNoYW5uZWxzID0gW11cbiAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXVxuICAgIHRoaXMucmVmID0gMFxuICAgIHRoaXMudGltZW91dCA9IG9wdHMudGltZW91dCB8fCBERUZBVUxUX1RJTUVPVVRcbiAgICB0aGlzLnRyYW5zcG9ydCA9IG9wdHMudHJhbnNwb3J0IHx8IGdsb2JhbC5XZWJTb2NrZXQgfHwgTG9uZ1BvbGxcbiAgICB0aGlzLnByaW1hcnlQYXNzZWRIZWFsdGhDaGVjayA9IGZhbHNlXG4gICAgdGhpcy5sb25nUG9sbEZhbGxiYWNrTXMgPSBvcHRzLmxvbmdQb2xsRmFsbGJhY2tNc1xuICAgIHRoaXMuZmFsbGJhY2tUaW1lciA9IG51bGxcbiAgICB0aGlzLnNlc3Npb25TdG9yZSA9IG9wdHMuc2Vzc2lvblN0b3JhZ2UgfHwgKGdsb2JhbCAmJiBnbG9iYWwuc2Vzc2lvblN0b3JhZ2UpXG4gICAgdGhpcy5lc3RhYmxpc2hlZENvbm5lY3Rpb25zID0gMFxuICAgIHRoaXMuZGVmYXVsdEVuY29kZXIgPSBTZXJpYWxpemVyLmVuY29kZS5iaW5kKFNlcmlhbGl6ZXIpXG4gICAgdGhpcy5kZWZhdWx0RGVjb2RlciA9IFNlcmlhbGl6ZXIuZGVjb2RlLmJpbmQoU2VyaWFsaXplcilcbiAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSBmYWxzZVxuICAgIHRoaXMuYmluYXJ5VHlwZSA9IG9wdHMuYmluYXJ5VHlwZSB8fCBcImFycmF5YnVmZmVyXCJcbiAgICB0aGlzLmNvbm5lY3RDbG9jayA9IDFcbiAgICBpZih0aGlzLnRyYW5zcG9ydCAhPT0gTG9uZ1BvbGwpe1xuICAgICAgdGhpcy5lbmNvZGUgPSBvcHRzLmVuY29kZSB8fCB0aGlzLmRlZmF1bHRFbmNvZGVyXG4gICAgICB0aGlzLmRlY29kZSA9IG9wdHMuZGVjb2RlIHx8IHRoaXMuZGVmYXVsdERlY29kZXJcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbmNvZGUgPSB0aGlzLmRlZmF1bHRFbmNvZGVyXG4gICAgICB0aGlzLmRlY29kZSA9IHRoaXMuZGVmYXVsdERlY29kZXJcbiAgICB9XG4gICAgbGV0IGF3YWl0aW5nQ29ubmVjdGlvbk9uUGFnZVNob3cgPSBudWxsXG4gICAgaWYocGh4V2luZG93ICYmIHBoeFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKXtcbiAgICAgIHBoeFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgX2UgPT4ge1xuICAgICAgICBpZih0aGlzLmNvbm4pe1xuICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpXG4gICAgICAgICAgYXdhaXRpbmdDb25uZWN0aW9uT25QYWdlU2hvdyA9IHRoaXMuY29ubmVjdENsb2NrXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBwaHhXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VzaG93XCIsIF9lID0+IHtcbiAgICAgICAgaWYoYXdhaXRpbmdDb25uZWN0aW9uT25QYWdlU2hvdyA9PT0gdGhpcy5jb25uZWN0Q2xvY2spe1xuICAgICAgICAgIGF3YWl0aW5nQ29ubmVjdGlvbk9uUGFnZVNob3cgPSBudWxsXG4gICAgICAgICAgdGhpcy5jb25uZWN0KClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zID0gb3B0cy5oZWFydGJlYXRJbnRlcnZhbE1zIHx8IDMwMDAwXG4gICAgdGhpcy5yZWpvaW5BZnRlck1zID0gKHRyaWVzKSA9PiB7XG4gICAgICBpZihvcHRzLnJlam9pbkFmdGVyTXMpe1xuICAgICAgICByZXR1cm4gb3B0cy5yZWpvaW5BZnRlck1zKHRyaWVzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFsxMDAwLCAyMDAwLCA1MDAwXVt0cmllcyAtIDFdIHx8IDEwMDAwXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVjb25uZWN0QWZ0ZXJNcyA9ICh0cmllcykgPT4ge1xuICAgICAgaWYob3B0cy5yZWNvbm5lY3RBZnRlck1zKXtcbiAgICAgICAgcmV0dXJuIG9wdHMucmVjb25uZWN0QWZ0ZXJNcyh0cmllcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbMTAsIDUwLCAxMDAsIDE1MCwgMjAwLCAyNTAsIDUwMCwgMTAwMCwgMjAwMF1bdHJpZXMgLSAxXSB8fCA1MDAwXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyID0gb3B0cy5sb2dnZXIgfHwgbnVsbFxuICAgIGlmKCF0aGlzLmxvZ2dlciAmJiBvcHRzLmRlYnVnKXtcbiAgICAgIHRoaXMubG9nZ2VyID0gKGtpbmQsIG1zZywgZGF0YSkgPT4geyBjb25zb2xlLmxvZyhgJHtraW5kfTogJHttc2d9YCwgZGF0YSkgfVxuICAgIH1cbiAgICB0aGlzLmxvbmdwb2xsZXJUaW1lb3V0ID0gb3B0cy5sb25ncG9sbGVyVGltZW91dCB8fCAyMDAwMFxuICAgIHRoaXMucGFyYW1zID0gY2xvc3VyZShvcHRzLnBhcmFtcyB8fCB7fSlcbiAgICB0aGlzLmVuZFBvaW50ID0gYCR7ZW5kUG9pbnR9LyR7VFJBTlNQT1JUUy53ZWJzb2NrZXR9YFxuICAgIHRoaXMudnNuID0gb3B0cy52c24gfHwgREVGQVVMVF9WU05cbiAgICB0aGlzLmhlYXJ0YmVhdFRpbWVvdXRUaW1lciA9IG51bGxcbiAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyID0gbnVsbFxuICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGxcbiAgICB0aGlzLnJlY29ubmVjdFRpbWVyID0gbmV3IFRpbWVyKCgpID0+IHtcbiAgICAgIHRoaXMudGVhcmRvd24oKCkgPT4gdGhpcy5jb25uZWN0KCkpXG4gICAgfSwgdGhpcy5yZWNvbm5lY3RBZnRlck1zKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIExvbmdQb2xsIHRyYW5zcG9ydCByZWZlcmVuY2VcbiAgICovXG4gIGdldExvbmdQb2xsVHJhbnNwb3J0KCl7IHJldHVybiBMb25nUG9sbCB9XG5cbiAgLyoqXG4gICAqIERpc2Nvbm5lY3RzIGFuZCByZXBsYWNlcyB0aGUgYWN0aXZlIHRyYW5zcG9ydFxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXdUcmFuc3BvcnQgLSBUaGUgbmV3IHRyYW5zcG9ydCBjbGFzcyB0byBpbnN0YW50aWF0ZVxuICAgKlxuICAgKi9cbiAgcmVwbGFjZVRyYW5zcG9ydChuZXdUcmFuc3BvcnQpe1xuICAgIHRoaXMuY29ubmVjdENsb2NrKytcbiAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSB0cnVlXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuZmFsbGJhY2tUaW1lcilcbiAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnJlc2V0KClcbiAgICBpZih0aGlzLmNvbm4pe1xuICAgICAgdGhpcy5jb25uLmNsb3NlKClcbiAgICAgIHRoaXMuY29ubiA9IG51bGxcbiAgICB9XG4gICAgdGhpcy50cmFuc3BvcnQgPSBuZXdUcmFuc3BvcnRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzb2NrZXQgcHJvdG9jb2xcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHByb3RvY29sKCl7IHJldHVybiBsb2NhdGlvbi5wcm90b2NvbC5tYXRjaCgvXmh0dHBzLykgPyBcIndzc1wiIDogXCJ3c1wiIH1cblxuICAvKipcbiAgICogVGhlIGZ1bGx5IHF1YWxpZmllZCBzb2NrZXQgdXJsXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBlbmRQb2ludFVSTCgpe1xuICAgIGxldCB1cmkgPSBBamF4LmFwcGVuZFBhcmFtcyhcbiAgICAgIEFqYXguYXBwZW5kUGFyYW1zKHRoaXMuZW5kUG9pbnQsIHRoaXMucGFyYW1zKCkpLCB7dnNuOiB0aGlzLnZzbn0pXG4gICAgaWYodXJpLmNoYXJBdCgwKSAhPT0gXCIvXCIpeyByZXR1cm4gdXJpIH1cbiAgICBpZih1cmkuY2hhckF0KDEpID09PSBcIi9cIil7IHJldHVybiBgJHt0aGlzLnByb3RvY29sKCl9OiR7dXJpfWAgfVxuXG4gICAgcmV0dXJuIGAke3RoaXMucHJvdG9jb2woKX06Ly8ke2xvY2F0aW9uLmhvc3R9JHt1cml9YFxuICB9XG5cbiAgLyoqXG4gICAqIERpc2Nvbm5lY3RzIHRoZSBzb2NrZXRcbiAgICpcbiAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DbG9zZUV2ZW50I1N0YXR1c19jb2RlcyBmb3IgdmFsaWQgc3RhdHVzIGNvZGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIE9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBzb2NrZXQgaXMgZGlzY29ubmVjdGVkLlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IGNvZGUgLSBBIHN0YXR1cyBjb2RlIGZvciBkaXNjb25uZWN0aW9uIChPcHRpb25hbCkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gLSBBIHRleHR1YWwgZGVzY3JpcHRpb24gb2YgdGhlIHJlYXNvbiB0byBkaXNjb25uZWN0LiAoT3B0aW9uYWwpXG4gICAqL1xuICBkaXNjb25uZWN0KGNhbGxiYWNrLCBjb2RlLCByZWFzb24pe1xuICAgIHRoaXMuY29ubmVjdENsb2NrKytcbiAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSB0cnVlXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuZmFsbGJhY2tUaW1lcilcbiAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnJlc2V0KClcbiAgICB0aGlzLnRlYXJkb3duKGNhbGxiYWNrLCBjb2RlLCByZWFzb24pXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbXMgdG8gc2VuZCB3aGVuIGNvbm5lY3RpbmcsIGZvciBleGFtcGxlIGB7dXNlcl9pZDogdXNlclRva2VufWBcbiAgICpcbiAgICogUGFzc2luZyBwYXJhbXMgdG8gY29ubmVjdCBpcyBkZXByZWNhdGVkOyBwYXNzIHRoZW0gaW4gdGhlIFNvY2tldCBjb25zdHJ1Y3RvciBpbnN0ZWFkOlxuICAgKiBgbmV3IFNvY2tldChcIi9zb2NrZXRcIiwge3BhcmFtczoge3VzZXJfaWQ6IHVzZXJUb2tlbn19KWAuXG4gICAqL1xuICBjb25uZWN0KHBhcmFtcyl7XG4gICAgaWYocGFyYW1zKXtcbiAgICAgIGNvbnNvbGUgJiYgY29uc29sZS5sb2coXCJwYXNzaW5nIHBhcmFtcyB0byBjb25uZWN0IGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQgcGFzcyA6cGFyYW1zIHRvIHRoZSBTb2NrZXQgY29uc3RydWN0b3JcIilcbiAgICAgIHRoaXMucGFyYW1zID0gY2xvc3VyZShwYXJhbXMpXG4gICAgfVxuICAgIGlmKHRoaXMuY29ubil7IHJldHVybiB9XG4gICAgaWYodGhpcy5sb25nUG9sbEZhbGxiYWNrTXMgJiYgdGhpcy50cmFuc3BvcnQgIT09IExvbmdQb2xsKXtcbiAgICAgIHRoaXMuY29ubmVjdFdpdGhGYWxsYmFjayhMb25nUG9sbCwgdGhpcy5sb25nUG9sbEZhbGxiYWNrTXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHJhbnNwb3J0Q29ubmVjdCgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgdGhlIG1lc3NhZ2UuIE92ZXJyaWRlIGB0aGlzLmxvZ2dlcmAgZm9yIHNwZWNpYWxpemVkIGxvZ2dpbmcuIG5vb3BzIGJ5IGRlZmF1bHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtpbmRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1zZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKi9cbiAgbG9nKGtpbmQsIG1zZywgZGF0YSl7IHRoaXMubG9nZ2VyICYmIHRoaXMubG9nZ2VyKGtpbmQsIG1zZywgZGF0YSkgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYSBsb2dnZXIgaGFzIGJlZW4gc2V0IG9uIHRoaXMgc29ja2V0LlxuICAgKi9cbiAgaGFzTG9nZ2VyKCl7IHJldHVybiB0aGlzLmxvZ2dlciAhPT0gbnVsbCB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBjYWxsYmFja3MgZm9yIGNvbm5lY3Rpb24gb3BlbiBldmVudHNcbiAgICpcbiAgICogQGV4YW1wbGUgc29ja2V0Lm9uT3BlbihmdW5jdGlvbigpeyBjb25zb2xlLmluZm8oXCJ0aGUgc29ja2V0IHdhcyBvcGVuZWRcIikgfSlcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uT3BlbihjYWxsYmFjayl7XG4gICAgbGV0IHJlZiA9IHRoaXMubWFrZVJlZigpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5vcGVuLnB1c2goW3JlZiwgY2FsbGJhY2tdKVxuICAgIHJldHVybiByZWZcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgY2FsbGJhY2tzIGZvciBjb25uZWN0aW9uIGNsb3NlIGV2ZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25DbG9zZShjYWxsYmFjayl7XG4gICAgbGV0IHJlZiA9IHRoaXMubWFrZVJlZigpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5jbG9zZS5wdXNoKFtyZWYsIGNhbGxiYWNrXSlcbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGNhbGxiYWNrcyBmb3IgY29ubmVjdGlvbiBlcnJvciBldmVudHNcbiAgICpcbiAgICogQGV4YW1wbGUgc29ja2V0Lm9uRXJyb3IoZnVuY3Rpb24oZXJyb3IpeyBhbGVydChcIkFuIGVycm9yIG9jY3VycmVkXCIpIH0pXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBvbkVycm9yKGNhbGxiYWNrKXtcbiAgICBsZXQgcmVmID0gdGhpcy5tYWtlUmVmKClcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmVycm9yLnB1c2goW3JlZiwgY2FsbGJhY2tdKVxuICAgIHJldHVybiByZWZcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgY2FsbGJhY2tzIGZvciBjb25uZWN0aW9uIG1lc3NhZ2UgZXZlbnRzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBvbk1lc3NhZ2UoY2FsbGJhY2spe1xuICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MubWVzc2FnZS5wdXNoKFtyZWYsIGNhbGxiYWNrXSlcbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICAvKipcbiAgICogUGluZ3MgdGhlIHNlcnZlciBhbmQgaW52b2tlcyB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgUlRUIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBpbmcgd2FzIHB1c2hlZCBvciBmYWxzZSBpZiB1bmFibGUgdG8gYmUgcHVzaGVkLlxuICAgKi9cbiAgcGluZyhjYWxsYmFjayl7XG4gICAgaWYoIXRoaXMuaXNDb25uZWN0ZWQoKSl7IHJldHVybiBmYWxzZSB9XG4gICAgbGV0IHJlZiA9IHRoaXMubWFrZVJlZigpXG4gICAgbGV0IHN0YXJ0VGltZSA9IERhdGUubm93KClcbiAgICB0aGlzLnB1c2goe3RvcGljOiBcInBob2VuaXhcIiwgZXZlbnQ6IFwiaGVhcnRiZWF0XCIsIHBheWxvYWQ6IHt9LCByZWY6IHJlZn0pXG4gICAgbGV0IG9uTXNnUmVmID0gdGhpcy5vbk1lc3NhZ2UobXNnID0+IHtcbiAgICAgIGlmKG1zZy5yZWYgPT09IHJlZil7XG4gICAgICAgIHRoaXMub2ZmKFtvbk1zZ1JlZl0pXG4gICAgICAgIGNhbGxiYWNrKERhdGUubm93KCkgLSBzdGFydFRpbWUpXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRyYW5zcG9ydENvbm5lY3QoKXtcbiAgICB0aGlzLmNvbm5lY3RDbG9jaysrXG4gICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gZmFsc2VcbiAgICB0aGlzLmNvbm4gPSBuZXcgdGhpcy50cmFuc3BvcnQodGhpcy5lbmRQb2ludFVSTCgpKVxuICAgIHRoaXMuY29ubi5iaW5hcnlUeXBlID0gdGhpcy5iaW5hcnlUeXBlXG4gICAgdGhpcy5jb25uLnRpbWVvdXQgPSB0aGlzLmxvbmdwb2xsZXJUaW1lb3V0XG4gICAgdGhpcy5jb25uLm9ub3BlbiA9ICgpID0+IHRoaXMub25Db25uT3BlbigpXG4gICAgdGhpcy5jb25uLm9uZXJyb3IgPSBlcnJvciA9PiB0aGlzLm9uQ29ubkVycm9yKGVycm9yKVxuICAgIHRoaXMuY29ubi5vbm1lc3NhZ2UgPSBldmVudCA9PiB0aGlzLm9uQ29ubk1lc3NhZ2UoZXZlbnQpXG4gICAgdGhpcy5jb25uLm9uY2xvc2UgPSBldmVudCA9PiB0aGlzLm9uQ29ubkNsb3NlKGV2ZW50KVxuICB9XG5cbiAgZ2V0U2Vzc2lvbihrZXkpeyByZXR1cm4gdGhpcy5zZXNzaW9uU3RvcmUgJiYgdGhpcy5zZXNzaW9uU3RvcmUuZ2V0SXRlbShrZXkpIH1cblxuICBzdG9yZVNlc3Npb24oa2V5LCB2YWwpeyB0aGlzLnNlc3Npb25TdG9yZSAmJiB0aGlzLnNlc3Npb25TdG9yZS5zZXRJdGVtKGtleSwgdmFsKSB9XG5cbiAgY29ubmVjdFdpdGhGYWxsYmFjayhmYWxsYmFja1RyYW5zcG9ydCwgZmFsbGJhY2tUaHJlc2hvbGQgPSAyNTAwKXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5mYWxsYmFja1RpbWVyKVxuICAgIGxldCBlc3RhYmxpc2hlZCA9IGZhbHNlXG4gICAgbGV0IHByaW1hcnlUcmFuc3BvcnQgPSB0cnVlXG4gICAgbGV0IG9wZW5SZWYsIGVycm9yUmVmXG4gICAgbGV0IGZhbGxiYWNrID0gKHJlYXNvbikgPT4ge1xuICAgICAgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgYGZhbGxpbmcgYmFjayB0byAke2ZhbGxiYWNrVHJhbnNwb3J0Lm5hbWV9Li4uYCwgcmVhc29uKVxuICAgICAgdGhpcy5vZmYoW29wZW5SZWYsIGVycm9yUmVmXSlcbiAgICAgIHByaW1hcnlUcmFuc3BvcnQgPSBmYWxzZVxuICAgICAgdGhpcy5yZXBsYWNlVHJhbnNwb3J0KGZhbGxiYWNrVHJhbnNwb3J0KVxuICAgICAgdGhpcy50cmFuc3BvcnRDb25uZWN0KClcbiAgICB9XG4gICAgaWYodGhpcy5nZXRTZXNzaW9uKGBwaHg6ZmFsbGJhY2s6JHtmYWxsYmFja1RyYW5zcG9ydC5uYW1lfWApKXsgcmV0dXJuIGZhbGxiYWNrKFwibWVtb3JpemVkXCIpIH1cblxuICAgIHRoaXMuZmFsbGJhY2tUaW1lciA9IHNldFRpbWVvdXQoZmFsbGJhY2ssIGZhbGxiYWNrVGhyZXNob2xkKVxuXG4gICAgZXJyb3JSZWYgPSB0aGlzLm9uRXJyb3IocmVhc29uID0+IHtcbiAgICAgIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIFwiZXJyb3JcIiwgcmVhc29uKVxuICAgICAgaWYocHJpbWFyeVRyYW5zcG9ydCAmJiAhZXN0YWJsaXNoZWQpe1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5mYWxsYmFja1RpbWVyKVxuICAgICAgICBmYWxsYmFjayhyZWFzb24pXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLm9uT3BlbigoKSA9PiB7XG4gICAgICBlc3RhYmxpc2hlZCA9IHRydWVcbiAgICAgIGlmKCFwcmltYXJ5VHJhbnNwb3J0KXtcbiAgICAgICAgLy8gb25seSBtZW1vcml6ZSBMUCBpZiB3ZSBuZXZlciBjb25uZWN0ZWQgdG8gcHJpbWFyeVxuICAgICAgICBpZighdGhpcy5wcmltYXJ5UGFzc2VkSGVhbHRoQ2hlY2speyB0aGlzLnN0b3JlU2Vzc2lvbihgcGh4OmZhbGxiYWNrOiR7ZmFsbGJhY2tUcmFuc3BvcnQubmFtZX1gLCBcInRydWVcIikgfVxuICAgICAgICByZXR1cm4gdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgYGVzdGFibGlzaGVkICR7ZmFsbGJhY2tUcmFuc3BvcnQubmFtZX0gZmFsbGJhY2tgKVxuICAgICAgfVxuICAgICAgLy8gaWYgd2UndmUgZXN0YWJsaXNoZWQgcHJpbWFyeSwgZ2l2ZSB0aGUgZmFsbGJhY2sgYSBuZXcgcGVyaW9kIHRvIGF0dGVtcHQgcGluZ1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZmFsbGJhY2tUaW1lcilcbiAgICAgIHRoaXMuZmFsbGJhY2tUaW1lciA9IHNldFRpbWVvdXQoZmFsbGJhY2ssIGZhbGxiYWNrVGhyZXNob2xkKVxuICAgICAgdGhpcy5waW5nKHJ0dCA9PiB7XG4gICAgICAgIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIFwiY29ubmVjdGVkIHRvIHByaW1hcnkgYWZ0ZXJcIiwgcnR0KVxuICAgICAgICB0aGlzLnByaW1hcnlQYXNzZWRIZWFsdGhDaGVjayA9IHRydWVcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZmFsbGJhY2tUaW1lcilcbiAgICAgIH0pXG4gICAgfSlcbiAgICB0aGlzLnRyYW5zcG9ydENvbm5lY3QoKVxuICB9XG5cbiAgY2xlYXJIZWFydGJlYXRzKCl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhcnRiZWF0VGltZXIpXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhcnRiZWF0VGltZW91dFRpbWVyKVxuICB9XG5cbiAgb25Db25uT3Blbigpe1xuICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIGAke3RoaXMudHJhbnNwb3J0Lm5hbWV9IGNvbm5lY3RlZCB0byAke3RoaXMuZW5kUG9pbnRVUkwoKX1gKVxuICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IGZhbHNlXG4gICAgdGhpcy5lc3RhYmxpc2hlZENvbm5lY3Rpb25zKytcbiAgICB0aGlzLmZsdXNoU2VuZEJ1ZmZlcigpXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lci5yZXNldCgpXG4gICAgdGhpcy5yZXNldEhlYXJ0YmVhdCgpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5vcGVuLmZvckVhY2goKFssIGNhbGxiYWNrXSkgPT4gY2FsbGJhY2soKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICBoZWFydGJlYXRUaW1lb3V0KCl7XG4gICAgaWYodGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmKXtcbiAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGxcbiAgICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpeyB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBcImhlYXJ0YmVhdCB0aW1lb3V0LiBBdHRlbXB0aW5nIHRvIHJlLWVzdGFibGlzaCBjb25uZWN0aW9uXCIpIH1cbiAgICAgIHRoaXMudHJpZ2dlckNoYW5FcnJvcigpXG4gICAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSBmYWxzZVxuICAgICAgdGhpcy50ZWFyZG93bigoKSA9PiB0aGlzLnJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpLCBXU19DTE9TRV9OT1JNQUwsIFwiaGVhcnRiZWF0IHRpbWVvdXRcIilcbiAgICB9XG4gIH1cblxuICByZXNldEhlYXJ0YmVhdCgpe1xuICAgIGlmKHRoaXMuY29ubiAmJiB0aGlzLmNvbm4uc2tpcEhlYXJ0YmVhdCl7IHJldHVybiB9XG4gICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbFxuICAgIHRoaXMuY2xlYXJIZWFydGJlYXRzKClcbiAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlbmRIZWFydGJlYXQoKSwgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zKVxuICB9XG5cbiAgdGVhcmRvd24oY2FsbGJhY2ssIGNvZGUsIHJlYXNvbil7XG4gICAgaWYoIXRoaXMuY29ubil7XG4gICAgICByZXR1cm4gY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgIH1cblxuICAgIHRoaXMud2FpdEZvckJ1ZmZlckRvbmUoKCkgPT4ge1xuICAgICAgaWYodGhpcy5jb25uKXtcbiAgICAgICAgaWYoY29kZSl7IHRoaXMuY29ubi5jbG9zZShjb2RlLCByZWFzb24gfHwgXCJcIikgfSBlbHNlIHsgdGhpcy5jb25uLmNsb3NlKCkgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLndhaXRGb3JTb2NrZXRDbG9zZWQoKCkgPT4ge1xuICAgICAgICBpZih0aGlzLmNvbm4pe1xuICAgICAgICAgIHRoaXMuY29ubi5vbm9wZW4gPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgICAgICAgdGhpcy5jb25uLm9uZXJyb3IgPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgICAgICAgdGhpcy5jb25uLm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpeyB9IC8vIG5vb3BcbiAgICAgICAgICB0aGlzLmNvbm4ub25jbG9zZSA9IGZ1bmN0aW9uICgpeyB9IC8vIG5vb3BcbiAgICAgICAgICB0aGlzLmNvbm4gPSBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICB3YWl0Rm9yQnVmZmVyRG9uZShjYWxsYmFjaywgdHJpZXMgPSAxKXtcbiAgICBpZih0cmllcyA9PT0gNSB8fCAhdGhpcy5jb25uIHx8ICF0aGlzLmNvbm4uYnVmZmVyZWRBbW91bnQpe1xuICAgICAgY2FsbGJhY2soKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLndhaXRGb3JCdWZmZXJEb25lKGNhbGxiYWNrLCB0cmllcyArIDEpXG4gICAgfSwgMTUwICogdHJpZXMpXG4gIH1cblxuICB3YWl0Rm9yU29ja2V0Q2xvc2VkKGNhbGxiYWNrLCB0cmllcyA9IDEpe1xuICAgIGlmKHRyaWVzID09PSA1IHx8ICF0aGlzLmNvbm4gfHwgdGhpcy5jb25uLnJlYWR5U3RhdGUgPT09IFNPQ0tFVF9TVEFURVMuY2xvc2VkKXtcbiAgICAgIGNhbGxiYWNrKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy53YWl0Rm9yU29ja2V0Q2xvc2VkKGNhbGxiYWNrLCB0cmllcyArIDEpXG4gICAgfSwgMTUwICogdHJpZXMpXG4gIH1cblxuICBvbkNvbm5DbG9zZShldmVudCl7XG4gICAgbGV0IGNsb3NlQ29kZSA9IGV2ZW50ICYmIGV2ZW50LmNvZGVcbiAgICBpZih0aGlzLmhhc0xvZ2dlcigpKSB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBcImNsb3NlXCIsIGV2ZW50KVxuICAgIHRoaXMudHJpZ2dlckNoYW5FcnJvcigpXG4gICAgdGhpcy5jbGVhckhlYXJ0YmVhdHMoKVxuICAgIGlmKCF0aGlzLmNsb3NlV2FzQ2xlYW4gJiYgY2xvc2VDb2RlICE9PSAxMDAwKXtcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KClcbiAgICB9XG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5jbG9zZS5mb3JFYWNoKChbLCBjYWxsYmFja10pID0+IGNhbGxiYWNrKGV2ZW50KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25Db25uRXJyb3IoZXJyb3Ipe1xuICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIGVycm9yKVxuICAgIGxldCB0cmFuc3BvcnRCZWZvcmUgPSB0aGlzLnRyYW5zcG9ydFxuICAgIGxldCBlc3RhYmxpc2hlZEJlZm9yZSA9IHRoaXMuZXN0YWJsaXNoZWRDb25uZWN0aW9uc1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuZXJyb3IuZm9yRWFjaCgoWywgY2FsbGJhY2tdKSA9PiB7XG4gICAgICBjYWxsYmFjayhlcnJvciwgdHJhbnNwb3J0QmVmb3JlLCBlc3RhYmxpc2hlZEJlZm9yZSlcbiAgICB9KVxuICAgIGlmKHRyYW5zcG9ydEJlZm9yZSA9PT0gdGhpcy50cmFuc3BvcnQgfHwgZXN0YWJsaXNoZWRCZWZvcmUgPiAwKXtcbiAgICAgIHRoaXMudHJpZ2dlckNoYW5FcnJvcigpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0cmlnZ2VyQ2hhbkVycm9yKCl7XG4gICAgdGhpcy5jaGFubmVscy5mb3JFYWNoKGNoYW5uZWwgPT4ge1xuICAgICAgaWYoIShjaGFubmVsLmlzRXJyb3JlZCgpIHx8IGNoYW5uZWwuaXNMZWF2aW5nKCkgfHwgY2hhbm5lbC5pc0Nsb3NlZCgpKSl7XG4gICAgICAgIGNoYW5uZWwudHJpZ2dlcihDSEFOTkVMX0VWRU5UUy5lcnJvcilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBjb25uZWN0aW9uU3RhdGUoKXtcbiAgICBzd2l0Y2godGhpcy5jb25uICYmIHRoaXMuY29ubi5yZWFkeVN0YXRlKXtcbiAgICAgIGNhc2UgU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nOiByZXR1cm4gXCJjb25uZWN0aW5nXCJcbiAgICAgIGNhc2UgU09DS0VUX1NUQVRFUy5vcGVuOiByZXR1cm4gXCJvcGVuXCJcbiAgICAgIGNhc2UgU09DS0VUX1NUQVRFUy5jbG9zaW5nOiByZXR1cm4gXCJjbG9zaW5nXCJcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBcImNsb3NlZFwiXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNDb25uZWN0ZWQoKXsgcmV0dXJuIHRoaXMuY29ubmVjdGlvblN0YXRlKCkgPT09IFwib3BlblwiIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtDaGFubmVsfVxuICAgKi9cbiAgcmVtb3ZlKGNoYW5uZWwpe1xuICAgIHRoaXMub2ZmKGNoYW5uZWwuc3RhdGVDaGFuZ2VSZWZzKVxuICAgIHRoaXMuY2hhbm5lbHMgPSB0aGlzLmNoYW5uZWxzLmZpbHRlcihjID0+IGMgIT09IGNoYW5uZWwpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBgb25PcGVuYCwgYG9uQ2xvc2VgLCBgb25FcnJvcixgIGFuZCBgb25NZXNzYWdlYCByZWdpc3RyYXRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge3JlZnN9IC0gbGlzdCBvZiByZWZzIHJldHVybmVkIGJ5IGNhbGxzIHRvXG4gICAqICAgICAgICAgICAgICAgICBgb25PcGVuYCwgYG9uQ2xvc2VgLCBgb25FcnJvcixgIGFuZCBgb25NZXNzYWdlYFxuICAgKi9cbiAgb2ZmKHJlZnMpe1xuICAgIGZvcihsZXQga2V5IGluIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Mpe1xuICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrc1trZXldID0gdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrc1trZXldLmZpbHRlcigoW3JlZl0pID0+IHtcbiAgICAgICAgcmV0dXJuIHJlZnMuaW5kZXhPZihyZWYpID09PSAtMVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhdGVzIGEgbmV3IGNoYW5uZWwgZm9yIHRoZSBnaXZlbiB0b3BpY1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9waWNcbiAgICogQHBhcmFtIHtPYmplY3R9IGNoYW5QYXJhbXMgLSBQYXJhbWV0ZXJzIGZvciB0aGUgY2hhbm5lbFxuICAgKiBAcmV0dXJucyB7Q2hhbm5lbH1cbiAgICovXG4gIGNoYW5uZWwodG9waWMsIGNoYW5QYXJhbXMgPSB7fSl7XG4gICAgbGV0IGNoYW4gPSBuZXcgQ2hhbm5lbCh0b3BpYywgY2hhblBhcmFtcywgdGhpcylcbiAgICB0aGlzLmNoYW5uZWxzLnB1c2goY2hhbilcbiAgICByZXR1cm4gY2hhblxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqL1xuICBwdXNoKGRhdGEpe1xuICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpe1xuICAgICAgbGV0IHt0b3BpYywgZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pbl9yZWZ9ID0gZGF0YVxuICAgICAgdGhpcy5sb2coXCJwdXNoXCIsIGAke3RvcGljfSAke2V2ZW50fSAoJHtqb2luX3JlZn0sICR7cmVmfSlgLCBwYXlsb2FkKVxuICAgIH1cblxuICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQoKSl7XG4gICAgICB0aGlzLmVuY29kZShkYXRhLCByZXN1bHQgPT4gdGhpcy5jb25uLnNlbmQocmVzdWx0KSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kQnVmZmVyLnB1c2goKCkgPT4gdGhpcy5lbmNvZGUoZGF0YSwgcmVzdWx0ID0+IHRoaXMuY29ubi5zZW5kKHJlc3VsdCkpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG5leHQgbWVzc2FnZSByZWYsIGFjY291bnRpbmcgZm9yIG92ZXJmbG93c1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgbWFrZVJlZigpe1xuICAgIGxldCBuZXdSZWYgPSB0aGlzLnJlZiArIDFcbiAgICBpZihuZXdSZWYgPT09IHRoaXMucmVmKXsgdGhpcy5yZWYgPSAwIH0gZWxzZSB7IHRoaXMucmVmID0gbmV3UmVmIH1cblxuICAgIHJldHVybiB0aGlzLnJlZi50b1N0cmluZygpXG4gIH1cblxuICBzZW5kSGVhcnRiZWF0KCl7XG4gICAgaWYodGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmICYmICF0aGlzLmlzQ29ubmVjdGVkKCkpeyByZXR1cm4gfVxuICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IHRoaXMubWFrZVJlZigpXG4gICAgdGhpcy5wdXNoKHt0b3BpYzogXCJwaG9lbml4XCIsIGV2ZW50OiBcImhlYXJ0YmVhdFwiLCBwYXlsb2FkOiB7fSwgcmVmOiB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWZ9KVxuICAgIHRoaXMuaGVhcnRiZWF0VGltZW91dFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmhlYXJ0YmVhdFRpbWVvdXQoKSwgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zKVxuICB9XG5cbiAgZmx1c2hTZW5kQnVmZmVyKCl7XG4gICAgaWYodGhpcy5pc0Nvbm5lY3RlZCgpICYmIHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGggPiAwKXtcbiAgICAgIHRoaXMuc2VuZEJ1ZmZlci5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKCkpXG4gICAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXVxuICAgIH1cbiAgfVxuXG4gIG9uQ29ubk1lc3NhZ2UocmF3TWVzc2FnZSl7XG4gICAgdGhpcy5kZWNvZGUocmF3TWVzc2FnZS5kYXRhLCBtc2cgPT4ge1xuICAgICAgbGV0IHt0b3BpYywgZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pbl9yZWZ9ID0gbXNnXG4gICAgICBpZihyZWYgJiYgcmVmID09PSB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYpe1xuICAgICAgICB0aGlzLmNsZWFySGVhcnRiZWF0cygpXG4gICAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGxcbiAgICAgICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZW5kSGVhcnRiZWF0KCksIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcylcbiAgICAgIH1cblxuICAgICAgaWYodGhpcy5oYXNMb2dnZXIoKSkgdGhpcy5sb2coXCJyZWNlaXZlXCIsIGAke3BheWxvYWQuc3RhdHVzIHx8IFwiXCJ9ICR7dG9waWN9ICR7ZXZlbnR9ICR7cmVmICYmIFwiKFwiICsgcmVmICsgXCIpXCIgfHwgXCJcIn1gLCBwYXlsb2FkKVxuXG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGFubmVscy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2ldXG4gICAgICAgIGlmKCFjaGFubmVsLmlzTWVtYmVyKHRvcGljLCBldmVudCwgcGF5bG9hZCwgam9pbl9yZWYpKXsgY29udGludWUgfVxuICAgICAgICBjaGFubmVsLnRyaWdnZXIoZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pbl9yZWYpXG4gICAgICB9XG5cbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm1lc3NhZ2UubGVuZ3RoOyBpKyspe1xuICAgICAgICBsZXQgWywgY2FsbGJhY2tdID0gdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5tZXNzYWdlW2ldXG4gICAgICAgIGNhbGxiYWNrKG1zZylcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgbGVhdmVPcGVuVG9waWModG9waWMpe1xuICAgIGxldCBkdXBDaGFubmVsID0gdGhpcy5jaGFubmVscy5maW5kKGMgPT4gYy50b3BpYyA9PT0gdG9waWMgJiYgKGMuaXNKb2luZWQoKSB8fCBjLmlzSm9pbmluZygpKSlcbiAgICBpZihkdXBDaGFubmVsKXtcbiAgICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIGBsZWF2aW5nIGR1cGxpY2F0ZSB0b3BpYyBcIiR7dG9waWN9XCJgKVxuICAgICAgZHVwQ2hhbm5lbC5sZWF2ZSgpXG4gICAgfVxuICB9XG59XG4iLCAiZXhwb3J0IGNvbnN0IENPTlNFQ1VUSVZFX1JFTE9BRFMgPSBcImNvbnNlY3V0aXZlLXJlbG9hZHNcIlxuZXhwb3J0IGNvbnN0IE1BWF9SRUxPQURTID0gMTBcbmV4cG9ydCBjb25zdCBSRUxPQURfSklUVEVSX01JTiA9IDUwMDBcbmV4cG9ydCBjb25zdCBSRUxPQURfSklUVEVSX01BWCA9IDEwMDAwXG5leHBvcnQgY29uc3QgRkFJTFNBRkVfSklUVEVSID0gMzAwMDBcbmV4cG9ydCBjb25zdCBQSFhfRVZFTlRfQ0xBU1NFUyA9IFtcbiAgXCJwaHgtY2xpY2stbG9hZGluZ1wiLCBcInBoeC1jaGFuZ2UtbG9hZGluZ1wiLCBcInBoeC1zdWJtaXQtbG9hZGluZ1wiLFxuICBcInBoeC1rZXlkb3duLWxvYWRpbmdcIiwgXCJwaHgta2V5dXAtbG9hZGluZ1wiLCBcInBoeC1ibHVyLWxvYWRpbmdcIiwgXCJwaHgtZm9jdXMtbG9hZGluZ1wiLFxuICBcInBoeC1ob29rLWxvYWRpbmdcIlxuXVxuZXhwb3J0IGNvbnN0IFBIWF9DT01QT05FTlQgPSBcImRhdGEtcGh4LWNvbXBvbmVudFwiXG5leHBvcnQgY29uc3QgUEhYX0xJVkVfTElOSyA9IFwiZGF0YS1waHgtbGlua1wiXG5leHBvcnQgY29uc3QgUEhYX1RSQUNLX1NUQVRJQyA9IFwidHJhY2stc3RhdGljXCJcbmV4cG9ydCBjb25zdCBQSFhfTElOS19TVEFURSA9IFwiZGF0YS1waHgtbGluay1zdGF0ZVwiXG5leHBvcnQgY29uc3QgUEhYX1JFRl9MT0FESU5HID0gXCJkYXRhLXBoeC1yZWYtbG9hZGluZ1wiXG5leHBvcnQgY29uc3QgUEhYX1JFRl9TUkMgPSBcImRhdGEtcGh4LXJlZi1zcmNcIlxuZXhwb3J0IGNvbnN0IFBIWF9SRUZfTE9DSyA9IFwiZGF0YS1waHgtcmVmLWxvY2tcIlxuZXhwb3J0IGNvbnN0IFBIWF9UUkFDS19VUExPQURTID0gXCJ0cmFjay11cGxvYWRzXCJcbmV4cG9ydCBjb25zdCBQSFhfVVBMT0FEX1JFRiA9IFwiZGF0YS1waHgtdXBsb2FkLXJlZlwiXG5leHBvcnQgY29uc3QgUEhYX1BSRUZMSUdIVEVEX1JFRlMgPSBcImRhdGEtcGh4LXByZWZsaWdodGVkLXJlZnNcIlxuZXhwb3J0IGNvbnN0IFBIWF9ET05FX1JFRlMgPSBcImRhdGEtcGh4LWRvbmUtcmVmc1wiXG5leHBvcnQgY29uc3QgUEhYX0RST1BfVEFSR0VUID0gXCJkcm9wLXRhcmdldFwiXG5leHBvcnQgY29uc3QgUEhYX0FDVElWRV9FTlRSWV9SRUZTID0gXCJkYXRhLXBoeC1hY3RpdmUtcmVmc1wiXG5leHBvcnQgY29uc3QgUEhYX0xJVkVfRklMRV9VUERBVEVEID0gXCJwaHg6bGl2ZS1maWxlOnVwZGF0ZWRcIlxuZXhwb3J0IGNvbnN0IFBIWF9TS0lQID0gXCJkYXRhLXBoeC1za2lwXCJcbmV4cG9ydCBjb25zdCBQSFhfTUFHSUNfSUQgPSBcImRhdGEtcGh4LWlkXCJcbmV4cG9ydCBjb25zdCBQSFhfUFJVTkUgPSBcImRhdGEtcGh4LXBydW5lXCJcbmV4cG9ydCBjb25zdCBQSFhfQ09OTkVDVEVEX0NMQVNTID0gXCJwaHgtY29ubmVjdGVkXCJcbmV4cG9ydCBjb25zdCBQSFhfTE9BRElOR19DTEFTUyA9IFwicGh4LWxvYWRpbmdcIlxuZXhwb3J0IGNvbnN0IFBIWF9FUlJPUl9DTEFTUyA9IFwicGh4LWVycm9yXCJcbmV4cG9ydCBjb25zdCBQSFhfQ0xJRU5UX0VSUk9SX0NMQVNTID0gXCJwaHgtY2xpZW50LWVycm9yXCJcbmV4cG9ydCBjb25zdCBQSFhfU0VSVkVSX0VSUk9SX0NMQVNTID0gXCJwaHgtc2VydmVyLWVycm9yXCJcbmV4cG9ydCBjb25zdCBQSFhfUEFSRU5UX0lEID0gXCJkYXRhLXBoeC1wYXJlbnQtaWRcIlxuZXhwb3J0IGNvbnN0IFBIWF9NQUlOID0gXCJkYXRhLXBoeC1tYWluXCJcbmV4cG9ydCBjb25zdCBQSFhfUk9PVF9JRCA9IFwiZGF0YS1waHgtcm9vdC1pZFwiXG5leHBvcnQgY29uc3QgUEhYX1ZJRVdQT1JUX1RPUCA9IFwidmlld3BvcnQtdG9wXCJcbmV4cG9ydCBjb25zdCBQSFhfVklFV1BPUlRfQk9UVE9NID0gXCJ2aWV3cG9ydC1ib3R0b21cIlxuZXhwb3J0IGNvbnN0IFBIWF9UUklHR0VSX0FDVElPTiA9IFwidHJpZ2dlci1hY3Rpb25cIlxuZXhwb3J0IGNvbnN0IFBIWF9IQVNfRk9DVVNFRCA9IFwicGh4LWhhcy1mb2N1c2VkXCJcbmV4cG9ydCBjb25zdCBGT0NVU0FCTEVfSU5QVVRTID0gW1widGV4dFwiLCBcInRleHRhcmVhXCIsIFwibnVtYmVyXCIsIFwiZW1haWxcIiwgXCJwYXNzd29yZFwiLCBcInNlYXJjaFwiLCBcInRlbFwiLCBcInVybFwiLCBcImRhdGVcIiwgXCJ0aW1lXCIsIFwiZGF0ZXRpbWUtbG9jYWxcIiwgXCJjb2xvclwiLCBcInJhbmdlXCJdXG5leHBvcnQgY29uc3QgQ0hFQ0tBQkxFX0lOUFVUUyA9IFtcImNoZWNrYm94XCIsIFwicmFkaW9cIl1cbmV4cG9ydCBjb25zdCBQSFhfSEFTX1NVQk1JVFRFRCA9IFwicGh4LWhhcy1zdWJtaXR0ZWRcIlxuZXhwb3J0IGNvbnN0IFBIWF9TRVNTSU9OID0gXCJkYXRhLXBoeC1zZXNzaW9uXCJcbmV4cG9ydCBjb25zdCBQSFhfVklFV19TRUxFQ1RPUiA9IGBbJHtQSFhfU0VTU0lPTn1dYFxuZXhwb3J0IGNvbnN0IFBIWF9TVElDS1kgPSBcImRhdGEtcGh4LXN0aWNreVwiXG5leHBvcnQgY29uc3QgUEhYX1NUQVRJQyA9IFwiZGF0YS1waHgtc3RhdGljXCJcbmV4cG9ydCBjb25zdCBQSFhfUkVBRE9OTFkgPSBcImRhdGEtcGh4LXJlYWRvbmx5XCJcbmV4cG9ydCBjb25zdCBQSFhfRElTQUJMRUQgPSBcImRhdGEtcGh4LWRpc2FibGVkXCJcbmV4cG9ydCBjb25zdCBQSFhfRElTQUJMRV9XSVRIID0gXCJkaXNhYmxlLXdpdGhcIlxuZXhwb3J0IGNvbnN0IFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSA9IFwiZGF0YS1waHgtZGlzYWJsZS13aXRoLXJlc3RvcmVcIlxuZXhwb3J0IGNvbnN0IFBIWF9IT09LID0gXCJob29rXCJcbmV4cG9ydCBjb25zdCBQSFhfREVCT1VOQ0UgPSBcImRlYm91bmNlXCJcbmV4cG9ydCBjb25zdCBQSFhfVEhST1RUTEUgPSBcInRocm90dGxlXCJcbmV4cG9ydCBjb25zdCBQSFhfVVBEQVRFID0gXCJ1cGRhdGVcIlxuZXhwb3J0IGNvbnN0IFBIWF9TVFJFQU0gPSBcInN0cmVhbVwiXG5leHBvcnQgY29uc3QgUEhYX1NUUkVBTV9SRUYgPSBcImRhdGEtcGh4LXN0cmVhbVwiXG5leHBvcnQgY29uc3QgUEhYX0tFWSA9IFwia2V5XCJcbmV4cG9ydCBjb25zdCBQSFhfUFJJVkFURSA9IFwicGh4UHJpdmF0ZVwiXG5leHBvcnQgY29uc3QgUEhYX0FVVE9fUkVDT1ZFUiA9IFwiYXV0by1yZWNvdmVyXCJcbmV4cG9ydCBjb25zdCBQSFhfTFZfREVCVUcgPSBcInBoeDpsaXZlLXNvY2tldDpkZWJ1Z1wiXG5leHBvcnQgY29uc3QgUEhYX0xWX1BST0ZJTEUgPSBcInBoeDpsaXZlLXNvY2tldDpwcm9maWxpbmdcIlxuZXhwb3J0IGNvbnN0IFBIWF9MVl9MQVRFTkNZX1NJTSA9IFwicGh4OmxpdmUtc29ja2V0OmxhdGVuY3ktc2ltXCJcbmV4cG9ydCBjb25zdCBQSFhfTFZfSElTVE9SWV9QT1NJVElPTiA9IFwicGh4Om5hdi1oaXN0b3J5LXBvc2l0aW9uXCJcbmV4cG9ydCBjb25zdCBQSFhfUFJPR1JFU1MgPSBcInByb2dyZXNzXCJcbmV4cG9ydCBjb25zdCBQSFhfTU9VTlRFRCA9IFwibW91bnRlZFwiXG5leHBvcnQgY29uc3QgUEhYX1JFTE9BRF9TVEFUVVMgPSBcIl9fcGhvZW5peF9yZWxvYWRfc3RhdHVzX19cIlxuZXhwb3J0IGNvbnN0IExPQURFUl9USU1FT1VUID0gMVxuZXhwb3J0IGNvbnN0IE1BWF9DSElMRF9KT0lOX0FUVEVNUFRTID0gM1xuZXhwb3J0IGNvbnN0IEJFRk9SRV9VTkxPQURfTE9BREVSX1RJTUVPVVQgPSAyMDBcbmV4cG9ydCBjb25zdCBCSU5ESU5HX1BSRUZJWCA9IFwicGh4LVwiXG5leHBvcnQgY29uc3QgUFVTSF9USU1FT1VUID0gMzAwMDBcbmV4cG9ydCBjb25zdCBMSU5LX0hFQURFUiA9IFwieC1yZXF1ZXN0ZWQtd2l0aFwiXG5leHBvcnQgY29uc3QgUkVTUE9OU0VfVVJMX0hFQURFUiA9IFwieC1yZXNwb25zZS11cmxcIlxuZXhwb3J0IGNvbnN0IERFQk9VTkNFX1RSSUdHRVIgPSBcImRlYm91bmNlLXRyaWdnZXJcIlxuZXhwb3J0IGNvbnN0IFRIUk9UVExFRCA9IFwidGhyb3R0bGVkXCJcbmV4cG9ydCBjb25zdCBERUJPVU5DRV9QUkVWX0tFWSA9IFwiZGVib3VuY2UtcHJldi1rZXlcIlxuZXhwb3J0IGNvbnN0IERFRkFVTFRTID0ge1xuICBkZWJvdW5jZTogMzAwLFxuICB0aHJvdHRsZTogMzAwXG59XG5leHBvcnQgY29uc3QgUEhYX1BFTkRJTkdfQVRUUlMgPSBbUEhYX1JFRl9MT0FESU5HLCBQSFhfUkVGX1NSQywgUEhYX1JFRl9MT0NLXVxuLy8gUmVuZGVyZWRcbmV4cG9ydCBjb25zdCBEWU5BTUlDUyA9IFwiZFwiXG5leHBvcnQgY29uc3QgU1RBVElDID0gXCJzXCJcbmV4cG9ydCBjb25zdCBST09UID0gXCJyXCJcbmV4cG9ydCBjb25zdCBDT01QT05FTlRTID0gXCJjXCJcbmV4cG9ydCBjb25zdCBFVkVOVFMgPSBcImVcIlxuZXhwb3J0IGNvbnN0IFJFUExZID0gXCJyXCJcbmV4cG9ydCBjb25zdCBUSVRMRSA9IFwidFwiXG5leHBvcnQgY29uc3QgVEVNUExBVEVTID0gXCJwXCJcbmV4cG9ydCBjb25zdCBTVFJFQU0gPSBcInN0cmVhbVwiXG4iLCAiaW1wb3J0IHtcbiAgbG9nRXJyb3Jcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbnRyeVVwbG9hZGVyIHtcbiAgY29uc3RydWN0b3IoZW50cnksIGNvbmZpZywgbGl2ZVNvY2tldCl7XG4gICAgbGV0IHtjaHVua19zaXplLCBjaHVua190aW1lb3V0fSA9IGNvbmZpZ1xuICAgIHRoaXMubGl2ZVNvY2tldCA9IGxpdmVTb2NrZXRcbiAgICB0aGlzLmVudHJ5ID0gZW50cnlcbiAgICB0aGlzLm9mZnNldCA9IDBcbiAgICB0aGlzLmNodW5rU2l6ZSA9IGNodW5rX3NpemVcbiAgICB0aGlzLmNodW5rVGltZW91dCA9IGNodW5rX3RpbWVvdXRcbiAgICB0aGlzLmNodW5rVGltZXIgPSBudWxsXG4gICAgdGhpcy5lcnJvcmVkID0gZmFsc2VcbiAgICB0aGlzLnVwbG9hZENoYW5uZWwgPSBsaXZlU29ja2V0LmNoYW5uZWwoYGx2dToke2VudHJ5LnJlZn1gLCB7dG9rZW46IGVudHJ5Lm1ldGFkYXRhKCl9KVxuICB9XG5cbiAgZXJyb3IocmVhc29uKXtcbiAgICBpZih0aGlzLmVycm9yZWQpeyByZXR1cm4gfVxuICAgIHRoaXMudXBsb2FkQ2hhbm5lbC5sZWF2ZSgpXG4gICAgdGhpcy5lcnJvcmVkID0gdHJ1ZVxuICAgIGNsZWFyVGltZW91dCh0aGlzLmNodW5rVGltZXIpXG4gICAgdGhpcy5lbnRyeS5lcnJvcihyZWFzb24pXG4gIH1cblxuICB1cGxvYWQoKXtcbiAgICB0aGlzLnVwbG9hZENoYW5uZWwub25FcnJvcihyZWFzb24gPT4gdGhpcy5lcnJvcihyZWFzb24pKVxuICAgIHRoaXMudXBsb2FkQ2hhbm5lbC5qb2luKClcbiAgICAgIC5yZWNlaXZlKFwib2tcIiwgX2RhdGEgPT4gdGhpcy5yZWFkTmV4dENodW5rKCkpXG4gICAgICAucmVjZWl2ZShcImVycm9yXCIsIHJlYXNvbiA9PiB0aGlzLmVycm9yKHJlYXNvbikpXG4gIH1cblxuICBpc0RvbmUoKXsgcmV0dXJuIHRoaXMub2Zmc2V0ID49IHRoaXMuZW50cnkuZmlsZS5zaXplIH1cblxuICByZWFkTmV4dENodW5rKCl7XG4gICAgbGV0IHJlYWRlciA9IG5ldyB3aW5kb3cuRmlsZVJlYWRlcigpXG4gICAgbGV0IGJsb2IgPSB0aGlzLmVudHJ5LmZpbGUuc2xpY2UodGhpcy5vZmZzZXQsIHRoaXMuY2h1bmtTaXplICsgdGhpcy5vZmZzZXQpXG4gICAgcmVhZGVyLm9ubG9hZCA9IChlKSA9PiB7XG4gICAgICBpZihlLnRhcmdldC5lcnJvciA9PT0gbnVsbCl7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IGUudGFyZ2V0LnJlc3VsdC5ieXRlTGVuZ3RoXG4gICAgICAgIHRoaXMucHVzaENodW5rKGUudGFyZ2V0LnJlc3VsdClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsb2dFcnJvcihcIlJlYWQgZXJyb3I6IFwiICsgZS50YXJnZXQuZXJyb3IpXG4gICAgICB9XG4gICAgfVxuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKVxuICB9XG5cbiAgcHVzaENodW5rKGNodW5rKXtcbiAgICBpZighdGhpcy51cGxvYWRDaGFubmVsLmlzSm9pbmVkKCkpeyByZXR1cm4gfVxuICAgIHRoaXMudXBsb2FkQ2hhbm5lbC5wdXNoKFwiY2h1bmtcIiwgY2h1bmssIHRoaXMuY2h1bmtUaW1lb3V0KVxuICAgICAgLnJlY2VpdmUoXCJva1wiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuZW50cnkucHJvZ3Jlc3MoKHRoaXMub2Zmc2V0IC8gdGhpcy5lbnRyeS5maWxlLnNpemUpICogMTAwKVxuICAgICAgICBpZighdGhpcy5pc0RvbmUoKSl7XG4gICAgICAgICAgdGhpcy5jaHVua1RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnJlYWROZXh0Q2h1bmsoKSwgdGhpcy5saXZlU29ja2V0LmdldExhdGVuY3lTaW0oKSB8fCAwKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLnJlY2VpdmUoXCJlcnJvclwiLCAoe3JlYXNvbn0pID0+IHRoaXMuZXJyb3IocmVhc29uKSlcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIFBIWF9WSUVXX1NFTEVDVE9SXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCBFbnRyeVVwbG9hZGVyIGZyb20gXCIuL2VudHJ5X3VwbG9hZGVyXCJcblxuZXhwb3J0IGxldCBsb2dFcnJvciA9IChtc2csIG9iaikgPT4gY29uc29sZS5lcnJvciAmJiBjb25zb2xlLmVycm9yKG1zZywgb2JqKVxuXG5leHBvcnQgbGV0IGlzQ2lkID0gKGNpZCkgPT4ge1xuICBsZXQgdHlwZSA9IHR5cGVvZihjaWQpXG4gIHJldHVybiB0eXBlID09PSBcIm51bWJlclwiIHx8ICh0eXBlID09PSBcInN0cmluZ1wiICYmIC9eKDB8WzEtOV1cXGQqKSQvLnRlc3QoY2lkKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdER1cGxpY2F0ZUlkcygpe1xuICBsZXQgaWRzID0gbmV3IFNldCgpXG4gIGxldCBlbGVtcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqW2lkXVwiKVxuICBmb3IobGV0IGkgPSAwLCBsZW4gPSBlbGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG4gICAgaWYoaWRzLmhhcyhlbGVtc1tpXS5pZCkpe1xuICAgICAgY29uc29sZS5lcnJvcihgTXVsdGlwbGUgSURzIGRldGVjdGVkOiAke2VsZW1zW2ldLmlkfS4gRW5zdXJlIHVuaXF1ZSBlbGVtZW50IGlkcy5gKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZHMuYWRkKGVsZW1zW2ldLmlkKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0SW52YWxpZFN0cmVhbUluc2VydHMoaW5zZXJ0cyl7XG4gIGNvbnN0IGVycm9ycyA9IG5ldyBTZXQoKVxuICBPYmplY3Qua2V5cyhpbnNlcnRzKS5mb3JFYWNoKChpZCkgPT4ge1xuICAgIGNvbnN0IHN0cmVhbUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpXG4gICAgaWYoc3RyZWFtRWwgJiYgc3RyZWFtRWwucGFyZW50RWxlbWVudCAmJiBzdHJlYW1FbC5wYXJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZShcInBoeC11cGRhdGVcIikgIT09IFwic3RyZWFtXCIpe1xuICAgICAgZXJyb3JzLmFkZChgVGhlIHN0cmVhbSBjb250YWluZXIgd2l0aCBpZCBcIiR7c3RyZWFtRWwucGFyZW50RWxlbWVudC5pZH1cIiBpcyBtaXNzaW5nIHRoZSBwaHgtdXBkYXRlPVwic3RyZWFtXCIgYXR0cmlidXRlLiBFbnN1cmUgaXQgaXMgc2V0IGZvciBzdHJlYW1zIHRvIHdvcmsgcHJvcGVybHkuYClcbiAgICB9XG4gIH0pXG4gIGVycm9ycy5mb3JFYWNoKGVycm9yID0+IGNvbnNvbGUuZXJyb3IoZXJyb3IpKVxufVxuXG5leHBvcnQgbGV0IGRlYnVnID0gKHZpZXcsIGtpbmQsIG1zZywgb2JqKSA9PiB7XG4gIGlmKHZpZXcubGl2ZVNvY2tldC5pc0RlYnVnRW5hYmxlZCgpKXtcbiAgICBjb25zb2xlLmxvZyhgJHt2aWV3LmlkfSAke2tpbmR9OiAke21zZ30gLSBgLCBvYmopXG4gIH1cbn1cblxuLy8gd3JhcHMgdmFsdWUgaW4gY2xvc3VyZSBvciByZXR1cm5zIGNsb3N1cmVcbmV4cG9ydCBsZXQgY2xvc3VyZSA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIiA/IHZhbCA6IGZ1bmN0aW9uICgpeyByZXR1cm4gdmFsIH1cblxuZXhwb3J0IGxldCBjbG9uZSA9IChvYmopID0+IHsgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSkgfVxuXG5leHBvcnQgbGV0IGNsb3Nlc3RQaHhCaW5kaW5nID0gKGVsLCBiaW5kaW5nLCBib3JkZXJFbCkgPT4ge1xuICBkbyB7XG4gICAgaWYoZWwubWF0Y2hlcyhgWyR7YmluZGluZ31dYCkgJiYgIWVsLmRpc2FibGVkKXsgcmV0dXJuIGVsIH1cbiAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQgfHwgZWwucGFyZW50Tm9kZVxuICB9IHdoaWxlKGVsICE9PSBudWxsICYmIGVsLm5vZGVUeXBlID09PSAxICYmICEoKGJvcmRlckVsICYmIGJvcmRlckVsLmlzU2FtZU5vZGUoZWwpKSB8fCBlbC5tYXRjaGVzKFBIWF9WSUVXX1NFTEVDVE9SKSkpXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBsZXQgaXNPYmplY3QgPSAob2JqKSA9PiB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiAhKG9iaiBpbnN0YW5jZW9mIEFycmF5KVxufVxuXG5leHBvcnQgbGV0IGlzRXF1YWxPYmogPSAob2JqMSwgb2JqMikgPT4gSlNPTi5zdHJpbmdpZnkob2JqMSkgPT09IEpTT04uc3RyaW5naWZ5KG9iajIpXG5cbmV4cG9ydCBsZXQgaXNFbXB0eSA9IChvYmopID0+IHtcbiAgZm9yKGxldCB4IGluIG9iail7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiB0cnVlXG59XG5cbmV4cG9ydCBsZXQgbWF5YmUgPSAoZWwsIGNhbGxiYWNrKSA9PiBlbCAmJiBjYWxsYmFjayhlbClcblxuZXhwb3J0IGxldCBjaGFubmVsVXBsb2FkZXIgPSBmdW5jdGlvbiAoZW50cmllcywgb25FcnJvciwgcmVzcCwgbGl2ZVNvY2tldCl7XG4gIGVudHJpZXMuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgbGV0IGVudHJ5VXBsb2FkZXIgPSBuZXcgRW50cnlVcGxvYWRlcihlbnRyeSwgcmVzcC5jb25maWcsIGxpdmVTb2NrZXQpXG4gICAgZW50cnlVcGxvYWRlci51cGxvYWQoKVxuICB9KVxufVxuIiwgImxldCBCcm93c2VyID0ge1xuICBjYW5QdXNoU3RhdGUoKXsgcmV0dXJuICh0eXBlb2YgKGhpc3RvcnkucHVzaFN0YXRlKSAhPT0gXCJ1bmRlZmluZWRcIikgfSxcblxuICBkcm9wTG9jYWwobG9jYWxTdG9yYWdlLCBuYW1lc3BhY2UsIHN1YmtleSl7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMubG9jYWxLZXkobmFtZXNwYWNlLCBzdWJrZXkpKVxuICB9LFxuXG4gIHVwZGF0ZUxvY2FsKGxvY2FsU3RvcmFnZSwgbmFtZXNwYWNlLCBzdWJrZXksIGluaXRpYWwsIGZ1bmMpe1xuICAgIGxldCBjdXJyZW50ID0gdGhpcy5nZXRMb2NhbChsb2NhbFN0b3JhZ2UsIG5hbWVzcGFjZSwgc3Via2V5KVxuICAgIGxldCBrZXkgPSB0aGlzLmxvY2FsS2V5KG5hbWVzcGFjZSwgc3Via2V5KVxuICAgIGxldCBuZXdWYWwgPSBjdXJyZW50ID09PSBudWxsID8gaW5pdGlhbCA6IGZ1bmMoY3VycmVudClcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KG5ld1ZhbCkpXG4gICAgcmV0dXJuIG5ld1ZhbFxuICB9LFxuXG4gIGdldExvY2FsKGxvY2FsU3RvcmFnZSwgbmFtZXNwYWNlLCBzdWJrZXkpe1xuICAgIHJldHVybiBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMubG9jYWxLZXkobmFtZXNwYWNlLCBzdWJrZXkpKSlcbiAgfSxcblxuICB1cGRhdGVDdXJyZW50U3RhdGUoY2FsbGJhY2spe1xuICAgIGlmKCF0aGlzLmNhblB1c2hTdGF0ZSgpKXsgcmV0dXJuIH1cbiAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZShjYWxsYmFjayhoaXN0b3J5LnN0YXRlIHx8IHt9KSwgXCJcIiwgd2luZG93LmxvY2F0aW9uLmhyZWYpXG4gIH0sXG5cbiAgcHVzaFN0YXRlKGtpbmQsIG1ldGEsIHRvKXtcbiAgICBpZih0aGlzLmNhblB1c2hTdGF0ZSgpKXtcbiAgICAgIGlmKHRvICE9PSB3aW5kb3cubG9jYXRpb24uaHJlZil7XG4gICAgICAgIGlmKG1ldGEudHlwZSA9PSBcInJlZGlyZWN0XCIgJiYgbWV0YS5zY3JvbGwpe1xuICAgICAgICAgIC8vIElmIHdlJ3JlIHJlZGlyZWN0aW5nIHN0b3JlIHRoZSBjdXJyZW50IHNjcm9sbFkgZm9yIHRoZSBjdXJyZW50IGhpc3Rvcnkgc3RhdGUuXG4gICAgICAgICAgbGV0IGN1cnJlbnRTdGF0ZSA9IGhpc3Rvcnkuc3RhdGUgfHwge31cbiAgICAgICAgICBjdXJyZW50U3RhdGUuc2Nyb2xsID0gbWV0YS5zY3JvbGxcbiAgICAgICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZShjdXJyZW50U3RhdGUsIFwiXCIsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIG1ldGEuc2Nyb2xsIC8vIE9ubHkgc3RvcmUgdGhlIHNjcm9sbCBpbiB0aGUgcmVkaXJlY3QgY2FzZS5cbiAgICAgICAgaGlzdG9yeVtraW5kICsgXCJTdGF0ZVwiXShtZXRhLCBcIlwiLCB0byB8fCBudWxsKSAvLyBJRSB3aWxsIGNvZXJjZSB1bmRlZmluZWQgdG8gc3RyaW5nXG5cbiAgICAgICAgLy8gd2hlbiB1c2luZyBuYXZpZ2F0ZSwgd2UnZCBjYWxsIHB1c2hTdGF0ZSBpbW1lZGlhdGVseSBiZWZvcmUgcGF0Y2hpbmcgdGhlIERPTSxcbiAgICAgICAgLy8ganVtcGluZyBiYWNrIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2UsIGVmZmVjdGl2ZWx5IGlnbm9yaW5nIHRoZSBzY3JvbGxJbnRvVmlldztcbiAgICAgICAgLy8gdGhlcmVmb3JlIHdlIHdhaXQgZm9yIHRoZSBuZXh0IGZyYW1lIChhZnRlciB0aGUgRE9NIHBhdGNoKSBhbmQgb25seSB0aGVuIHRyeVxuICAgICAgICAvLyB0byBzY3JvbGwgdG8gdGhlIGhhc2hFbFxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBsZXQgaGFzaEVsID0gdGhpcy5nZXRIYXNoVGFyZ2V0RWwod2luZG93LmxvY2F0aW9uLmhhc2gpXG4gIFxuICAgICAgICAgIGlmKGhhc2hFbCl7XG4gICAgICAgICAgICBoYXNoRWwuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgICAgIH0gZWxzZSBpZihtZXRhLnR5cGUgPT09IFwicmVkaXJlY3RcIil7XG4gICAgICAgICAgICB3aW5kb3cuc2Nyb2xsKDAsIDApXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlZGlyZWN0KHRvKVxuICAgIH1cbiAgfSxcblxuICBzZXRDb29raWUobmFtZSwgdmFsdWUsIG1heEFnZVNlY29uZHMpe1xuICAgIGxldCBleHBpcmVzID0gdHlwZW9mKG1heEFnZVNlY29uZHMpID09PSBcIm51bWJlclwiID8gYCBtYXgtYWdlPSR7bWF4QWdlU2Vjb25kc307YCA6IFwiXCJcbiAgICBkb2N1bWVudC5jb29raWUgPSBgJHtuYW1lfT0ke3ZhbHVlfTske2V4cGlyZXN9IHBhdGg9L2BcbiAgfSxcblxuICBnZXRDb29raWUobmFtZSl7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNvb2tpZS5yZXBsYWNlKG5ldyBSZWdFeHAoYCg/Oig/Ol58Lio7XFxzKikke25hbWV9XFxzKlxcPVxccyooW147XSopLiokKXxeLiokYCksIFwiJDFcIilcbiAgfSxcblxuICBkZWxldGVDb29raWUobmFtZSl7XG4gICAgZG9jdW1lbnQuY29va2llID0gYCR7bmFtZX09OyBtYXgtYWdlPS0xOyBwYXRoPS9gXG4gIH0sXG5cbiAgcmVkaXJlY3QodG9VUkwsIGZsYXNoKXtcbiAgICBpZihmbGFzaCl7IHRoaXMuc2V0Q29va2llKFwiX19waG9lbml4X2ZsYXNoX19cIiwgZmxhc2gsIDYwKSB9XG4gICAgd2luZG93LmxvY2F0aW9uID0gdG9VUkxcbiAgfSxcblxuICBsb2NhbEtleShuYW1lc3BhY2UsIHN1YmtleSl7IHJldHVybiBgJHtuYW1lc3BhY2V9LSR7c3Via2V5fWAgfSxcblxuICBnZXRIYXNoVGFyZ2V0RWwobWF5YmVIYXNoKXtcbiAgICBsZXQgaGFzaCA9IG1heWJlSGFzaC50b1N0cmluZygpLnN1YnN0cmluZygxKVxuICAgIGlmKGhhc2ggPT09IFwiXCIpeyByZXR1cm4gfVxuICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChoYXNoKSB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBhW25hbWU9XCIke2hhc2h9XCJdYClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCcm93c2VyXG4iLCAiaW1wb3J0IHtcbiAgQ0hFQ0tBQkxFX0lOUFVUUyxcbiAgREVCT1VOQ0VfUFJFVl9LRVksXG4gIERFQk9VTkNFX1RSSUdHRVIsXG4gIEZPQ1VTQUJMRV9JTlBVVFMsXG4gIFBIWF9DT01QT05FTlQsXG4gIFBIWF9IQVNfRk9DVVNFRCxcbiAgUEhYX0hBU19TVUJNSVRURUQsXG4gIFBIWF9NQUlOLFxuICBQSFhfUEFSRU5UX0lELFxuICBQSFhfUFJJVkFURSxcbiAgUEhYX1JFRl9TUkMsXG4gIFBIWF9SRUZfTE9DSyxcbiAgUEhYX1BFTkRJTkdfQVRUUlMsXG4gIFBIWF9ST09UX0lELFxuICBQSFhfU0VTU0lPTixcbiAgUEhYX1NUQVRJQyxcbiAgUEhYX1VQTE9BRF9SRUYsXG4gIFBIWF9WSUVXX1NFTEVDVE9SLFxuICBQSFhfU1RJQ0tZLFxuICBQSFhfRVZFTlRfQ0xBU1NFUyxcbiAgVEhST1RUTEVELFxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xuICBsb2dFcnJvclxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmxldCBET00gPSB7XG4gIGJ5SWQoaWQpeyByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIHx8IGxvZ0Vycm9yKGBubyBpZCBmb3VuZCBmb3IgJHtpZH1gKSB9LFxuXG4gIHJlbW92ZUNsYXNzKGVsLCBjbGFzc05hbWUpe1xuICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKVxuICAgIGlmKGVsLmNsYXNzTGlzdC5sZW5ndGggPT09IDApeyBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKSB9XG4gIH0sXG5cbiAgYWxsKG5vZGUsIHF1ZXJ5LCBjYWxsYmFjayl7XG4gICAgaWYoIW5vZGUpeyByZXR1cm4gW10gfVxuICAgIGxldCBhcnJheSA9IEFycmF5LmZyb20obm9kZS5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KSlcbiAgICByZXR1cm4gY2FsbGJhY2sgPyBhcnJheS5mb3JFYWNoKGNhbGxiYWNrKSA6IGFycmF5XG4gIH0sXG5cbiAgY2hpbGROb2RlTGVuZ3RoKGh0bWwpe1xuICAgIGxldCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKVxuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWxcbiAgICByZXR1cm4gdGVtcGxhdGUuY29udGVudC5jaGlsZEVsZW1lbnRDb3VudFxuICB9LFxuXG4gIGlzVXBsb2FkSW5wdXQoZWwpeyByZXR1cm4gZWwudHlwZSA9PT0gXCJmaWxlXCIgJiYgZWwuZ2V0QXR0cmlidXRlKFBIWF9VUExPQURfUkVGKSAhPT0gbnVsbCB9LFxuXG4gIGlzQXV0b1VwbG9hZChpbnB1dEVsKXsgcmV0dXJuIGlucHV0RWwuaGFzQXR0cmlidXRlKFwiZGF0YS1waHgtYXV0by11cGxvYWRcIikgfSxcblxuICBmaW5kVXBsb2FkSW5wdXRzKG5vZGUpe1xuICAgIGNvbnN0IGZvcm1JZCA9IG5vZGUuaWRcbiAgICBjb25zdCBpbnB1dHNPdXRzaWRlRm9ybSA9IHRoaXMuYWxsKGRvY3VtZW50LCBgaW5wdXRbdHlwZT1cImZpbGVcIl1bJHtQSFhfVVBMT0FEX1JFRn1dW2Zvcm09XCIke2Zvcm1JZH1cIl1gKVxuICAgIHJldHVybiB0aGlzLmFsbChub2RlLCBgaW5wdXRbdHlwZT1cImZpbGVcIl1bJHtQSFhfVVBMT0FEX1JFRn1dYCkuY29uY2F0KGlucHV0c091dHNpZGVGb3JtKVxuICB9LFxuXG4gIGZpbmRDb21wb25lbnROb2RlTGlzdChub2RlLCBjaWQpe1xuICAgIHJldHVybiB0aGlzLmZpbHRlcldpdGhpblNhbWVMaXZlVmlldyh0aGlzLmFsbChub2RlLCBgWyR7UEhYX0NPTVBPTkVOVH09XCIke2NpZH1cIl1gKSwgbm9kZSlcbiAgfSxcblxuICBpc1BoeERlc3Ryb3llZChub2RlKXtcbiAgICByZXR1cm4gbm9kZS5pZCAmJiBET00ucHJpdmF0ZShub2RlLCBcImRlc3Ryb3llZFwiKSA/IHRydWUgOiBmYWxzZVxuICB9LFxuXG4gIHdhbnRzTmV3VGFiKGUpe1xuICAgIGxldCB3YW50c05ld1RhYiA9IGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5IHx8IGUubWV0YUtleSB8fCAoZS5idXR0b24gJiYgZS5idXR0b24gPT09IDEpXG4gICAgbGV0IGlzRG93bmxvYWQgPSAoZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MQW5jaG9yRWxlbWVudCAmJiBlLnRhcmdldC5oYXNBdHRyaWJ1dGUoXCJkb3dubG9hZFwiKSlcbiAgICBsZXQgaXNUYXJnZXRCbGFuayA9IGUudGFyZ2V0Lmhhc0F0dHJpYnV0ZShcInRhcmdldFwiKSAmJiBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIikudG9Mb3dlckNhc2UoKSA9PT0gXCJfYmxhbmtcIlxuICAgIGxldCBpc1RhcmdldE5hbWVkVGFiID0gZS50YXJnZXQuaGFzQXR0cmlidXRlKFwidGFyZ2V0XCIpICYmICFlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIikuc3RhcnRzV2l0aChcIl9cIilcbiAgICByZXR1cm4gd2FudHNOZXdUYWIgfHwgaXNUYXJnZXRCbGFuayB8fCBpc0Rvd25sb2FkIHx8IGlzVGFyZ2V0TmFtZWRUYWJcbiAgfSxcblxuICBpc1VubG9hZGFibGVGb3JtU3VibWl0KGUpe1xuICAgIC8vIElnbm9yZSBmb3JtIHN1Ym1pc3Npb25zIGludGVuZGVkIHRvIGNsb3NlIGEgbmF0aXZlIDxkaWFsb2c+IGVsZW1lbnRcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvZGlhbG9nI3VzYWdlX25vdGVzXG4gICAgbGV0IGlzRGlhbG9nU3VibWl0ID0gKGUudGFyZ2V0ICYmIGUudGFyZ2V0LmdldEF0dHJpYnV0ZShcIm1ldGhvZFwiKSA9PT0gXCJkaWFsb2dcIikgfHxcbiAgICAgIChlLnN1Ym1pdHRlciAmJiBlLnN1Ym1pdHRlci5nZXRBdHRyaWJ1dGUoXCJmb3JtbWV0aG9kXCIpID09PSBcImRpYWxvZ1wiKVxuXG4gICAgaWYoaXNEaWFsb2dTdWJtaXQpe1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAhZS5kZWZhdWx0UHJldmVudGVkICYmICF0aGlzLndhbnRzTmV3VGFiKGUpXG4gICAgfVxuICB9LFxuXG4gIGlzTmV3UGFnZUNsaWNrKGUsIGN1cnJlbnRMb2NhdGlvbil7XG4gICAgbGV0IGhyZWYgPSBlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxBbmNob3JFbGVtZW50ID8gZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA6IG51bGxcbiAgICBsZXQgdXJsXG5cbiAgICBpZihlLmRlZmF1bHRQcmV2ZW50ZWQgfHwgaHJlZiA9PT0gbnVsbCB8fCB0aGlzLndhbnRzTmV3VGFiKGUpKXsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZihocmVmLnN0YXJ0c1dpdGgoXCJtYWlsdG86XCIpIHx8IGhyZWYuc3RhcnRzV2l0aChcInRlbDpcIikpeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmKGUudGFyZ2V0LmlzQ29udGVudEVkaXRhYmxlKXsgcmV0dXJuIGZhbHNlIH1cblxuICAgIHRyeSB7XG4gICAgICB1cmwgPSBuZXcgVVJMKGhyZWYpXG4gICAgfSBjYXRjaCB7XG4gICAgICB0cnkge1xuICAgICAgICB1cmwgPSBuZXcgVVJMKGhyZWYsIGN1cnJlbnRMb2NhdGlvbilcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBiYWQgVVJMLCBmYWxsYmFjayB0byBsZXQgYnJvd3NlciB0cnkgaXQgYXMgZXh0ZXJuYWxcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZih1cmwuaG9zdCA9PT0gY3VycmVudExvY2F0aW9uLmhvc3QgJiYgdXJsLnByb3RvY29sID09PSBjdXJyZW50TG9jYXRpb24ucHJvdG9jb2wpe1xuICAgICAgaWYodXJsLnBhdGhuYW1lID09PSBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWUgJiYgdXJsLnNlYXJjaCA9PT0gY3VycmVudExvY2F0aW9uLnNlYXJjaCl7XG4gICAgICAgIHJldHVybiB1cmwuaGFzaCA9PT0gXCJcIiAmJiAhdXJsLmhyZWYuZW5kc1dpdGgoXCIjXCIpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1cmwucHJvdG9jb2wuc3RhcnRzV2l0aChcImh0dHBcIilcbiAgfSxcblxuICBtYXJrUGh4Q2hpbGREZXN0cm95ZWQoZWwpe1xuICAgIGlmKHRoaXMuaXNQaHhDaGlsZChlbCkpeyBlbC5zZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04sIFwiXCIpIH1cbiAgICB0aGlzLnB1dFByaXZhdGUoZWwsIFwiZGVzdHJveWVkXCIsIHRydWUpXG4gIH0sXG5cbiAgZmluZFBoeENoaWxkcmVuSW5GcmFnbWVudChodG1sLCBwYXJlbnRJZCl7XG4gICAgbGV0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpXG4gICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbFxuICAgIHJldHVybiB0aGlzLmZpbmRQaHhDaGlsZHJlbih0ZW1wbGF0ZS5jb250ZW50LCBwYXJlbnRJZClcbiAgfSxcblxuICBpc0lnbm9yZWQoZWwsIHBoeFVwZGF0ZSl7XG4gICAgcmV0dXJuIChlbC5nZXRBdHRyaWJ1dGUocGh4VXBkYXRlKSB8fCBlbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC11cGRhdGVcIikpID09PSBcImlnbm9yZVwiXG4gIH0sXG5cbiAgaXNQaHhVcGRhdGUoZWwsIHBoeFVwZGF0ZSwgdXBkYXRlVHlwZXMpe1xuICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUgJiYgdXBkYXRlVHlwZXMuaW5kZXhPZihlbC5nZXRBdHRyaWJ1dGUocGh4VXBkYXRlKSkgPj0gMFxuICB9LFxuXG4gIGZpbmRQaHhTdGlja3koZWwpeyByZXR1cm4gdGhpcy5hbGwoZWwsIGBbJHtQSFhfU1RJQ0tZfV1gKSB9LFxuXG4gIGZpbmRQaHhDaGlsZHJlbihlbCwgcGFyZW50SWQpe1xuICAgIHJldHVybiB0aGlzLmFsbChlbCwgYCR7UEhYX1ZJRVdfU0VMRUNUT1J9WyR7UEhYX1BBUkVOVF9JRH09XCIke3BhcmVudElkfVwiXWApXG4gIH0sXG5cbiAgZmluZEV4aXN0aW5nUGFyZW50Q0lEcyhub2RlLCBjaWRzKXtcbiAgICAvLyB3ZSBvbmx5IHdhbnQgdG8gZmluZCBwYXJlbnRzIHRoYXQgZXhpc3Qgb24gdGhlIHBhZ2VcbiAgICAvLyBpZiBhIGNpZCBpcyBub3Qgb24gdGhlIHBhZ2UsIHRoZSBvbmx5IHdheSBpdCBjYW4gYmUgYWRkZWQgYmFjayB0byB0aGUgcGFnZVxuICAgIC8vIGlzIGlmIGEgcGFyZW50IGFkZHMgaXQgYmFjaywgdGhlcmVmb3JlIGlmIGEgY2lkIGRvZXMgbm90IGV4aXN0IG9uIHRoZSBwYWdlLFxuICAgIC8vIHdlIHNob3VsZCBub3QgdHJ5IHRvIHJlbmRlciBpdCBieSBpdHNlbGYgKGJlY2F1c2UgaXQgd291bGQgYmUgcmVuZGVyZWQgdHdpY2UsXG4gICAgLy8gb25lIGJ5IHRoZSBwYXJlbnQsIGFuZCBhIHNlY29uZCB0aW1lIGJ5IGl0c2VsZilcbiAgICBsZXQgcGFyZW50Q2lkcyA9IG5ldyBTZXQoKVxuICAgIGxldCBjaGlsZHJlbkNpZHMgPSBuZXcgU2V0KClcblxuICAgIGNpZHMuZm9yRWFjaChjaWQgPT4ge1xuICAgICAgdGhpcy5maWx0ZXJXaXRoaW5TYW1lTGl2ZVZpZXcodGhpcy5hbGwobm9kZSwgYFske1BIWF9DT01QT05FTlR9PVwiJHtjaWR9XCJdYCksIG5vZGUpLmZvckVhY2gocGFyZW50ID0+IHtcbiAgICAgICAgcGFyZW50Q2lkcy5hZGQoY2lkKVxuICAgICAgICB0aGlzLmZpbHRlcldpdGhpblNhbWVMaXZlVmlldyh0aGlzLmFsbChwYXJlbnQsIGBbJHtQSFhfQ09NUE9ORU5UfV1gKSwgcGFyZW50KVxuICAgICAgICAgIC5tYXAoZWwgPT4gcGFyc2VJbnQoZWwuZ2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQpKSlcbiAgICAgICAgICAuZm9yRWFjaChjaGlsZENJRCA9PiBjaGlsZHJlbkNpZHMuYWRkKGNoaWxkQ0lEKSlcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGNoaWxkcmVuQ2lkcy5mb3JFYWNoKGNoaWxkQ2lkID0+IHBhcmVudENpZHMuZGVsZXRlKGNoaWxkQ2lkKSlcblxuICAgIHJldHVybiBwYXJlbnRDaWRzXG4gIH0sXG5cbiAgZmlsdGVyV2l0aGluU2FtZUxpdmVWaWV3KG5vZGVzLCBwYXJlbnQpe1xuICAgIGlmKHBhcmVudC5xdWVyeVNlbGVjdG9yKFBIWF9WSUVXX1NFTEVDVE9SKSl7XG4gICAgICByZXR1cm4gbm9kZXMuZmlsdGVyKGVsID0+IHRoaXMud2l0aGluU2FtZUxpdmVWaWV3KGVsLCBwYXJlbnQpKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZXNcbiAgICB9XG4gIH0sXG5cbiAgd2l0aGluU2FtZUxpdmVWaWV3KG5vZGUsIHBhcmVudCl7XG4gICAgd2hpbGUobm9kZSA9IG5vZGUucGFyZW50Tm9kZSl7XG4gICAgICBpZihub2RlLmlzU2FtZU5vZGUocGFyZW50KSl7IHJldHVybiB0cnVlIH1cbiAgICAgIGlmKG5vZGUuZ2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OKSAhPT0gbnVsbCl7IHJldHVybiBmYWxzZSB9XG4gICAgfVxuICB9LFxuXG4gIHByaXZhdGUoZWwsIGtleSl7IHJldHVybiBlbFtQSFhfUFJJVkFURV0gJiYgZWxbUEhYX1BSSVZBVEVdW2tleV0gfSxcblxuICBkZWxldGVQcml2YXRlKGVsLCBrZXkpeyBlbFtQSFhfUFJJVkFURV0gJiYgZGVsZXRlIChlbFtQSFhfUFJJVkFURV1ba2V5XSkgfSxcblxuICBwdXRQcml2YXRlKGVsLCBrZXksIHZhbHVlKXtcbiAgICBpZighZWxbUEhYX1BSSVZBVEVdKXsgZWxbUEhYX1BSSVZBVEVdID0ge30gfVxuICAgIGVsW1BIWF9QUklWQVRFXVtrZXldID0gdmFsdWVcbiAgfSxcblxuICB1cGRhdGVQcml2YXRlKGVsLCBrZXksIGRlZmF1bHRWYWwsIHVwZGF0ZUZ1bmMpe1xuICAgIGxldCBleGlzdGluZyA9IHRoaXMucHJpdmF0ZShlbCwga2V5KVxuICAgIGlmKGV4aXN0aW5nID09PSB1bmRlZmluZWQpe1xuICAgICAgdGhpcy5wdXRQcml2YXRlKGVsLCBrZXksIHVwZGF0ZUZ1bmMoZGVmYXVsdFZhbCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHV0UHJpdmF0ZShlbCwga2V5LCB1cGRhdGVGdW5jKGV4aXN0aW5nKSlcbiAgICB9XG4gIH0sXG5cbiAgc3luY1BlbmRpbmdBdHRycyhmcm9tRWwsIHRvRWwpe1xuICAgIGlmKCFmcm9tRWwuaGFzQXR0cmlidXRlKFBIWF9SRUZfU1JDKSl7IHJldHVybiB9XG4gICAgUEhYX0VWRU5UX0NMQVNTRVMuZm9yRWFjaChjbGFzc05hbWUgPT4ge1xuICAgICAgZnJvbUVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpICYmIHRvRWwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpXG4gICAgfSlcbiAgICBQSFhfUEVORElOR19BVFRSUy5maWx0ZXIoYXR0ciA9PiBmcm9tRWwuaGFzQXR0cmlidXRlKGF0dHIpKS5mb3JFYWNoKGF0dHIgPT4ge1xuICAgICAgdG9FbC5zZXRBdHRyaWJ1dGUoYXR0ciwgZnJvbUVsLmdldEF0dHJpYnV0ZShhdHRyKSlcbiAgICB9KVxuICB9LFxuXG4gIGNvcHlQcml2YXRlcyh0YXJnZXQsIHNvdXJjZSl7XG4gICAgaWYoc291cmNlW1BIWF9QUklWQVRFXSl7XG4gICAgICB0YXJnZXRbUEhYX1BSSVZBVEVdID0gc291cmNlW1BIWF9QUklWQVRFXVxuICAgIH1cbiAgfSxcblxuICBwdXRUaXRsZShzdHIpe1xuICAgIGxldCB0aXRsZUVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcInRpdGxlXCIpXG4gICAgaWYodGl0bGVFbCl7XG4gICAgICBsZXQge3ByZWZpeCwgc3VmZml4LCBkZWZhdWx0OiBkZWZhdWx0VGl0bGV9ID0gdGl0bGVFbC5kYXRhc2V0XG4gICAgICBsZXQgaXNFbXB0eSA9IHR5cGVvZihzdHIpICE9PSBcInN0cmluZ1wiIHx8IHN0ci50cmltKCkgPT09IFwiXCJcbiAgICAgIGlmKGlzRW1wdHkgJiYgdHlwZW9mKGRlZmF1bHRUaXRsZSkgIT09IFwic3RyaW5nXCIpeyByZXR1cm4gfVxuXG4gICAgICBsZXQgaW5uZXIgPSBpc0VtcHR5ID8gZGVmYXVsdFRpdGxlIDogc3RyXG4gICAgICBkb2N1bWVudC50aXRsZSA9IGAke3ByZWZpeCB8fCBcIlwifSR7aW5uZXIgfHwgXCJcIn0ke3N1ZmZpeCB8fCBcIlwifWBcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQudGl0bGUgPSBzdHJcbiAgICB9XG4gIH0sXG5cbiAgZGVib3VuY2UoZWwsIGV2ZW50LCBwaHhEZWJvdW5jZSwgZGVmYXVsdERlYm91bmNlLCBwaHhUaHJvdHRsZSwgZGVmYXVsdFRocm90dGxlLCBhc3luY0ZpbHRlciwgY2FsbGJhY2spe1xuICAgIGxldCBkZWJvdW5jZSA9IGVsLmdldEF0dHJpYnV0ZShwaHhEZWJvdW5jZSlcbiAgICBsZXQgdGhyb3R0bGUgPSBlbC5nZXRBdHRyaWJ1dGUocGh4VGhyb3R0bGUpXG5cbiAgICBpZihkZWJvdW5jZSA9PT0gXCJcIil7IGRlYm91bmNlID0gZGVmYXVsdERlYm91bmNlIH1cbiAgICBpZih0aHJvdHRsZSA9PT0gXCJcIil7IHRocm90dGxlID0gZGVmYXVsdFRocm90dGxlIH1cbiAgICBsZXQgdmFsdWUgPSBkZWJvdW5jZSB8fCB0aHJvdHRsZVxuICAgIHN3aXRjaCh2YWx1ZSl7XG4gICAgICBjYXNlIG51bGw6IHJldHVybiBjYWxsYmFjaygpXG5cbiAgICAgIGNhc2UgXCJibHVyXCI6XG4gICAgICAgIGlmKHRoaXMub25jZShlbCwgXCJkZWJvdW5jZS1ibHVyXCIpKXtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCAoKSA9PiB7XG4gICAgICAgICAgICBpZihhc3luY0ZpbHRlcigpKXsgY2FsbGJhY2soKSB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGV0IHRpbWVvdXQgPSBwYXJzZUludCh2YWx1ZSlcbiAgICAgICAgbGV0IHRyaWdnZXIgPSAoKSA9PiB0aHJvdHRsZSA/IHRoaXMuZGVsZXRlUHJpdmF0ZShlbCwgVEhST1RUTEVEKSA6IGNhbGxiYWNrKClcbiAgICAgICAgbGV0IGN1cnJlbnRDeWNsZSA9IHRoaXMuaW5jQ3ljbGUoZWwsIERFQk9VTkNFX1RSSUdHRVIsIHRyaWdnZXIpXG4gICAgICAgIGlmKGlzTmFOKHRpbWVvdXQpKXsgcmV0dXJuIGxvZ0Vycm9yKGBpbnZhbGlkIHRocm90dGxlL2RlYm91bmNlIHZhbHVlOiAke3ZhbHVlfWApIH1cbiAgICAgICAgaWYodGhyb3R0bGUpe1xuICAgICAgICAgIGxldCBuZXdLZXlEb3duID0gZmFsc2VcbiAgICAgICAgICBpZihldmVudC50eXBlID09PSBcImtleWRvd25cIil7XG4gICAgICAgICAgICBsZXQgcHJldktleSA9IHRoaXMucHJpdmF0ZShlbCwgREVCT1VOQ0VfUFJFVl9LRVkpXG4gICAgICAgICAgICB0aGlzLnB1dFByaXZhdGUoZWwsIERFQk9VTkNFX1BSRVZfS0VZLCBldmVudC5rZXkpXG4gICAgICAgICAgICBuZXdLZXlEb3duID0gcHJldktleSAhPT0gZXZlbnQua2V5XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIW5ld0tleURvd24gJiYgdGhpcy5wcml2YXRlKGVsLCBUSFJPVFRMRUQpKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgICAgICBjb25zdCB0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGlmKGFzeW5jRmlsdGVyKCkpeyB0aGlzLnRyaWdnZXJDeWNsZShlbCwgREVCT1VOQ0VfVFJJR0dFUikgfVxuICAgICAgICAgICAgfSwgdGltZW91dClcbiAgICAgICAgICAgIHRoaXMucHV0UHJpdmF0ZShlbCwgVEhST1RUTEVELCB0KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmKGFzeW5jRmlsdGVyKCkpeyB0aGlzLnRyaWdnZXJDeWNsZShlbCwgREVCT1VOQ0VfVFJJR0dFUiwgY3VycmVudEN5Y2xlKSB9XG4gICAgICAgICAgfSwgdGltZW91dClcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmb3JtID0gZWwuZm9ybVxuICAgICAgICBpZihmb3JtICYmIHRoaXMub25jZShmb3JtLCBcImJpbmQtZGVib3VuY2VcIikpe1xuICAgICAgICAgIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLCAoKSA9PiB7XG4gICAgICAgICAgICBBcnJheS5mcm9tKChuZXcgRm9ybURhdGEoZm9ybSkpLmVudHJpZXMoKSwgKFtuYW1lXSkgPT4ge1xuICAgICAgICAgICAgICBsZXQgaW5wdXQgPSBmb3JtLnF1ZXJ5U2VsZWN0b3IoYFtuYW1lPVwiJHtuYW1lfVwiXWApXG4gICAgICAgICAgICAgIHRoaXMuaW5jQ3ljbGUoaW5wdXQsIERFQk9VTkNFX1RSSUdHRVIpXG4gICAgICAgICAgICAgIHRoaXMuZGVsZXRlUHJpdmF0ZShpbnB1dCwgVEhST1RUTEVEKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMub25jZShlbCwgXCJiaW5kLWRlYm91bmNlXCIpKXtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBiZWNhdXNlIHdlIHRyaWdnZXIgdGhlIGNhbGxiYWNrIGhlcmUsXG4gICAgICAgICAgICAvLyB3ZSBhbHNvIGNsZWFyIHRoZSB0aHJvdHRsZSB0aW1lb3V0IHRvIHByZXZlbnQgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAvLyBmcm9tIGJlaW5nIGNhbGxlZCBhZ2FpbiBhZnRlciB0aGUgdGltZW91dCBmaXJlc1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucHJpdmF0ZShlbCwgVEhST1RUTEVEKSlcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckN5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdHJpZ2dlckN5Y2xlKGVsLCBrZXksIGN1cnJlbnRDeWNsZSl7XG4gICAgbGV0IFtjeWNsZSwgdHJpZ2dlcl0gPSB0aGlzLnByaXZhdGUoZWwsIGtleSlcbiAgICBpZighY3VycmVudEN5Y2xlKXsgY3VycmVudEN5Y2xlID0gY3ljbGUgfVxuICAgIGlmKGN1cnJlbnRDeWNsZSA9PT0gY3ljbGUpe1xuICAgICAgdGhpcy5pbmNDeWNsZShlbCwga2V5KVxuICAgICAgdHJpZ2dlcigpXG4gICAgfVxuICB9LFxuXG4gIG9uY2UoZWwsIGtleSl7XG4gICAgaWYodGhpcy5wcml2YXRlKGVsLCBrZXkpID09PSB0cnVlKXsgcmV0dXJuIGZhbHNlIH1cbiAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgdHJ1ZSlcbiAgICByZXR1cm4gdHJ1ZVxuICB9LFxuXG4gIGluY0N5Y2xlKGVsLCBrZXksIHRyaWdnZXIgPSBmdW5jdGlvbiAoKXsgfSl7XG4gICAgbGV0IFtjdXJyZW50Q3ljbGVdID0gdGhpcy5wcml2YXRlKGVsLCBrZXkpIHx8IFswLCB0cmlnZ2VyXVxuICAgIGN1cnJlbnRDeWNsZSsrXG4gICAgdGhpcy5wdXRQcml2YXRlKGVsLCBrZXksIFtjdXJyZW50Q3ljbGUsIHRyaWdnZXJdKVxuICAgIHJldHVybiBjdXJyZW50Q3ljbGVcbiAgfSxcblxuICAvLyBtYWludGFpbnMgb3IgYWRkcyBwcml2YXRlbHkgdXNlZCBob29rIGluZm9ybWF0aW9uXG4gIC8vIGZyb21FbCBhbmQgdG9FbCBjYW4gYmUgdGhlIHNhbWUgZWxlbWVudCBpbiB0aGUgY2FzZSBvZiBhIG5ld2x5IGFkZGVkIG5vZGVcbiAgLy8gZnJvbUVsIGFuZCB0b0VsIGNhbiBiZSBhbnkgSFRNTCBub2RlIHR5cGUsIHNvIHdlIG5lZWQgdG8gY2hlY2sgaWYgaXQncyBhbiBlbGVtZW50IG5vZGVcbiAgbWFpbnRhaW5Qcml2YXRlSG9va3MoZnJvbUVsLCB0b0VsLCBwaHhWaWV3cG9ydFRvcCwgcGh4Vmlld3BvcnRCb3R0b20pe1xuICAgIC8vIG1haW50YWluIHRoZSBob29rcyBjcmVhdGVkIHdpdGggY3JlYXRlSG9va1xuICAgIGlmKGZyb21FbC5oYXNBdHRyaWJ1dGUgJiYgZnJvbUVsLmhhc0F0dHJpYnV0ZShcImRhdGEtcGh4LWhvb2tcIikgJiYgIXRvRWwuaGFzQXR0cmlidXRlKFwiZGF0YS1waHgtaG9va1wiKSl7XG4gICAgICB0b0VsLnNldEF0dHJpYnV0ZShcImRhdGEtcGh4LWhvb2tcIiwgZnJvbUVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LWhvb2tcIikpXG4gICAgfVxuICAgIC8vIGFkZCBob29rcyB0byBlbGVtZW50cyB3aXRoIHZpZXdwb3J0IGF0dHJpYnV0ZXNcbiAgICBpZih0b0VsLmhhc0F0dHJpYnV0ZSAmJiAodG9FbC5oYXNBdHRyaWJ1dGUocGh4Vmlld3BvcnRUb3ApIHx8IHRvRWwuaGFzQXR0cmlidXRlKHBoeFZpZXdwb3J0Qm90dG9tKSkpe1xuICAgICAgdG9FbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1ob29rXCIsIFwiUGhvZW5peC5JbmZpbml0ZVNjcm9sbFwiKVxuICAgIH1cbiAgfSxcblxuICBwdXRDdXN0b21FbEhvb2soZWwsIGhvb2spe1xuICAgIGlmKGVsLmlzQ29ubmVjdGVkKXtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShcImRhdGEtcGh4LWhvb2tcIiwgXCJcIilcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihgXG4gICAgICAgIGhvb2sgYXR0YWNoZWQgdG8gbm9uLWNvbm5lY3RlZCBET00gZWxlbWVudFxuICAgICAgICBlbnN1cmUgeW91IGFyZSBjYWxsaW5nIGNyZWF0ZUhvb2sgd2l0aGluIHlvdXIgY29ubmVjdGVkQ2FsbGJhY2suICR7ZWwub3V0ZXJIVE1MfVxuICAgICAgYClcbiAgICB9XG4gICAgdGhpcy5wdXRQcml2YXRlKGVsLCBcImN1c3RvbS1lbC1ob29rXCIsIGhvb2spXG4gIH0sXG5cbiAgZ2V0Q3VzdG9tRWxIb29rKGVsKXsgcmV0dXJuIHRoaXMucHJpdmF0ZShlbCwgXCJjdXN0b20tZWwtaG9va1wiKSB9LFxuXG4gIGlzVXNlZElucHV0KGVsKXtcbiAgICByZXR1cm4gKGVsLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJlxuICAgICAgKHRoaXMucHJpdmF0ZShlbCwgUEhYX0hBU19GT0NVU0VEKSB8fCB0aGlzLnByaXZhdGUoZWwsIFBIWF9IQVNfU1VCTUlUVEVEKSkpXG4gIH0sXG5cbiAgcmVzZXRGb3JtKGZvcm0pe1xuICAgIEFycmF5LmZyb20oZm9ybS5lbGVtZW50cykuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICB0aGlzLmRlbGV0ZVByaXZhdGUoaW5wdXQsIFBIWF9IQVNfRk9DVVNFRClcbiAgICAgIHRoaXMuZGVsZXRlUHJpdmF0ZShpbnB1dCwgUEhYX0hBU19TVUJNSVRURUQpXG4gICAgfSlcbiAgfSxcblxuICBpc1BoeENoaWxkKG5vZGUpe1xuICAgIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZShQSFhfUEFSRU5UX0lEKVxuICB9LFxuXG4gIGlzUGh4U3RpY2t5KG5vZGUpe1xuICAgIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZShQSFhfU1RJQ0tZKSAhPT0gbnVsbFxuICB9LFxuXG4gIGlzQ2hpbGRPZkFueShlbCwgcGFyZW50cyl7XG4gICAgcmV0dXJuICEhcGFyZW50cy5maW5kKHBhcmVudCA9PiBwYXJlbnQuY29udGFpbnMoZWwpKVxuICB9LFxuXG4gIGZpcnN0UGh4Q2hpbGQoZWwpe1xuICAgIHJldHVybiB0aGlzLmlzUGh4Q2hpbGQoZWwpID8gZWwgOiB0aGlzLmFsbChlbCwgYFske1BIWF9QQVJFTlRfSUR9XWApWzBdXG4gIH0sXG5cbiAgZGlzcGF0Y2hFdmVudCh0YXJnZXQsIG5hbWUsIG9wdHMgPSB7fSl7XG4gICAgbGV0IGRlZmF1bHRCdWJibGUgPSB0cnVlXG4gICAgbGV0IGlzVXBsb2FkVGFyZ2V0ID0gdGFyZ2V0Lm5vZGVOYW1lID09PSBcIklOUFVUXCIgJiYgdGFyZ2V0LnR5cGUgPT09IFwiZmlsZVwiXG4gICAgaWYoaXNVcGxvYWRUYXJnZXQgJiYgbmFtZSA9PT0gXCJjbGlja1wiKXtcbiAgICAgIGRlZmF1bHRCdWJibGUgPSBmYWxzZVxuICAgIH1cbiAgICBsZXQgYnViYmxlcyA9IG9wdHMuYnViYmxlcyA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdEJ1YmJsZSA6ICEhb3B0cy5idWJibGVzXG4gICAgbGV0IGV2ZW50T3B0cyA9IHtidWJibGVzOiBidWJibGVzLCBjYW5jZWxhYmxlOiB0cnVlLCBkZXRhaWw6IG9wdHMuZGV0YWlsIHx8IHt9fVxuICAgIGxldCBldmVudCA9IG5hbWUgPT09IFwiY2xpY2tcIiA/IG5ldyBNb3VzZUV2ZW50KFwiY2xpY2tcIiwgZXZlbnRPcHRzKSA6IG5ldyBDdXN0b21FdmVudChuYW1lLCBldmVudE9wdHMpXG4gICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpXG4gIH0sXG5cbiAgY2xvbmVOb2RlKG5vZGUsIGh0bWwpe1xuICAgIGlmKHR5cGVvZiAoaHRtbCkgPT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgcmV0dXJuIG5vZGUuY2xvbmVOb2RlKHRydWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjbG9uZWQgPSBub2RlLmNsb25lTm9kZShmYWxzZSlcbiAgICAgIGNsb25lZC5pbm5lckhUTUwgPSBodG1sXG4gICAgICByZXR1cm4gY2xvbmVkXG4gICAgfVxuICB9LFxuXG4gIC8vIG1lcmdlIGF0dHJpYnV0ZXMgZnJvbSBzb3VyY2UgdG8gdGFyZ2V0XG4gIC8vIGlmIGFuIGVsZW1lbnQgaXMgaWdub3JlZCwgd2Ugb25seSBtZXJnZSBkYXRhIGF0dHJpYnV0ZXNcbiAgLy8gaW5jbHVkaW5nIHJlbW92aW5nIGRhdGEgYXR0cmlidXRlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIHNvdXJjZVxuICBtZXJnZUF0dHJzKHRhcmdldCwgc291cmNlLCBvcHRzID0ge30pe1xuICAgIGxldCBleGNsdWRlID0gbmV3IFNldChvcHRzLmV4Y2x1ZGUgfHwgW10pXG4gICAgbGV0IGlzSWdub3JlZCA9IG9wdHMuaXNJZ25vcmVkXG4gICAgbGV0IHNvdXJjZUF0dHJzID0gc291cmNlLmF0dHJpYnV0ZXNcbiAgICBmb3IobGV0IGkgPSBzb3VyY2VBdHRycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG4gICAgICBsZXQgbmFtZSA9IHNvdXJjZUF0dHJzW2ldLm5hbWVcbiAgICAgIGlmKCFleGNsdWRlLmhhcyhuYW1lKSl7XG4gICAgICAgIGNvbnN0IHNvdXJjZVZhbHVlID0gc291cmNlLmdldEF0dHJpYnV0ZShuYW1lKVxuICAgICAgICBpZih0YXJnZXQuZ2V0QXR0cmlidXRlKG5hbWUpICE9PSBzb3VyY2VWYWx1ZSAmJiAoIWlzSWdub3JlZCB8fCAoaXNJZ25vcmVkICYmIG5hbWUuc3RhcnRzV2l0aChcImRhdGEtXCIpKSkpe1xuICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUobmFtZSwgc291cmNlVmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIGV4Y2x1ZGUgdGhlIHZhbHVlIGZyb20gYmVpbmcgbWVyZ2VkIG9uIGZvY3VzZWQgaW5wdXRzLCBiZWNhdXNlIHRoZVxuICAgICAgICAvLyB1c2VyJ3MgaW5wdXQgc2hvdWxkIGFsd2F5cyB3aW4uXG4gICAgICAgIC8vIFdlIGNhbiBzdGlsbCBhc3NpZ24gaXQgYXMgbG9uZyBhcyB0aGUgdmFsdWUgcHJvcGVydHkgaXMgdGhlIHNhbWUsIHRob3VnaC5cbiAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyBhIHNpdHVhdGlvbiB3aGVyZSB0aGUgdXBkYXRlZCBob29rIGlzIG5vdCBiZWluZyB0cmlnZ2VyZWRcbiAgICAgICAgLy8gd2hlbiBhbiBpbnB1dCBpcyBiYWNrIGluIGl0cyBcIm9yaWdpbmFsIHN0YXRlXCIsIGJlY2F1c2UgdGhlIGF0dHJpYnV0ZVxuICAgICAgICAvLyB3YXMgbmV2ZXIgY2hhbmdlZCwgc2VlOlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGhvZW5peGZyYW1ld29yay9waG9lbml4X2xpdmVfdmlldy9pc3N1ZXMvMjE2M1xuICAgICAgICBpZihuYW1lID09PSBcInZhbHVlXCIgJiYgdGFyZ2V0LnZhbHVlID09PSBzb3VyY2UudmFsdWUpe1xuICAgICAgICAgIC8vIGFjdHVhbGx5IHNldCB0aGUgdmFsdWUgYXR0cmlidXRlIHRvIHN5bmMgaXQgd2l0aCB0aGUgdmFsdWUgcHJvcGVydHlcbiAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgc291cmNlLmdldEF0dHJpYnV0ZShuYW1lKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCB0YXJnZXRBdHRycyA9IHRhcmdldC5hdHRyaWJ1dGVzXG4gICAgZm9yKGxldCBpID0gdGFyZ2V0QXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuICAgICAgbGV0IG5hbWUgPSB0YXJnZXRBdHRyc1tpXS5uYW1lXG4gICAgICBpZihpc0lnbm9yZWQpe1xuICAgICAgICBpZihuYW1lLnN0YXJ0c1dpdGgoXCJkYXRhLVwiKSAmJiAhc291cmNlLmhhc0F0dHJpYnV0ZShuYW1lKSAmJiAhUEhYX1BFTkRJTkdfQVRUUlMuaW5jbHVkZXMobmFtZSkpeyB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKG5hbWUpIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmKCFzb3VyY2UuaGFzQXR0cmlidXRlKG5hbWUpKXsgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShuYW1lKSB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIG1lcmdlRm9jdXNlZElucHV0KHRhcmdldCwgc291cmNlKXtcbiAgICAvLyBza2lwIHNlbGVjdHMgYmVjYXVzZSBGRiB3aWxsIHJlc2V0IGhpZ2hsaWdodGVkIGluZGV4IGZvciBhbnkgc2V0QXR0cmlidXRlXG4gICAgaWYoISh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MU2VsZWN0RWxlbWVudCkpeyBET00ubWVyZ2VBdHRycyh0YXJnZXQsIHNvdXJjZSwge2V4Y2x1ZGU6IFtcInZhbHVlXCJdfSkgfVxuXG4gICAgaWYoc291cmNlLnJlYWRPbmx5KXtcbiAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJyZWFkb25seVwiLCB0cnVlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwicmVhZG9ubHlcIilcbiAgICB9XG4gIH0sXG5cbiAgaGFzU2VsZWN0aW9uUmFuZ2UoZWwpe1xuICAgIHJldHVybiBlbC5zZXRTZWxlY3Rpb25SYW5nZSAmJiAoZWwudHlwZSA9PT0gXCJ0ZXh0XCIgfHwgZWwudHlwZSA9PT0gXCJ0ZXh0YXJlYVwiKVxuICB9LFxuXG4gIHJlc3RvcmVGb2N1cyhmb2N1c2VkLCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKXtcbiAgICBpZihmb2N1c2VkIGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnQpeyBmb2N1c2VkLmZvY3VzKCkgfVxuICAgIGlmKCFET00uaXNUZXh0dWFsSW5wdXQoZm9jdXNlZCkpeyByZXR1cm4gfVxuXG4gICAgbGV0IHdhc0ZvY3VzZWQgPSBmb2N1c2VkLm1hdGNoZXMoXCI6Zm9jdXNcIilcbiAgICBpZighd2FzRm9jdXNlZCl7IGZvY3VzZWQuZm9jdXMoKSB9XG4gICAgaWYodGhpcy5oYXNTZWxlY3Rpb25SYW5nZShmb2N1c2VkKSl7XG4gICAgICBmb2N1c2VkLnNldFNlbGVjdGlvblJhbmdlKHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpXG4gICAgfVxuICB9LFxuXG4gIGlzRm9ybUlucHV0KGVsKXsgcmV0dXJuIC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhKSQvaS50ZXN0KGVsLnRhZ05hbWUpICYmIGVsLnR5cGUgIT09IFwiYnV0dG9uXCIgfSxcblxuICBzeW5jQXR0cnNUb1Byb3BzKGVsKXtcbiAgICBpZihlbCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgJiYgQ0hFQ0tBQkxFX0lOUFVUUy5pbmRleE9mKGVsLnR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKSkgPj0gMCl7XG4gICAgICBlbC5jaGVja2VkID0gZWwuZ2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiKSAhPT0gbnVsbFxuICAgIH1cbiAgfSxcblxuICBpc1RleHR1YWxJbnB1dChlbCl7IHJldHVybiBGT0NVU0FCTEVfSU5QVVRTLmluZGV4T2YoZWwudHlwZSkgPj0gMCB9LFxuXG4gIGlzTm93VHJpZ2dlckZvcm1FeHRlcm5hbChlbCwgcGh4VHJpZ2dlckV4dGVybmFsKXtcbiAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShwaHhUcmlnZ2VyRXh0ZXJuYWwpICE9PSBudWxsICYmIGRvY3VtZW50LmJvZHkuY29udGFpbnMoZWwpXG4gIH0sXG5cbiAgY2xlYW5DaGlsZE5vZGVzKGNvbnRhaW5lciwgcGh4VXBkYXRlKXtcbiAgICBpZihET00uaXNQaHhVcGRhdGUoY29udGFpbmVyLCBwaHhVcGRhdGUsIFtcImFwcGVuZFwiLCBcInByZXBlbmRcIl0pKXtcbiAgICAgIGxldCB0b1JlbW92ZSA9IFtdXG4gICAgICBjb250YWluZXIuY2hpbGROb2Rlcy5mb3JFYWNoKGNoaWxkTm9kZSA9PiB7XG4gICAgICAgIGlmKCFjaGlsZE5vZGUuaWQpe1xuICAgICAgICAgIC8vIFNraXAgd2FybmluZyBpZiBpdCdzIGFuIGVtcHR5IHRleHQgbm9kZSAoZS5nLiBhIG5ldy1saW5lKVxuICAgICAgICAgIGxldCBpc0VtcHR5VGV4dE5vZGUgPSBjaGlsZE5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFICYmIGNoaWxkTm9kZS5ub2RlVmFsdWUudHJpbSgpID09PSBcIlwiXG4gICAgICAgICAgaWYoIWlzRW1wdHlUZXh0Tm9kZSAmJiBjaGlsZE5vZGUubm9kZVR5cGUgIT09IE5vZGUuQ09NTUVOVF9OT0RFKXtcbiAgICAgICAgICAgIGxvZ0Vycm9yKFwib25seSBIVE1MIGVsZW1lbnQgdGFncyB3aXRoIGFuIGlkIGFyZSBhbGxvd2VkIGluc2lkZSBjb250YWluZXJzIHdpdGggcGh4LXVwZGF0ZS5cXG5cXG5cIiArXG4gICAgICAgICAgICAgIGByZW1vdmluZyBpbGxlZ2FsIG5vZGU6IFwiJHsoY2hpbGROb2RlLm91dGVySFRNTCB8fCBjaGlsZE5vZGUubm9kZVZhbHVlKS50cmltKCl9XCJcXG5cXG5gKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0b1JlbW92ZS5wdXNoKGNoaWxkTm9kZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHRvUmVtb3ZlLmZvckVhY2goY2hpbGROb2RlID0+IGNoaWxkTm9kZS5yZW1vdmUoKSlcbiAgICB9XG4gIH0sXG5cbiAgcmVwbGFjZVJvb3RDb250YWluZXIoY29udGFpbmVyLCB0YWdOYW1lLCBhdHRycyl7XG4gICAgbGV0IHJldGFpbmVkQXR0cnMgPSBuZXcgU2V0KFtcImlkXCIsIFBIWF9TRVNTSU9OLCBQSFhfU1RBVElDLCBQSFhfTUFJTiwgUEhYX1JPT1RfSURdKVxuICAgIGlmKGNvbnRhaW5lci50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHRhZ05hbWUudG9Mb3dlckNhc2UoKSl7XG4gICAgICBBcnJheS5mcm9tKGNvbnRhaW5lci5hdHRyaWJ1dGVzKVxuICAgICAgICAuZmlsdGVyKGF0dHIgPT4gIXJldGFpbmVkQXR0cnMuaGFzKGF0dHIubmFtZS50b0xvd2VyQ2FzZSgpKSlcbiAgICAgICAgLmZvckVhY2goYXR0ciA9PiBjb250YWluZXIucmVtb3ZlQXR0cmlidXRlKGF0dHIubmFtZSkpXG5cbiAgICAgIE9iamVjdC5rZXlzKGF0dHJzKVxuICAgICAgICAuZmlsdGVyKG5hbWUgPT4gIXJldGFpbmVkQXR0cnMuaGFzKG5hbWUudG9Mb3dlckNhc2UoKSkpXG4gICAgICAgIC5mb3JFYWNoKGF0dHIgPT4gY29udGFpbmVyLnNldEF0dHJpYnV0ZShhdHRyLCBhdHRyc1thdHRyXSkpXG5cbiAgICAgIHJldHVybiBjb250YWluZXJcblxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbmV3Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKVxuICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goYXR0ciA9PiBuZXdDb250YWluZXIuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJzW2F0dHJdKSlcbiAgICAgIHJldGFpbmVkQXR0cnMuZm9yRWFjaChhdHRyID0+IG5ld0NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoYXR0ciwgY29udGFpbmVyLmdldEF0dHJpYnV0ZShhdHRyKSkpXG4gICAgICBuZXdDb250YWluZXIuaW5uZXJIVE1MID0gY29udGFpbmVyLmlubmVySFRNTFxuICAgICAgY29udGFpbmVyLnJlcGxhY2VXaXRoKG5ld0NvbnRhaW5lcilcbiAgICAgIHJldHVybiBuZXdDb250YWluZXJcbiAgICB9XG4gIH0sXG5cbiAgZ2V0U3RpY2t5KGVsLCBuYW1lLCBkZWZhdWx0VmFsKXtcbiAgICBsZXQgb3AgPSAoRE9NLnByaXZhdGUoZWwsIFwic3RpY2t5XCIpIHx8IFtdKS5maW5kKChbZXhpc3RpbmdOYW1lLF0pID0+IG5hbWUgPT09IGV4aXN0aW5nTmFtZSlcbiAgICBpZihvcCl7XG4gICAgICBsZXQgW19uYW1lLCBfb3AsIHN0YXNoZWRSZXN1bHRdID0gb3BcbiAgICAgIHJldHVybiBzdGFzaGVkUmVzdWx0XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0eXBlb2YoZGVmYXVsdFZhbCkgPT09IFwiZnVuY3Rpb25cIiA/IGRlZmF1bHRWYWwoKSA6IGRlZmF1bHRWYWxcbiAgICB9XG4gIH0sXG5cbiAgZGVsZXRlU3RpY2t5KGVsLCBuYW1lKXtcbiAgICB0aGlzLnVwZGF0ZVByaXZhdGUoZWwsIFwic3RpY2t5XCIsIFtdLCBvcHMgPT4ge1xuICAgICAgcmV0dXJuIG9wcy5maWx0ZXIoKFtleGlzdGluZ05hbWUsIF9dKSA9PiBleGlzdGluZ05hbWUgIT09IG5hbWUpXG4gICAgfSlcbiAgfSxcblxuICBwdXRTdGlja3koZWwsIG5hbWUsIG9wKXtcbiAgICBsZXQgc3Rhc2hlZFJlc3VsdCA9IG9wKGVsKVxuICAgIHRoaXMudXBkYXRlUHJpdmF0ZShlbCwgXCJzdGlja3lcIiwgW10sIG9wcyA9PiB7XG4gICAgICBsZXQgZXhpc3RpbmdJbmRleCA9IG9wcy5maW5kSW5kZXgoKFtleGlzdGluZ05hbWUsXSkgPT4gbmFtZSA9PT0gZXhpc3RpbmdOYW1lKVxuICAgICAgaWYoZXhpc3RpbmdJbmRleCA+PSAwKXtcbiAgICAgICAgb3BzW2V4aXN0aW5nSW5kZXhdID0gW25hbWUsIG9wLCBzdGFzaGVkUmVzdWx0XVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3BzLnB1c2goW25hbWUsIG9wLCBzdGFzaGVkUmVzdWx0XSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHNcbiAgICB9KVxuICB9LFxuXG4gIGFwcGx5U3RpY2t5T3BlcmF0aW9ucyhlbCl7XG4gICAgbGV0IG9wcyA9IERPTS5wcml2YXRlKGVsLCBcInN0aWNreVwiKVxuICAgIGlmKCFvcHMpeyByZXR1cm4gfVxuXG4gICAgb3BzLmZvckVhY2goKFtuYW1lLCBvcCwgX3N0YXNoZWRdKSA9PiB0aGlzLnB1dFN0aWNreShlbCwgbmFtZSwgb3ApKVxuICB9LFxuXG4gIGlzTG9ja2VkKGVsKXtcbiAgICByZXR1cm4gZWwuaGFzQXR0cmlidXRlICYmIGVsLmhhc0F0dHJpYnV0ZShQSFhfUkVGX0xPQ0spXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRE9NXG4iLCAiaW1wb3J0IHtcbiAgUEhYX0FDVElWRV9FTlRSWV9SRUZTLFxuICBQSFhfTElWRV9GSUxFX1VQREFURUQsXG4gIFBIWF9QUkVGTElHSFRFRF9SRUZTXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG4gIGNoYW5uZWxVcGxvYWRlcixcbiAgbG9nRXJyb3Jcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5pbXBvcnQgTGl2ZVVwbG9hZGVyIGZyb20gXCIuL2xpdmVfdXBsb2FkZXJcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVcGxvYWRFbnRyeSB7XG4gIHN0YXRpYyBpc0FjdGl2ZShmaWxlRWwsIGZpbGUpe1xuICAgIGxldCBpc05ldyA9IGZpbGUuX3BoeFJlZiA9PT0gdW5kZWZpbmVkXG4gICAgbGV0IGFjdGl2ZVJlZnMgPSBmaWxlRWwuZ2V0QXR0cmlidXRlKFBIWF9BQ1RJVkVfRU5UUllfUkVGUykuc3BsaXQoXCIsXCIpXG4gICAgbGV0IGlzQWN0aXZlID0gYWN0aXZlUmVmcy5pbmRleE9mKExpdmVVcGxvYWRlci5nZW5GaWxlUmVmKGZpbGUpKSA+PSAwXG4gICAgcmV0dXJuIGZpbGUuc2l6ZSA+IDAgJiYgKGlzTmV3IHx8IGlzQWN0aXZlKVxuICB9XG5cbiAgc3RhdGljIGlzUHJlZmxpZ2h0ZWQoZmlsZUVsLCBmaWxlKXtcbiAgICBsZXQgcHJlZmxpZ2h0ZWRSZWZzID0gZmlsZUVsLmdldEF0dHJpYnV0ZShQSFhfUFJFRkxJR0hURURfUkVGUykuc3BsaXQoXCIsXCIpXG4gICAgbGV0IGlzUHJlZmxpZ2h0ZWQgPSBwcmVmbGlnaHRlZFJlZnMuaW5kZXhPZihMaXZlVXBsb2FkZXIuZ2VuRmlsZVJlZihmaWxlKSkgPj0gMFxuICAgIHJldHVybiBpc1ByZWZsaWdodGVkICYmIHRoaXMuaXNBY3RpdmUoZmlsZUVsLCBmaWxlKVxuICB9XG5cbiAgc3RhdGljIGlzUHJlZmxpZ2h0SW5Qcm9ncmVzcyhmaWxlKXtcbiAgICByZXR1cm4gZmlsZS5fcHJlZmxpZ2h0SW5Qcm9ncmVzcyA9PT0gdHJ1ZVxuICB9XG5cbiAgc3RhdGljIG1hcmtQcmVmbGlnaHRJblByb2dyZXNzKGZpbGUpe1xuICAgIGZpbGUuX3ByZWZsaWdodEluUHJvZ3Jlc3MgPSB0cnVlXG4gIH1cblxuICBjb25zdHJ1Y3RvcihmaWxlRWwsIGZpbGUsIHZpZXcsIGF1dG9VcGxvYWQpe1xuICAgIHRoaXMucmVmID0gTGl2ZVVwbG9hZGVyLmdlbkZpbGVSZWYoZmlsZSlcbiAgICB0aGlzLmZpbGVFbCA9IGZpbGVFbFxuICAgIHRoaXMuZmlsZSA9IGZpbGVcbiAgICB0aGlzLnZpZXcgPSB2aWV3XG4gICAgdGhpcy5tZXRhID0gbnVsbFxuICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gZmFsc2VcbiAgICB0aGlzLl9pc0RvbmUgPSBmYWxzZVxuICAgIHRoaXMuX3Byb2dyZXNzID0gMFxuICAgIHRoaXMuX2xhc3RQcm9ncmVzc1NlbnQgPSAtMVxuICAgIHRoaXMuX29uRG9uZSA9IGZ1bmN0aW9uKCl7IH1cbiAgICB0aGlzLl9vbkVsVXBkYXRlZCA9IHRoaXMub25FbFVwZGF0ZWQuYmluZCh0aGlzKVxuICAgIHRoaXMuZmlsZUVsLmFkZEV2ZW50TGlzdGVuZXIoUEhYX0xJVkVfRklMRV9VUERBVEVELCB0aGlzLl9vbkVsVXBkYXRlZClcbiAgICB0aGlzLmF1dG9VcGxvYWQgPSBhdXRvVXBsb2FkXG4gIH1cblxuICBtZXRhZGF0YSgpeyByZXR1cm4gdGhpcy5tZXRhIH1cblxuICBwcm9ncmVzcyhwcm9ncmVzcyl7XG4gICAgdGhpcy5fcHJvZ3Jlc3MgPSBNYXRoLmZsb29yKHByb2dyZXNzKVxuICAgIGlmKHRoaXMuX3Byb2dyZXNzID4gdGhpcy5fbGFzdFByb2dyZXNzU2VudCl7XG4gICAgICBpZih0aGlzLl9wcm9ncmVzcyA+PSAxMDApe1xuICAgICAgICB0aGlzLl9wcm9ncmVzcyA9IDEwMFxuICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3NTZW50ID0gMTAwXG4gICAgICAgIHRoaXMuX2lzRG9uZSA9IHRydWVcbiAgICAgICAgdGhpcy52aWV3LnB1c2hGaWxlUHJvZ3Jlc3ModGhpcy5maWxlRWwsIHRoaXMucmVmLCAxMDAsICgpID0+IHtcbiAgICAgICAgICBMaXZlVXBsb2FkZXIudW50cmFja0ZpbGUodGhpcy5maWxlRWwsIHRoaXMuZmlsZSlcbiAgICAgICAgICB0aGlzLl9vbkRvbmUoKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzU2VudCA9IHRoaXMuX3Byb2dyZXNzXG4gICAgICAgIHRoaXMudmlldy5wdXNoRmlsZVByb2dyZXNzKHRoaXMuZmlsZUVsLCB0aGlzLnJlZiwgdGhpcy5fcHJvZ3Jlc3MpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaXNDYW5jZWxsZWQoKXsgcmV0dXJuIHRoaXMuX2lzQ2FuY2VsbGVkIH1cblxuICBjYW5jZWwoKXtcbiAgICB0aGlzLmZpbGUuX3ByZWZsaWdodEluUHJvZ3Jlc3MgPSBmYWxzZVxuICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gdHJ1ZVxuICAgIHRoaXMuX2lzRG9uZSA9IHRydWVcbiAgICB0aGlzLl9vbkRvbmUoKVxuICB9XG5cbiAgaXNEb25lKCl7IHJldHVybiB0aGlzLl9pc0RvbmUgfVxuXG4gIGVycm9yKHJlYXNvbiA9IFwiZmFpbGVkXCIpe1xuICAgIHRoaXMuZmlsZUVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoUEhYX0xJVkVfRklMRV9VUERBVEVELCB0aGlzLl9vbkVsVXBkYXRlZClcbiAgICB0aGlzLnZpZXcucHVzaEZpbGVQcm9ncmVzcyh0aGlzLmZpbGVFbCwgdGhpcy5yZWYsIHtlcnJvcjogcmVhc29ufSlcbiAgICBpZighdGhpcy5pc0F1dG9VcGxvYWQoKSl7IExpdmVVcGxvYWRlci5jbGVhckZpbGVzKHRoaXMuZmlsZUVsKSB9XG4gIH1cblxuICBpc0F1dG9VcGxvYWQoKXsgcmV0dXJuIHRoaXMuYXV0b1VwbG9hZCB9XG5cbiAgLy9wcml2YXRlXG5cbiAgb25Eb25lKGNhbGxiYWNrKXtcbiAgICB0aGlzLl9vbkRvbmUgPSAoKSA9PiB7XG4gICAgICB0aGlzLmZpbGVFbC5yZW1vdmVFdmVudExpc3RlbmVyKFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCwgdGhpcy5fb25FbFVwZGF0ZWQpXG4gICAgICBjYWxsYmFjaygpXG4gICAgfVxuICB9XG5cbiAgb25FbFVwZGF0ZWQoKXtcbiAgICBsZXQgYWN0aXZlUmVmcyA9IHRoaXMuZmlsZUVsLmdldEF0dHJpYnV0ZShQSFhfQUNUSVZFX0VOVFJZX1JFRlMpLnNwbGl0KFwiLFwiKVxuICAgIGlmKGFjdGl2ZVJlZnMuaW5kZXhPZih0aGlzLnJlZikgPT09IC0xKXtcbiAgICAgIExpdmVVcGxvYWRlci51bnRyYWNrRmlsZSh0aGlzLmZpbGVFbCwgdGhpcy5maWxlKVxuICAgICAgdGhpcy5jYW5jZWwoKVxuICAgIH1cbiAgfVxuXG4gIHRvUHJlZmxpZ2h0UGF5bG9hZCgpe1xuICAgIHJldHVybiB7XG4gICAgICBsYXN0X21vZGlmaWVkOiB0aGlzLmZpbGUubGFzdE1vZGlmaWVkLFxuICAgICAgbmFtZTogdGhpcy5maWxlLm5hbWUsXG4gICAgICByZWxhdGl2ZV9wYXRoOiB0aGlzLmZpbGUud2Via2l0UmVsYXRpdmVQYXRoLFxuICAgICAgc2l6ZTogdGhpcy5maWxlLnNpemUsXG4gICAgICB0eXBlOiB0aGlzLmZpbGUudHlwZSxcbiAgICAgIHJlZjogdGhpcy5yZWYsXG4gICAgICBtZXRhOiB0eXBlb2YodGhpcy5maWxlLm1ldGEpID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzLmZpbGUubWV0YSgpIDogdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgdXBsb2FkZXIodXBsb2FkZXJzKXtcbiAgICBpZih0aGlzLm1ldGEudXBsb2FkZXIpe1xuICAgICAgbGV0IGNhbGxiYWNrID0gdXBsb2FkZXJzW3RoaXMubWV0YS51cGxvYWRlcl0gfHwgbG9nRXJyb3IoYG5vIHVwbG9hZGVyIGNvbmZpZ3VyZWQgZm9yICR7dGhpcy5tZXRhLnVwbG9hZGVyfWApXG4gICAgICByZXR1cm4ge25hbWU6IHRoaXMubWV0YS51cGxvYWRlciwgY2FsbGJhY2s6IGNhbGxiYWNrfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge25hbWU6IFwiY2hhbm5lbFwiLCBjYWxsYmFjazogY2hhbm5lbFVwbG9hZGVyfVxuICAgIH1cbiAgfVxuXG4gIHppcFBvc3RGbGlnaHQocmVzcCl7XG4gICAgdGhpcy5tZXRhID0gcmVzcC5lbnRyaWVzW3RoaXMucmVmXVxuICAgIGlmKCF0aGlzLm1ldGEpeyBsb2dFcnJvcihgbm8gcHJlZmxpZ2h0IHVwbG9hZCByZXNwb25zZSByZXR1cm5lZCB3aXRoIHJlZiAke3RoaXMucmVmfWAsIHtpbnB1dDogdGhpcy5maWxlRWwsIHJlc3BvbnNlOiByZXNwfSkgfVxuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgUEhYX0RPTkVfUkVGUyxcbiAgUEhYX1BSRUZMSUdIVEVEX1JFRlMsXG4gIFBIWF9VUExPQURfUkVGXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIlxuaW1wb3J0IFVwbG9hZEVudHJ5IGZyb20gXCIuL3VwbG9hZF9lbnRyeVwiXG5cbmxldCBsaXZlVXBsb2FkZXJGaWxlUmVmID0gMFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaXZlVXBsb2FkZXIge1xuICBzdGF0aWMgZ2VuRmlsZVJlZihmaWxlKXtcbiAgICBsZXQgcmVmID0gZmlsZS5fcGh4UmVmXG4gICAgaWYocmVmICE9PSB1bmRlZmluZWQpe1xuICAgICAgcmV0dXJuIHJlZlxuICAgIH0gZWxzZSB7XG4gICAgICBmaWxlLl9waHhSZWYgPSAobGl2ZVVwbG9hZGVyRmlsZVJlZisrKS50b1N0cmluZygpXG4gICAgICByZXR1cm4gZmlsZS5fcGh4UmVmXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldEVudHJ5RGF0YVVSTChpbnB1dEVsLCByZWYsIGNhbGxiYWNrKXtcbiAgICBsZXQgZmlsZSA9IHRoaXMuYWN0aXZlRmlsZXMoaW5wdXRFbCkuZmluZChmaWxlID0+IHRoaXMuZ2VuRmlsZVJlZihmaWxlKSA9PT0gcmVmKVxuICAgIGNhbGxiYWNrKFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSkpXG4gIH1cblxuICBzdGF0aWMgaGFzVXBsb2Fkc0luUHJvZ3Jlc3MoZm9ybUVsKXtcbiAgICBsZXQgYWN0aXZlID0gMFxuICAgIERPTS5maW5kVXBsb2FkSW5wdXRzKGZvcm1FbCkuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICBpZihpbnB1dC5nZXRBdHRyaWJ1dGUoUEhYX1BSRUZMSUdIVEVEX1JFRlMpICE9PSBpbnB1dC5nZXRBdHRyaWJ1dGUoUEhYX0RPTkVfUkVGUykpe1xuICAgICAgICBhY3RpdmUrK1xuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGFjdGl2ZSA+IDBcbiAgfVxuXG4gIHN0YXRpYyBzZXJpYWxpemVVcGxvYWRzKGlucHV0RWwpe1xuICAgIGxldCBmaWxlcyA9IHRoaXMuYWN0aXZlRmlsZXMoaW5wdXRFbClcbiAgICBsZXQgZmlsZURhdGEgPSB7fVxuICAgIGZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICBsZXQgZW50cnkgPSB7cGF0aDogaW5wdXRFbC5uYW1lfVxuICAgICAgbGV0IHVwbG9hZFJlZiA9IGlucHV0RWwuZ2V0QXR0cmlidXRlKFBIWF9VUExPQURfUkVGKVxuICAgICAgZmlsZURhdGFbdXBsb2FkUmVmXSA9IGZpbGVEYXRhW3VwbG9hZFJlZl0gfHwgW11cbiAgICAgIGVudHJ5LnJlZiA9IHRoaXMuZ2VuRmlsZVJlZihmaWxlKVxuICAgICAgZW50cnkubGFzdF9tb2RpZmllZCA9IGZpbGUubGFzdE1vZGlmaWVkXG4gICAgICBlbnRyeS5uYW1lID0gZmlsZS5uYW1lIHx8IGVudHJ5LnJlZlxuICAgICAgZW50cnkucmVsYXRpdmVfcGF0aCA9IGZpbGUud2Via2l0UmVsYXRpdmVQYXRoXG4gICAgICBlbnRyeS50eXBlID0gZmlsZS50eXBlXG4gICAgICBlbnRyeS5zaXplID0gZmlsZS5zaXplXG4gICAgICBpZih0eXBlb2YoZmlsZS5tZXRhKSA9PT0gXCJmdW5jdGlvblwiKXsgZW50cnkubWV0YSA9IGZpbGUubWV0YSgpIH1cbiAgICAgIGZpbGVEYXRhW3VwbG9hZFJlZl0ucHVzaChlbnRyeSlcbiAgICB9KVxuICAgIHJldHVybiBmaWxlRGF0YVxuICB9XG5cbiAgc3RhdGljIGNsZWFyRmlsZXMoaW5wdXRFbCl7XG4gICAgaW5wdXRFbC52YWx1ZSA9IG51bGxcbiAgICBpbnB1dEVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRilcbiAgICBET00ucHV0UHJpdmF0ZShpbnB1dEVsLCBcImZpbGVzXCIsIFtdKVxuICB9XG5cbiAgc3RhdGljIHVudHJhY2tGaWxlKGlucHV0RWwsIGZpbGUpe1xuICAgIERPTS5wdXRQcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIiwgRE9NLnByaXZhdGUoaW5wdXRFbCwgXCJmaWxlc1wiKS5maWx0ZXIoZiA9PiAhT2JqZWN0LmlzKGYsIGZpbGUpKSlcbiAgfVxuXG4gIHN0YXRpYyB0cmFja0ZpbGVzKGlucHV0RWwsIGZpbGVzLCBkYXRhVHJhbnNmZXIpe1xuICAgIGlmKGlucHV0RWwuZ2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIikgIT09IG51bGwpe1xuICAgICAgbGV0IG5ld0ZpbGVzID0gZmlsZXMuZmlsdGVyKGZpbGUgPT4gIXRoaXMuYWN0aXZlRmlsZXMoaW5wdXRFbCkuZmluZChmID0+IE9iamVjdC5pcyhmLCBmaWxlKSkpXG4gICAgICBET00udXBkYXRlUHJpdmF0ZShpbnB1dEVsLCBcImZpbGVzXCIsIFtdLCAoZXhpc3RpbmcpID0+IGV4aXN0aW5nLmNvbmNhdChuZXdGaWxlcykpXG4gICAgICBpbnB1dEVsLnZhbHVlID0gbnVsbFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXNldCBpbnB1dEVsIGZpbGVzIHRvIGFsaWduIG91dHB1dCB3aXRoIHByb2dyYW1tYXRpYyBjaGFuZ2VzIChpLmUuIGRyYWcgYW5kIGRyb3ApXG4gICAgICBpZihkYXRhVHJhbnNmZXIgJiYgZGF0YVRyYW5zZmVyLmZpbGVzLmxlbmd0aCA+IDApeyBpbnB1dEVsLmZpbGVzID0gZGF0YVRyYW5zZmVyLmZpbGVzIH1cbiAgICAgIERPTS5wdXRQcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIiwgZmlsZXMpXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGFjdGl2ZUZpbGVJbnB1dHMoZm9ybUVsKXtcbiAgICBsZXQgZmlsZUlucHV0cyA9IERPTS5maW5kVXBsb2FkSW5wdXRzKGZvcm1FbClcbiAgICByZXR1cm4gQXJyYXkuZnJvbShmaWxlSW5wdXRzKS5maWx0ZXIoZWwgPT4gZWwuZmlsZXMgJiYgdGhpcy5hY3RpdmVGaWxlcyhlbCkubGVuZ3RoID4gMClcbiAgfVxuXG4gIHN0YXRpYyBhY3RpdmVGaWxlcyhpbnB1dCl7XG4gICAgcmV0dXJuIChET00ucHJpdmF0ZShpbnB1dCwgXCJmaWxlc1wiKSB8fCBbXSkuZmlsdGVyKGYgPT4gVXBsb2FkRW50cnkuaXNBY3RpdmUoaW5wdXQsIGYpKVxuICB9XG5cbiAgc3RhdGljIGlucHV0c0F3YWl0aW5nUHJlZmxpZ2h0KGZvcm1FbCl7XG4gICAgbGV0IGZpbGVJbnB1dHMgPSBET00uZmluZFVwbG9hZElucHV0cyhmb3JtRWwpXG4gICAgcmV0dXJuIEFycmF5LmZyb20oZmlsZUlucHV0cykuZmlsdGVyKGlucHV0ID0+IHRoaXMuZmlsZXNBd2FpdGluZ1ByZWZsaWdodChpbnB1dCkubGVuZ3RoID4gMClcbiAgfVxuXG4gIHN0YXRpYyBmaWxlc0F3YWl0aW5nUHJlZmxpZ2h0KGlucHV0KXtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVGaWxlcyhpbnB1dCkuZmlsdGVyKGYgPT4gIVVwbG9hZEVudHJ5LmlzUHJlZmxpZ2h0ZWQoaW5wdXQsIGYpICYmICFVcGxvYWRFbnRyeS5pc1ByZWZsaWdodEluUHJvZ3Jlc3MoZikpXG4gIH1cblxuICBzdGF0aWMgbWFya1ByZWZsaWdodEluUHJvZ3Jlc3MoZW50cmllcyl7XG4gICAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IFVwbG9hZEVudHJ5Lm1hcmtQcmVmbGlnaHRJblByb2dyZXNzKGVudHJ5LmZpbGUpKVxuICB9XG5cbiAgY29uc3RydWN0b3IoaW5wdXRFbCwgdmlldywgb25Db21wbGV0ZSl7XG4gICAgdGhpcy5hdXRvVXBsb2FkID0gRE9NLmlzQXV0b1VwbG9hZChpbnB1dEVsKVxuICAgIHRoaXMudmlldyA9IHZpZXdcbiAgICB0aGlzLm9uQ29tcGxldGUgPSBvbkNvbXBsZXRlXG4gICAgdGhpcy5fZW50cmllcyA9XG4gICAgICBBcnJheS5mcm9tKExpdmVVcGxvYWRlci5maWxlc0F3YWl0aW5nUHJlZmxpZ2h0KGlucHV0RWwpIHx8IFtdKVxuICAgICAgICAubWFwKGZpbGUgPT4gbmV3IFVwbG9hZEVudHJ5KGlucHV0RWwsIGZpbGUsIHZpZXcsIHRoaXMuYXV0b1VwbG9hZCkpXG5cbiAgICAvLyBwcmV2ZW50IHNlbmRpbmcgZHVwbGljYXRlIHByZWZsaWdodCByZXF1ZXN0c1xuICAgIExpdmVVcGxvYWRlci5tYXJrUHJlZmxpZ2h0SW5Qcm9ncmVzcyh0aGlzLl9lbnRyaWVzKVxuXG4gICAgdGhpcy5udW1FbnRyaWVzSW5Qcm9ncmVzcyA9IHRoaXMuX2VudHJpZXMubGVuZ3RoXG4gIH1cblxuICBpc0F1dG9VcGxvYWQoKXsgcmV0dXJuIHRoaXMuYXV0b1VwbG9hZCB9XG5cbiAgZW50cmllcygpeyByZXR1cm4gdGhpcy5fZW50cmllcyB9XG5cbiAgaW5pdEFkYXB0ZXJVcGxvYWQocmVzcCwgb25FcnJvciwgbGl2ZVNvY2tldCl7XG4gICAgdGhpcy5fZW50cmllcyA9XG4gICAgICB0aGlzLl9lbnRyaWVzLm1hcChlbnRyeSA9PiB7XG4gICAgICAgIGlmKGVudHJ5LmlzQ2FuY2VsbGVkKCkpe1xuICAgICAgICAgIHRoaXMubnVtRW50cmllc0luUHJvZ3Jlc3MtLVxuICAgICAgICAgIGlmKHRoaXMubnVtRW50cmllc0luUHJvZ3Jlc3MgPT09IDApeyB0aGlzLm9uQ29tcGxldGUoKSB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW50cnkuemlwUG9zdEZsaWdodChyZXNwKVxuICAgICAgICAgIGVudHJ5Lm9uRG9uZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm51bUVudHJpZXNJblByb2dyZXNzLS1cbiAgICAgICAgICAgIGlmKHRoaXMubnVtRW50cmllc0luUHJvZ3Jlc3MgPT09IDApeyB0aGlzLm9uQ29tcGxldGUoKSB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50cnlcbiAgICAgIH0pXG5cbiAgICBsZXQgZ3JvdXBlZEVudHJpZXMgPSB0aGlzLl9lbnRyaWVzLnJlZHVjZSgoYWNjLCBlbnRyeSkgPT4ge1xuICAgICAgaWYoIWVudHJ5Lm1ldGEpeyByZXR1cm4gYWNjIH1cbiAgICAgIGxldCB7bmFtZSwgY2FsbGJhY2t9ID0gZW50cnkudXBsb2FkZXIobGl2ZVNvY2tldC51cGxvYWRlcnMpXG4gICAgICBhY2NbbmFtZV0gPSBhY2NbbmFtZV0gfHwge2NhbGxiYWNrOiBjYWxsYmFjaywgZW50cmllczogW119XG4gICAgICBhY2NbbmFtZV0uZW50cmllcy5wdXNoKGVudHJ5KVxuICAgICAgcmV0dXJuIGFjY1xuICAgIH0sIHt9KVxuXG4gICAgZm9yKGxldCBuYW1lIGluIGdyb3VwZWRFbnRyaWVzKXtcbiAgICAgIGxldCB7Y2FsbGJhY2ssIGVudHJpZXN9ID0gZ3JvdXBlZEVudHJpZXNbbmFtZV1cbiAgICAgIGNhbGxiYWNrKGVudHJpZXMsIG9uRXJyb3IsIHJlc3AsIGxpdmVTb2NrZXQpXG4gICAgfVxuICB9XG59XG4iLCAibGV0IEFSSUEgPSB7XG4gIGFueU9mKGluc3RhbmNlLCBjbGFzc2VzKXsgcmV0dXJuIGNsYXNzZXMuZmluZChuYW1lID0+IGluc3RhbmNlIGluc3RhbmNlb2YgbmFtZSkgfSxcblxuICBpc0ZvY3VzYWJsZShlbCwgaW50ZXJhY3RpdmVPbmx5KXtcbiAgICByZXR1cm4gKFxuICAgICAgKGVsIGluc3RhbmNlb2YgSFRNTEFuY2hvckVsZW1lbnQgJiYgZWwucmVsICE9PSBcImlnbm9yZVwiKSB8fFxuICAgICAgKGVsIGluc3RhbmNlb2YgSFRNTEFyZWFFbGVtZW50ICYmIGVsLmhyZWYgIT09IHVuZGVmaW5lZCkgfHxcbiAgICAgICghZWwuZGlzYWJsZWQgJiYgKHRoaXMuYW55T2YoZWwsIFtIVE1MSW5wdXRFbGVtZW50LCBIVE1MU2VsZWN0RWxlbWVudCwgSFRNTFRleHRBcmVhRWxlbWVudCwgSFRNTEJ1dHRvbkVsZW1lbnRdKSkpIHx8XG4gICAgICAoZWwgaW5zdGFuY2VvZiBIVE1MSUZyYW1lRWxlbWVudCkgfHxcbiAgICAgIChlbC50YWJJbmRleCA+IDAgfHwgKCFpbnRlcmFjdGl2ZU9ubHkgJiYgZWwuZ2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIikgIT09IG51bGwgJiYgZWwuZ2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIikgIT09IFwidHJ1ZVwiKSlcbiAgICApXG4gIH0sXG5cbiAgYXR0ZW1wdEZvY3VzKGVsLCBpbnRlcmFjdGl2ZU9ubHkpe1xuICAgIGlmKHRoaXMuaXNGb2N1c2FibGUoZWwsIGludGVyYWN0aXZlT25seSkpeyB0cnkgeyBlbC5mb2N1cygpIH0gY2F0Y2gge30gfVxuICAgIHJldHVybiAhIWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5pc1NhbWVOb2RlKGVsKVxuICB9LFxuXG4gIGZvY3VzRmlyc3RJbnRlcmFjdGl2ZShlbCl7XG4gICAgbGV0IGNoaWxkID0gZWwuZmlyc3RFbGVtZW50Q2hpbGRcbiAgICB3aGlsZShjaGlsZCl7XG4gICAgICBpZih0aGlzLmF0dGVtcHRGb2N1cyhjaGlsZCwgdHJ1ZSkgfHwgdGhpcy5mb2N1c0ZpcnN0SW50ZXJhY3RpdmUoY2hpbGQsIHRydWUpKXtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQubmV4dEVsZW1lbnRTaWJsaW5nXG4gICAgfVxuICB9LFxuXG4gIGZvY3VzRmlyc3QoZWwpe1xuICAgIGxldCBjaGlsZCA9IGVsLmZpcnN0RWxlbWVudENoaWxkXG4gICAgd2hpbGUoY2hpbGQpe1xuICAgICAgaWYodGhpcy5hdHRlbXB0Rm9jdXMoY2hpbGQpIHx8IHRoaXMuZm9jdXNGaXJzdChjaGlsZCkpe1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0RWxlbWVudFNpYmxpbmdcbiAgICB9XG4gIH0sXG5cbiAgZm9jdXNMYXN0KGVsKXtcbiAgICBsZXQgY2hpbGQgPSBlbC5sYXN0RWxlbWVudENoaWxkXG4gICAgd2hpbGUoY2hpbGQpe1xuICAgICAgaWYodGhpcy5hdHRlbXB0Rm9jdXMoY2hpbGQpIHx8IHRoaXMuZm9jdXNMYXN0KGNoaWxkKSl7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnByZXZpb3VzRWxlbWVudFNpYmxpbmdcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IEFSSUFcbiIsICJpbXBvcnQge1xuICBQSFhfQUNUSVZFX0VOVFJZX1JFRlMsXG4gIFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCxcbiAgUEhYX1BSRUZMSUdIVEVEX1JFRlMsXG4gIFBIWF9VUExPQURfUkVGXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCBMaXZlVXBsb2FkZXIgZnJvbSBcIi4vbGl2ZV91cGxvYWRlclwiXG5pbXBvcnQgQVJJQSBmcm9tIFwiLi9hcmlhXCJcblxubGV0IEhvb2tzID0ge1xuICBMaXZlRmlsZVVwbG9hZDoge1xuICAgIGFjdGl2ZVJlZnMoKXsgcmV0dXJuIHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9BQ1RJVkVfRU5UUllfUkVGUykgfSxcblxuICAgIHByZWZsaWdodGVkUmVmcygpeyByZXR1cm4gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX1BSRUZMSUdIVEVEX1JFRlMpIH0sXG5cbiAgICBtb3VudGVkKCl7IHRoaXMucHJlZmxpZ2h0ZWRXYXMgPSB0aGlzLnByZWZsaWdodGVkUmVmcygpIH0sXG5cbiAgICB1cGRhdGVkKCl7XG4gICAgICBsZXQgbmV3UHJlZmxpZ2h0cyA9IHRoaXMucHJlZmxpZ2h0ZWRSZWZzKClcbiAgICAgIGlmKHRoaXMucHJlZmxpZ2h0ZWRXYXMgIT09IG5ld1ByZWZsaWdodHMpe1xuICAgICAgICB0aGlzLnByZWZsaWdodGVkV2FzID0gbmV3UHJlZmxpZ2h0c1xuICAgICAgICBpZihuZXdQcmVmbGlnaHRzID09PSBcIlwiKXtcbiAgICAgICAgICB0aGlzLl9fdmlldygpLmNhbmNlbFN1Ym1pdCh0aGlzLmVsLmZvcm0pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYodGhpcy5hY3RpdmVSZWZzKCkgPT09IFwiXCIpeyB0aGlzLmVsLnZhbHVlID0gbnVsbCB9XG4gICAgICB0aGlzLmVsLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCkpXG4gICAgfVxuICB9LFxuXG4gIExpdmVJbWdQcmV2aWV3OiB7XG4gICAgbW91bnRlZCgpe1xuICAgICAgdGhpcy5yZWYgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LWVudHJ5LXJlZlwiKVxuICAgICAgdGhpcy5pbnB1dEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpKVxuICAgICAgTGl2ZVVwbG9hZGVyLmdldEVudHJ5RGF0YVVSTCh0aGlzLmlucHV0RWwsIHRoaXMucmVmLCB1cmwgPT4ge1xuICAgICAgICB0aGlzLnVybCA9IHVybFxuICAgICAgICB0aGlzLmVsLnNyYyA9IHVybFxuICAgICAgfSlcbiAgICB9LFxuICAgIGRlc3Ryb3llZCgpe1xuICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLnVybClcbiAgICB9XG4gIH0sXG4gIEZvY3VzV3JhcDoge1xuICAgIG1vdW50ZWQoKXtcbiAgICAgIHRoaXMuZm9jdXNTdGFydCA9IHRoaXMuZWwuZmlyc3RFbGVtZW50Q2hpbGRcbiAgICAgIHRoaXMuZm9jdXNFbmQgPSB0aGlzLmVsLmxhc3RFbGVtZW50Q2hpbGRcbiAgICAgIHRoaXMuZm9jdXNTdGFydC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgKGUpID0+IHtcbiAgICAgICAgaWYoIWUucmVsYXRlZFRhcmdldCB8fCAhdGhpcy5lbC5jb250YWlucyhlLnJlbGF0ZWRUYXJnZXQpKXsgXG4gICAgICAgICAgLy8gSGFuZGxlIGZvY3VzIGVudGVyaW5nIGZyb20gb3V0c2lkZSAoZS5nLiBUYWIgd2hlbiBib2R5IGlzIGZvY3VzZWQpXG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Bob2VuaXhmcmFtZXdvcmsvcGhvZW5peF9saXZlX3ZpZXcvaXNzdWVzLzM2MzZcbiAgICAgICAgICBjb25zdCBuZXh0Rm9jdXMgPSBlLnRhcmdldC5uZXh0RWxlbWVudFNpYmxpbmdcbiAgICAgICAgICBBUklBLmF0dGVtcHRGb2N1cyhuZXh0Rm9jdXMpIHx8IEFSSUEuZm9jdXNGaXJzdChuZXh0Rm9jdXMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgQVJJQS5mb2N1c0xhc3QodGhpcy5lbClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHRoaXMuZm9jdXNFbmQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIChlKSA9PiB7XG4gICAgICAgIGlmKCFlLnJlbGF0ZWRUYXJnZXQgfHwgIXRoaXMuZWwuY29udGFpbnMoZS5yZWxhdGVkVGFyZ2V0KSl7IFxuICAgICAgICAgIC8vIEhhbmRsZSBmb2N1cyBlbnRlcmluZyBmcm9tIG91dHNpZGUgKGUuZy4gU2hpZnQrVGFiIHdoZW4gYm9keSBpcyBmb2N1c2VkKVxuICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXhfbGl2ZV92aWV3L2lzc3Vlcy8zNjM2XG4gICAgICAgICAgY29uc3QgbmV4dEZvY3VzID0gZS50YXJnZXQucHJldmlvdXNFbGVtZW50U2libGluZ1xuICAgICAgICAgIEFSSUEuYXR0ZW1wdEZvY3VzKG5leHRGb2N1cykgfHwgQVJJQS5mb2N1c0xhc3QobmV4dEZvY3VzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEFSSUEuZm9jdXNGaXJzdCh0aGlzLmVsKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLy8gb25seSB0cnkgdG8gY2hhbmdlIHRoZSBmb2N1cyBpZiBpdCBpcyBub3QgYWxyZWFkeSBpbnNpZGVcbiAgICAgIGlmKCF0aGlzLmVsLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKXtcbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKFwicGh4OnNob3ctZW5kXCIsICgpID0+IHRoaXMuZWwuZm9jdXMoKSlcbiAgICAgICAgaWYod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5lbCkuZGlzcGxheSAhPT0gXCJub25lXCIpe1xuICAgICAgICAgIEFSSUEuZm9jdXNGaXJzdCh0aGlzLmVsKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmxldCBmaW5kU2Nyb2xsQ29udGFpbmVyID0gKGVsKSA9PiB7XG4gIC8vIHRoZSBzY3JvbGwgZXZlbnQgd29uJ3QgYmUgZmlyZWQgb24gdGhlIGh0bWwvYm9keSBlbGVtZW50IGV2ZW4gaWYgb3ZlcmZsb3cgaXMgc2V0XG4gIC8vIHRoZXJlZm9yZSB3ZSByZXR1cm4gbnVsbCB0byBpbnN0ZWFkIGxpc3RlbiBmb3Igc2Nyb2xsIGV2ZW50cyBvbiBkb2N1bWVudFxuICBpZihbXCJIVE1MXCIsIFwiQk9EWVwiXS5pbmRleE9mKGVsLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkpID49IDApIHJldHVybiBudWxsXG4gIGlmKFtcInNjcm9sbFwiLCBcImF1dG9cIl0uaW5kZXhPZihnZXRDb21wdXRlZFN0eWxlKGVsKS5vdmVyZmxvd1kpID49IDApIHJldHVybiBlbFxuICByZXR1cm4gZmluZFNjcm9sbENvbnRhaW5lcihlbC5wYXJlbnRFbGVtZW50KVxufVxuXG5sZXQgc2Nyb2xsVG9wID0gKHNjcm9sbENvbnRhaW5lcikgPT4ge1xuICBpZihzY3JvbGxDb250YWluZXIpe1xuICAgIHJldHVybiBzY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3BcbiAgfVxufVxuXG5sZXQgYm90dG9tID0gKHNjcm9sbENvbnRhaW5lcikgPT4ge1xuICBpZihzY3JvbGxDb250YWluZXIpe1xuICAgIHJldHVybiBzY3JvbGxDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tXG4gIH0gZWxzZSB7XG4gICAgLy8gd2hlbiB3ZSBoYXZlIG5vIGNvbnRhaW5lciwgdGhlIHdob2xlIHBhZ2Ugc2Nyb2xscyxcbiAgICAvLyB0aGVyZWZvcmUgdGhlIGJvdHRvbSBjb29yZGluYXRlIGlzIHRoZSB2aWV3cG9ydCBoZWlnaHRcbiAgICByZXR1cm4gd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcbiAgfVxufVxuXG5sZXQgdG9wID0gKHNjcm9sbENvbnRhaW5lcikgPT4ge1xuICBpZihzY3JvbGxDb250YWluZXIpe1xuICAgIHJldHVybiBzY3JvbGxDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wXG4gIH0gZWxzZSB7XG4gICAgLy8gd2hlbiB3ZSBoYXZlIG5vIGNvbnRhaW5lciB0aGUgd2hvbGUgcGFnZSBzY3JvbGxzLFxuICAgIC8vIHRoZXJlZm9yZSB0aGUgdG9wIGNvb3JkaW5hdGUgaXMgMFxuICAgIHJldHVybiAwXG4gIH1cbn1cblxubGV0IGlzQXRWaWV3cG9ydFRvcCA9IChlbCwgc2Nyb2xsQ29udGFpbmVyKSA9PiB7XG4gIGxldCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgcmV0dXJuIE1hdGguY2VpbChyZWN0LnRvcCkgPj0gdG9wKHNjcm9sbENvbnRhaW5lcikgJiYgTWF0aC5jZWlsKHJlY3QubGVmdCkgPj0gMCAmJiBNYXRoLmZsb29yKHJlY3QudG9wKSA8PSBib3R0b20oc2Nyb2xsQ29udGFpbmVyKVxufVxuXG5sZXQgaXNBdFZpZXdwb3J0Qm90dG9tID0gKGVsLCBzY3JvbGxDb250YWluZXIpID0+IHtcbiAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICByZXR1cm4gTWF0aC5jZWlsKHJlY3QuYm90dG9tKSA+PSB0b3Aoc2Nyb2xsQ29udGFpbmVyKSAmJiBNYXRoLmNlaWwocmVjdC5sZWZ0KSA+PSAwICYmIE1hdGguZmxvb3IocmVjdC5ib3R0b20pIDw9IGJvdHRvbShzY3JvbGxDb250YWluZXIpXG59XG5cbmxldCBpc1dpdGhpblZpZXdwb3J0ID0gKGVsLCBzY3JvbGxDb250YWluZXIpID0+IHtcbiAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICByZXR1cm4gTWF0aC5jZWlsKHJlY3QudG9wKSA+PSB0b3Aoc2Nyb2xsQ29udGFpbmVyKSAmJiBNYXRoLmNlaWwocmVjdC5sZWZ0KSA+PSAwICYmIE1hdGguZmxvb3IocmVjdC50b3ApIDw9IGJvdHRvbShzY3JvbGxDb250YWluZXIpXG59XG5cbkhvb2tzLkluZmluaXRlU2Nyb2xsID0ge1xuICBtb3VudGVkKCl7XG4gICAgdGhpcy5zY3JvbGxDb250YWluZXIgPSBmaW5kU2Nyb2xsQ29udGFpbmVyKHRoaXMuZWwpXG4gICAgbGV0IHNjcm9sbEJlZm9yZSA9IHNjcm9sbFRvcCh0aGlzLnNjcm9sbENvbnRhaW5lcilcbiAgICBsZXQgdG9wT3ZlcnJhbiA9IGZhbHNlXG4gICAgbGV0IHRocm90dGxlSW50ZXJ2YWwgPSA1MDBcbiAgICBsZXQgcGVuZGluZ09wID0gbnVsbFxuXG4gICAgbGV0IG9uVG9wT3ZlcnJ1biA9IHRoaXMudGhyb3R0bGUodGhyb3R0bGVJbnRlcnZhbCwgKHRvcEV2ZW50LCBmaXJzdENoaWxkKSA9PiB7XG4gICAgICBwZW5kaW5nT3AgPSAoKSA9PiB0cnVlXG4gICAgICB0aGlzLmxpdmVTb2NrZXQuZXhlY0pTSG9va1B1c2godGhpcy5lbCwgdG9wRXZlbnQsIHtpZDogZmlyc3RDaGlsZC5pZCwgX292ZXJyYW46IHRydWV9LCAoKSA9PiB7XG4gICAgICAgIHBlbmRpbmdPcCA9IG51bGxcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGxldCBvbkZpcnN0Q2hpbGRBdFRvcCA9IHRoaXMudGhyb3R0bGUodGhyb3R0bGVJbnRlcnZhbCwgKHRvcEV2ZW50LCBmaXJzdENoaWxkKSA9PiB7XG4gICAgICBwZW5kaW5nT3AgPSAoKSA9PiBmaXJzdENoaWxkLnNjcm9sbEludG9WaWV3KHtibG9jazogXCJzdGFydFwifSlcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5leGVjSlNIb29rUHVzaCh0aGlzLmVsLCB0b3BFdmVudCwge2lkOiBmaXJzdENoaWxkLmlkfSwgKCkgPT4ge1xuICAgICAgICBwZW5kaW5nT3AgPSBudWxsXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHRoZSBET00gaXMgcGF0Y2hlZCBieSB3YWl0aW5nIGZvciB0aGUgbmV4dCB0aWNrXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIGlmKCFpc1dpdGhpblZpZXdwb3J0KGZpcnN0Q2hpbGQsIHRoaXMuc2Nyb2xsQ29udGFpbmVyKSl7XG4gICAgICAgICAgICBmaXJzdENoaWxkLnNjcm9sbEludG9WaWV3KHtibG9jazogXCJzdGFydFwifSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBsZXQgb25MYXN0Q2hpbGRBdEJvdHRvbSA9IHRoaXMudGhyb3R0bGUodGhyb3R0bGVJbnRlcnZhbCwgKGJvdHRvbUV2ZW50LCBsYXN0Q2hpbGQpID0+IHtcbiAgICAgIHBlbmRpbmdPcCA9ICgpID0+IGxhc3RDaGlsZC5zY3JvbGxJbnRvVmlldyh7YmxvY2s6IFwiZW5kXCJ9KVxuICAgICAgdGhpcy5saXZlU29ja2V0LmV4ZWNKU0hvb2tQdXNoKHRoaXMuZWwsIGJvdHRvbUV2ZW50LCB7aWQ6IGxhc3RDaGlsZC5pZH0sICgpID0+IHtcbiAgICAgICAgcGVuZGluZ09wID0gbnVsbFxuICAgICAgICAvLyBtYWtlIHN1cmUgdGhhdCB0aGUgRE9NIGlzIHBhdGNoZWQgYnkgd2FpdGluZyBmb3IgdGhlIG5leHQgdGlja1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBpZighaXNXaXRoaW5WaWV3cG9ydChsYXN0Q2hpbGQsIHRoaXMuc2Nyb2xsQ29udGFpbmVyKSl7XG4gICAgICAgICAgICBsYXN0Q2hpbGQuc2Nyb2xsSW50b1ZpZXcoe2Jsb2NrOiBcImVuZFwifSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICB0aGlzLm9uU2Nyb2xsID0gKF9lKSA9PiB7XG4gICAgICBsZXQgc2Nyb2xsTm93ID0gc2Nyb2xsVG9wKHRoaXMuc2Nyb2xsQ29udGFpbmVyKVxuXG4gICAgICBpZihwZW5kaW5nT3Ape1xuICAgICAgICBzY3JvbGxCZWZvcmUgPSBzY3JvbGxOb3dcbiAgICAgICAgcmV0dXJuIHBlbmRpbmdPcCgpXG4gICAgICB9XG4gICAgICBsZXQgcmVjdCA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIGxldCB0b3BFdmVudCA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKHRoaXMubGl2ZVNvY2tldC5iaW5kaW5nKFwidmlld3BvcnQtdG9wXCIpKVxuICAgICAgbGV0IGJvdHRvbUV2ZW50ID0gdGhpcy5lbC5nZXRBdHRyaWJ1dGUodGhpcy5saXZlU29ja2V0LmJpbmRpbmcoXCJ2aWV3cG9ydC1ib3R0b21cIikpXG4gICAgICBsZXQgbGFzdENoaWxkID0gdGhpcy5lbC5sYXN0RWxlbWVudENoaWxkXG4gICAgICBsZXQgZmlyc3RDaGlsZCA9IHRoaXMuZWwuZmlyc3RFbGVtZW50Q2hpbGRcbiAgICAgIGxldCBpc1Njcm9sbGluZ1VwID0gc2Nyb2xsTm93IDwgc2Nyb2xsQmVmb3JlXG4gICAgICBsZXQgaXNTY3JvbGxpbmdEb3duID0gc2Nyb2xsTm93ID4gc2Nyb2xsQmVmb3JlXG5cbiAgICAgIC8vIGVsIG92ZXJyYW4gd2hpbGUgc2Nyb2xsaW5nIHVwXG4gICAgICBpZihpc1Njcm9sbGluZ1VwICYmIHRvcEV2ZW50ICYmICF0b3BPdmVycmFuICYmIHJlY3QudG9wID49IDApe1xuICAgICAgICB0b3BPdmVycmFuID0gdHJ1ZVxuICAgICAgICBvblRvcE92ZXJydW4odG9wRXZlbnQsIGZpcnN0Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYoaXNTY3JvbGxpbmdEb3duICYmIHRvcE92ZXJyYW4gJiYgcmVjdC50b3AgPD0gMCl7XG4gICAgICAgIHRvcE92ZXJyYW4gPSBmYWxzZVxuICAgICAgfVxuXG4gICAgICBpZih0b3BFdmVudCAmJiBpc1Njcm9sbGluZ1VwICYmIGlzQXRWaWV3cG9ydFRvcChmaXJzdENoaWxkLCB0aGlzLnNjcm9sbENvbnRhaW5lcikpe1xuICAgICAgICBvbkZpcnN0Q2hpbGRBdFRvcCh0b3BFdmVudCwgZmlyc3RDaGlsZClcbiAgICAgIH0gZWxzZSBpZihib3R0b21FdmVudCAmJiBpc1Njcm9sbGluZ0Rvd24gJiYgaXNBdFZpZXdwb3J0Qm90dG9tKGxhc3RDaGlsZCwgdGhpcy5zY3JvbGxDb250YWluZXIpKXtcbiAgICAgICAgb25MYXN0Q2hpbGRBdEJvdHRvbShib3R0b21FdmVudCwgbGFzdENoaWxkKVxuICAgICAgfVxuICAgICAgc2Nyb2xsQmVmb3JlID0gc2Nyb2xsTm93XG4gICAgfVxuXG4gICAgaWYodGhpcy5zY3JvbGxDb250YWluZXIpe1xuICAgICAgdGhpcy5zY3JvbGxDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKVxuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKVxuICAgIH1cbiAgfSxcbiAgXG4gIGRlc3Ryb3llZCgpe1xuICAgIGlmKHRoaXMuc2Nyb2xsQ29udGFpbmVyKXtcbiAgICAgIHRoaXMuc2Nyb2xsQ29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbClcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbClcbiAgICB9XG4gIH0sXG5cbiAgdGhyb3R0bGUoaW50ZXJ2YWwsIGNhbGxiYWNrKXtcbiAgICBsZXQgbGFzdENhbGxBdCA9IDBcbiAgICBsZXQgdGltZXJcblxuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgbGV0IG5vdyA9IERhdGUubm93KClcbiAgICAgIGxldCByZW1haW5pbmdUaW1lID0gaW50ZXJ2YWwgLSAobm93IC0gbGFzdENhbGxBdClcblxuICAgICAgaWYocmVtYWluaW5nVGltZSA8PSAwIHx8IHJlbWFpbmluZ1RpbWUgPiBpbnRlcnZhbCl7XG4gICAgICAgIGlmKHRpbWVyKXtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpXG4gICAgICAgICAgdGltZXIgPSBudWxsXG4gICAgICAgIH1cbiAgICAgICAgbGFzdENhbGxBdCA9IG5vd1xuICAgICAgICBjYWxsYmFjayguLi5hcmdzKVxuICAgICAgfSBlbHNlIGlmKCF0aW1lcil7XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgbGFzdENhbGxBdCA9IERhdGUubm93KClcbiAgICAgICAgICB0aW1lciA9IG51bGxcbiAgICAgICAgICBjYWxsYmFjayguLi5hcmdzKVxuICAgICAgICB9LCByZW1haW5pbmdUaW1lKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgSG9va3NcbiIsICJpbXBvcnQge1xuICBQSFhfUkVGX0xPQURJTkcsXG4gIFBIWF9SRUZfTE9DSyxcbiAgUEhYX1JFRl9TUkMsXG4gIFBIWF9FVkVOVF9DTEFTU0VTLFxuICBQSFhfRElTQUJMRUQsXG4gIFBIWF9SRUFET05MWSxcbiAgUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCBET00gZnJvbSBcIi4vZG9tXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWxlbWVudFJlZiB7XG4gIHN0YXRpYyBvblVubG9jayhlbCwgY2FsbGJhY2spe1xuICAgIGlmKCFET00uaXNMb2NrZWQoZWwpICYmICFlbC5jbG9zZXN0KGBbJHtQSFhfUkVGX0xPQ0t9XWApKXsgcmV0dXJuIGNhbGxiYWNrKCkgfVxuICAgIGNvbnN0IGNsb3Nlc3RMb2NrID0gZWwuY2xvc2VzdChgWyR7UEhYX1JFRl9MT0NLfV1gKVxuICAgIGNvbnN0IHJlZiA9IGNsb3Nlc3RMb2NrLmNsb3Nlc3QoYFske1BIWF9SRUZfTE9DS31dYCkuZ2V0QXR0cmlidXRlKFBIWF9SRUZfTE9DSylcbiAgICBjbG9zZXN0TG9jay5hZGRFdmVudExpc3RlbmVyKGBwaHg6dW5kby1sb2NrOiR7cmVmfWAsICgpID0+IHtcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9LCB7b25jZTogdHJ1ZX0pXG4gIH1cblxuICBjb25zdHJ1Y3RvcihlbCl7XG4gICAgdGhpcy5lbCA9IGVsXG4gICAgdGhpcy5sb2FkaW5nUmVmID0gZWwuaGFzQXR0cmlidXRlKFBIWF9SRUZfTE9BRElORykgPyBwYXJzZUludChlbC5nZXRBdHRyaWJ1dGUoUEhYX1JFRl9MT0FESU5HKSwgMTApIDogbnVsbFxuICAgIHRoaXMubG9ja1JlZiA9IGVsLmhhc0F0dHJpYnV0ZShQSFhfUkVGX0xPQ0spID8gcGFyc2VJbnQoZWwuZ2V0QXR0cmlidXRlKFBIWF9SRUZfTE9DSyksIDEwKSA6IG51bGxcbiAgfVxuXG4gIC8vIHB1YmxpY1xuXG4gIG1heWJlVW5kbyhyZWYsIHBoeEV2ZW50LCBlYWNoQ2xvbmVDYWxsYmFjayl7XG4gICAgaWYoIXRoaXMuaXNXaXRoaW4ocmVmKSl7IHJldHVybiB9XG5cbiAgICAvLyB1bmRvIGxvY2tzIGFuZCBhcHBseSBjbG9uZXNcbiAgICB0aGlzLnVuZG9Mb2NrcyhyZWYsIHBoeEV2ZW50LCBlYWNoQ2xvbmVDYWxsYmFjaylcblxuICAgIC8vIHVuZG8gbG9hZGluZyBzdGF0ZXNcbiAgICB0aGlzLnVuZG9Mb2FkaW5nKHJlZiwgcGh4RXZlbnQpXG5cbiAgICAvLyBjbGVhbiB1cCBpZiBmdWxseSByZXNvbHZlZFxuICAgIGlmKHRoaXMuaXNGdWxseVJlc29sdmVkQnkocmVmKSl7IHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9SRUZfU1JDKSB9XG4gIH1cblxuICAvLyBwcml2YXRlXG5cbiAgaXNXaXRoaW4ocmVmKXtcbiAgICByZXR1cm4gISgodGhpcy5sb2FkaW5nUmVmICE9PSBudWxsICYmIHRoaXMubG9hZGluZ1JlZiA+IHJlZikgJiYgKHRoaXMubG9ja1JlZiAhPT0gbnVsbCAmJiB0aGlzLmxvY2tSZWYgPiByZWYpKVxuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIGNsb25lZCBQSFhfUkVGX0xPQ0sgZWxlbWVudCB0aGF0IGhhcyBiZWVuIG1vcnBoZWQgYmVoaW5kXG4gIC8vIHRoZSBzY2VuZXMgd2hpbGUgdGhpcyBlbGVtZW50IHdhcyBsb2NrZWQgaW4gdGhlIERPTS5cbiAgLy8gV2hlbiB3ZSBhcHBseSB0aGUgY2xvbmVkIHRyZWUgdG8gdGhlIGFjdGl2ZSBET00gZWxlbWVudCwgd2UgbXVzdFxuICAvL1xuICAvLyAgIDEuIGV4ZWN1dGUgcGVuZGluZyBtb3VudGVkIGhvb2tzIGZvciBub2RlcyBub3cgaW4gdGhlIERPTVxuICAvLyAgIDIuIHVuZG8gYW55IHJlZiBpbnNpZGUgdGhlIGNsb25lZCB0cmVlIHRoYXQgaGFzIHNpbmNlIGJlZW4gYWNrJ2RcbiAgdW5kb0xvY2tzKHJlZiwgcGh4RXZlbnQsIGVhY2hDbG9uZUNhbGxiYWNrKXtcbiAgICBpZighdGhpcy5pc0xvY2tVbmRvbmVCeShyZWYpKXsgcmV0dXJuIH1cblxuICAgIGxldCBjbG9uZWRUcmVlID0gRE9NLnByaXZhdGUodGhpcy5lbCwgUEhYX1JFRl9MT0NLKVxuICAgIGlmKGNsb25lZFRyZWUpe1xuICAgICAgZWFjaENsb25lQ2FsbGJhY2soY2xvbmVkVHJlZSlcbiAgICAgIERPTS5kZWxldGVQcml2YXRlKHRoaXMuZWwsIFBIWF9SRUZfTE9DSylcbiAgICB9XG4gICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFRl9MT0NLKVxuXG4gICAgbGV0IG9wdHMgPSB7ZGV0YWlsOiB7cmVmOiByZWYsIGV2ZW50OiBwaHhFdmVudH0sIGJ1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IGZhbHNlfVxuICAgIHRoaXMuZWwuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoYHBoeDp1bmRvLWxvY2s6JHt0aGlzLmxvY2tSZWZ9YCwgb3B0cykpXG4gIH1cblxuICB1bmRvTG9hZGluZyhyZWYsIHBoeEV2ZW50KXtcbiAgICBpZighdGhpcy5pc0xvYWRpbmdVbmRvbmVCeShyZWYpKXtcbiAgICAgIGlmKHRoaXMuY2FuVW5kb0xvYWRpbmcocmVmKSAmJiB0aGlzLmVsLmNsYXNzTGlzdC5jb250YWlucyhcInBoeC1zdWJtaXQtbG9hZGluZ1wiKSl7XG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZShcInBoeC1jaGFuZ2UtbG9hZGluZ1wiKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYodGhpcy5jYW5VbmRvTG9hZGluZyhyZWYpKXtcbiAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9SRUZfTE9BRElORylcbiAgICAgIGxldCBkaXNhYmxlZFZhbCA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFRClcbiAgICAgIGxldCByZWFkT25seVZhbCA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9SRUFET05MWSlcbiAgICAgIC8vIHJlc3RvcmUgaW5wdXRzXG4gICAgICBpZihyZWFkT25seVZhbCAhPT0gbnVsbCl7XG4gICAgICAgIHRoaXMuZWwucmVhZE9ubHkgPSByZWFkT25seVZhbCA9PT0gXCJ0cnVlXCIgPyB0cnVlIDogZmFsc2VcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFQURPTkxZKVxuICAgICAgfVxuICAgICAgaWYoZGlzYWJsZWRWYWwgIT09IG51bGwpe1xuICAgICAgICB0aGlzLmVsLmRpc2FibGVkID0gZGlzYWJsZWRWYWwgPT09IFwidHJ1ZVwiID8gdHJ1ZSA6IGZhbHNlXG4gICAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9ESVNBQkxFRClcbiAgICAgIH1cbiAgICAgIC8vIHJlc3RvcmUgZGlzYWJsZXNcbiAgICAgIGxldCBkaXNhYmxlUmVzdG9yZSA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSlcbiAgICAgIGlmKGRpc2FibGVSZXN0b3JlICE9PSBudWxsKXtcbiAgICAgICAgdGhpcy5lbC5pbm5lclRleHQgPSBkaXNhYmxlUmVzdG9yZVxuICAgICAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUpXG4gICAgICB9XG5cbiAgICAgIGxldCBvcHRzID0ge2RldGFpbDoge3JlZjogcmVmLCBldmVudDogcGh4RXZlbnR9LCBidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiBmYWxzZX1cbiAgICAgIHRoaXMuZWwuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoYHBoeDp1bmRvLWxvYWRpbmc6JHt0aGlzLmxvYWRpbmdSZWZ9YCwgb3B0cykpXG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGNsYXNzZXNcbiAgICBQSFhfRVZFTlRfQ0xBU1NFUy5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgaWYobmFtZSAhPT0gXCJwaHgtc3VibWl0LWxvYWRpbmdcIiB8fCB0aGlzLmNhblVuZG9Mb2FkaW5nKHJlZikpe1xuICAgICAgICBET00ucmVtb3ZlQ2xhc3ModGhpcy5lbCwgbmFtZSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgaXNMb2FkaW5nVW5kb25lQnkocmVmKXsgcmV0dXJuIHRoaXMubG9hZGluZ1JlZiA9PT0gbnVsbCA/IGZhbHNlIDogdGhpcy5sb2FkaW5nUmVmIDw9IHJlZiB9XG4gIGlzTG9ja1VuZG9uZUJ5KHJlZil7IHJldHVybiB0aGlzLmxvY2tSZWYgPT09IG51bGwgPyBmYWxzZSA6IHRoaXMubG9ja1JlZiA8PSByZWYgfVxuXG4gIGlzRnVsbHlSZXNvbHZlZEJ5KHJlZil7XG4gICAgcmV0dXJuICh0aGlzLmxvYWRpbmdSZWYgPT09IG51bGwgfHwgdGhpcy5sb2FkaW5nUmVmIDw9IHJlZikgJiYgKHRoaXMubG9ja1JlZiA9PT0gbnVsbCB8fCB0aGlzLmxvY2tSZWYgPD0gcmVmKVxuICB9XG5cbiAgLy8gb25seSByZW1vdmUgdGhlIHBoeC1zdWJtaXQtbG9hZGluZyBjbGFzcyBpZiB3ZSBhcmUgbm90IGxvY2tlZFxuICBjYW5VbmRvTG9hZGluZyhyZWYpeyByZXR1cm4gdGhpcy5sb2NrUmVmID09PSBudWxsIHx8IHRoaXMubG9ja1JlZiA8PSByZWYgfVxufVxuIiwgImltcG9ydCB7XG4gIG1heWJlXG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBET01Qb3N0TW9ycGhSZXN0b3JlciB7XG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lckJlZm9yZSwgY29udGFpbmVyQWZ0ZXIsIHVwZGF0ZVR5cGUpe1xuICAgIGxldCBpZHNCZWZvcmUgPSBuZXcgU2V0KClcbiAgICBsZXQgaWRzQWZ0ZXIgPSBuZXcgU2V0KFsuLi5jb250YWluZXJBZnRlci5jaGlsZHJlbl0ubWFwKGNoaWxkID0+IGNoaWxkLmlkKSlcblxuICAgIGxldCBlbGVtZW50c1RvTW9kaWZ5ID0gW11cblxuICAgIEFycmF5LmZyb20oY29udGFpbmVyQmVmb3JlLmNoaWxkcmVuKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGlmKGNoaWxkLmlkKXsgLy8gYWxsIG9mIG91ciBjaGlsZHJlbiBzaG91bGQgYmUgZWxlbWVudHMgd2l0aCBpZHNcbiAgICAgICAgaWRzQmVmb3JlLmFkZChjaGlsZC5pZClcbiAgICAgICAgaWYoaWRzQWZ0ZXIuaGFzKGNoaWxkLmlkKSl7XG4gICAgICAgICAgbGV0IHByZXZpb3VzRWxlbWVudElkID0gY2hpbGQucHJldmlvdXNFbGVtZW50U2libGluZyAmJiBjaGlsZC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLmlkXG4gICAgICAgICAgZWxlbWVudHNUb01vZGlmeS5wdXNoKHtlbGVtZW50SWQ6IGNoaWxkLmlkLCBwcmV2aW91c0VsZW1lbnRJZDogcHJldmlvdXNFbGVtZW50SWR9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuY29udGFpbmVySWQgPSBjb250YWluZXJBZnRlci5pZFxuICAgIHRoaXMudXBkYXRlVHlwZSA9IHVwZGF0ZVR5cGVcbiAgICB0aGlzLmVsZW1lbnRzVG9Nb2RpZnkgPSBlbGVtZW50c1RvTW9kaWZ5XG4gICAgdGhpcy5lbGVtZW50SWRzVG9BZGQgPSBbLi4uaWRzQWZ0ZXJdLmZpbHRlcihpZCA9PiAhaWRzQmVmb3JlLmhhcyhpZCkpXG4gIH1cblxuICAvLyBXZSBkbyB0aGUgZm9sbG93aW5nIHRvIG9wdGltaXplIGFwcGVuZC9wcmVwZW5kIG9wZXJhdGlvbnM6XG4gIC8vICAgMSkgVHJhY2sgaWRzIG9mIG1vZGlmaWVkIGVsZW1lbnRzICYgb2YgbmV3IGVsZW1lbnRzXG4gIC8vICAgMikgQWxsIHRoZSBtb2RpZmllZCBlbGVtZW50cyBhcmUgcHV0IGJhY2sgaW4gdGhlIGNvcnJlY3QgcG9zaXRpb24gaW4gdGhlIERPTSB0cmVlXG4gIC8vICAgICAgYnkgc3RvcmluZyB0aGUgaWQgb2YgdGhlaXIgcHJldmlvdXMgc2libGluZ1xuICAvLyAgIDMpIE5ldyBlbGVtZW50cyBhcmUgZ29pbmcgdG8gYmUgcHV0IGluIHRoZSByaWdodCBwbGFjZSBieSBtb3JwaGRvbSBkdXJpbmcgYXBwZW5kLlxuICAvLyAgICAgIEZvciBwcmVwZW5kLCB3ZSBtb3ZlIHRoZW0gdG8gdGhlIGZpcnN0IHBvc2l0aW9uIGluIHRoZSBjb250YWluZXJcbiAgcGVyZm9ybSgpe1xuICAgIGxldCBjb250YWluZXIgPSBET00uYnlJZCh0aGlzLmNvbnRhaW5lcklkKVxuICAgIHRoaXMuZWxlbWVudHNUb01vZGlmeS5mb3JFYWNoKGVsZW1lbnRUb01vZGlmeSA9PiB7XG4gICAgICBpZihlbGVtZW50VG9Nb2RpZnkucHJldmlvdXNFbGVtZW50SWQpe1xuICAgICAgICBtYXliZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50VG9Nb2RpZnkucHJldmlvdXNFbGVtZW50SWQpLCBwcmV2aW91c0VsZW0gPT4ge1xuICAgICAgICAgIG1heWJlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRUb01vZGlmeS5lbGVtZW50SWQpLCBlbGVtID0+IHtcbiAgICAgICAgICAgIGxldCBpc0luUmlnaHRQbGFjZSA9IGVsZW0ucHJldmlvdXNFbGVtZW50U2libGluZyAmJiBlbGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmcuaWQgPT0gcHJldmlvdXNFbGVtLmlkXG4gICAgICAgICAgICBpZighaXNJblJpZ2h0UGxhY2Upe1xuICAgICAgICAgICAgICBwcmV2aW91c0VsZW0uaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJlbmRcIiwgZWxlbSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgY29udGFpbmVyXG4gICAgICAgIG1heWJlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRUb01vZGlmeS5lbGVtZW50SWQpLCBlbGVtID0+IHtcbiAgICAgICAgICBsZXQgaXNJblJpZ2h0UGxhY2UgPSBlbGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgPT0gbnVsbFxuICAgICAgICAgIGlmKCFpc0luUmlnaHRQbGFjZSl7XG4gICAgICAgICAgICBjb250YWluZXIuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJiZWdpblwiLCBlbGVtKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYodGhpcy51cGRhdGVUeXBlID09IFwicHJlcGVuZFwiKXtcbiAgICAgIHRoaXMuZWxlbWVudElkc1RvQWRkLnJldmVyc2UoKS5mb3JFYWNoKGVsZW1JZCA9PiB7XG4gICAgICAgIG1heWJlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1JZCksIGVsZW0gPT4gY29udGFpbmVyLmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyYmVnaW5cIiwgZWxlbSkpXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuIiwgInZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFID0gMTE7XG5cbmZ1bmN0aW9uIG1vcnBoQXR0cnMoZnJvbU5vZGUsIHRvTm9kZSkge1xuICAgIHZhciB0b05vZGVBdHRycyA9IHRvTm9kZS5hdHRyaWJ1dGVzO1xuICAgIHZhciBhdHRyO1xuICAgIHZhciBhdHRyTmFtZTtcbiAgICB2YXIgYXR0ck5hbWVzcGFjZVVSSTtcbiAgICB2YXIgYXR0clZhbHVlO1xuICAgIHZhciBmcm9tVmFsdWU7XG5cbiAgICAvLyBkb2N1bWVudC1mcmFnbWVudHMgZG9udCBoYXZlIGF0dHJpYnV0ZXMgc28gbGV0cyBub3QgZG8gYW55dGhpbmdcbiAgICBpZiAodG9Ob2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFIHx8IGZyb21Ob2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGF0dHJpYnV0ZXMgb24gb3JpZ2luYWwgRE9NIGVsZW1lbnRcbiAgICBmb3IgKHZhciBpID0gdG9Ob2RlQXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYXR0ciA9IHRvTm9kZUF0dHJzW2ldO1xuICAgICAgICBhdHRyTmFtZSA9IGF0dHIubmFtZTtcbiAgICAgICAgYXR0ck5hbWVzcGFjZVVSSSA9IGF0dHIubmFtZXNwYWNlVVJJO1xuICAgICAgICBhdHRyVmFsdWUgPSBhdHRyLnZhbHVlO1xuXG4gICAgICAgIGlmIChhdHRyTmFtZXNwYWNlVVJJKSB7XG4gICAgICAgICAgICBhdHRyTmFtZSA9IGF0dHIubG9jYWxOYW1lIHx8IGF0dHJOYW1lO1xuICAgICAgICAgICAgZnJvbVZhbHVlID0gZnJvbU5vZGUuZ2V0QXR0cmlidXRlTlMoYXR0ck5hbWVzcGFjZVVSSSwgYXR0ck5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoZnJvbVZhbHVlICE9PSBhdHRyVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ci5wcmVmaXggPT09ICd4bWxucycpe1xuICAgICAgICAgICAgICAgICAgICBhdHRyTmFtZSA9IGF0dHIubmFtZTsgLy8gSXQncyBub3QgYWxsb3dlZCB0byBzZXQgYW4gYXR0cmlidXRlIHdpdGggdGhlIFhNTE5TIG5hbWVzcGFjZSB3aXRob3V0IHNwZWNpZnlpbmcgdGhlIGB4bWxuc2AgcHJlZml4XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZyb21Ob2RlLnNldEF0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lLCBhdHRyVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJvbVZhbHVlID0gZnJvbU5vZGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKTtcblxuICAgICAgICAgICAgaWYgKGZyb21WYWx1ZSAhPT0gYXR0clZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZnJvbU5vZGUuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFueSBleHRyYSBhdHRyaWJ1dGVzIGZvdW5kIG9uIHRoZSBvcmlnaW5hbCBET00gZWxlbWVudCB0aGF0XG4gICAgLy8gd2VyZW4ndCBmb3VuZCBvbiB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAgdmFyIGZyb21Ob2RlQXR0cnMgPSBmcm9tTm9kZS5hdHRyaWJ1dGVzO1xuXG4gICAgZm9yICh2YXIgZCA9IGZyb21Ob2RlQXR0cnMubGVuZ3RoIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgYXR0ciA9IGZyb21Ob2RlQXR0cnNbZF07XG4gICAgICAgIGF0dHJOYW1lID0gYXR0ci5uYW1lO1xuICAgICAgICBhdHRyTmFtZXNwYWNlVVJJID0gYXR0ci5uYW1lc3BhY2VVUkk7XG5cbiAgICAgICAgaWYgKGF0dHJOYW1lc3BhY2VVUkkpIHtcbiAgICAgICAgICAgIGF0dHJOYW1lID0gYXR0ci5sb2NhbE5hbWUgfHwgYXR0ck5hbWU7XG5cbiAgICAgICAgICAgIGlmICghdG9Ob2RlLmhhc0F0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lKSkge1xuICAgICAgICAgICAgICAgIGZyb21Ob2RlLnJlbW92ZUF0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdG9Ob2RlLmhhc0F0dHJpYnV0ZShhdHRyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBmcm9tTm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgcmFuZ2U7IC8vIENyZWF0ZSBhIHJhbmdlIG9iamVjdCBmb3IgZWZmaWNlbnRseSByZW5kZXJpbmcgc3RyaW5ncyB0byBlbGVtZW50cy5cbnZhciBOU19YSFRNTCA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcblxudmFyIGRvYyA9IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBkb2N1bWVudDtcbnZhciBIQVNfVEVNUExBVEVfU1VQUE9SVCA9ICEhZG9jICYmICdjb250ZW50JyBpbiBkb2MuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbnZhciBIQVNfUkFOR0VfU1VQUE9SVCA9ICEhZG9jICYmIGRvYy5jcmVhdGVSYW5nZSAmJiAnY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50JyBpbiBkb2MuY3JlYXRlUmFuZ2UoKTtcblxuZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnRGcm9tVGVtcGxhdGUoc3RyKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gc3RyO1xuICAgIHJldHVybiB0ZW1wbGF0ZS5jb250ZW50LmNoaWxkTm9kZXNbMF07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50RnJvbVJhbmdlKHN0cikge1xuICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgcmFuZ2UgPSBkb2MuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZShkb2MuYm9keSk7XG4gICAgfVxuXG4gICAgdmFyIGZyYWdtZW50ID0gcmFuZ2UuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KHN0cik7XG4gICAgcmV0dXJuIGZyYWdtZW50LmNoaWxkTm9kZXNbMF07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50RnJvbVdyYXAoc3RyKSB7XG4gICAgdmFyIGZyYWdtZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2JvZHknKTtcbiAgICBmcmFnbWVudC5pbm5lckhUTUwgPSBzdHI7XG4gICAgcmV0dXJuIGZyYWdtZW50LmNoaWxkTm9kZXNbMF07XG59XG5cbi8qKlxuICogVGhpcyBpcyBhYm91dCB0aGUgc2FtZVxuICogdmFyIGh0bWwgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHN0ciwgJ3RleHQvaHRtbCcpO1xuICogcmV0dXJuIGh0bWwuYm9keS5maXJzdENoaWxkO1xuICpcbiAqIEBtZXRob2QgdG9FbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKi9cbmZ1bmN0aW9uIHRvRWxlbWVudChzdHIpIHtcbiAgICBzdHIgPSBzdHIudHJpbSgpO1xuICAgIGlmIChIQVNfVEVNUExBVEVfU1VQUE9SVCkge1xuICAgICAgLy8gYXZvaWQgcmVzdHJpY3Rpb25zIG9uIGNvbnRlbnQgZm9yIHRoaW5ncyBsaWtlIGA8dHI+PHRoPkhpPC90aD48L3RyPmAgd2hpY2hcbiAgICAgIC8vIGNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCBkb2Vzbid0IHN1cHBvcnRcbiAgICAgIC8vIDx0ZW1wbGF0ZT4gc3VwcG9ydCBub3QgYXZhaWxhYmxlIGluIElFXG4gICAgICByZXR1cm4gY3JlYXRlRnJhZ21lbnRGcm9tVGVtcGxhdGUoc3RyKTtcbiAgICB9IGVsc2UgaWYgKEhBU19SQU5HRV9TVVBQT1JUKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRnJhZ21lbnRGcm9tUmFuZ2Uoc3RyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlRnJhZ21lbnRGcm9tV3JhcChzdHIpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0d28gbm9kZSdzIG5hbWVzIGFyZSB0aGUgc2FtZS5cbiAqXG4gKiBOT1RFOiBXZSBkb24ndCBib3RoZXIgY2hlY2tpbmcgYG5hbWVzcGFjZVVSSWAgYmVjYXVzZSB5b3Ugd2lsbCBuZXZlciBmaW5kIHR3byBIVE1MIGVsZW1lbnRzIHdpdGggdGhlIHNhbWVcbiAqICAgICAgIG5vZGVOYW1lIGFuZCBkaWZmZXJlbnQgbmFtZXNwYWNlIFVSSXMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGIgVGhlIHRhcmdldCBlbGVtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb21wYXJlTm9kZU5hbWVzKGZyb21FbCwgdG9FbCkge1xuICAgIHZhciBmcm9tTm9kZU5hbWUgPSBmcm9tRWwubm9kZU5hbWU7XG4gICAgdmFyIHRvTm9kZU5hbWUgPSB0b0VsLm5vZGVOYW1lO1xuICAgIHZhciBmcm9tQ29kZVN0YXJ0LCB0b0NvZGVTdGFydDtcblxuICAgIGlmIChmcm9tTm9kZU5hbWUgPT09IHRvTm9kZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnJvbUNvZGVTdGFydCA9IGZyb21Ob2RlTmFtZS5jaGFyQ29kZUF0KDApO1xuICAgIHRvQ29kZVN0YXJ0ID0gdG9Ob2RlTmFtZS5jaGFyQ29kZUF0KDApO1xuXG4gICAgLy8gSWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGEgdmlydHVhbCBET00gbm9kZSBvciBTVkcgbm9kZSB0aGVuIHdlIG1heVxuICAgIC8vIG5lZWQgdG8gbm9ybWFsaXplIHRoZSB0YWcgbmFtZSBiZWZvcmUgY29tcGFyaW5nLiBOb3JtYWwgSFRNTCBlbGVtZW50cyB0aGF0IGFyZVxuICAgIC8vIGluIHRoZSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIlxuICAgIC8vIGFyZSBjb252ZXJ0ZWQgdG8gdXBwZXIgY2FzZVxuICAgIGlmIChmcm9tQ29kZVN0YXJ0IDw9IDkwICYmIHRvQ29kZVN0YXJ0ID49IDk3KSB7IC8vIGZyb20gaXMgdXBwZXIgYW5kIHRvIGlzIGxvd2VyXG4gICAgICAgIHJldHVybiBmcm9tTm9kZU5hbWUgPT09IHRvTm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2UgaWYgKHRvQ29kZVN0YXJ0IDw9IDkwICYmIGZyb21Db2RlU3RhcnQgPj0gOTcpIHsgLy8gdG8gaXMgdXBwZXIgYW5kIGZyb20gaXMgbG93ZXJcbiAgICAgICAgcmV0dXJuIHRvTm9kZU5hbWUgPT09IGZyb21Ob2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGVsZW1lbnQsIG9wdGlvbmFsbHkgd2l0aCBhIGtub3duIG5hbWVzcGFjZSBVUkkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIGVsZW1lbnQgbmFtZSwgZS5nLiAnZGl2JyBvciAnc3ZnJ1xuICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lc3BhY2VVUkldIHRoZSBlbGVtZW50J3MgbmFtZXNwYWNlIFVSSSwgaS5lLiB0aGUgdmFsdWUgb2ZcbiAqIGl0cyBgeG1sbnNgIGF0dHJpYnV0ZSBvciBpdHMgaW5mZXJyZWQgbmFtZXNwYWNlLlxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyhuYW1lLCBuYW1lc3BhY2VVUkkpIHtcbiAgICByZXR1cm4gIW5hbWVzcGFjZVVSSSB8fCBuYW1lc3BhY2VVUkkgPT09IE5TX1hIVE1MID9cbiAgICAgICAgZG9jLmNyZWF0ZUVsZW1lbnQobmFtZSkgOlxuICAgICAgICBkb2MuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgbmFtZSk7XG59XG5cbi8qKlxuICogQ29waWVzIHRoZSBjaGlsZHJlbiBvZiBvbmUgRE9NIGVsZW1lbnQgdG8gYW5vdGhlciBET00gZWxlbWVudFxuICovXG5mdW5jdGlvbiBtb3ZlQ2hpbGRyZW4oZnJvbUVsLCB0b0VsKSB7XG4gICAgdmFyIGN1ckNoaWxkID0gZnJvbUVsLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGN1ckNoaWxkKSB7XG4gICAgICAgIHZhciBuZXh0Q2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgdG9FbC5hcHBlbmRDaGlsZChjdXJDaGlsZCk7XG4gICAgICAgIGN1ckNoaWxkID0gbmV4dENoaWxkO1xuICAgIH1cbiAgICByZXR1cm4gdG9FbDtcbn1cblxuZnVuY3Rpb24gc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsIG5hbWUpIHtcbiAgICBpZiAoZnJvbUVsW25hbWVdICE9PSB0b0VsW25hbWVdKSB7XG4gICAgICAgIGZyb21FbFtuYW1lXSA9IHRvRWxbbmFtZV07XG4gICAgICAgIGlmIChmcm9tRWxbbmFtZV0pIHtcbiAgICAgICAgICAgIGZyb21FbC5zZXRBdHRyaWJ1dGUobmFtZSwgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJvbUVsLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIHNwZWNpYWxFbEhhbmRsZXJzID0ge1xuICAgIE9QVElPTjogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICAgIHZhciBwYXJlbnROb2RlID0gZnJvbUVsLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50TmFtZSA9IHBhcmVudE5vZGUubm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnROYW1lID09PSAnT1BUR1JPVVAnKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBwYXJlbnROYW1lID0gcGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50TmFtZSA9PT0gJ1NFTEVDVCcgJiYgIXBhcmVudE5vZGUuaGFzQXR0cmlidXRlKCdtdWx0aXBsZScpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyb21FbC5oYXNBdHRyaWJ1dGUoJ3NlbGVjdGVkJykgJiYgIXRvRWwuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgTVMgRWRnZSBidWcgd2hlcmUgdGhlICdzZWxlY3RlZCcgYXR0cmlidXRlIGNhbiBvbmx5IGJlXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZWQgaWYgc2V0IHRvIGEgbm9uLWVtcHR5IHZhbHVlOlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMjA4NzY3OS9cbiAgICAgICAgICAgICAgICAgICAgZnJvbUVsLnNldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnLCAnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbUVsLnJlbW92ZUF0dHJpYnV0ZSgnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byByZXNldCBzZWxlY3QgZWxlbWVudCdzIHNlbGVjdGVkSW5kZXggdG8gLTEsIG90aGVyd2lzZSBzZXR0aW5nXG4gICAgICAgICAgICAgICAgLy8gZnJvbUVsLnNlbGVjdGVkIHVzaW5nIHRoZSBzeW5jQm9vbGVhbkF0dHJQcm9wIGJlbG93IGhhcyBubyBlZmZlY3QuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGNvcnJlY3Qgc2VsZWN0ZWRJbmRleCB3aWxsIGJlIHNldCBpbiB0aGUgU0VMRUNUIHNwZWNpYWwgaGFuZGxlciBiZWxvdy5cbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzeW5jQm9vbGVhbkF0dHJQcm9wKGZyb21FbCwgdG9FbCwgJ3NlbGVjdGVkJyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgXCJ2YWx1ZVwiIGF0dHJpYnV0ZSBpcyBzcGVjaWFsIGZvciB0aGUgPGlucHV0PiBlbGVtZW50IHNpbmNlIGl0IHNldHNcbiAgICAgKiB0aGUgaW5pdGlhbCB2YWx1ZS4gQ2hhbmdpbmcgdGhlIFwidmFsdWVcIiBhdHRyaWJ1dGUgd2l0aG91dCBjaGFuZ2luZyB0aGVcbiAgICAgKiBcInZhbHVlXCIgcHJvcGVydHkgd2lsbCBoYXZlIG5vIGVmZmVjdCBzaW5jZSBpdCBpcyBvbmx5IHVzZWQgdG8gdGhlIHNldCB0aGVcbiAgICAgKiBpbml0aWFsIHZhbHVlLiAgU2ltaWxhciBmb3IgdGhlIFwiY2hlY2tlZFwiIGF0dHJpYnV0ZSwgYW5kIFwiZGlzYWJsZWRcIi5cbiAgICAgKi9cbiAgICBJTlBVVDogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICAgIHN5bmNCb29sZWFuQXR0clByb3AoZnJvbUVsLCB0b0VsLCAnY2hlY2tlZCcpO1xuICAgICAgICBzeW5jQm9vbGVhbkF0dHJQcm9wKGZyb21FbCwgdG9FbCwgJ2Rpc2FibGVkJyk7XG5cbiAgICAgICAgaWYgKGZyb21FbC52YWx1ZSAhPT0gdG9FbC52YWx1ZSkge1xuICAgICAgICAgICAgZnJvbUVsLnZhbHVlID0gdG9FbC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdG9FbC5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgIGZyb21FbC5yZW1vdmVBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgVEVYVEFSRUE6IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSB0b0VsLnZhbHVlO1xuICAgICAgICBpZiAoZnJvbUVsLnZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgZnJvbUVsLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlyc3RDaGlsZCA9IGZyb21FbC5maXJzdENoaWxkO1xuICAgICAgICBpZiAoZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgLy8gTmVlZGVkIGZvciBJRS4gQXBwYXJlbnRseSBJRSBzZXRzIHRoZSBwbGFjZWhvbGRlciBhcyB0aGVcbiAgICAgICAgICAgIC8vIG5vZGUgdmFsdWUgYW5kIHZpc2UgdmVyc2EuIFRoaXMgaWdub3JlcyBhbiBlbXB0eSB1cGRhdGUuXG4gICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSBmaXJzdENoaWxkLm5vZGVWYWx1ZTtcblxuICAgICAgICAgICAgaWYgKG9sZFZhbHVlID09IG5ld1ZhbHVlIHx8ICghbmV3VmFsdWUgJiYgb2xkVmFsdWUgPT0gZnJvbUVsLnBsYWNlaG9sZGVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgU0VMRUNUOiBmdW5jdGlvbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgICAgaWYgKCF0b0VsLmhhc0F0dHJpYnV0ZSgnbXVsdGlwbGUnKSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gbG9vcCB0aHJvdWdoIGNoaWxkcmVuIG9mIGZyb21FbCwgbm90IHRvRWwgc2luY2Ugbm9kZXMgY2FuIGJlIG1vdmVkXG4gICAgICAgICAgICAvLyBmcm9tIHRvRWwgdG8gZnJvbUVsIGRpcmVjdGx5IHdoZW4gbW9ycGhpbmcuXG4gICAgICAgICAgICAvLyBBdCB0aGUgdGltZSB0aGlzIHNwZWNpYWwgaGFuZGxlciBpcyBpbnZva2VkLCBhbGwgY2hpbGRyZW4gaGF2ZSBhbHJlYWR5IGJlZW4gbW9ycGhlZFxuICAgICAgICAgICAgLy8gYW5kIGFwcGVuZGVkIHRvIC8gcmVtb3ZlZCBmcm9tIGZyb21FbCwgc28gdXNpbmcgZnJvbUVsIGhlcmUgaXMgc2FmZSBhbmQgY29ycmVjdC5cbiAgICAgICAgICAgIHZhciBjdXJDaGlsZCA9IGZyb21FbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgdmFyIG9wdGdyb3VwO1xuICAgICAgICAgICAgdmFyIG5vZGVOYW1lO1xuICAgICAgICAgICAgd2hpbGUoY3VyQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICBub2RlTmFtZSA9IGN1ckNoaWxkLm5vZGVOYW1lICYmIGN1ckNoaWxkLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnT1BUR1JPVVAnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGdyb3VwID0gY3VyQ2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gb3B0Z3JvdXAuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZU5hbWUgPT09ICdPUFRJT04nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyQ2hpbGQuaGFzQXR0cmlidXRlKCdzZWxlY3RlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJDaGlsZCAmJiBvcHRncm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBvcHRncm91cC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGdyb3VwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnJvbUVsLnNlbGVjdGVkSW5kZXggPSBzZWxlY3RlZEluZGV4O1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIEVMRU1FTlRfTk9ERSA9IDE7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSQxID0gMTE7XG52YXIgVEVYVF9OT0RFID0gMztcbnZhciBDT01NRU5UX05PREUgPSA4O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gZGVmYXVsdEdldE5vZGVLZXkobm9kZSkge1xuICBpZiAobm9kZSkge1xuICAgIHJldHVybiAobm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ2lkJykpIHx8IG5vZGUuaWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbW9ycGhkb21GYWN0b3J5KG1vcnBoQXR0cnMpIHtcblxuICByZXR1cm4gZnVuY3Rpb24gbW9ycGhkb20oZnJvbU5vZGUsIHRvTm9kZSwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdG9Ob2RlID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKGZyb21Ob2RlLm5vZGVOYW1lID09PSAnI2RvY3VtZW50JyB8fCBmcm9tTm9kZS5ub2RlTmFtZSA9PT0gJ0hUTUwnIHx8IGZyb21Ob2RlLm5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgdmFyIHRvTm9kZUh0bWwgPSB0b05vZGU7XG4gICAgICAgIHRvTm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdodG1sJyk7XG4gICAgICAgIHRvTm9kZS5pbm5lckhUTUwgPSB0b05vZGVIdG1sO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9Ob2RlID0gdG9FbGVtZW50KHRvTm9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0b05vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUkMSkge1xuICAgICAgdG9Ob2RlID0gdG9Ob2RlLmZpcnN0RWxlbWVudENoaWxkO1xuICAgIH1cblxuICAgIHZhciBnZXROb2RlS2V5ID0gb3B0aW9ucy5nZXROb2RlS2V5IHx8IGRlZmF1bHRHZXROb2RlS2V5O1xuICAgIHZhciBvbkJlZm9yZU5vZGVBZGRlZCA9IG9wdGlvbnMub25CZWZvcmVOb2RlQWRkZWQgfHwgbm9vcDtcbiAgICB2YXIgb25Ob2RlQWRkZWQgPSBvcHRpb25zLm9uTm9kZUFkZGVkIHx8IG5vb3A7XG4gICAgdmFyIG9uQmVmb3JlRWxVcGRhdGVkID0gb3B0aW9ucy5vbkJlZm9yZUVsVXBkYXRlZCB8fCBub29wO1xuICAgIHZhciBvbkVsVXBkYXRlZCA9IG9wdGlvbnMub25FbFVwZGF0ZWQgfHwgbm9vcDtcbiAgICB2YXIgb25CZWZvcmVOb2RlRGlzY2FyZGVkID0gb3B0aW9ucy5vbkJlZm9yZU5vZGVEaXNjYXJkZWQgfHwgbm9vcDtcbiAgICB2YXIgb25Ob2RlRGlzY2FyZGVkID0gb3B0aW9ucy5vbk5vZGVEaXNjYXJkZWQgfHwgbm9vcDtcbiAgICB2YXIgb25CZWZvcmVFbENoaWxkcmVuVXBkYXRlZCA9IG9wdGlvbnMub25CZWZvcmVFbENoaWxkcmVuVXBkYXRlZCB8fCBub29wO1xuICAgIHZhciBza2lwRnJvbUNoaWxkcmVuID0gb3B0aW9ucy5za2lwRnJvbUNoaWxkcmVuIHx8IG5vb3A7XG4gICAgdmFyIGFkZENoaWxkID0gb3B0aW9ucy5hZGRDaGlsZCB8fCBmdW5jdGlvbihwYXJlbnQsIGNoaWxkKXsgcmV0dXJuIHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZCk7IH07XG4gICAgdmFyIGNoaWxkcmVuT25seSA9IG9wdGlvbnMuY2hpbGRyZW5Pbmx5ID09PSB0cnVlO1xuXG4gICAgLy8gVGhpcyBvYmplY3QgaXMgdXNlZCBhcyBhIGxvb2t1cCB0byBxdWlja2x5IGZpbmQgYWxsIGtleWVkIGVsZW1lbnRzIGluIHRoZSBvcmlnaW5hbCBET00gdHJlZS5cbiAgICB2YXIgZnJvbU5vZGVzTG9va3VwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIga2V5ZWRSZW1vdmFsTGlzdCA9IFtdO1xuXG4gICAgZnVuY3Rpb24gYWRkS2V5ZWRSZW1vdmFsKGtleSkge1xuICAgICAga2V5ZWRSZW1vdmFsTGlzdC5wdXNoKGtleSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fsa0Rpc2NhcmRlZENoaWxkTm9kZXMobm9kZSwgc2tpcEtleWVkTm9kZXMpIHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgdmFyIGN1ckNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcblxuICAgICAgICAgIHZhciBrZXkgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAoc2tpcEtleWVkTm9kZXMgJiYgKGtleSA9IGdldE5vZGVLZXkoY3VyQ2hpbGQpKSkge1xuICAgICAgICAgICAgLy8gSWYgd2UgYXJlIHNraXBwaW5nIGtleWVkIG5vZGVzIHRoZW4gd2UgYWRkIHRoZSBrZXlcbiAgICAgICAgICAgIC8vIHRvIGEgbGlzdCBzbyB0aGF0IGl0IGNhbiBiZSBoYW5kbGVkIGF0IHRoZSB2ZXJ5IGVuZC5cbiAgICAgICAgICAgIGFkZEtleWVkUmVtb3ZhbChrZXkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPbmx5IHJlcG9ydCB0aGUgbm9kZSBhcyBkaXNjYXJkZWQgaWYgaXQgaXMgbm90IGtleWVkLiBXZSBkbyB0aGlzIGJlY2F1c2VcbiAgICAgICAgICAgIC8vIGF0IHRoZSBlbmQgd2UgbG9vcCB0aHJvdWdoIGFsbCBrZXllZCBlbGVtZW50cyB0aGF0IHdlcmUgdW5tYXRjaGVkXG4gICAgICAgICAgICAvLyBhbmQgdGhlbiBkaXNjYXJkIHRoZW0gaW4gb25lIGZpbmFsIHBhc3MuXG4gICAgICAgICAgICBvbk5vZGVEaXNjYXJkZWQoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgaWYgKGN1ckNoaWxkLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgd2Fsa0Rpc2NhcmRlZENoaWxkTm9kZXMoY3VyQ2hpbGQsIHNraXBLZXllZE5vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJDaGlsZCA9IGN1ckNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBSZW1vdmVzIGEgRE9NIG5vZGUgb3V0IG9mIHRoZSBvcmlnaW5hbCBET01cbiAgICAqXG4gICAgKiBAcGFyYW0gIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZVxuICAgICogQHBhcmFtICB7Tm9kZX0gcGFyZW50Tm9kZSBUaGUgbm9kZXMgcGFyZW50XG4gICAgKiBAcGFyYW0gIHtCb29sZWFufSBza2lwS2V5ZWROb2RlcyBJZiB0cnVlIHRoZW4gZWxlbWVudHMgd2l0aCBrZXlzIHdpbGwgYmUgc2tpcHBlZCBhbmQgbm90IGRpc2NhcmRlZC5cbiAgICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZSwgcGFyZW50Tm9kZSwgc2tpcEtleWVkTm9kZXMpIHtcbiAgICAgIGlmIChvbkJlZm9yZU5vZGVEaXNjYXJkZWQobm9kZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgIH1cblxuICAgICAgb25Ob2RlRGlzY2FyZGVkKG5vZGUpO1xuICAgICAgd2Fsa0Rpc2NhcmRlZENoaWxkTm9kZXMobm9kZSwgc2tpcEtleWVkTm9kZXMpO1xuICAgIH1cblxuICAgIC8vIC8vIFRyZWVXYWxrZXIgaW1wbGVtZW50YXRpb24gaXMgbm8gZmFzdGVyLCBidXQga2VlcGluZyB0aGlzIGFyb3VuZCBpbiBjYXNlIHRoaXMgY2hhbmdlcyBpbiB0aGUgZnV0dXJlXG4gICAgLy8gZnVuY3Rpb24gaW5kZXhUcmVlKHJvb3QpIHtcbiAgICAvLyAgICAgdmFyIHRyZWVXYWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKFxuICAgIC8vICAgICAgICAgcm9vdCxcbiAgICAvLyAgICAgICAgIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UKTtcbiAgICAvL1xuICAgIC8vICAgICB2YXIgZWw7XG4gICAgLy8gICAgIHdoaWxlKChlbCA9IHRyZWVXYWxrZXIubmV4dE5vZGUoKSkpIHtcbiAgICAvLyAgICAgICAgIHZhciBrZXkgPSBnZXROb2RlS2V5KGVsKTtcbiAgICAvLyAgICAgICAgIGlmIChrZXkpIHtcbiAgICAvLyAgICAgICAgICAgICBmcm9tTm9kZXNMb29rdXBba2V5XSA9IGVsO1xuICAgIC8vICAgICAgICAgfVxuICAgIC8vICAgICB9XG4gICAgLy8gfVxuXG4gICAgLy8gLy8gTm9kZUl0ZXJhdG9yIGltcGxlbWVudGF0aW9uIGlzIG5vIGZhc3RlciwgYnV0IGtlZXBpbmcgdGhpcyBhcm91bmQgaW4gY2FzZSB0aGlzIGNoYW5nZXMgaW4gdGhlIGZ1dHVyZVxuICAgIC8vXG4gICAgLy8gZnVuY3Rpb24gaW5kZXhUcmVlKG5vZGUpIHtcbiAgICAvLyAgICAgdmFyIG5vZGVJdGVyYXRvciA9IGRvY3VtZW50LmNyZWF0ZU5vZGVJdGVyYXRvcihub2RlLCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCk7XG4gICAgLy8gICAgIHZhciBlbDtcbiAgICAvLyAgICAgd2hpbGUoKGVsID0gbm9kZUl0ZXJhdG9yLm5leHROb2RlKCkpKSB7XG4gICAgLy8gICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShlbCk7XG4gICAgLy8gICAgICAgICBpZiAoa2V5KSB7XG4gICAgLy8gICAgICAgICAgICAgZnJvbU5vZGVzTG9va3VwW2tleV0gPSBlbDtcbiAgICAvLyAgICAgICAgIH1cbiAgICAvLyAgICAgfVxuICAgIC8vIH1cblxuICAgIGZ1bmN0aW9uIGluZGV4VHJlZShub2RlKSB7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUkMSkge1xuICAgICAgICB2YXIgY3VyQ2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHdoaWxlIChjdXJDaGlsZCkge1xuICAgICAgICAgIHZhciBrZXkgPSBnZXROb2RlS2V5KGN1ckNoaWxkKTtcbiAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBmcm9tTm9kZXNMb29rdXBba2V5XSA9IGN1ckNoaWxkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFdhbGsgcmVjdXJzaXZlbHlcbiAgICAgICAgICBpbmRleFRyZWUoY3VyQ2hpbGQpO1xuXG4gICAgICAgICAgY3VyQ2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGluZGV4VHJlZShmcm9tTm9kZSk7XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVOb2RlQWRkZWQoZWwpIHtcbiAgICAgIG9uTm9kZUFkZGVkKGVsKTtcblxuICAgICAgdmFyIGN1ckNoaWxkID0gZWwuZmlyc3RDaGlsZDtcbiAgICAgIHdoaWxlIChjdXJDaGlsZCkge1xuICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBjdXJDaGlsZC5uZXh0U2libGluZztcblxuICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShjdXJDaGlsZCk7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICB2YXIgdW5tYXRjaGVkRnJvbUVsID0gZnJvbU5vZGVzTG9va3VwW2tleV07XG4gICAgICAgICAgLy8gaWYgd2UgZmluZCBhIGR1cGxpY2F0ZSAjaWQgbm9kZSBpbiBjYWNoZSwgcmVwbGFjZSBgZWxgIHdpdGggY2FjaGUgdmFsdWVcbiAgICAgICAgICAvLyBhbmQgbW9ycGggaXQgdG8gdGhlIGNoaWxkIG5vZGUuXG4gICAgICAgICAgaWYgKHVubWF0Y2hlZEZyb21FbCAmJiBjb21wYXJlTm9kZU5hbWVzKGN1ckNoaWxkLCB1bm1hdGNoZWRGcm9tRWwpKSB7XG4gICAgICAgICAgICBjdXJDaGlsZC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh1bm1hdGNoZWRGcm9tRWwsIGN1ckNoaWxkKTtcbiAgICAgICAgICAgIG1vcnBoRWwodW5tYXRjaGVkRnJvbUVsLCBjdXJDaGlsZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZU5vZGVBZGRlZChjdXJDaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGNhbGwgZm9yIGN1ckNoaWxkIGFuZCBpdCdzIGNoaWxkcmVuIHRvIHNlZSBpZiB3ZSBmaW5kIHNvbWV0aGluZyBpblxuICAgICAgICAgIC8vIGZyb21Ob2Rlc0xvb2t1cFxuICAgICAgICAgIGhhbmRsZU5vZGVBZGRlZChjdXJDaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJDaGlsZCA9IG5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFudXBGcm9tRWwoZnJvbUVsLCBjdXJGcm9tTm9kZUNoaWxkLCBjdXJGcm9tTm9kZUtleSkge1xuICAgICAgLy8gV2UgaGF2ZSBwcm9jZXNzZWQgYWxsIG9mIHRoZSBcInRvIG5vZGVzXCIuIElmIGN1ckZyb21Ob2RlQ2hpbGQgaXNcbiAgICAgIC8vIG5vbi1udWxsIHRoZW4gd2Ugc3RpbGwgaGF2ZSBzb21lIGZyb20gbm9kZXMgbGVmdCBvdmVyIHRoYXQgbmVlZFxuICAgICAgLy8gdG8gYmUgcmVtb3ZlZFxuICAgICAgd2hpbGUgKGN1ckZyb21Ob2RlQ2hpbGQpIHtcbiAgICAgICAgdmFyIGZyb21OZXh0U2libGluZyA9IGN1ckZyb21Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgIGlmICgoY3VyRnJvbU5vZGVLZXkgPSBnZXROb2RlS2V5KGN1ckZyb21Ob2RlQ2hpbGQpKSkge1xuICAgICAgICAgIC8vIFNpbmNlIHRoZSBub2RlIGlzIGtleWVkIGl0IG1pZ2h0IGJlIG1hdGNoZWQgdXAgbGF0ZXIgc28gd2UgZGVmZXJcbiAgICAgICAgICAvLyB0aGUgYWN0dWFsIHJlbW92YWwgdG8gbGF0ZXJcbiAgICAgICAgICBhZGRLZXllZFJlbW92YWwoY3VyRnJvbU5vZGVLZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5PVEU6IHdlIHNraXAgbmVzdGVkIGtleWVkIG5vZGVzIGZyb20gYmVpbmcgcmVtb3ZlZCBzaW5jZSB0aGVyZSBpc1xuICAgICAgICAgIC8vICAgICAgIHN0aWxsIGEgY2hhbmNlIHRoZXkgd2lsbCBiZSBtYXRjaGVkIHVwIGxhdGVyXG4gICAgICAgICAgcmVtb3ZlTm9kZShjdXJGcm9tTm9kZUNoaWxkLCBmcm9tRWwsIHRydWUgLyogc2tpcCBrZXllZCBub2RlcyAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3JwaEVsKGZyb21FbCwgdG9FbCwgY2hpbGRyZW5Pbmx5KSB7XG4gICAgICB2YXIgdG9FbEtleSA9IGdldE5vZGVLZXkodG9FbCk7XG5cbiAgICAgIGlmICh0b0VsS2V5KSB7XG4gICAgICAgIC8vIElmIGFuIGVsZW1lbnQgd2l0aCBhbiBJRCBpcyBiZWluZyBtb3JwaGVkIHRoZW4gaXQgd2lsbCBiZSBpbiB0aGUgZmluYWxcbiAgICAgICAgLy8gRE9NIHNvIGNsZWFyIGl0IG91dCBvZiB0aGUgc2F2ZWQgZWxlbWVudHMgY29sbGVjdGlvblxuICAgICAgICBkZWxldGUgZnJvbU5vZGVzTG9va3VwW3RvRWxLZXldO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNoaWxkcmVuT25seSkge1xuICAgICAgICAvLyBvcHRpb25hbFxuICAgICAgICB2YXIgYmVmb3JlVXBkYXRlUmVzdWx0ID0gb25CZWZvcmVFbFVwZGF0ZWQoZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgaWYgKGJlZm9yZVVwZGF0ZVJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoYmVmb3JlVXBkYXRlUmVzdWx0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICBmcm9tRWwgPSBiZWZvcmVVcGRhdGVSZXN1bHQ7XG4gICAgICAgICAgLy8gcmVpbmRleCB0aGUgbmV3IGZyb21FbCBpbiBjYXNlIGl0J3Mgbm90IGluIHRoZSBzYW1lXG4gICAgICAgICAgLy8gdHJlZSBhcyB0aGUgb3JpZ2luYWwgZnJvbUVsXG4gICAgICAgICAgLy8gKFBob2VuaXggTGl2ZVZpZXcgc29tZXRpbWVzIHJldHVybnMgYSBjbG9uZWQgdHJlZSxcbiAgICAgICAgICAvLyAgYnV0IGtleWVkIGxvb2t1cHMgd291bGQgc3RpbGwgcG9pbnQgdG8gdGhlIG9yaWdpbmFsIHRyZWUpXG4gICAgICAgICAgaW5kZXhUcmVlKGZyb21FbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgYXR0cmlidXRlcyBvbiBvcmlnaW5hbCBET00gZWxlbWVudCBmaXJzdFxuICAgICAgICBtb3JwaEF0dHJzKGZyb21FbCwgdG9FbCk7XG4gICAgICAgIC8vIG9wdGlvbmFsXG4gICAgICAgIG9uRWxVcGRhdGVkKGZyb21FbCk7XG5cbiAgICAgICAgaWYgKG9uQmVmb3JlRWxDaGlsZHJlblVwZGF0ZWQoZnJvbUVsLCB0b0VsKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZyb21FbC5ub2RlTmFtZSAhPT0gJ1RFWFRBUkVBJykge1xuICAgICAgICBtb3JwaENoaWxkcmVuKGZyb21FbCwgdG9FbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGVjaWFsRWxIYW5kbGVycy5URVhUQVJFQShmcm9tRWwsIHRvRWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vcnBoQ2hpbGRyZW4oZnJvbUVsLCB0b0VsKSB7XG4gICAgICB2YXIgc2tpcEZyb20gPSBza2lwRnJvbUNoaWxkcmVuKGZyb21FbCwgdG9FbCk7XG4gICAgICB2YXIgY3VyVG9Ob2RlQ2hpbGQgPSB0b0VsLmZpcnN0Q2hpbGQ7XG4gICAgICB2YXIgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21FbC5maXJzdENoaWxkO1xuICAgICAgdmFyIGN1clRvTm9kZUtleTtcbiAgICAgIHZhciBjdXJGcm9tTm9kZUtleTtcblxuICAgICAgdmFyIGZyb21OZXh0U2libGluZztcbiAgICAgIHZhciB0b05leHRTaWJsaW5nO1xuICAgICAgdmFyIG1hdGNoaW5nRnJvbUVsO1xuXG4gICAgICAvLyB3YWxrIHRoZSBjaGlsZHJlblxuICAgICAgb3V0ZXI6IHdoaWxlIChjdXJUb05vZGVDaGlsZCkge1xuICAgICAgICB0b05leHRTaWJsaW5nID0gY3VyVG9Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgIGN1clRvTm9kZUtleSA9IGdldE5vZGVLZXkoY3VyVG9Ob2RlQ2hpbGQpO1xuXG4gICAgICAgIC8vIHdhbGsgdGhlIGZyb21Ob2RlIGNoaWxkcmVuIGFsbCB0aGUgd2F5IHRocm91Z2hcbiAgICAgICAgd2hpbGUgKCFza2lwRnJvbSAmJiBjdXJGcm9tTm9kZUNoaWxkKSB7XG4gICAgICAgICAgZnJvbU5leHRTaWJsaW5nID0gY3VyRnJvbU5vZGVDaGlsZC5uZXh0U2libGluZztcblxuICAgICAgICAgIGlmIChjdXJUb05vZGVDaGlsZC5pc1NhbWVOb2RlICYmIGN1clRvTm9kZUNoaWxkLmlzU2FtZU5vZGUoY3VyRnJvbU5vZGVDaGlsZCkpIHtcbiAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gdG9OZXh0U2libGluZztcbiAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJGcm9tTm9kZUtleSA9IGdldE5vZGVLZXkoY3VyRnJvbU5vZGVDaGlsZCk7XG5cbiAgICAgICAgICB2YXIgY3VyRnJvbU5vZGVUeXBlID0gY3VyRnJvbU5vZGVDaGlsZC5ub2RlVHlwZTtcblxuICAgICAgICAgIC8vIHRoaXMgbWVhbnMgaWYgdGhlIGN1ckZyb21Ob2RlQ2hpbGQgZG9lc250IGhhdmUgYSBtYXRjaCB3aXRoIHRoZSBjdXJUb05vZGVDaGlsZFxuICAgICAgICAgIHZhciBpc0NvbXBhdGlibGUgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVUeXBlID09PSBjdXJUb05vZGVDaGlsZC5ub2RlVHlwZSkge1xuICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgIC8vIEJvdGggbm9kZXMgYmVpbmcgY29tcGFyZWQgYXJlIEVsZW1lbnQgbm9kZXNcblxuICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHRhcmdldCBub2RlIGhhcyBhIGtleSBzbyB3ZSB3YW50IHRvIG1hdGNoIGl0IHVwIHdpdGggdGhlIGNvcnJlY3QgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIGluIHRoZSBvcmlnaW5hbCBET00gdHJlZVxuICAgICAgICAgICAgICAgIGlmIChjdXJUb05vZGVLZXkgIT09IGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgY3VycmVudCBlbGVtZW50IGluIHRoZSBvcmlnaW5hbCBET00gdHJlZSBkb2VzIG5vdCBoYXZlIGEgbWF0Y2hpbmcga2V5IHNvXG4gICAgICAgICAgICAgICAgICAvLyBsZXQncyBjaGVjayBvdXIgbG9va3VwIHRvIHNlZSBpZiB0aGVyZSBpcyBhIG1hdGNoaW5nIGVsZW1lbnQgaW4gdGhlIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgICAvLyBET00gdHJlZVxuICAgICAgICAgICAgICAgICAgaWYgKChtYXRjaGluZ0Zyb21FbCA9IGZyb21Ob2Rlc0xvb2t1cFtjdXJUb05vZGVLZXldKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbU5leHRTaWJsaW5nID09PSBtYXRjaGluZ0Zyb21FbCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3Igc2luZ2xlIGVsZW1lbnQgcmVtb3ZhbHMuIFRvIGF2b2lkIHJlbW92aW5nIHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgICAgICAgICAgIC8vIERPTSBub2RlIG91dCBvZiB0aGUgdHJlZSAoc2luY2UgdGhhdCBjYW4gYnJlYWsgQ1NTIHRyYW5zaXRpb25zLCBldGMuKSxcbiAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSB3aWxsIGluc3RlYWQgZGlzY2FyZCB0aGUgY3VycmVudCBub2RlIGFuZCB3YWl0IHVudGlsIHRoZSBuZXh0XG4gICAgICAgICAgICAgICAgICAgICAgLy8gaXRlcmF0aW9uIHRvIHByb3Blcmx5IG1hdGNoIHVwIHRoZSBrZXllZCB0YXJnZXQgZWxlbWVudCB3aXRoIGl0cyBtYXRjaGluZ1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgaW4gdGhlIG9yaWdpbmFsIHRyZWVcbiAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBmb3VuZCBhIG1hdGNoaW5nIGtleWVkIGVsZW1lbnQgc29tZXdoZXJlIGluIHRoZSBvcmlnaW5hbCBET00gdHJlZS5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBMZXQncyBtb3ZlIHRoZSBvcmlnaW5hbCBET00gbm9kZSBpbnRvIHRoZSBjdXJyZW50IHBvc2l0aW9uIGFuZCBtb3JwaFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGl0LlxuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogV2UgdXNlIGluc2VydEJlZm9yZSBpbnN0ZWFkIG9mIHJlcGxhY2VDaGlsZCBiZWNhdXNlIHdlIHdhbnQgdG8gZ28gdGhyb3VnaFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBgcmVtb3ZlTm9kZSgpYCBmdW5jdGlvbiBmb3IgdGhlIG5vZGUgdGhhdCBpcyBiZWluZyBkaXNjYXJkZWQgc28gdGhhdFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCBsaWZlY3ljbGUgaG9va3MgYXJlIGNvcnJlY3RseSBpbnZva2VkXG4gICAgICAgICAgICAgICAgICAgICAgZnJvbUVsLmluc2VydEJlZm9yZShtYXRjaGluZ0Zyb21FbCwgY3VyRnJvbU5vZGVDaGlsZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBmcm9tTmV4dFNpYmxpbmcgPSBjdXJGcm9tTm9kZUNoaWxkLm5leHRTaWJsaW5nO1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGUgbm9kZSBpcyBrZXllZCBpdCBtaWdodCBiZSBtYXRjaGVkIHVwIGxhdGVyIHNvIHdlIGRlZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgYWN0dWFsIHJlbW92YWwgdG8gbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEtleWVkUmVtb3ZhbChjdXJGcm9tTm9kZUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IHdlIHNraXAgbmVzdGVkIGtleWVkIG5vZGVzIGZyb20gYmVpbmcgcmVtb3ZlZCBzaW5jZSB0aGVyZSBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgc3RpbGwgYSBjaGFuY2UgdGhleSB3aWxsIGJlIG1hdGNoZWQgdXAgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoY3VyRnJvbU5vZGVDaGlsZCwgZnJvbUVsLCB0cnVlIC8qIHNraXAga2V5ZWQgbm9kZXMgKi8pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBtYXRjaGluZ0Zyb21FbDtcbiAgICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUtleSA9IGdldE5vZGVLZXkoY3VyRnJvbU5vZGVDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBub2RlcyBhcmUgbm90IGNvbXBhdGlibGUgc2luY2UgdGhlIFwidG9cIiBub2RlIGhhcyBhIGtleSBhbmQgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgbm8gbWF0Y2hpbmcga2V5ZWQgbm9kZSBpbiB0aGUgc291cmNlIHRyZWVcbiAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIG9yaWdpbmFsIGhhcyBhIGtleVxuICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gaXNDb21wYXRpYmxlICE9PSBmYWxzZSAmJiBjb21wYXJlTm9kZU5hbWVzKGN1ckZyb21Ob2RlQ2hpbGQsIGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgaWYgKGlzQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIGNvbXBhdGlibGUgRE9NIGVsZW1lbnRzIHNvIHRyYW5zZm9ybVxuICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IFwiZnJvbVwiIG5vZGUgdG8gbWF0Y2ggdGhlIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAvLyB0YXJnZXQgRE9NIG5vZGUuXG4gICAgICAgICAgICAgICAgLy8gTU9SUEhcbiAgICAgICAgICAgICAgICBtb3JwaEVsKGN1ckZyb21Ob2RlQ2hpbGQsIGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1ckZyb21Ob2RlVHlwZSA9PT0gVEVYVF9OT0RFIHx8IGN1ckZyb21Ob2RlVHlwZSA9PSBDT01NRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgLy8gQm90aCBub2RlcyBiZWluZyBjb21wYXJlZCBhcmUgVGV4dCBvciBDb21tZW50IG5vZGVzXG4gICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgIC8vIFNpbXBseSB1cGRhdGUgbm9kZVZhbHVlIG9uIHRoZSBvcmlnaW5hbCBub2RlIHRvXG4gICAgICAgICAgICAgIC8vIGNoYW5nZSB0aGUgdGV4dCB2YWx1ZVxuICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVDaGlsZC5ub2RlVmFsdWUgIT09IGN1clRvTm9kZUNoaWxkLm5vZGVWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQubm9kZVZhbHVlID0gY3VyVG9Ob2RlQ2hpbGQubm9kZVZhbHVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNDb21wYXRpYmxlKSB7XG4gICAgICAgICAgICAvLyBBZHZhbmNlIGJvdGggdGhlIFwidG9cIiBjaGlsZCBhbmQgdGhlIFwiZnJvbVwiIGNoaWxkIHNpbmNlIHdlIGZvdW5kIGEgbWF0Y2hcbiAgICAgICAgICAgIC8vIE5vdGhpbmcgZWxzZSB0byBkbyBhcyB3ZSBhbHJlYWR5IHJlY3Vyc2l2ZWx5IGNhbGxlZCBtb3JwaENoaWxkcmVuIGFib3ZlXG4gICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IHRvTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTm8gY29tcGF0aWJsZSBtYXRjaCBzbyByZW1vdmUgdGhlIG9sZCBub2RlIGZyb20gdGhlIERPTSBhbmQgY29udGludWUgdHJ5aW5nIHRvIGZpbmQgYVxuICAgICAgICAgIC8vIG1hdGNoIGluIHRoZSBvcmlnaW5hbCBET00uIEhvd2V2ZXIsIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgZnJvbSBub2RlIGlzIG5vdCBrZXllZFxuICAgICAgICAgIC8vIHNpbmNlIGl0IGlzIHBvc3NpYmxlIHRoYXQgYSBrZXllZCBub2RlIG1pZ2h0IG1hdGNoIHVwIHdpdGggYSBub2RlIHNvbWV3aGVyZSBlbHNlIGluIHRoZVxuICAgICAgICAgIC8vIHRhcmdldCB0cmVlIGFuZCB3ZSBkb24ndCB3YW50IHRvIGRpc2NhcmQgaXQganVzdCB5ZXQgc2luY2UgaXQgc3RpbGwgbWlnaHQgZmluZCBhXG4gICAgICAgICAgLy8gaG9tZSBpbiB0aGUgZmluYWwgRE9NIHRyZWUuIEFmdGVyIGV2ZXJ5dGhpbmcgaXMgZG9uZSB3ZSB3aWxsIHJlbW92ZSBhbnkga2V5ZWQgbm9kZXNcbiAgICAgICAgICAvLyB0aGF0IGRpZG4ndCBmaW5kIGEgaG9tZVxuICAgICAgICAgIGlmIChjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgLy8gU2luY2UgdGhlIG5vZGUgaXMga2V5ZWQgaXQgbWlnaHQgYmUgbWF0Y2hlZCB1cCBsYXRlciBzbyB3ZSBkZWZlclxuICAgICAgICAgICAgLy8gdGhlIGFjdHVhbCByZW1vdmFsIHRvIGxhdGVyXG4gICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoY3VyRnJvbU5vZGVLZXkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBOT1RFOiB3ZSBza2lwIG5lc3RlZCBrZXllZCBub2RlcyBmcm9tIGJlaW5nIHJlbW92ZWQgc2luY2UgdGhlcmUgaXNcbiAgICAgICAgICAgIC8vICAgICAgIHN0aWxsIGEgY2hhbmNlIHRoZXkgd2lsbCBiZSBtYXRjaGVkIHVwIGxhdGVyXG4gICAgICAgICAgICByZW1vdmVOb2RlKGN1ckZyb21Ob2RlQ2hpbGQsIGZyb21FbCwgdHJ1ZSAvKiBza2lwIGtleWVkIG5vZGVzICovKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICB9IC8vIEVORDogd2hpbGUoY3VyRnJvbU5vZGVDaGlsZCkge31cblxuICAgICAgICAvLyBJZiB3ZSBnb3QgdGhpcyBmYXIgdGhlbiB3ZSBkaWQgbm90IGZpbmQgYSBjYW5kaWRhdGUgbWF0Y2ggZm9yXG4gICAgICAgIC8vIG91ciBcInRvIG5vZGVcIiBhbmQgd2UgZXhoYXVzdGVkIGFsbCBvZiB0aGUgY2hpbGRyZW4gXCJmcm9tXCJcbiAgICAgICAgLy8gbm9kZXMuIFRoZXJlZm9yZSwgd2Ugd2lsbCBqdXN0IGFwcGVuZCB0aGUgY3VycmVudCBcInRvXCIgbm9kZVxuICAgICAgICAvLyB0byB0aGUgZW5kXG4gICAgICAgIGlmIChjdXJUb05vZGVLZXkgJiYgKG1hdGNoaW5nRnJvbUVsID0gZnJvbU5vZGVzTG9va3VwW2N1clRvTm9kZUtleV0pICYmIGNvbXBhcmVOb2RlTmFtZXMobWF0Y2hpbmdGcm9tRWwsIGN1clRvTm9kZUNoaWxkKSkge1xuICAgICAgICAgIC8vIE1PUlBIXG4gICAgICAgICAgaWYoIXNraXBGcm9tKXsgYWRkQ2hpbGQoZnJvbUVsLCBtYXRjaGluZ0Zyb21FbCk7IH1cbiAgICAgICAgICBtb3JwaEVsKG1hdGNoaW5nRnJvbUVsLCBjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG9uQmVmb3JlTm9kZUFkZGVkUmVzdWx0ID0gb25CZWZvcmVOb2RlQWRkZWQoY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgIGlmIChvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdCkge1xuICAgICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IG9uQmVmb3JlTm9kZUFkZGVkUmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VyVG9Ob2RlQ2hpbGQuYWN0dWFsaXplKSB7XG4gICAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gY3VyVG9Ob2RlQ2hpbGQuYWN0dWFsaXplKGZyb21FbC5vd25lckRvY3VtZW50IHx8IGRvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRDaGlsZChmcm9tRWwsIGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgIGhhbmRsZU5vZGVBZGRlZChjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSB0b05leHRTaWJsaW5nO1xuICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBjbGVhbnVwRnJvbUVsKGZyb21FbCwgY3VyRnJvbU5vZGVDaGlsZCwgY3VyRnJvbU5vZGVLZXkpO1xuXG4gICAgICB2YXIgc3BlY2lhbEVsSGFuZGxlciA9IHNwZWNpYWxFbEhhbmRsZXJzW2Zyb21FbC5ub2RlTmFtZV07XG4gICAgICBpZiAoc3BlY2lhbEVsSGFuZGxlcikge1xuICAgICAgICBzcGVjaWFsRWxIYW5kbGVyKGZyb21FbCwgdG9FbCk7XG4gICAgICB9XG4gICAgfSAvLyBFTkQ6IG1vcnBoQ2hpbGRyZW4oLi4uKVxuXG4gICAgdmFyIG1vcnBoZWROb2RlID0gZnJvbU5vZGU7XG4gICAgdmFyIG1vcnBoZWROb2RlVHlwZSA9IG1vcnBoZWROb2RlLm5vZGVUeXBlO1xuICAgIHZhciB0b05vZGVUeXBlID0gdG9Ob2RlLm5vZGVUeXBlO1xuXG4gICAgaWYgKCFjaGlsZHJlbk9ubHkpIHtcbiAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSB3ZSBhcmUgZ2l2ZW4gdHdvIERPTSBub2RlcyB0aGF0IGFyZSBub3RcbiAgICAgIC8vIGNvbXBhdGlibGUgKGUuZy4gPGRpdj4gLS0+IDxzcGFuPiBvciA8ZGl2PiAtLT4gVEVYVClcbiAgICAgIGlmIChtb3JwaGVkTm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICBpZiAodG9Ob2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgaWYgKCFjb21wYXJlTm9kZU5hbWVzKGZyb21Ob2RlLCB0b05vZGUpKSB7XG4gICAgICAgICAgICBvbk5vZGVEaXNjYXJkZWQoZnJvbU5vZGUpO1xuICAgICAgICAgICAgbW9ycGhlZE5vZGUgPSBtb3ZlQ2hpbGRyZW4oZnJvbU5vZGUsIGNyZWF0ZUVsZW1lbnROUyh0b05vZGUubm9kZU5hbWUsIHRvTm9kZS5uYW1lc3BhY2VVUkkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gR29pbmcgZnJvbSBhbiBlbGVtZW50IG5vZGUgdG8gYSB0ZXh0IG5vZGVcbiAgICAgICAgICBtb3JwaGVkTm9kZSA9IHRvTm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChtb3JwaGVkTm9kZVR5cGUgPT09IFRFWFRfTk9ERSB8fCBtb3JwaGVkTm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkgeyAvLyBUZXh0IG9yIGNvbW1lbnQgbm9kZVxuICAgICAgICBpZiAodG9Ob2RlVHlwZSA9PT0gbW9ycGhlZE5vZGVUeXBlKSB7XG4gICAgICAgICAgaWYgKG1vcnBoZWROb2RlLm5vZGVWYWx1ZSAhPT0gdG9Ob2RlLm5vZGVWYWx1ZSkge1xuICAgICAgICAgICAgbW9ycGhlZE5vZGUubm9kZVZhbHVlID0gdG9Ob2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbW9ycGhlZE5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGV4dCBub2RlIHRvIHNvbWV0aGluZyBlbHNlXG4gICAgICAgICAgbW9ycGhlZE5vZGUgPSB0b05vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9ycGhlZE5vZGUgPT09IHRvTm9kZSkge1xuICAgICAgLy8gVGhlIFwidG8gbm9kZVwiIHdhcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSBcImZyb20gbm9kZVwiIHNvIHdlIGhhZCB0b1xuICAgICAgLy8gdG9zcyBvdXQgdGhlIFwiZnJvbSBub2RlXCIgYW5kIHVzZSB0aGUgXCJ0byBub2RlXCJcbiAgICAgIG9uTm9kZURpc2NhcmRlZChmcm9tTm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0b05vZGUuaXNTYW1lTm9kZSAmJiB0b05vZGUuaXNTYW1lTm9kZShtb3JwaGVkTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBtb3JwaEVsKG1vcnBoZWROb2RlLCB0b05vZGUsIGNoaWxkcmVuT25seSk7XG5cbiAgICAgIC8vIFdlIG5vdyBuZWVkIHRvIGxvb3Agb3ZlciBhbnkga2V5ZWQgbm9kZXMgdGhhdCBtaWdodCBuZWVkIHRvIGJlXG4gICAgICAvLyByZW1vdmVkLiBXZSBvbmx5IGRvIHRoZSByZW1vdmFsIGlmIHdlIGtub3cgdGhhdCB0aGUga2V5ZWQgbm9kZVxuICAgICAgLy8gbmV2ZXIgZm91bmQgYSBtYXRjaC4gV2hlbiBhIGtleWVkIG5vZGUgaXMgbWF0Y2hlZCB1cCB3ZSByZW1vdmVcbiAgICAgIC8vIGl0IG91dCBvZiBmcm9tTm9kZXNMb29rdXAgYW5kIHdlIHVzZSBmcm9tTm9kZXNMb29rdXAgdG8gZGV0ZXJtaW5lXG4gICAgICAvLyBpZiBhIGtleWVkIG5vZGUgaGFzIGJlZW4gbWF0Y2hlZCB1cCBvciBub3RcbiAgICAgIGlmIChrZXllZFJlbW92YWxMaXN0KSB7XG4gICAgICAgIGZvciAodmFyIGk9MCwgbGVuPWtleWVkUmVtb3ZhbExpc3QubGVuZ3RoOyBpPGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsVG9SZW1vdmUgPSBmcm9tTm9kZXNMb29rdXBba2V5ZWRSZW1vdmFsTGlzdFtpXV07XG4gICAgICAgICAgaWYgKGVsVG9SZW1vdmUpIHtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUoZWxUb1JlbW92ZSwgZWxUb1JlbW92ZS5wYXJlbnROb2RlLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjaGlsZHJlbk9ubHkgJiYgbW9ycGhlZE5vZGUgIT09IGZyb21Ob2RlICYmIGZyb21Ob2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIGlmIChtb3JwaGVkTm9kZS5hY3R1YWxpemUpIHtcbiAgICAgICAgbW9ycGhlZE5vZGUgPSBtb3JwaGVkTm9kZS5hY3R1YWxpemUoZnJvbU5vZGUub3duZXJEb2N1bWVudCB8fCBkb2MpO1xuICAgICAgfVxuICAgICAgLy8gSWYgd2UgaGFkIHRvIHN3YXAgb3V0IHRoZSBmcm9tIG5vZGUgd2l0aCBhIG5ldyBub2RlIGJlY2F1c2UgdGhlIG9sZFxuICAgICAgLy8gbm9kZSB3YXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgdGFyZ2V0IG5vZGUgdGhlbiB3ZSBuZWVkIHRvXG4gICAgICAvLyByZXBsYWNlIHRoZSBvbGQgRE9NIG5vZGUgaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlLiBUaGlzIGlzIG9ubHlcbiAgICAgIC8vIHBvc3NpYmxlIGlmIHRoZSBvcmlnaW5hbCBET00gbm9kZSB3YXMgcGFydCBvZiBhIERPTSB0cmVlIHdoaWNoXG4gICAgICAvLyB3ZSBrbm93IGlzIHRoZSBjYXNlIGlmIGl0IGhhcyBhIHBhcmVudCBub2RlLlxuICAgICAgZnJvbU5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobW9ycGhlZE5vZGUsIGZyb21Ob2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbW9ycGhlZE5vZGU7XG4gIH07XG59XG5cbnZhciBtb3JwaGRvbSA9IG1vcnBoZG9tRmFjdG9yeShtb3JwaEF0dHJzKTtcblxuZXhwb3J0IGRlZmF1bHQgbW9ycGhkb207XG4iLCAiaW1wb3J0IHtcbiAgUEhYX0NPTVBPTkVOVCxcbiAgUEhYX1BSVU5FLFxuICBQSFhfUk9PVF9JRCxcbiAgUEhYX1NFU1NJT04sXG4gIFBIWF9TS0lQLFxuICBQSFhfTUFHSUNfSUQsXG4gIFBIWF9TVEFUSUMsXG4gIFBIWF9UUklHR0VSX0FDVElPTixcbiAgUEhYX1VQREFURSxcbiAgUEhYX1JFRl9TUkMsXG4gIFBIWF9SRUZfTE9DSyxcbiAgUEhYX1NUUkVBTSxcbiAgUEhYX1NUUkVBTV9SRUYsXG4gIFBIWF9WSUVXUE9SVF9UT1AsXG4gIFBIWF9WSUVXUE9SVF9CT1RUT00sXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG4gIGRldGVjdER1cGxpY2F0ZUlkcyxcbiAgZGV0ZWN0SW52YWxpZFN0cmVhbUluc2VydHMsXG4gIGlzQ2lkXG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIlxuaW1wb3J0IERPTVBvc3RNb3JwaFJlc3RvcmVyIGZyb20gXCIuL2RvbV9wb3N0X21vcnBoX3Jlc3RvcmVyXCJcbmltcG9ydCBtb3JwaGRvbSBmcm9tIFwibW9ycGhkb21cIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBET01QYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHZpZXcsIGNvbnRhaW5lciwgaWQsIGh0bWwsIHN0cmVhbXMsIHRhcmdldENJRCwgb3B0cz17fSl7XG4gICAgdGhpcy52aWV3ID0gdmlld1xuICAgIHRoaXMubGl2ZVNvY2tldCA9IHZpZXcubGl2ZVNvY2tldFxuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyXG4gICAgdGhpcy5pZCA9IGlkXG4gICAgdGhpcy5yb290SUQgPSB2aWV3LnJvb3QuaWRcbiAgICB0aGlzLmh0bWwgPSBodG1sXG4gICAgdGhpcy5zdHJlYW1zID0gc3RyZWFtc1xuICAgIHRoaXMuc3RyZWFtSW5zZXJ0cyA9IHt9XG4gICAgdGhpcy5zdHJlYW1Db21wb25lbnRSZXN0b3JlID0ge31cbiAgICB0aGlzLnRhcmdldENJRCA9IHRhcmdldENJRFxuICAgIHRoaXMuY2lkUGF0Y2ggPSBpc0NpZCh0aGlzLnRhcmdldENJRClcbiAgICB0aGlzLnBlbmRpbmdSZW1vdmVzID0gW11cbiAgICB0aGlzLnBoeFJlbW92ZSA9IHRoaXMubGl2ZVNvY2tldC5iaW5kaW5nKFwicmVtb3ZlXCIpXG4gICAgdGhpcy50YXJnZXRDb250YWluZXIgPSB0aGlzLmlzQ0lEUGF0Y2goKSA/IHRoaXMudGFyZ2V0Q0lEQ29udGFpbmVyKGh0bWwpIDogY29udGFpbmVyXG4gICAgdGhpcy5jYWxsYmFja3MgPSB7XG4gICAgICBiZWZvcmVhZGRlZDogW10sIGJlZm9yZXVwZGF0ZWQ6IFtdLCBiZWZvcmVwaHhDaGlsZEFkZGVkOiBbXSxcbiAgICAgIGFmdGVyYWRkZWQ6IFtdLCBhZnRlcnVwZGF0ZWQ6IFtdLCBhZnRlcmRpc2NhcmRlZDogW10sIGFmdGVycGh4Q2hpbGRBZGRlZDogW10sXG4gICAgICBhZnRlcnRyYW5zaXRpb25zRGlzY2FyZGVkOiBbXVxuICAgIH1cbiAgICB0aGlzLndpdGhDaGlsZHJlbiA9IG9wdHMud2l0aENoaWxkcmVuIHx8IG9wdHMudW5kb1JlZiB8fCBmYWxzZVxuICAgIHRoaXMudW5kb1JlZiA9IG9wdHMudW5kb1JlZlxuICB9XG5cbiAgYmVmb3JlKGtpbmQsIGNhbGxiYWNrKXsgdGhpcy5jYWxsYmFja3NbYGJlZm9yZSR7a2luZH1gXS5wdXNoKGNhbGxiYWNrKSB9XG4gIGFmdGVyKGtpbmQsIGNhbGxiYWNrKXsgdGhpcy5jYWxsYmFja3NbYGFmdGVyJHtraW5kfWBdLnB1c2goY2FsbGJhY2spIH1cblxuICB0cmFja0JlZm9yZShraW5kLCAuLi5hcmdzKXtcbiAgICB0aGlzLmNhbGxiYWNrc1tgYmVmb3JlJHtraW5kfWBdLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soLi4uYXJncykpXG4gIH1cblxuICB0cmFja0FmdGVyKGtpbmQsIC4uLmFyZ3Mpe1xuICAgIHRoaXMuY2FsbGJhY2tzW2BhZnRlciR7a2luZH1gXS5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKC4uLmFyZ3MpKVxuICB9XG5cbiAgbWFya1BydW5hYmxlQ29udGVudEZvclJlbW92YWwoKXtcbiAgICBsZXQgcGh4VXBkYXRlID0gdGhpcy5saXZlU29ja2V0LmJpbmRpbmcoUEhYX1VQREFURSlcbiAgICBET00uYWxsKHRoaXMuY29udGFpbmVyLCBgWyR7cGh4VXBkYXRlfT1hcHBlbmRdID4gKiwgWyR7cGh4VXBkYXRlfT1wcmVwZW5kXSA+ICpgLCBlbCA9PiB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoUEhYX1BSVU5FLCBcIlwiKVxuICAgIH0pXG4gIH1cblxuICBwZXJmb3JtKGlzSm9pblBhdGNoKXtcbiAgICBsZXQge3ZpZXcsIGxpdmVTb2NrZXQsIGh0bWwsIGNvbnRhaW5lciwgdGFyZ2V0Q29udGFpbmVyfSA9IHRoaXNcbiAgICBpZih0aGlzLmlzQ0lEUGF0Y2goKSAmJiAhdGFyZ2V0Q29udGFpbmVyKXsgcmV0dXJuIH1cblxuICAgIGxldCBmb2N1c2VkID0gbGl2ZVNvY2tldC5nZXRBY3RpdmVFbGVtZW50KClcbiAgICBsZXQge3NlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmR9ID0gZm9jdXNlZCAmJiBET00uaGFzU2VsZWN0aW9uUmFuZ2UoZm9jdXNlZCkgPyBmb2N1c2VkIDoge31cbiAgICBsZXQgcGh4VXBkYXRlID0gbGl2ZVNvY2tldC5iaW5kaW5nKFBIWF9VUERBVEUpXG4gICAgbGV0IHBoeFZpZXdwb3J0VG9wID0gbGl2ZVNvY2tldC5iaW5kaW5nKFBIWF9WSUVXUE9SVF9UT1ApXG4gICAgbGV0IHBoeFZpZXdwb3J0Qm90dG9tID0gbGl2ZVNvY2tldC5iaW5kaW5nKFBIWF9WSUVXUE9SVF9CT1RUT00pXG4gICAgbGV0IHBoeFRyaWdnZXJFeHRlcm5hbCA9IGxpdmVTb2NrZXQuYmluZGluZyhQSFhfVFJJR0dFUl9BQ1RJT04pXG4gICAgbGV0IGFkZGVkID0gW11cbiAgICBsZXQgdXBkYXRlcyA9IFtdXG4gICAgbGV0IGFwcGVuZFByZXBlbmRVcGRhdGVzID0gW11cblxuICAgIGxldCBleHRlcm5hbEZvcm1UcmlnZ2VyZWQgPSBudWxsXG5cbiAgICBmdW5jdGlvbiBtb3JwaCh0YXJnZXRDb250YWluZXIsIHNvdXJjZSwgd2l0aENoaWxkcmVuPXRoaXMud2l0aENoaWxkcmVuKXtcbiAgICAgIGxldCBtb3JwaENhbGxiYWNrcyA9IHtcbiAgICAgICAgLy8gbm9ybWFsbHksIHdlIGFyZSBydW5uaW5nIHdpdGggY2hpbGRyZW5Pbmx5LCBhcyB0aGUgcGF0Y2ggSFRNTCBmb3IgYSBMVlxuICAgICAgICAvLyBkb2VzIG5vdCBpbmNsdWRlIHRoZSBMViBhdHRycyAoZGF0YS1waHgtc2Vzc2lvbiwgZXRjLilcbiAgICAgICAgLy8gd2hlbiB3ZSBhcmUgcGF0Y2hpbmcgYSBsaXZlIGNvbXBvbmVudCwgd2UgZG8gd2FudCB0byBwYXRjaCB0aGUgcm9vdCBlbGVtZW50IGFzIHdlbGw7XG4gICAgICAgIC8vIGFub3RoZXIgY2FzZSBpcyB0aGUgcmVjdXJzaXZlIHBhdGNoIG9mIGEgc3RyZWFtIGl0ZW0gdGhhdCB3YXMga2VwdCBvbiByZXNldCAoLT4gb25CZWZvcmVOb2RlQWRkZWQpXG4gICAgICAgIGNoaWxkcmVuT25seTogdGFyZ2V0Q29udGFpbmVyLmdldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5UKSA9PT0gbnVsbCAmJiAhd2l0aENoaWxkcmVuLFxuICAgICAgICBnZXROb2RlS2V5OiAobm9kZSkgPT4ge1xuICAgICAgICAgIGlmKERPTS5pc1BoeERlc3Ryb3llZChub2RlKSl7IHJldHVybiBudWxsIH1cbiAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgam9pbiBwYXRjaCwgdGhlbiBieSBkZWZpbml0aW9uIHRoZXJlIHdhcyBubyBQSFhfTUFHSUNfSUQuXG4gICAgICAgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgdG8gcmVkdWNlIHRoZSBhbW91bnQgb2YgZWxlbWVudHMgbW9ycGhkb20gZGlzY2FyZHMuXG4gICAgICAgICAgaWYoaXNKb2luUGF0Y2gpeyByZXR1cm4gbm9kZS5pZCB9XG4gICAgICAgICAgcmV0dXJuIG5vZGUuaWQgfHwgKG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKFBIWF9NQUdJQ19JRCkpXG4gICAgICAgIH0sXG4gICAgICAgIC8vIHNraXAgaW5kZXhpbmcgZnJvbSBjaGlsZHJlbiB3aGVuIGNvbnRhaW5lciBpcyBzdHJlYW1cbiAgICAgICAgc2tpcEZyb21DaGlsZHJlbjogKGZyb20pID0+IHsgcmV0dXJuIGZyb20uZ2V0QXR0cmlidXRlKHBoeFVwZGF0ZSkgPT09IFBIWF9TVFJFQU0gfSxcbiAgICAgICAgLy8gdGVsbCBtb3JwaGRvbSBob3cgdG8gYWRkIGEgY2hpbGRcbiAgICAgICAgYWRkQ2hpbGQ6IChwYXJlbnQsIGNoaWxkKSA9PiB7XG4gICAgICAgICAgbGV0IHtyZWYsIHN0cmVhbUF0fSA9IHRoaXMuZ2V0U3RyZWFtSW5zZXJ0KGNoaWxkKVxuICAgICAgICAgIGlmKHJlZiA9PT0gdW5kZWZpbmVkKXsgcmV0dXJuIHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZCkgfVxuXG4gICAgICAgICAgdGhpcy5zZXRTdHJlYW1SZWYoY2hpbGQsIHJlZilcblxuICAgICAgICAgIC8vIHN0cmVhbWluZ1xuICAgICAgICAgIGlmKHN0cmVhbUF0ID09PSAwKXtcbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJhZnRlcmJlZ2luXCIsIGNoaWxkKVxuICAgICAgICAgIH0gZWxzZSBpZihzdHJlYW1BdCA9PT0gLTEpe1xuICAgICAgICAgICAgbGV0IGxhc3RDaGlsZCA9IHBhcmVudC5sYXN0RWxlbWVudENoaWxkXG4gICAgICAgICAgICBpZihsYXN0Q2hpbGQgJiYgIWxhc3RDaGlsZC5oYXNBdHRyaWJ1dGUoUEhYX1NUUkVBTV9SRUYpKXtcbiAgICAgICAgICAgICAgbGV0IG5vblN0cmVhbUNoaWxkID0gQXJyYXkuZnJvbShwYXJlbnQuY2hpbGRyZW4pLmZpbmQoYyA9PiAhYy5oYXNBdHRyaWJ1dGUoUEhYX1NUUkVBTV9SRUYpKVxuICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBub25TdHJlYW1DaGlsZClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYoc3RyZWFtQXQgPiAwKXtcbiAgICAgICAgICAgIGxldCBzaWJsaW5nID0gQXJyYXkuZnJvbShwYXJlbnQuY2hpbGRyZW4pW3N0cmVhbUF0XVxuICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgc2libGluZylcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uQmVmb3JlTm9kZUFkZGVkOiAoZWwpID0+IHtcbiAgICAgICAgICBET00ubWFpbnRhaW5Qcml2YXRlSG9va3MoZWwsIGVsLCBwaHhWaWV3cG9ydFRvcCwgcGh4Vmlld3BvcnRCb3R0b20pXG4gICAgICAgICAgdGhpcy50cmFja0JlZm9yZShcImFkZGVkXCIsIGVsKVxuXG4gICAgICAgICAgbGV0IG1vcnBoZWRFbCA9IGVsXG4gICAgICAgICAgLy8gdGhpcyBpcyBhIHN0cmVhbSBpdGVtIHRoYXQgd2FzIGtlcHQgb24gcmVzZXQsIHJlY3Vyc2l2ZWx5IG1vcnBoIGl0XG4gICAgICAgICAgaWYodGhpcy5zdHJlYW1Db21wb25lbnRSZXN0b3JlW2VsLmlkXSl7XG4gICAgICAgICAgICBtb3JwaGVkRWwgPSB0aGlzLnN0cmVhbUNvbXBvbmVudFJlc3RvcmVbZWwuaWRdXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zdHJlYW1Db21wb25lbnRSZXN0b3JlW2VsLmlkXVxuICAgICAgICAgICAgbW9ycGguY2FsbCh0aGlzLCBtb3JwaGVkRWwsIGVsLCB0cnVlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBtb3JwaGVkRWxcbiAgICAgICAgfSxcbiAgICAgICAgb25Ob2RlQWRkZWQ6IChlbCkgPT4ge1xuICAgICAgICAgIGlmKGVsLmdldEF0dHJpYnV0ZSl7IHRoaXMubWF5YmVSZU9yZGVyU3RyZWFtKGVsLCB0cnVlKSB9XG5cbiAgICAgICAgICAvLyBoYWNrIHRvIGZpeCBTYWZhcmkgaGFuZGxpbmcgb2YgaW1nIHNyY3NldCBhbmQgdmlkZW8gdGFnc1xuICAgICAgICAgIGlmKGVsIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCAmJiBlbC5zcmNzZXQpe1xuICAgICAgICAgICAgZWwuc3Jjc2V0ID0gZWwuc3Jjc2V0XG4gICAgICAgICAgfSBlbHNlIGlmKGVsIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCAmJiBlbC5hdXRvcGxheSl7XG4gICAgICAgICAgICBlbC5wbGF5KClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoRE9NLmlzTm93VHJpZ2dlckZvcm1FeHRlcm5hbChlbCwgcGh4VHJpZ2dlckV4dGVybmFsKSl7XG4gICAgICAgICAgICBleHRlcm5hbEZvcm1UcmlnZ2VyZWQgPSBlbFxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIG5lc3RlZCB2aWV3IGhhbmRsaW5nXG4gICAgICAgICAgaWYoKERPTS5pc1BoeENoaWxkKGVsKSAmJiB2aWV3Lm93bnNFbGVtZW50KGVsKSkgfHwgRE9NLmlzUGh4U3RpY2t5KGVsKSAmJiB2aWV3Lm93bnNFbGVtZW50KGVsLnBhcmVudE5vZGUpKXtcbiAgICAgICAgICAgIHRoaXMudHJhY2tBZnRlcihcInBoeENoaWxkQWRkZWRcIiwgZWwpXG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZGVkLnB1c2goZWwpXG4gICAgICAgIH0sXG4gICAgICAgIG9uTm9kZURpc2NhcmRlZDogKGVsKSA9PiB0aGlzLm9uTm9kZURpc2NhcmRlZChlbCksXG4gICAgICAgIG9uQmVmb3JlTm9kZURpc2NhcmRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgaWYoZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShQSFhfUFJVTkUpICE9PSBudWxsKXsgcmV0dXJuIHRydWUgfVxuICAgICAgICAgIGlmKGVsLnBhcmVudEVsZW1lbnQgIT09IG51bGwgJiYgZWwuaWQgJiZcbiAgICAgICAgICAgIERPTS5pc1BoeFVwZGF0ZShlbC5wYXJlbnRFbGVtZW50LCBwaHhVcGRhdGUsIFtQSFhfU1RSRUFNLCBcImFwcGVuZFwiLCBcInByZXBlbmRcIl0pKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZih0aGlzLm1heWJlUGVuZGluZ1JlbW92ZShlbCkpeyByZXR1cm4gZmFsc2UgfVxuICAgICAgICAgIGlmKHRoaXMuc2tpcENJRFNpYmxpbmcoZWwpKXsgcmV0dXJuIGZhbHNlIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIG9uRWxVcGRhdGVkOiAoZWwpID0+IHtcbiAgICAgICAgICBpZihET00uaXNOb3dUcmlnZ2VyRm9ybUV4dGVybmFsKGVsLCBwaHhUcmlnZ2VyRXh0ZXJuYWwpKXtcbiAgICAgICAgICAgIGV4dGVybmFsRm9ybVRyaWdnZXJlZCA9IGVsXG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZXMucHVzaChlbClcbiAgICAgICAgICB0aGlzLm1heWJlUmVPcmRlclN0cmVhbShlbCwgZmFsc2UpXG4gICAgICAgIH0sXG4gICAgICAgIG9uQmVmb3JlRWxVcGRhdGVkOiAoZnJvbUVsLCB0b0VsKSA9PiB7XG4gICAgICAgICAgLy8gaWYgd2UgYXJlIHBhdGNoaW5nIHRoZSByb290IHRhcmdldCBjb250YWluZXIgYW5kIHRoZSBpZCBoYXMgY2hhbmdlZCwgdHJlYXQgaXQgYXMgYSBuZXcgbm9kZVxuICAgICAgICAgIC8vIGJ5IHJlcGxhY2luZyB0aGUgZnJvbUVsIHdpdGggdGhlIHRvRWwsIHdoaWNoIGVuc3VyZXMgaG9va3MgYXJlIHRvcm4gZG93biBhbmQgcmUtY3JlYXRlZFxuICAgICAgICAgIGlmKGZyb21FbC5pZCAmJiBmcm9tRWwuaXNTYW1lTm9kZSh0YXJnZXRDb250YWluZXIpICYmIGZyb21FbC5pZCAhPT0gdG9FbC5pZCl7XG4gICAgICAgICAgICBtb3JwaENhbGxiYWNrcy5vbk5vZGVEaXNjYXJkZWQoZnJvbUVsKVxuICAgICAgICAgICAgZnJvbUVsLnJlcGxhY2VXaXRoKHRvRWwpXG4gICAgICAgICAgICByZXR1cm4gbW9ycGhDYWxsYmFja3Mub25Ob2RlQWRkZWQodG9FbClcbiAgICAgICAgICB9XG4gICAgICAgICAgRE9NLnN5bmNQZW5kaW5nQXR0cnMoZnJvbUVsLCB0b0VsKVxuICAgICAgICAgIERPTS5tYWludGFpblByaXZhdGVIb29rcyhmcm9tRWwsIHRvRWwsIHBoeFZpZXdwb3J0VG9wLCBwaHhWaWV3cG9ydEJvdHRvbSlcbiAgICAgICAgICBET00uY2xlYW5DaGlsZE5vZGVzKHRvRWwsIHBoeFVwZGF0ZSlcbiAgICAgICAgICBpZih0aGlzLnNraXBDSURTaWJsaW5nKHRvRWwpKXtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBsaXZlIGNvbXBvbmVudCB1c2VkIGluIGEgc3RyZWFtLCB3ZSBtYXkgbmVlZCB0byByZW9yZGVyIGl0XG4gICAgICAgICAgICB0aGlzLm1heWJlUmVPcmRlclN0cmVhbShmcm9tRWwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoRE9NLmlzUGh4U3RpY2t5KGZyb21FbCkpe1xuICAgICAgICAgICAgW1BIWF9TRVNTSU9OLCBQSFhfU1RBVElDLCBQSFhfUk9PVF9JRF1cbiAgICAgICAgICAgICAgLm1hcChhdHRyID0+IFthdHRyLCBmcm9tRWwuZ2V0QXR0cmlidXRlKGF0dHIpLCB0b0VsLmdldEF0dHJpYnV0ZShhdHRyKV0pXG4gICAgICAgICAgICAgIC5mb3JFYWNoKChbYXR0ciwgZnJvbVZhbCwgdG9WYWxdKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYodG9WYWwgJiYgZnJvbVZhbCAhPT0gdG9WYWwpeyBmcm9tRWwuc2V0QXR0cmlidXRlKGF0dHIsIHRvVmFsKSB9XG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZihET00uaXNJZ25vcmVkKGZyb21FbCwgcGh4VXBkYXRlKSB8fCAoZnJvbUVsLmZvcm0gJiYgZnJvbUVsLmZvcm0uaXNTYW1lTm9kZShleHRlcm5hbEZvcm1UcmlnZ2VyZWQpKSl7XG4gICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpXG4gICAgICAgICAgICBET00ubWVyZ2VBdHRycyhmcm9tRWwsIHRvRWwsIHtpc0lnbm9yZWQ6IERPTS5pc0lnbm9yZWQoZnJvbUVsLCBwaHhVcGRhdGUpfSlcbiAgICAgICAgICAgIHVwZGF0ZXMucHVzaChmcm9tRWwpXG4gICAgICAgICAgICBET00uYXBwbHlTdGlja3lPcGVyYXRpb25zKGZyb21FbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZihmcm9tRWwudHlwZSA9PT0gXCJudW1iZXJcIiAmJiAoZnJvbUVsLnZhbGlkaXR5ICYmIGZyb21FbC52YWxpZGl0eS5iYWRJbnB1dCkpeyByZXR1cm4gZmFsc2UgfVxuICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50IGhhcyBQSFhfUkVGX1NSQywgaXQgaXMgbG9hZGluZyBvciBsb2NrZWQgYW5kIGF3YWl0aW5nIGFuIGFjay5cbiAgICAgICAgICAvLyBJZiBpdCdzIGxvY2tlZCwgd2UgY2xvbmUgdGhlIGZyb21FbCB0cmVlIGFuZCBpbnN0cnVjdCBtb3JwaGRvbSB0byB1c2VcbiAgICAgICAgICAvLyB0aGUgY2xvbmVkIHRyZWUgYXMgdGhlIHNvdXJjZSBvZiB0aGUgbW9ycGggZm9yIHRoaXMgYnJhbmNoIGZyb20gaGVyZSBvbiBvdXQuXG4gICAgICAgICAgLy8gV2Uga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgY2xvbmVkIHRyZWUgaW4gdGhlIGVsZW1lbnQncyBwcml2YXRlIGRhdGEsIGFuZFxuICAgICAgICAgIC8vIG9uIGFjayAodmlldy51bmRvUmVmcyksIHdlIG1vcnBoIHRoZSBjbG9uZWQgdHJlZSB3aXRoIHRoZSB0cnVlIGZyb21FbCBpbiB0aGUgRE9NIHRvXG4gICAgICAgICAgLy8gYXBwbHkgYW55IGNoYW5nZXMgdGhhdCBoYXBwZW5lZCB3aGlsZSB0aGUgZWxlbWVudCB3YXMgbG9ja2VkLlxuICAgICAgICAgIGxldCBpc0ZvY3VzZWRGb3JtRWwgPSBmb2N1c2VkICYmIGZyb21FbC5pc1NhbWVOb2RlKGZvY3VzZWQpICYmIERPTS5pc0Zvcm1JbnB1dChmcm9tRWwpXG4gICAgICAgICAgbGV0IGZvY3VzZWRTZWxlY3RDaGFuZ2VkID0gaXNGb2N1c2VkRm9ybUVsICYmIHRoaXMuaXNDaGFuZ2VkU2VsZWN0KGZyb21FbCwgdG9FbClcbiAgICAgICAgICAvLyBvbmx5IHBlcmZvcm0gdGhlIGNsb25lIHN0ZXAgaWYgdGhpcyBpcyBub3QgYSBwYXRjaCB0aGF0IHVubG9ja3NcbiAgICAgICAgICBpZihmcm9tRWwuaGFzQXR0cmlidXRlKFBIWF9SRUZfU1JDKSAmJiBmcm9tRWwuZ2V0QXR0cmlidXRlKFBIWF9SRUZfTE9DSykgIT0gdGhpcy51bmRvUmVmKXtcbiAgICAgICAgICAgIGlmKERPTS5pc1VwbG9hZElucHV0KGZyb21FbCkpe1xuICAgICAgICAgICAgICBET00ubWVyZ2VBdHRycyhmcm9tRWwsIHRvRWwsIHtpc0lnbm9yZWQ6IHRydWV9KVxuICAgICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpXG4gICAgICAgICAgICAgIHVwZGF0ZXMucHVzaChmcm9tRWwpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBET00uYXBwbHlTdGlja3lPcGVyYXRpb25zKGZyb21FbClcbiAgICAgICAgICAgIGxldCBpc0xvY2tlZCA9IGZyb21FbC5oYXNBdHRyaWJ1dGUoUEhYX1JFRl9MT0NLKVxuICAgICAgICAgICAgbGV0IGNsb25lID0gaXNMb2NrZWQgPyBET00ucHJpdmF0ZShmcm9tRWwsIFBIWF9SRUZfTE9DSykgfHwgZnJvbUVsLmNsb25lTm9kZSh0cnVlKSA6IG51bGxcbiAgICAgICAgICAgIGlmKGNsb25lKXtcbiAgICAgICAgICAgICAgRE9NLnB1dFByaXZhdGUoZnJvbUVsLCBQSFhfUkVGX0xPQ0ssIGNsb25lKVxuICAgICAgICAgICAgICBpZighaXNGb2N1c2VkRm9ybUVsKXtcbiAgICAgICAgICAgICAgICBmcm9tRWwgPSBjbG9uZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gbmVzdGVkIHZpZXcgaGFuZGxpbmdcbiAgICAgICAgICBpZihET00uaXNQaHhDaGlsZCh0b0VsKSl7XG4gICAgICAgICAgICBsZXQgcHJldlNlc3Npb24gPSBmcm9tRWwuZ2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OKVxuICAgICAgICAgICAgRE9NLm1lcmdlQXR0cnMoZnJvbUVsLCB0b0VsLCB7ZXhjbHVkZTogW1BIWF9TVEFUSUNdfSlcbiAgICAgICAgICAgIGlmKHByZXZTZXNzaW9uICE9PSBcIlwiKXsgZnJvbUVsLnNldEF0dHJpYnV0ZShQSFhfU0VTU0lPTiwgcHJldlNlc3Npb24pIH1cbiAgICAgICAgICAgIGZyb21FbC5zZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQsIHRoaXMucm9vdElEKVxuICAgICAgICAgICAgRE9NLmFwcGx5U3RpY2t5T3BlcmF0aW9ucyhmcm9tRWwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpbnB1dCBoYW5kbGluZ1xuICAgICAgICAgIERPTS5jb3B5UHJpdmF0ZXModG9FbCwgZnJvbUVsKVxuXG4gICAgICAgICAgLy8gc2tpcCBwYXRjaGluZyBmb2N1c2VkIGlucHV0cyB1bmxlc3MgZm9jdXMgaXMgYSBzZWxlY3QgdGhhdCBoYXMgY2hhbmdlZCBvcHRpb25zXG4gICAgICAgICAgaWYoaXNGb2N1c2VkRm9ybUVsICYmIGZyb21FbC50eXBlICE9PSBcImhpZGRlblwiICYmICFmb2N1c2VkU2VsZWN0Q2hhbmdlZCl7XG4gICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpXG4gICAgICAgICAgICBET00ubWVyZ2VGb2N1c2VkSW5wdXQoZnJvbUVsLCB0b0VsKVxuICAgICAgICAgICAgRE9NLnN5bmNBdHRyc1RvUHJvcHMoZnJvbUVsKVxuICAgICAgICAgICAgdXBkYXRlcy5wdXNoKGZyb21FbClcbiAgICAgICAgICAgIERPTS5hcHBseVN0aWNreU9wZXJhdGlvbnMoZnJvbUVsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGJsdXIgZm9jdXNlZCBzZWxlY3QgaWYgaXQgY2hhbmdlZCBzbyBuYXRpdmUgVUkgaXMgdXBkYXRlZCAoaWUgc2FmYXJpIHdvbid0IHVwZGF0ZSB2aXNpYmxlIG9wdGlvbnMpXG4gICAgICAgICAgICBpZihmb2N1c2VkU2VsZWN0Q2hhbmdlZCl7IGZyb21FbC5ibHVyKCkgfVxuICAgICAgICAgICAgaWYoRE9NLmlzUGh4VXBkYXRlKHRvRWwsIHBoeFVwZGF0ZSwgW1wiYXBwZW5kXCIsIFwicHJlcGVuZFwiXSkpe1xuICAgICAgICAgICAgICBhcHBlbmRQcmVwZW5kVXBkYXRlcy5wdXNoKG5ldyBET01Qb3N0TW9ycGhSZXN0b3Jlcihmcm9tRWwsIHRvRWwsIHRvRWwuZ2V0QXR0cmlidXRlKHBoeFVwZGF0ZSkpKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBET00uc3luY0F0dHJzVG9Qcm9wcyh0b0VsKVxuICAgICAgICAgICAgRE9NLmFwcGx5U3RpY2t5T3BlcmF0aW9ucyh0b0VsKVxuICAgICAgICAgICAgdGhpcy50cmFja0JlZm9yZShcInVwZGF0ZWRcIiwgZnJvbUVsLCB0b0VsKVxuICAgICAgICAgICAgcmV0dXJuIGZyb21FbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbW9ycGhkb20odGFyZ2V0Q29udGFpbmVyLCBzb3VyY2UsIG1vcnBoQ2FsbGJhY2tzKVxuICAgIH1cblxuICAgIHRoaXMudHJhY2tCZWZvcmUoXCJhZGRlZFwiLCBjb250YWluZXIpXG4gICAgdGhpcy50cmFja0JlZm9yZShcInVwZGF0ZWRcIiwgY29udGFpbmVyLCBjb250YWluZXIpXG5cbiAgICBsaXZlU29ja2V0LnRpbWUoXCJtb3JwaGRvbVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnN0cmVhbXMuZm9yRWFjaCgoW3JlZiwgaW5zZXJ0cywgZGVsZXRlSWRzLCByZXNldF0pID0+IHtcbiAgICAgICAgaW5zZXJ0cy5mb3JFYWNoKChba2V5LCBzdHJlYW1BdCwgbGltaXRdKSA9PiB7XG4gICAgICAgICAgdGhpcy5zdHJlYW1JbnNlcnRzW2tleV0gPSB7cmVmLCBzdHJlYW1BdCwgbGltaXQsIHJlc2V0fVxuICAgICAgICB9KVxuICAgICAgICBpZihyZXNldCAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICBET00uYWxsKGNvbnRhaW5lciwgYFske1BIWF9TVFJFQU1fUkVGfT1cIiR7cmVmfVwiXWAsIGNoaWxkID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlU3RyZWFtQ2hpbGRFbGVtZW50KGNoaWxkKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlSWRzLmZvckVhY2goaWQgPT4ge1xuICAgICAgICAgIGxldCBjaGlsZCA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKGBbaWQ9XCIke2lkfVwiXWApXG4gICAgICAgICAgaWYoY2hpbGQpeyB0aGlzLnJlbW92ZVN0cmVhbUNoaWxkRWxlbWVudChjaGlsZCkgfVxuICAgICAgICB9KVxuICAgICAgfSlcblxuICAgICAgLy8gY2xlYXIgc3RyZWFtIGl0ZW1zIGZyb20gdGhlIGRlYWQgcmVuZGVyIGlmIHRoZXkgYXJlIG5vdCBpbnNlcnRlZCBhZ2FpblxuICAgICAgaWYoaXNKb2luUGF0Y2gpe1xuICAgICAgICBET00uYWxsKHRoaXMuY29udGFpbmVyLCBgWyR7cGh4VXBkYXRlfT0ke1BIWF9TVFJFQU19XWAsIGVsID0+IHtcbiAgICAgICAgICAvLyBtYWtlIHN1cmUgdG8gb25seSByZW1vdmUgZWxlbWVudHMgb3duZWQgYnkgdGhlIGN1cnJlbnQgdmlld1xuICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhvZW5peGZyYW1ld29yay9waG9lbml4X2xpdmVfdmlldy9pc3N1ZXMvMzA0N1xuICAgICAgICAgIHRoaXMubGl2ZVNvY2tldC5vd25lcihlbCwgKHZpZXcpID0+IHtcbiAgICAgICAgICAgIGlmKHZpZXcgPT09IHRoaXMudmlldyl7XG4gICAgICAgICAgICAgIEFycmF5LmZyb20oZWwuY2hpbGRyZW4pLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlU3RyZWFtQ2hpbGRFbGVtZW50KGNoaWxkKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIG1vcnBoLmNhbGwodGhpcywgdGFyZ2V0Q29udGFpbmVyLCBodG1sKVxuICAgIH0pXG5cbiAgICBpZihsaXZlU29ja2V0LmlzRGVidWdFbmFibGVkKCkpe1xuICAgICAgZGV0ZWN0RHVwbGljYXRlSWRzKClcbiAgICAgIGRldGVjdEludmFsaWRTdHJlYW1JbnNlcnRzKHRoaXMuc3RyZWFtSW5zZXJ0cylcbiAgICAgIC8vIHdhcm4gaWYgdGhlcmUgYXJlIGFueSBpbnB1dHMgbmFtZWQgXCJpZFwiXG4gICAgICBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFtuYW1lPWlkXVwiKSkuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgaWYobm9kZS5mb3JtKXtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRGV0ZWN0ZWQgYW4gaW5wdXQgd2l0aCBuYW1lPVxcXCJpZFxcXCIgaW5zaWRlIGEgZm9ybSEgVGhpcyB3aWxsIGNhdXNlIHByb2JsZW1zIHdoZW4gcGF0Y2hpbmcgdGhlIERPTS5cXG5cIiwgbm9kZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZihhcHBlbmRQcmVwZW5kVXBkYXRlcy5sZW5ndGggPiAwKXtcbiAgICAgIGxpdmVTb2NrZXQudGltZShcInBvc3QtbW9ycGggYXBwZW5kL3ByZXBlbmQgcmVzdG9yYXRpb25cIiwgKCkgPT4ge1xuICAgICAgICBhcHBlbmRQcmVwZW5kVXBkYXRlcy5mb3JFYWNoKHVwZGF0ZSA9PiB1cGRhdGUucGVyZm9ybSgpKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBsaXZlU29ja2V0LnNpbGVuY2VFdmVudHMoKCkgPT4gRE9NLnJlc3RvcmVGb2N1cyhmb2N1c2VkLCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKSlcbiAgICBET00uZGlzcGF0Y2hFdmVudChkb2N1bWVudCwgXCJwaHg6dXBkYXRlXCIpXG4gICAgYWRkZWQuZm9yRWFjaChlbCA9PiB0aGlzLnRyYWNrQWZ0ZXIoXCJhZGRlZFwiLCBlbCkpXG4gICAgdXBkYXRlcy5mb3JFYWNoKGVsID0+IHRoaXMudHJhY2tBZnRlcihcInVwZGF0ZWRcIiwgZWwpKVxuXG4gICAgdGhpcy50cmFuc2l0aW9uUGVuZGluZ1JlbW92ZXMoKVxuXG4gICAgaWYoZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkKXtcbiAgICAgIGxpdmVTb2NrZXQudW5sb2FkKClcbiAgICAgIC8vIHVzZSBwcm90b3R5cGUncyBzdWJtaXQgaW4gY2FzZSB0aGVyZSdzIGEgZm9ybSBjb250cm9sIHdpdGggbmFtZSBvciBpZCBvZiBcInN1Ym1pdFwiXG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTEZvcm1FbGVtZW50L3N1Ym1pdFxuICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKGV4dGVybmFsRm9ybVRyaWdnZXJlZCkuc3VibWl0LmNhbGwoZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkKVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgb25Ob2RlRGlzY2FyZGVkKGVsKXtcbiAgICAvLyBuZXN0ZWQgdmlldyBoYW5kbGluZ1xuICAgIGlmKERPTS5pc1BoeENoaWxkKGVsKSB8fCBET00uaXNQaHhTdGlja3koZWwpKXsgdGhpcy5saXZlU29ja2V0LmRlc3Ryb3lWaWV3QnlFbChlbCkgfVxuICAgIHRoaXMudHJhY2tBZnRlcihcImRpc2NhcmRlZFwiLCBlbClcbiAgfVxuXG4gIG1heWJlUGVuZGluZ1JlbW92ZShub2RlKXtcbiAgICBpZihub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZSh0aGlzLnBoeFJlbW92ZSkgIT09IG51bGwpe1xuICAgICAgdGhpcy5wZW5kaW5nUmVtb3Zlcy5wdXNoKG5vZGUpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZW1vdmVTdHJlYW1DaGlsZEVsZW1lbnQoY2hpbGQpe1xuICAgIC8vIHdlIG5lZWQgdG8gc3RvcmUgdGhlIG5vZGUgaWYgaXQgaXMgYWN0dWFsbHkgcmUtYWRkZWQgaW4gdGhlIHNhbWUgcGF0Y2hcbiAgICAvLyB3ZSBkbyBOT1Qgd2FudCB0byBleGVjdXRlIHBoeC1yZW1vdmUsIHdlIGRvIE5PVCB3YW50IHRvIGNhbGwgb25Ob2RlRGlzY2FyZGVkXG4gICAgaWYodGhpcy5zdHJlYW1JbnNlcnRzW2NoaWxkLmlkXSl7XG4gICAgICB0aGlzLnN0cmVhbUNvbXBvbmVudFJlc3RvcmVbY2hpbGQuaWRdID0gY2hpbGRcbiAgICAgIGNoaWxkLnJlbW92ZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG9ubHkgcmVtb3ZlIHRoZSBlbGVtZW50IG5vdyBpZiBpdCBoYXMgbm8gcGh4LXJlbW92ZSBiaW5kaW5nXG4gICAgICBpZighdGhpcy5tYXliZVBlbmRpbmdSZW1vdmUoY2hpbGQpKXtcbiAgICAgICAgY2hpbGQucmVtb3ZlKClcbiAgICAgICAgdGhpcy5vbk5vZGVEaXNjYXJkZWQoY2hpbGQpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0U3RyZWFtSW5zZXJ0KGVsKXtcbiAgICBsZXQgaW5zZXJ0ID0gZWwuaWQgPyB0aGlzLnN0cmVhbUluc2VydHNbZWwuaWRdIDoge31cbiAgICByZXR1cm4gaW5zZXJ0IHx8IHt9XG4gIH1cblxuICBzZXRTdHJlYW1SZWYoZWwsIHJlZil7XG4gICAgRE9NLnB1dFN0aWNreShlbCwgUEhYX1NUUkVBTV9SRUYsIGVsID0+IGVsLnNldEF0dHJpYnV0ZShQSFhfU1RSRUFNX1JFRiwgcmVmKSlcbiAgfVxuXG4gIG1heWJlUmVPcmRlclN0cmVhbShlbCwgaXNOZXcpe1xuICAgIGxldCB7cmVmLCBzdHJlYW1BdCwgcmVzZXR9ID0gdGhpcy5nZXRTdHJlYW1JbnNlcnQoZWwpXG4gICAgaWYoc3RyZWFtQXQgPT09IHVuZGVmaW5lZCl7IHJldHVybiB9XG5cbiAgICAvLyB3ZSBuZWVkIHRvIHNldCB0aGUgUEhYX1NUUkVBTV9SRUYgaGVyZSBhcyB3ZWxsIGFzIGFkZENoaWxkIGlzIGludm9rZWQgb25seSBmb3IgcGFyZW50c1xuICAgIHRoaXMuc2V0U3RyZWFtUmVmKGVsLCByZWYpXG5cbiAgICBpZighcmVzZXQgJiYgIWlzTmV3KXtcbiAgICAgIC8vIHdlIG9ubHkgcmVvcmRlciBpZiB0aGUgZWxlbWVudCBpcyBuZXcgb3IgaXQncyBhIHN0cmVhbSByZXNldFxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgdGhlIGVsZW1lbnQgaGFzIGEgcGFyZW50IGVsZW1lbnQ7XG4gICAgLy8gaXQgZG9lc24ndCBpZiB3ZSBhcmUgY3VycmVudGx5IHJlY3Vyc2l2ZWx5IG1vcnBoaW5nIChyZXN0b3JpbmcgYSBzYXZlZCBzdHJlYW0gY2hpbGQpXG4gICAgLy8gYmVjYXVzZSB0aGUgZWxlbWVudCBpcyBub3QgeWV0IGFkZGVkIHRvIHRoZSByZWFsIGRvbTtcbiAgICAvLyByZW9yZGVyaW5nIGRvZXMgbm90IG1ha2Ugc2Vuc2UgaW4gdGhhdCBjYXNlIGFueXdheVxuICAgIGlmKCFlbC5wYXJlbnRFbGVtZW50KXsgcmV0dXJuIH1cblxuICAgIGlmKHN0cmVhbUF0ID09PSAwKXtcbiAgICAgIGVsLnBhcmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKGVsLCBlbC5wYXJlbnRFbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKVxuICAgIH0gZWxzZSBpZihzdHJlYW1BdCA+IDApe1xuICAgICAgbGV0IGNoaWxkcmVuID0gQXJyYXkuZnJvbShlbC5wYXJlbnRFbGVtZW50LmNoaWxkcmVuKVxuICAgICAgbGV0IG9sZEluZGV4ID0gY2hpbGRyZW4uaW5kZXhPZihlbClcbiAgICAgIGlmKHN0cmVhbUF0ID49IGNoaWxkcmVuLmxlbmd0aCAtIDEpe1xuICAgICAgICBlbC5wYXJlbnRFbGVtZW50LmFwcGVuZENoaWxkKGVsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHNpYmxpbmcgPSBjaGlsZHJlbltzdHJlYW1BdF1cbiAgICAgICAgaWYob2xkSW5kZXggPiBzdHJlYW1BdCl7XG4gICAgICAgICAgZWwucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUoZWwsIHNpYmxpbmcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWwucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUoZWwsIHNpYmxpbmcubmV4dEVsZW1lbnRTaWJsaW5nKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5tYXliZUxpbWl0U3RyZWFtKGVsKVxuICB9XG5cbiAgbWF5YmVMaW1pdFN0cmVhbShlbCl7XG4gICAgbGV0IHtsaW1pdH0gPSB0aGlzLmdldFN0cmVhbUluc2VydChlbClcbiAgICBsZXQgY2hpbGRyZW4gPSBsaW1pdCAhPT0gbnVsbCAmJiBBcnJheS5mcm9tKGVsLnBhcmVudEVsZW1lbnQuY2hpbGRyZW4pXG4gICAgaWYobGltaXQgJiYgbGltaXQgPCAwICYmIGNoaWxkcmVuLmxlbmd0aCA+IGxpbWl0ICogLTEpe1xuICAgICAgY2hpbGRyZW4uc2xpY2UoMCwgY2hpbGRyZW4ubGVuZ3RoICsgbGltaXQpLmZvckVhY2goY2hpbGQgPT4gdGhpcy5yZW1vdmVTdHJlYW1DaGlsZEVsZW1lbnQoY2hpbGQpKVxuICAgIH0gZWxzZSBpZihsaW1pdCAmJiBsaW1pdCA+PSAwICYmIGNoaWxkcmVuLmxlbmd0aCA+IGxpbWl0KXtcbiAgICAgIGNoaWxkcmVuLnNsaWNlKGxpbWl0KS5mb3JFYWNoKGNoaWxkID0+IHRoaXMucmVtb3ZlU3RyZWFtQ2hpbGRFbGVtZW50KGNoaWxkKSlcbiAgICB9XG4gIH1cblxuICB0cmFuc2l0aW9uUGVuZGluZ1JlbW92ZXMoKXtcbiAgICBsZXQge3BlbmRpbmdSZW1vdmVzLCBsaXZlU29ja2V0fSA9IHRoaXNcbiAgICBpZihwZW5kaW5nUmVtb3Zlcy5sZW5ndGggPiAwKXtcbiAgICAgIGxpdmVTb2NrZXQudHJhbnNpdGlvblJlbW92ZXMocGVuZGluZ1JlbW92ZXMsICgpID0+IHtcbiAgICAgICAgcGVuZGluZ1JlbW92ZXMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgbGV0IGNoaWxkID0gRE9NLmZpcnN0UGh4Q2hpbGQoZWwpXG4gICAgICAgICAgaWYoY2hpbGQpeyBsaXZlU29ja2V0LmRlc3Ryb3lWaWV3QnlFbChjaGlsZCkgfVxuICAgICAgICAgIGVsLnJlbW92ZSgpXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMudHJhY2tBZnRlcihcInRyYW5zaXRpb25zRGlzY2FyZGVkXCIsIHBlbmRpbmdSZW1vdmVzKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBpc0NoYW5nZWRTZWxlY3QoZnJvbUVsLCB0b0VsKXtcbiAgICBpZighKGZyb21FbCBpbnN0YW5jZW9mIEhUTUxTZWxlY3RFbGVtZW50KSB8fCBmcm9tRWwubXVsdGlwbGUpeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmKGZyb21FbC5vcHRpb25zLmxlbmd0aCAhPT0gdG9FbC5vcHRpb25zLmxlbmd0aCl7IHJldHVybiB0cnVlIH1cblxuICAgIC8vIGtlZXAgdGhlIGN1cnJlbnQgdmFsdWVcbiAgICB0b0VsLnZhbHVlID0gZnJvbUVsLnZhbHVlXG5cbiAgICAvLyBpbiBnZW5lcmFsIHdlIGhhdmUgdG8gYmUgdmVyeSBjYXJlZnVsIHdpdGggdXNpbmcgaXNFcXVhbE5vZGUgYXMgaXQgZG9lcyBub3QgYSByZWxpYWJsZVxuICAgIC8vIERPTSB0cmVlIGVxdWFsaXR5IGNoZWNrLCBidXQgZm9yIHNlbGVjdGlvbiBhdHRyaWJ1dGVzIGFuZCBvcHRpb25zIGl0IHdvcmtzIGZpbmVcbiAgICByZXR1cm4gIWZyb21FbC5pc0VxdWFsTm9kZSh0b0VsKVxuICB9XG5cbiAgaXNDSURQYXRjaCgpeyByZXR1cm4gdGhpcy5jaWRQYXRjaCB9XG5cbiAgc2tpcENJRFNpYmxpbmcoZWwpe1xuICAgIHJldHVybiBlbC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgZWwuaGFzQXR0cmlidXRlKFBIWF9TS0lQKVxuICB9XG5cbiAgdGFyZ2V0Q0lEQ29udGFpbmVyKGh0bWwpe1xuICAgIGlmKCF0aGlzLmlzQ0lEUGF0Y2goKSl7IHJldHVybiB9XG4gICAgbGV0IFtmaXJzdCwgLi4ucmVzdF0gPSBET00uZmluZENvbXBvbmVudE5vZGVMaXN0KHRoaXMuY29udGFpbmVyLCB0aGlzLnRhcmdldENJRClcbiAgICBpZihyZXN0Lmxlbmd0aCA9PT0gMCAmJiBET00uY2hpbGROb2RlTGVuZ3RoKGh0bWwpID09PSAxKXtcbiAgICAgIHJldHVybiBmaXJzdFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmlyc3QgJiYgZmlyc3QucGFyZW50Tm9kZVxuICAgIH1cbiAgfVxuXG4gIGluZGV4T2YocGFyZW50LCBjaGlsZCl7IHJldHVybiBBcnJheS5mcm9tKHBhcmVudC5jaGlsZHJlbikuaW5kZXhPZihjaGlsZCkgfVxufVxuIiwgImltcG9ydCB7XG4gIENPTVBPTkVOVFMsXG4gIERZTkFNSUNTLFxuICBURU1QTEFURVMsXG4gIEVWRU5UUyxcbiAgUEhYX0NPTVBPTkVOVCxcbiAgUEhYX1NLSVAsXG4gIFBIWF9NQUdJQ19JRCxcbiAgUkVQTFksXG4gIFNUQVRJQyxcbiAgVElUTEUsXG4gIFNUUkVBTSxcbiAgUk9PVCxcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IHtcbiAgaXNPYmplY3QsXG4gIGxvZ0Vycm9yLFxuICBpc0NpZCxcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5jb25zdCBWT0lEX1RBR1MgPSBuZXcgU2V0KFtcbiAgXCJhcmVhXCIsXG4gIFwiYmFzZVwiLFxuICBcImJyXCIsXG4gIFwiY29sXCIsXG4gIFwiY29tbWFuZFwiLFxuICBcImVtYmVkXCIsXG4gIFwiaHJcIixcbiAgXCJpbWdcIixcbiAgXCJpbnB1dFwiLFxuICBcImtleWdlblwiLFxuICBcImxpbmtcIixcbiAgXCJtZXRhXCIsXG4gIFwicGFyYW1cIixcbiAgXCJzb3VyY2VcIixcbiAgXCJ0cmFja1wiLFxuICBcIndiclwiXG5dKVxuY29uc3QgcXVvdGVDaGFycyA9IG5ldyBTZXQoW1wiJ1wiLCBcIlxcXCJcIl0pXG5cbmV4cG9ydCBsZXQgbW9kaWZ5Um9vdCA9IChodG1sLCBhdHRycywgY2xlYXJJbm5lckhUTUwpID0+IHtcbiAgbGV0IGkgPSAwXG4gIGxldCBpbnNpZGVDb21tZW50ID0gZmFsc2VcbiAgbGV0IGJlZm9yZVRhZywgYWZ0ZXJUYWcsIHRhZywgdGFnTmFtZUVuZHNBdCwgaWQsIG5ld0hUTUxcblxuICBsZXQgbG9va2FoZWFkID0gaHRtbC5tYXRjaCgvXihcXHMqKD86PCEtLS4qPy0tPlxccyopKik8KFteXFxzXFwvPl0rKS8pXG4gIGlmKGxvb2thaGVhZCA9PT0gbnVsbCl7IHRocm93IG5ldyBFcnJvcihgbWFsZm9ybWVkIGh0bWwgJHtodG1sfWApIH1cblxuICBpID0gbG9va2FoZWFkWzBdLmxlbmd0aFxuICBiZWZvcmVUYWcgPSBsb29rYWhlYWRbMV1cbiAgdGFnID0gbG9va2FoZWFkWzJdXG4gIHRhZ05hbWVFbmRzQXQgPSBpXG5cbiAgLy8gU2NhbiB0aGUgb3BlbmluZyB0YWcgZm9yIGlkLCBpZiB0aGVyZSBpcyBhbnlcbiAgZm9yKGk7IGkgPCBodG1sLmxlbmd0aDsgaSsrKXtcbiAgICBpZihodG1sLmNoYXJBdChpKSA9PT0gXCI+XCIgKXsgYnJlYWsgfVxuICAgIGlmKGh0bWwuY2hhckF0KGkpID09PSBcIj1cIil7XG4gICAgICBsZXQgaXNJZCA9IGh0bWwuc2xpY2UoaSAtIDMsIGkpID09PSBcIiBpZFwiXG4gICAgICBpKytcbiAgICAgIGxldCBjaGFyID0gaHRtbC5jaGFyQXQoaSlcbiAgICAgIGlmKHF1b3RlQ2hhcnMuaGFzKGNoYXIpKXtcbiAgICAgICAgbGV0IGF0dHJTdGFydHNBdCA9IGlcbiAgICAgICAgaSsrXG4gICAgICAgIGZvcihpOyBpIDwgaHRtbC5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgaWYoaHRtbC5jaGFyQXQoaSkgPT09IGNoYXIpeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoaXNJZCl7XG4gICAgICAgICAgaWQgPSBodG1sLnNsaWNlKGF0dHJTdGFydHNBdCArIDEsIGkpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCBjbG9zZUF0ID0gaHRtbC5sZW5ndGggLSAxXG4gIGluc2lkZUNvbW1lbnQgPSBmYWxzZVxuICB3aGlsZShjbG9zZUF0ID49IGJlZm9yZVRhZy5sZW5ndGggKyB0YWcubGVuZ3RoKXtcbiAgICBsZXQgY2hhciA9IGh0bWwuY2hhckF0KGNsb3NlQXQpXG4gICAgaWYoaW5zaWRlQ29tbWVudCl7XG4gICAgICBpZihjaGFyID09PSBcIi1cIiAmJiBodG1sLnNsaWNlKGNsb3NlQXQgLSAzLCBjbG9zZUF0KSA9PT0gXCI8IS1cIil7XG4gICAgICAgIGluc2lkZUNvbW1lbnQgPSBmYWxzZVxuICAgICAgICBjbG9zZUF0IC09IDRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsb3NlQXQgLT0gMVxuICAgICAgfVxuICAgIH0gZWxzZSBpZihjaGFyID09PSBcIj5cIiAmJiBodG1sLnNsaWNlKGNsb3NlQXQgLSAyLCBjbG9zZUF0KSA9PT0gXCItLVwiKXtcbiAgICAgIGluc2lkZUNvbW1lbnQgPSB0cnVlXG4gICAgICBjbG9zZUF0IC09IDNcbiAgICB9IGVsc2UgaWYoY2hhciA9PT0gXCI+XCIpe1xuICAgICAgYnJlYWtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xvc2VBdCAtPSAxXG4gICAgfVxuICB9XG4gIGFmdGVyVGFnID0gaHRtbC5zbGljZShjbG9zZUF0ICsgMSwgaHRtbC5sZW5ndGgpXG5cbiAgbGV0IGF0dHJzU3RyID1cbiAgICBPYmplY3Qua2V5cyhhdHRycylcbiAgICAgIC5tYXAoYXR0ciA9PiBhdHRyc1thdHRyXSA9PT0gdHJ1ZSA/IGF0dHIgOiBgJHthdHRyfT1cIiR7YXR0cnNbYXR0cl19XCJgKVxuICAgICAgLmpvaW4oXCIgXCIpXG5cbiAgaWYoY2xlYXJJbm5lckhUTUwpe1xuICAgIC8vIEtlZXAgdGhlIGlkIGlmIGFueVxuICAgIGxldCBpZEF0dHJTdHIgPSBpZCA/IGAgaWQ9XCIke2lkfVwiYCA6IFwiXCJcbiAgICBpZihWT0lEX1RBR1MuaGFzKHRhZykpe1xuICAgICAgbmV3SFRNTCA9IGA8JHt0YWd9JHtpZEF0dHJTdHJ9JHthdHRyc1N0ciA9PT0gXCJcIiA/IFwiXCIgOiBcIiBcIn0ke2F0dHJzU3RyfS8+YFxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdIVE1MID0gYDwke3RhZ30ke2lkQXR0clN0cn0ke2F0dHJzU3RyID09PSBcIlwiID8gXCJcIiA6IFwiIFwifSR7YXR0cnNTdHJ9PjwvJHt0YWd9PmBcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IHJlc3QgPSBodG1sLnNsaWNlKHRhZ05hbWVFbmRzQXQsIGNsb3NlQXQgKyAxKVxuICAgIG5ld0hUTUwgPSBgPCR7dGFnfSR7YXR0cnNTdHIgPT09IFwiXCIgPyBcIlwiIDogXCIgXCJ9JHthdHRyc1N0cn0ke3Jlc3R9YFxuICB9XG5cbiAgcmV0dXJuIFtuZXdIVE1MLCBiZWZvcmVUYWcsIGFmdGVyVGFnXVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJlZCB7XG4gIHN0YXRpYyBleHRyYWN0KGRpZmYpe1xuICAgIGxldCB7W1JFUExZXTogcmVwbHksIFtFVkVOVFNdOiBldmVudHMsIFtUSVRMRV06IHRpdGxlfSA9IGRpZmZcbiAgICBkZWxldGUgZGlmZltSRVBMWV1cbiAgICBkZWxldGUgZGlmZltFVkVOVFNdXG4gICAgZGVsZXRlIGRpZmZbVElUTEVdXG4gICAgcmV0dXJuIHtkaWZmLCB0aXRsZSwgcmVwbHk6IHJlcGx5IHx8IG51bGwsIGV2ZW50czogZXZlbnRzIHx8IFtdfVxuICB9XG5cbiAgY29uc3RydWN0b3Iodmlld0lkLCByZW5kZXJlZCl7XG4gICAgdGhpcy52aWV3SWQgPSB2aWV3SWRcbiAgICB0aGlzLnJlbmRlcmVkID0ge31cbiAgICB0aGlzLm1hZ2ljSWQgPSAwXG4gICAgdGhpcy5tZXJnZURpZmYocmVuZGVyZWQpXG4gIH1cblxuICBwYXJlbnRWaWV3SWQoKXsgcmV0dXJuIHRoaXMudmlld0lkIH1cblxuICB0b1N0cmluZyhvbmx5Q2lkcyl7XG4gICAgbGV0IFtzdHIsIHN0cmVhbXNdID0gdGhpcy5yZWN1cnNpdmVUb1N0cmluZyh0aGlzLnJlbmRlcmVkLCB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdLCBvbmx5Q2lkcywgdHJ1ZSwge30pXG4gICAgcmV0dXJuIFtzdHIsIHN0cmVhbXNdXG4gIH1cblxuICByZWN1cnNpdmVUb1N0cmluZyhyZW5kZXJlZCwgY29tcG9uZW50cyA9IHJlbmRlcmVkW0NPTVBPTkVOVFNdLCBvbmx5Q2lkcywgY2hhbmdlVHJhY2tpbmcsIHJvb3RBdHRycyl7XG4gICAgb25seUNpZHMgPSBvbmx5Q2lkcyA/IG5ldyBTZXQob25seUNpZHMpIDogbnVsbFxuICAgIGxldCBvdXRwdXQgPSB7YnVmZmVyOiBcIlwiLCBjb21wb25lbnRzOiBjb21wb25lbnRzLCBvbmx5Q2lkczogb25seUNpZHMsIHN0cmVhbXM6IG5ldyBTZXQoKX1cbiAgICB0aGlzLnRvT3V0cHV0QnVmZmVyKHJlbmRlcmVkLCBudWxsLCBvdXRwdXQsIGNoYW5nZVRyYWNraW5nLCByb290QXR0cnMpXG4gICAgcmV0dXJuIFtvdXRwdXQuYnVmZmVyLCBvdXRwdXQuc3RyZWFtc11cbiAgfVxuXG4gIGNvbXBvbmVudENJRHMoZGlmZil7IHJldHVybiBPYmplY3Qua2V5cyhkaWZmW0NPTVBPTkVOVFNdIHx8IHt9KS5tYXAoaSA9PiBwYXJzZUludChpKSkgfVxuXG4gIGlzQ29tcG9uZW50T25seURpZmYoZGlmZil7XG4gICAgaWYoIWRpZmZbQ09NUE9ORU5UU10peyByZXR1cm4gZmFsc2UgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhkaWZmKS5sZW5ndGggPT09IDFcbiAgfVxuXG4gIGdldENvbXBvbmVudChkaWZmLCBjaWQpeyByZXR1cm4gZGlmZltDT01QT05FTlRTXVtjaWRdIH1cblxuICByZXNldFJlbmRlcihjaWQpe1xuICAgIC8vIHdlIGFyZSByYWNpbmcgYSBjb21wb25lbnQgZGVzdHJveSwgaXQgY291bGQgbm90IGV4aXN0LCBzb1xuICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHdlIGRvbid0IHRyeSB0byBzZXQgcmVzZXQgb24gdW5kZWZpbmVkXG4gICAgaWYodGhpcy5yZW5kZXJlZFtDT01QT05FTlRTXVtjaWRdKXtcbiAgICAgIHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU11bY2lkXS5yZXNldCA9IHRydWVcbiAgICB9XG4gIH1cblxuICBtZXJnZURpZmYoZGlmZil7XG4gICAgbGV0IG5ld2MgPSBkaWZmW0NPTVBPTkVOVFNdXG4gICAgbGV0IGNhY2hlID0ge31cbiAgICBkZWxldGUgZGlmZltDT01QT05FTlRTXVxuICAgIHRoaXMucmVuZGVyZWQgPSB0aGlzLm11dGFibGVNZXJnZSh0aGlzLnJlbmRlcmVkLCBkaWZmKVxuICAgIHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU10gPSB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdIHx8IHt9XG5cbiAgICBpZihuZXdjKXtcbiAgICAgIGxldCBvbGRjID0gdGhpcy5yZW5kZXJlZFtDT01QT05FTlRTXVxuXG4gICAgICBmb3IobGV0IGNpZCBpbiBuZXdjKXtcbiAgICAgICAgbmV3Y1tjaWRdID0gdGhpcy5jYWNoZWRGaW5kQ29tcG9uZW50KGNpZCwgbmV3Y1tjaWRdLCBvbGRjLCBuZXdjLCBjYWNoZSlcbiAgICAgIH1cblxuICAgICAgZm9yKGxldCBjaWQgaW4gbmV3Yyl7IG9sZGNbY2lkXSA9IG5ld2NbY2lkXSB9XG4gICAgICBkaWZmW0NPTVBPTkVOVFNdID0gbmV3Y1xuICAgIH1cbiAgfVxuXG4gIGNhY2hlZEZpbmRDb21wb25lbnQoY2lkLCBjZGlmZiwgb2xkYywgbmV3YywgY2FjaGUpe1xuICAgIGlmKGNhY2hlW2NpZF0pe1xuICAgICAgcmV0dXJuIGNhY2hlW2NpZF1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG5kaWZmLCBzdGF0LCBzY2lkID0gY2RpZmZbU1RBVElDXVxuXG4gICAgICBpZihpc0NpZChzY2lkKSl7XG4gICAgICAgIGxldCB0ZGlmZlxuXG4gICAgICAgIGlmKHNjaWQgPiAwKXtcbiAgICAgICAgICB0ZGlmZiA9IHRoaXMuY2FjaGVkRmluZENvbXBvbmVudChzY2lkLCBuZXdjW3NjaWRdLCBvbGRjLCBuZXdjLCBjYWNoZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZGlmZiA9IG9sZGNbLXNjaWRdXG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ID0gdGRpZmZbU1RBVElDXVxuICAgICAgICBuZGlmZiA9IHRoaXMuY2xvbmVNZXJnZSh0ZGlmZiwgY2RpZmYsIHRydWUpXG4gICAgICAgIG5kaWZmW1NUQVRJQ10gPSBzdGF0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZGlmZiA9IGNkaWZmW1NUQVRJQ10gIT09IHVuZGVmaW5lZCB8fCBvbGRjW2NpZF0gPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgY2RpZmYgOiB0aGlzLmNsb25lTWVyZ2Uob2xkY1tjaWRdLCBjZGlmZiwgZmFsc2UpXG4gICAgICB9XG5cbiAgICAgIGNhY2hlW2NpZF0gPSBuZGlmZlxuICAgICAgcmV0dXJuIG5kaWZmXG4gICAgfVxuICB9XG5cbiAgbXV0YWJsZU1lcmdlKHRhcmdldCwgc291cmNlKXtcbiAgICBpZihzb3VyY2VbU1RBVElDXSAhPT0gdW5kZWZpbmVkKXtcbiAgICAgIHJldHVybiBzb3VyY2VcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kb011dGFibGVNZXJnZSh0YXJnZXQsIHNvdXJjZSlcbiAgICAgIHJldHVybiB0YXJnZXRcbiAgICB9XG4gIH1cblxuICBkb011dGFibGVNZXJnZSh0YXJnZXQsIHNvdXJjZSl7XG4gICAgZm9yKGxldCBrZXkgaW4gc291cmNlKXtcbiAgICAgIGxldCB2YWwgPSBzb3VyY2Vba2V5XVxuICAgICAgbGV0IHRhcmdldFZhbCA9IHRhcmdldFtrZXldXG4gICAgICBsZXQgaXNPYmpWYWwgPSBpc09iamVjdCh2YWwpXG4gICAgICBpZihpc09ialZhbCAmJiB2YWxbU1RBVElDXSA9PT0gdW5kZWZpbmVkICYmIGlzT2JqZWN0KHRhcmdldFZhbCkpe1xuICAgICAgICB0aGlzLmRvTXV0YWJsZU1lcmdlKHRhcmdldFZhbCwgdmFsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWxcbiAgICAgIH1cbiAgICB9XG4gICAgaWYodGFyZ2V0W1JPT1RdKXtcbiAgICAgIHRhcmdldC5uZXdSZW5kZXIgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgLy8gTWVyZ2VzIGNpZCB0cmVlcyB0b2dldGhlciwgY29weWluZyBzdGF0aWNzIGZyb20gc291cmNlIHRyZWUuXG4gIC8vXG4gIC8vIFRoZSBgcHJ1bmVNYWdpY0lkYCBpcyBwYXNzZWQgdG8gY29udHJvbCBwcnVuaW5nIHRoZSBtYWdpY0lkIG9mIHRoZVxuICAvLyB0YXJnZXQuIFdlIG11c3QgYWx3YXlzIHBydW5lIHRoZSBtYWdpY0lkIHdoZW4gd2UgYXJlIHNoYXJpbmcgc3RhdGljc1xuICAvLyBmcm9tIGFub3RoZXIgY29tcG9uZW50LiBJZiBub3QgcHJ1bmluZywgd2UgcmVwbGljYXRlIHRoZSBsb2dpYyBmcm9tXG4gIC8vIG11dGFibGVNZXJnZSwgd2hlcmUgd2Ugc2V0IG5ld1JlbmRlciB0byB0cnVlIGlmIHRoZXJlIGlzIGEgcm9vdFxuICAvLyAoZWZmZWN0aXZlbHkgZm9yY2luZyB0aGUgbmV3IHZlcnNpb24gdG8gYmUgcmVuZGVyZWQgaW5zdGVhZCBvZiBza2lwcGVkKVxuICAvL1xuICBjbG9uZU1lcmdlKHRhcmdldCwgc291cmNlLCBwcnVuZU1hZ2ljSWQpe1xuICAgIGxldCBtZXJnZWQgPSB7Li4udGFyZ2V0LCAuLi5zb3VyY2V9XG4gICAgZm9yKGxldCBrZXkgaW4gbWVyZ2VkKXtcbiAgICAgIGxldCB2YWwgPSBzb3VyY2Vba2V5XVxuICAgICAgbGV0IHRhcmdldFZhbCA9IHRhcmdldFtrZXldXG4gICAgICBpZihpc09iamVjdCh2YWwpICYmIHZhbFtTVEFUSUNdID09PSB1bmRlZmluZWQgJiYgaXNPYmplY3QodGFyZ2V0VmFsKSl7XG4gICAgICAgIG1lcmdlZFtrZXldID0gdGhpcy5jbG9uZU1lcmdlKHRhcmdldFZhbCwgdmFsLCBwcnVuZU1hZ2ljSWQpXG4gICAgICB9IGVsc2UgaWYodmFsID09PSB1bmRlZmluZWQgJiYgaXNPYmplY3QodGFyZ2V0VmFsKSl7XG4gICAgICAgIG1lcmdlZFtrZXldID0gdGhpcy5jbG9uZU1lcmdlKHRhcmdldFZhbCwge30sIHBydW5lTWFnaWNJZClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYocHJ1bmVNYWdpY0lkKXtcbiAgICAgIGRlbGV0ZSBtZXJnZWQubWFnaWNJZFxuICAgICAgZGVsZXRlIG1lcmdlZC5uZXdSZW5kZXJcbiAgICB9IGVsc2UgaWYodGFyZ2V0W1JPT1RdKXtcbiAgICAgIG1lcmdlZC5uZXdSZW5kZXIgPSB0cnVlXG4gICAgfVxuICAgIHJldHVybiBtZXJnZWRcbiAgfVxuXG4gIGNvbXBvbmVudFRvU3RyaW5nKGNpZCl7XG4gICAgbGV0IFtzdHIsIHN0cmVhbXNdID0gdGhpcy5yZWN1cnNpdmVDSURUb1N0cmluZyh0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdLCBjaWQsIG51bGwpXG4gICAgbGV0IFtzdHJpcHBlZEhUTUwsIF9iZWZvcmUsIF9hZnRlcl0gPSBtb2RpZnlSb290KHN0ciwge30pXG4gICAgcmV0dXJuIFtzdHJpcHBlZEhUTUwsIHN0cmVhbXNdXG4gIH1cblxuICBwcnVuZUNJRHMoY2lkcyl7XG4gICAgY2lkcy5mb3JFYWNoKGNpZCA9PiBkZWxldGUgdGhpcy5yZW5kZXJlZFtDT01QT05FTlRTXVtjaWRdKVxuICB9XG5cbiAgLy8gcHJpdmF0ZVxuXG4gIGdldCgpeyByZXR1cm4gdGhpcy5yZW5kZXJlZCB9XG5cbiAgaXNOZXdGaW5nZXJwcmludChkaWZmID0ge30peyByZXR1cm4gISFkaWZmW1NUQVRJQ10gfVxuXG4gIHRlbXBsYXRlU3RhdGljKHBhcnQsIHRlbXBsYXRlcyl7XG4gICAgaWYodHlwZW9mIChwYXJ0KSA9PT0gXCJudW1iZXJcIil7XG4gICAgICByZXR1cm4gdGVtcGxhdGVzW3BhcnRdXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYXJ0XG4gICAgfVxuICB9XG5cbiAgbmV4dE1hZ2ljSUQoKXtcbiAgICB0aGlzLm1hZ2ljSWQrK1xuICAgIHJldHVybiBgbSR7dGhpcy5tYWdpY0lkfS0ke3RoaXMucGFyZW50Vmlld0lkKCl9YFxuICB9XG5cbiAgLy8gQ29udmVydHMgcmVuZGVyZWQgdHJlZSB0byBvdXRwdXQgYnVmZmVyLlxuICAvL1xuICAvLyBjaGFuZ2VUcmFja2luZyBjb250cm9scyBpZiB3ZSBjYW4gYXBwbHkgdGhlIFBIWF9TS0lQIG9wdGltaXphdGlvbi5cbiAgLy8gSXQgaXMgZGlzYWJsZWQgZm9yIGNvbXByZWhlbnNpb25zIHNpbmNlIHdlIG11c3QgcmUtcmVuZGVyIHRoZSBlbnRpcmUgY29sbGVjdGlvblxuICAvLyBhbmQgbm8gaW5kaXZpZHVhbCBlbGVtZW50IGlzIHRyYWNrZWQgaW5zaWRlIHRoZSBjb21wcmVoZW5zaW9uLlxuICB0b091dHB1dEJ1ZmZlcihyZW5kZXJlZCwgdGVtcGxhdGVzLCBvdXRwdXQsIGNoYW5nZVRyYWNraW5nLCByb290QXR0cnMgPSB7fSl7XG4gICAgaWYocmVuZGVyZWRbRFlOQU1JQ1NdKXsgcmV0dXJuIHRoaXMuY29tcHJlaGVuc2lvblRvQnVmZmVyKHJlbmRlcmVkLCB0ZW1wbGF0ZXMsIG91dHB1dCkgfVxuICAgIGxldCB7W1NUQVRJQ106IHN0YXRpY3N9ID0gcmVuZGVyZWRcbiAgICBzdGF0aWNzID0gdGhpcy50ZW1wbGF0ZVN0YXRpYyhzdGF0aWNzLCB0ZW1wbGF0ZXMpXG4gICAgbGV0IGlzUm9vdCA9IHJlbmRlcmVkW1JPT1RdXG4gICAgbGV0IHByZXZCdWZmZXIgPSBvdXRwdXQuYnVmZmVyXG4gICAgaWYoaXNSb290KXsgb3V0cHV0LmJ1ZmZlciA9IFwiXCIgfVxuXG4gICAgLy8gdGhpcyBjb25kaXRpb24gaXMgY2FsbGVkIHdoZW4gZmlyc3QgcmVuZGVyaW5nIGFuIG9wdGltaXphYmxlIGZ1bmN0aW9uIGNvbXBvbmVudC5cbiAgICAvLyBMQyBoYXZlIHRoZWlyIG1hZ2ljSWQgcHJldmlvdXNseSBzZXRcbiAgICBpZihjaGFuZ2VUcmFja2luZyAmJiBpc1Jvb3QgJiYgIXJlbmRlcmVkLm1hZ2ljSWQpe1xuICAgICAgcmVuZGVyZWQubmV3UmVuZGVyID0gdHJ1ZVxuICAgICAgcmVuZGVyZWQubWFnaWNJZCA9IHRoaXMubmV4dE1hZ2ljSUQoKVxuICAgIH1cblxuICAgIG91dHB1dC5idWZmZXIgKz0gc3RhdGljc1swXVxuICAgIGZvcihsZXQgaSA9IDE7IGkgPCBzdGF0aWNzLmxlbmd0aDsgaSsrKXtcbiAgICAgIHRoaXMuZHluYW1pY1RvQnVmZmVyKHJlbmRlcmVkW2kgLSAxXSwgdGVtcGxhdGVzLCBvdXRwdXQsIGNoYW5nZVRyYWNraW5nKVxuICAgICAgb3V0cHV0LmJ1ZmZlciArPSBzdGF0aWNzW2ldXG4gICAgfVxuXG4gICAgLy8gQXBwbGllcyB0aGUgcm9vdCB0YWcgXCJza2lwXCIgb3B0aW1pemF0aW9uIGlmIHN1cHBvcnRlZCwgd2hpY2ggY2xlYXJzXG4gICAgLy8gdGhlIHJvb3QgdGFnIGF0dHJpYnV0ZXMgYW5kIGlubmVySFRNTCwgYW5kIG9ubHkgbWFpbnRhaW5zIHRoZSBtYWdpY0lkLlxuICAgIC8vIFdlIGNhbiBvbmx5IHNraXAgd2hlbiBjaGFuZ2VUcmFja2luZyBpcyBzdXBwb3J0ZWQgKG91dHNpZGUgb2YgYSBjb21wcmVoZW5zaW9uKSxcbiAgICAvLyBhbmQgd2hlbiB0aGUgcm9vdCBlbGVtZW50IGhhc24ndCBleHBlcmllbmNlZCBhbiB1bnJlbmRlcmVkIG1lcmdlIChuZXdSZW5kZXIgdHJ1ZSkuXG4gICAgaWYoaXNSb290KXtcbiAgICAgIGxldCBza2lwID0gZmFsc2VcbiAgICAgIGxldCBhdHRyc1xuICAgICAgLy8gV2hlbiBhIExDIGlzIHJlLWFkZGVkIHRvIHRoZSBwYWdlLCB3ZSBuZWVkIHRvIHJlLXJlbmRlciB0aGUgZW50aXJlIExDIHRyZWUsXG4gICAgICAvLyB0aGVyZWZvcmUgY2hhbmdlVHJhY2tpbmcgaXMgZmFsc2U7IGhvd2V2ZXIsIHdlIG5lZWQgdG8ga2VlcCBhbGwgdGhlIG1hZ2ljSWRzXG4gICAgICAvLyBmcm9tIGFueSBmdW5jdGlvbiBjb21wb25lbnQgc28gdGhlIG5leHQgdGltZSB0aGUgTEMgaXMgdXBkYXRlZCwgd2UgY2FuIGFwcGx5XG4gICAgICAvLyB0aGUgc2tpcCBvcHRpbWl6YXRpb25cbiAgICAgIGlmKGNoYW5nZVRyYWNraW5nIHx8IHJlbmRlcmVkLm1hZ2ljSWQpe1xuICAgICAgICBza2lwID0gY2hhbmdlVHJhY2tpbmcgJiYgIXJlbmRlcmVkLm5ld1JlbmRlclxuICAgICAgICBhdHRycyA9IHtbUEhYX01BR0lDX0lEXTogcmVuZGVyZWQubWFnaWNJZCwgLi4ucm9vdEF0dHJzfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cnMgPSByb290QXR0cnNcbiAgICAgIH1cbiAgICAgIGlmKHNraXApeyBhdHRyc1tQSFhfU0tJUF0gPSB0cnVlIH1cbiAgICAgIGxldCBbbmV3Um9vdCwgY29tbWVudEJlZm9yZSwgY29tbWVudEFmdGVyXSA9IG1vZGlmeVJvb3Qob3V0cHV0LmJ1ZmZlciwgYXR0cnMsIHNraXApXG4gICAgICByZW5kZXJlZC5uZXdSZW5kZXIgPSBmYWxzZVxuICAgICAgb3V0cHV0LmJ1ZmZlciA9IHByZXZCdWZmZXIgKyBjb21tZW50QmVmb3JlICsgbmV3Um9vdCArIGNvbW1lbnRBZnRlclxuICAgIH1cbiAgfVxuXG4gIGNvbXByZWhlbnNpb25Ub0J1ZmZlcihyZW5kZXJlZCwgdGVtcGxhdGVzLCBvdXRwdXQpe1xuICAgIGxldCB7W0RZTkFNSUNTXTogZHluYW1pY3MsIFtTVEFUSUNdOiBzdGF0aWNzLCBbU1RSRUFNXTogc3RyZWFtfSA9IHJlbmRlcmVkXG4gICAgbGV0IFtfcmVmLCBfaW5zZXJ0cywgZGVsZXRlSWRzLCByZXNldF0gPSBzdHJlYW0gfHwgW251bGwsIHt9LCBbXSwgbnVsbF1cbiAgICBzdGF0aWNzID0gdGhpcy50ZW1wbGF0ZVN0YXRpYyhzdGF0aWNzLCB0ZW1wbGF0ZXMpXG4gICAgbGV0IGNvbXBUZW1wbGF0ZXMgPSB0ZW1wbGF0ZXMgfHwgcmVuZGVyZWRbVEVNUExBVEVTXVxuICAgIGZvcihsZXQgZCA9IDA7IGQgPCBkeW5hbWljcy5sZW5ndGg7IGQrKyl7XG4gICAgICBsZXQgZHluYW1pYyA9IGR5bmFtaWNzW2RdXG4gICAgICBvdXRwdXQuYnVmZmVyICs9IHN0YXRpY3NbMF1cbiAgICAgIGZvcihsZXQgaSA9IDE7IGkgPCBzdGF0aWNzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgLy8gSW5zaWRlIGEgY29tcHJlaGVuc2lvbiwgd2UgZG9uJ3QgdHJhY2sgaG93IGR5bmFtaWNzIGNoYW5nZVxuICAgICAgICAvLyBvdmVyIHRpbWUgKGFuZCBmZWF0dXJlcyBsaWtlIHN0cmVhbXMgd291bGQgbWFrZSB0aGF0IGltcG9zc2libGVcbiAgICAgICAgLy8gdW5sZXNzIHdlIG1vdmUgdGhlIHN0cmVhbSBkaWZmaW5nIGF3YXkgZnJvbSBtb3JwaGRvbSksXG4gICAgICAgIC8vIHNvIHdlIGNhbid0IHBlcmZvcm0gcm9vdCBjaGFuZ2UgdHJhY2tpbmcuXG4gICAgICAgIGxldCBjaGFuZ2VUcmFja2luZyA9IGZhbHNlXG4gICAgICAgIHRoaXMuZHluYW1pY1RvQnVmZmVyKGR5bmFtaWNbaSAtIDFdLCBjb21wVGVtcGxhdGVzLCBvdXRwdXQsIGNoYW5nZVRyYWNraW5nKVxuICAgICAgICBvdXRwdXQuYnVmZmVyICs9IHN0YXRpY3NbaV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihzdHJlYW0gIT09IHVuZGVmaW5lZCAmJiAocmVuZGVyZWRbRFlOQU1JQ1NdLmxlbmd0aCA+IDAgfHwgZGVsZXRlSWRzLmxlbmd0aCA+IDAgfHwgcmVzZXQpKXtcbiAgICAgIGRlbGV0ZSByZW5kZXJlZFtTVFJFQU1dXG4gICAgICByZW5kZXJlZFtEWU5BTUlDU10gPSBbXVxuICAgICAgb3V0cHV0LnN0cmVhbXMuYWRkKHN0cmVhbSlcbiAgICB9XG4gIH1cblxuICBkeW5hbWljVG9CdWZmZXIocmVuZGVyZWQsIHRlbXBsYXRlcywgb3V0cHV0LCBjaGFuZ2VUcmFja2luZyl7XG4gICAgaWYodHlwZW9mIChyZW5kZXJlZCkgPT09IFwibnVtYmVyXCIpe1xuICAgICAgbGV0IFtzdHIsIHN0cmVhbXNdID0gdGhpcy5yZWN1cnNpdmVDSURUb1N0cmluZyhvdXRwdXQuY29tcG9uZW50cywgcmVuZGVyZWQsIG91dHB1dC5vbmx5Q2lkcylcbiAgICAgIG91dHB1dC5idWZmZXIgKz0gc3RyXG4gICAgICBvdXRwdXQuc3RyZWFtcyA9IG5ldyBTZXQoWy4uLm91dHB1dC5zdHJlYW1zLCAuLi5zdHJlYW1zXSlcbiAgICB9IGVsc2UgaWYoaXNPYmplY3QocmVuZGVyZWQpKXtcbiAgICAgIHRoaXMudG9PdXRwdXRCdWZmZXIocmVuZGVyZWQsIHRlbXBsYXRlcywgb3V0cHV0LCBjaGFuZ2VUcmFja2luZywge30pXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5idWZmZXIgKz0gcmVuZGVyZWRcbiAgICB9XG4gIH1cblxuICByZWN1cnNpdmVDSURUb1N0cmluZyhjb21wb25lbnRzLCBjaWQsIG9ubHlDaWRzKXtcbiAgICBsZXQgY29tcG9uZW50ID0gY29tcG9uZW50c1tjaWRdIHx8IGxvZ0Vycm9yKGBubyBjb21wb25lbnQgZm9yIENJRCAke2NpZH1gLCBjb21wb25lbnRzKVxuICAgIGxldCBhdHRycyA9IHtbUEhYX0NPTVBPTkVOVF06IGNpZH1cbiAgICBsZXQgc2tpcCA9IG9ubHlDaWRzICYmICFvbmx5Q2lkcy5oYXMoY2lkKVxuICAgIC8vIFR3byBvcHRpbWl6YXRpb24gcGF0aHMgYXBwbHkgaGVyZTpcbiAgICAvL1xuICAgIC8vICAgMS4gVGhlIG9ubHlDaWRzIG9wdGltaXphdGlvbiB3b3JrcyBieSB0aGUgc2VydmVyIGRpZmYgdGVsbGluZyB1cyBvbmx5IHNwZWNpZmljXG4gICAgLy8gICAgIGNpZCdzIGhhdmUgY2hhbmdlZC4gVGhpcyBhbGxvd3MgdXMgdG8gc2tpcCByZW5kZXJpbmcgYW55IGNvbXBvbmVudCB0aGF0IGhhc24ndCBjaGFuZ2VkLFxuICAgIC8vICAgICB3aGljaCB1bHRpbWF0ZWx5IHNldHMgUEhYX1NLSVAgcm9vdCBhdHRyaWJ1dGUgYW5kIGF2b2lkcyByZW5kZXJpbmcgdGhlIGlubmVySFRNTC5cbiAgICAvL1xuICAgIC8vICAgMi4gVGhlIHJvb3QgUEhYX1NLSVAgb3B0aW1pemF0aW9uIGdlbmVyYWxpemVzIHRvIGFsbCBIRUV4IGZ1bmN0aW9uIGNvbXBvbmVudHMsIGFuZFxuICAgIC8vICAgICB3b3JrcyBpbiB0aGUgc2FtZSBQSFhfU0tJUCBhdHRyaWJ1dGUgZmFzaGlvbiBhcyAxLCBidXQgdGhlIG5ld1JlbmRlciB0cmFja2luZyBpcyBkb25lXG4gICAgLy8gICAgIGF0IHRoZSBnZW5lcmFsIGRpZmYgbWVyZ2UgbGV2ZWwuIElmIHdlIG1lcmdlIGEgZGlmZiB3aXRoIG5ldyBkeW5hbWljcywgd2UgbmVjZXNzYXJpbHkgaGF2ZVxuICAgIC8vICAgICBleHBlcmllbmNlZCBhIGNoYW5nZSB3aGljaCBtdXN0IGJlIGEgbmV3UmVuZGVyLCBhbmQgdGh1cyB3ZSBjYW4ndCBza2lwIHRoZSByZW5kZXIuXG4gICAgLy9cbiAgICAvLyBCb3RoIG9wdGltaXphdGlvbiBmbG93cyBhcHBseSBoZXJlLiBuZXdSZW5kZXIgaXMgc2V0IGJhc2VkIG9uIHRoZSBvbmx5Q2lkcyBvcHRpbWl6YXRpb24sIGFuZFxuICAgIC8vIHdlIHRyYWNrIGEgZGV0ZXJtaW5pc3RpYyBtYWdpY0lkIGJhc2VkIG9uIHRoZSBjaWQuXG4gICAgLy9cbiAgICAvLyBjaGFuZ2VUcmFja2luZyBpcyBhYm91dCB0aGUgZW50aXJlIHRyZWVcbiAgICAvLyBuZXdSZW5kZXIgaXMgYWJvdXQgdGhlIGN1cnJlbnQgcm9vdCBpbiB0aGUgdHJlZVxuICAgIC8vXG4gICAgLy8gQnkgZGVmYXVsdCBjaGFuZ2VUcmFja2luZyBpcyBlbmFibGVkLCBidXQgd2Ugc3BlY2lhbCBjYXNlIHRoZSBmbG93IHdoZXJlIHRoZSBjbGllbnQgaXMgcHJ1bmluZ1xuICAgIC8vIGNpZHMgYW5kIHRoZSBzZXJ2ZXIgYWRkcyB0aGUgY29tcG9uZW50IGJhY2suIEluIHN1Y2ggY2FzZXMsIHdlIGV4cGxpY2l0bHkgZGlzYWJsZSBjaGFuZ2VUcmFja2luZ1xuICAgIC8vIHdpdGggcmVzZXRSZW5kZXIgZm9yIHRoaXMgY2lkLCB0aGVuIHJlLWVuYWJsZSBpdCBhZnRlciB0aGUgcmVjdXJzaXZlIGNhbGwgdG8gc2tpcCB0aGUgb3B0aW1pemF0aW9uXG4gICAgLy8gZm9yIHRoZSBlbnRpcmUgY29tcG9uZW50IHRyZWUuXG4gICAgY29tcG9uZW50Lm5ld1JlbmRlciA9ICFza2lwXG4gICAgY29tcG9uZW50Lm1hZ2ljSWQgPSBgYyR7Y2lkfS0ke3RoaXMucGFyZW50Vmlld0lkKCl9YFxuICAgIC8vIGVuYWJsZSBjaGFuZ2UgdHJhY2tpbmcgYXMgbG9uZyBhcyB0aGUgY29tcG9uZW50IGhhc24ndCBiZWVuIHJlc2V0XG4gICAgbGV0IGNoYW5nZVRyYWNraW5nID0gIWNvbXBvbmVudC5yZXNldFxuICAgIGxldCBbaHRtbCwgc3RyZWFtc10gPSB0aGlzLnJlY3Vyc2l2ZVRvU3RyaW5nKGNvbXBvbmVudCwgY29tcG9uZW50cywgb25seUNpZHMsIGNoYW5nZVRyYWNraW5nLCBhdHRycylcbiAgICAvLyBkaXNhYmxlIHJlc2V0IGFmdGVyIHdlJ3ZlIHJlbmRlcmVkXG4gICAgZGVsZXRlIGNvbXBvbmVudC5yZXNldFxuXG4gICAgcmV0dXJuIFtodG1sLCBzdHJlYW1zXVxuICB9XG59XG4iLCAiaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIlxuaW1wb3J0IEFSSUEgZnJvbSBcIi4vYXJpYVwiXG5cbmxldCBmb2N1c1N0YWNrID0gW11cbmxldCBkZWZhdWx0X3RyYW5zaXRpb25fdGltZSA9IDIwMFxuXG5sZXQgSlMgPSB7XG4gIC8vIHByaXZhdGVcbiAgZXhlYyhlLCBldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZGVmYXVsdHMpe1xuICAgIGxldCBbZGVmYXVsdEtpbmQsIGRlZmF1bHRBcmdzXSA9IGRlZmF1bHRzIHx8IFtudWxsLCB7Y2FsbGJhY2s6IGRlZmF1bHRzICYmIGRlZmF1bHRzLmNhbGxiYWNrfV1cbiAgICBsZXQgY29tbWFuZHMgPSBwaHhFdmVudC5jaGFyQXQoMCkgPT09IFwiW1wiID9cbiAgICAgIEpTT04ucGFyc2UocGh4RXZlbnQpIDogW1tkZWZhdWx0S2luZCwgZGVmYXVsdEFyZ3NdXVxuXG4gICAgY29tbWFuZHMuZm9yRWFjaCgoW2tpbmQsIGFyZ3NdKSA9PiB7XG4gICAgICBpZihraW5kID09PSBkZWZhdWx0S2luZCl7XG4gICAgICAgIC8vIGFsd2F5cyBwcmVmZXIgdGhlIGFyZ3MsIGJ1dCBrZWVwIGV4aXN0aW5nIGtleXMgZnJvbSB0aGUgZGVmYXVsdEFyZ3NcbiAgICAgICAgYXJncyA9IHsuLi5kZWZhdWx0QXJncywgLi4uYXJnc31cbiAgICAgICAgYXJncy5jYWxsYmFjayA9IGFyZ3MuY2FsbGJhY2sgfHwgZGVmYXVsdEFyZ3MuY2FsbGJhY2tcbiAgICAgIH1cbiAgICAgIHRoaXMuZmlsdGVyVG9FbHModmlldy5saXZlU29ja2V0LCBzb3VyY2VFbCwgYXJncykuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIHRoaXNbYGV4ZWNfJHtraW5kfWBdKGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwgYXJncylcbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcblxuICBpc1Zpc2libGUoZWwpe1xuICAgIHJldHVybiAhIShlbC5vZmZzZXRXaWR0aCB8fCBlbC5vZmZzZXRIZWlnaHQgfHwgZWwuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPiAwKVxuICB9LFxuXG4gIC8vIHJldHVybnMgdHJ1ZSBpZiBhbnkgcGFydCBvZiB0aGUgZWxlbWVudCBpcyBpbnNpZGUgdGhlIHZpZXdwb3J0XG4gIGlzSW5WaWV3cG9ydChlbCl7XG4gICAgY29uc3QgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgY29uc3Qgd2luZG93SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcbiAgICBjb25zdCB3aW5kb3dXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aFxuXG4gICAgcmV0dXJuIChcbiAgICAgIHJlY3QucmlnaHQgPiAwICYmXG4gICAgICByZWN0LmJvdHRvbSA+IDAgJiZcbiAgICAgIHJlY3QubGVmdCA8IHdpbmRvd1dpZHRoICYmXG4gICAgICByZWN0LnRvcCA8IHdpbmRvd0hlaWdodFxuICAgIClcbiAgfSxcblxuICAvLyBwcml2YXRlXG5cbiAgLy8gY29tbWFuZHNcblxuICBleGVjX2V4ZWMoZSwgZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7YXR0ciwgdG99KXtcbiAgICBsZXQgbm9kZXMgPSB0byA/IERPTS5hbGwoZG9jdW1lbnQsIHRvKSA6IFtzb3VyY2VFbF1cbiAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgbGV0IGVuY29kZWRKUyA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHIpXG4gICAgICBpZighZW5jb2RlZEpTKXsgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke2F0dHJ9IHRvIGNvbnRhaW4gSlMgY29tbWFuZCBvbiBcIiR7dG99XCJgKSB9XG4gICAgICB2aWV3LmxpdmVTb2NrZXQuZXhlY0pTKG5vZGUsIGVuY29kZWRKUywgZXZlbnRUeXBlKVxuICAgIH0pXG4gIH0sXG5cbiAgZXhlY19kaXNwYXRjaChlLCBldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHtldmVudCwgZGV0YWlsLCBidWJibGVzfSl7XG4gICAgZGV0YWlsID0gZGV0YWlsIHx8IHt9XG4gICAgZGV0YWlsLmRpc3BhdGNoZXIgPSBzb3VyY2VFbFxuICAgIERPTS5kaXNwYXRjaEV2ZW50KGVsLCBldmVudCwge2RldGFpbCwgYnViYmxlc30pXG4gIH0sXG5cbiAgZXhlY19wdXNoKGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwgYXJncyl7XG4gICAgbGV0IHtldmVudCwgZGF0YSwgdGFyZ2V0LCBwYWdlX2xvYWRpbmcsIGxvYWRpbmcsIHZhbHVlLCBkaXNwYXRjaGVyLCBjYWxsYmFja30gPSBhcmdzXG4gICAgbGV0IHB1c2hPcHRzID0ge2xvYWRpbmcsIHZhbHVlLCB0YXJnZXQsIHBhZ2VfbG9hZGluZzogISFwYWdlX2xvYWRpbmd9XG4gICAgbGV0IHRhcmdldFNyYyA9IGV2ZW50VHlwZSA9PT0gXCJjaGFuZ2VcIiAmJiBkaXNwYXRjaGVyID8gZGlzcGF0Y2hlciA6IHNvdXJjZUVsXG4gICAgbGV0IHBoeFRhcmdldCA9IHRhcmdldCB8fCB0YXJnZXRTcmMuZ2V0QXR0cmlidXRlKHZpZXcuYmluZGluZyhcInRhcmdldFwiKSkgfHwgdGFyZ2V0U3JjXG4gICAgY29uc3QgaGFuZGxlciA9ICh0YXJnZXRWaWV3LCB0YXJnZXRDdHgpID0+IHtcbiAgICAgIGlmKCF0YXJnZXRWaWV3LmlzQ29ubmVjdGVkKCkpeyByZXR1cm4gfVxuICAgICAgaWYoZXZlbnRUeXBlID09PSBcImNoYW5nZVwiKXtcbiAgICAgICAgbGV0IHtuZXdDaWQsIF90YXJnZXR9ID0gYXJnc1xuICAgICAgICBfdGFyZ2V0ID0gX3RhcmdldCB8fCAoRE9NLmlzRm9ybUlucHV0KHNvdXJjZUVsKSA/IHNvdXJjZUVsLm5hbWUgOiB1bmRlZmluZWQpXG4gICAgICAgIGlmKF90YXJnZXQpeyBwdXNoT3B0cy5fdGFyZ2V0ID0gX3RhcmdldCB9XG4gICAgICAgIHRhcmdldFZpZXcucHVzaElucHV0KHNvdXJjZUVsLCB0YXJnZXRDdHgsIG5ld0NpZCwgZXZlbnQgfHwgcGh4RXZlbnQsIHB1c2hPcHRzLCBjYWxsYmFjaylcbiAgICAgIH0gZWxzZSBpZihldmVudFR5cGUgPT09IFwic3VibWl0XCIpe1xuICAgICAgICBsZXQge3N1Ym1pdHRlcn0gPSBhcmdzXG4gICAgICAgIHRhcmdldFZpZXcuc3VibWl0Rm9ybShzb3VyY2VFbCwgdGFyZ2V0Q3R4LCBldmVudCB8fCBwaHhFdmVudCwgc3VibWl0dGVyLCBwdXNoT3B0cywgY2FsbGJhY2spXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRWaWV3LnB1c2hFdmVudChldmVudFR5cGUsIHNvdXJjZUVsLCB0YXJnZXRDdHgsIGV2ZW50IHx8IHBoeEV2ZW50LCBkYXRhLCBwdXNoT3B0cywgY2FsbGJhY2spXG4gICAgICB9XG4gICAgfVxuICAgIC8vIGluIGNhc2Ugb2YgZm9ybVJlY292ZXJ5LCB0YXJnZXRWaWV3IGFuZCB0YXJnZXRDdHggYXJlIHBhc3NlZCBhcyBhcmd1bWVudFxuICAgIC8vIGFzIHRoZXkgYXJlIGxvb2tlZCB1cCBpbiBhIHRlbXBsYXRlIGVsZW1lbnQsIG5vdCB0aGUgcmVhbCBET01cbiAgICBpZihhcmdzLnRhcmdldFZpZXcgJiYgYXJncy50YXJnZXRDdHgpe1xuICAgICAgaGFuZGxlcihhcmdzLnRhcmdldFZpZXcsIGFyZ3MudGFyZ2V0Q3R4KVxuICAgIH0gZWxzZSB7XG4gICAgICB2aWV3LndpdGhpblRhcmdldHMocGh4VGFyZ2V0LCBoYW5kbGVyKVxuICAgIH1cbiAgfSxcblxuICBleGVjX25hdmlnYXRlKGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2hyZWYsIHJlcGxhY2V9KXtcbiAgICB2aWV3LmxpdmVTb2NrZXQuaGlzdG9yeVJlZGlyZWN0KGUsIGhyZWYsIHJlcGxhY2UgPyBcInJlcGxhY2VcIiA6IFwicHVzaFwiLCBudWxsLCBzb3VyY2VFbClcbiAgfSxcblxuICBleGVjX3BhdGNoKGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2hyZWYsIHJlcGxhY2V9KXtcbiAgICB2aWV3LmxpdmVTb2NrZXQucHVzaEhpc3RvcnlQYXRjaChlLCBocmVmLCByZXBsYWNlID8gXCJyZXBsYWNlXCIgOiBcInB1c2hcIiwgc291cmNlRWwpXG4gIH0sXG5cbiAgZXhlY19mb2N1cyhlLCBldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwpe1xuICAgIEFSSUEuYXR0ZW1wdEZvY3VzKGVsKVxuICB9LFxuXG4gIGV4ZWNfZm9jdXNfZmlyc3QoZSwgZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsKXtcbiAgICBBUklBLmZvY3VzRmlyc3RJbnRlcmFjdGl2ZShlbCkgfHwgQVJJQS5mb2N1c0ZpcnN0KGVsKVxuICB9LFxuXG4gIGV4ZWNfcHVzaF9mb2N1cyhlLCBldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwpe1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gZm9jdXNTdGFjay5wdXNoKGVsIHx8IHNvdXJjZUVsKSlcbiAgfSxcblxuICBleGVjX3BvcF9mb2N1cyhfZSwgX2V2ZW50VHlwZSwgX3BoeEV2ZW50LCBfdmlldywgX3NvdXJjZUVsLCBfZWwpe1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgY29uc3QgZWwgPSBmb2N1c1N0YWNrLnBvcCgpXG4gICAgICBpZihlbCl7IGVsLmZvY3VzKCkgfVxuICAgIH0pXG4gIH0sXG5cbiAgZXhlY19hZGRfY2xhc3MoZSwgZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7bmFtZXMsIHRyYW5zaXRpb24sIHRpbWUsIGJsb2NraW5nfSl7XG4gICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIG5hbWVzLCBbXSwgdHJhbnNpdGlvbiwgdGltZSwgdmlldywgYmxvY2tpbmcpXG4gIH0sXG5cbiAgZXhlY19yZW1vdmVfY2xhc3MoZSwgZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7bmFtZXMsIHRyYW5zaXRpb24sIHRpbWUsIGJsb2NraW5nfSl7XG4gICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIFtdLCBuYW1lcywgdHJhbnNpdGlvbiwgdGltZSwgdmlldywgYmxvY2tpbmcpXG4gIH0sXG5cbiAgZXhlY190b2dnbGVfY2xhc3MoZSwgZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7bmFtZXMsIHRyYW5zaXRpb24sIHRpbWUsIGJsb2NraW5nfSl7XG4gICAgdGhpcy50b2dnbGVDbGFzc2VzKGVsLCBuYW1lcywgdHJhbnNpdGlvbiwgdGltZSwgdmlldywgYmxvY2tpbmcpXG4gIH0sXG5cbiAgZXhlY190b2dnbGVfYXR0cihlLCBldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHthdHRyOiBbYXR0ciwgdmFsMSwgdmFsMl19KXtcbiAgICB0aGlzLnRvZ2dsZUF0dHIoZWwsIGF0dHIsIHZhbDEsIHZhbDIpXG4gIH0sXG5cbiAgZXhlY190cmFuc2l0aW9uKGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge3RpbWUsIHRyYW5zaXRpb24sIGJsb2NraW5nfSl7XG4gICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIFtdLCBbXSwgdHJhbnNpdGlvbiwgdGltZSwgdmlldywgYmxvY2tpbmcpXG4gIH0sXG5cbiAgZXhlY190b2dnbGUoZSwgZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7ZGlzcGxheSwgaW5zLCBvdXRzLCB0aW1lLCBibG9ja2luZ30pe1xuICAgIHRoaXMudG9nZ2xlKGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIGlucywgb3V0cywgdGltZSwgYmxvY2tpbmcpXG4gIH0sXG5cbiAgZXhlY19zaG93KGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2Rpc3BsYXksIHRyYW5zaXRpb24sIHRpbWUsIGJsb2NraW5nfSl7XG4gICAgdGhpcy5zaG93KGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIHRyYW5zaXRpb24sIHRpbWUsIGJsb2NraW5nKVxuICB9LFxuXG4gIGV4ZWNfaGlkZShlLCBldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHtkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lLCBibG9ja2luZ30pe1xuICAgIHRoaXMuaGlkZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lLCBibG9ja2luZylcbiAgfSxcblxuICBleGVjX3NldF9hdHRyKGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2F0dHI6IFthdHRyLCB2YWxdfSl7XG4gICAgdGhpcy5zZXRPclJlbW92ZUF0dHJzKGVsLCBbW2F0dHIsIHZhbF1dLCBbXSlcbiAgfSxcblxuICBleGVjX3JlbW92ZV9hdHRyKGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2F0dHJ9KXtcbiAgICB0aGlzLnNldE9yUmVtb3ZlQXR0cnMoZWwsIFtdLCBbYXR0cl0pXG4gIH0sXG5cbiAgLy8gdXRpbHMgZm9yIGNvbW1hbmRzXG5cbiAgc2hvdyhldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lLCBibG9ja2luZyl7XG4gICAgaWYoIXRoaXMuaXNWaXNpYmxlKGVsKSl7XG4gICAgICB0aGlzLnRvZ2dsZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCBudWxsLCB0aW1lLCBibG9ja2luZylcbiAgICB9XG4gIH0sXG5cbiAgaGlkZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lLCBibG9ja2luZyl7XG4gICAgaWYodGhpcy5pc1Zpc2libGUoZWwpKXtcbiAgICAgIHRoaXMudG9nZ2xlKGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIG51bGwsIHRyYW5zaXRpb24sIHRpbWUsIGJsb2NraW5nKVxuICAgIH1cbiAgfSxcblxuICB0b2dnbGUoZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgaW5zLCBvdXRzLCB0aW1lLCBibG9ja2luZyl7XG4gICAgdGltZSA9IHRpbWUgfHwgZGVmYXVsdF90cmFuc2l0aW9uX3RpbWVcbiAgICBsZXQgW2luQ2xhc3NlcywgaW5TdGFydENsYXNzZXMsIGluRW5kQ2xhc3Nlc10gPSBpbnMgfHwgW1tdLCBbXSwgW11dXG4gICAgbGV0IFtvdXRDbGFzc2VzLCBvdXRTdGFydENsYXNzZXMsIG91dEVuZENsYXNzZXNdID0gb3V0cyB8fCBbW10sIFtdLCBbXV1cbiAgICBpZihpbkNsYXNzZXMubGVuZ3RoID4gMCB8fCBvdXRDbGFzc2VzLmxlbmd0aCA+IDApe1xuICAgICAgaWYodGhpcy5pc1Zpc2libGUoZWwpKXtcbiAgICAgICAgbGV0IG9uU3RhcnQgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIG91dFN0YXJ0Q2xhc3NlcywgaW5DbGFzc2VzLmNvbmNhdChpblN0YXJ0Q2xhc3NlcykuY29uY2F0KGluRW5kQ2xhc3NlcykpXG4gICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgb3V0Q2xhc3NlcywgW10pXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBvdXRFbmRDbGFzc2VzLCBvdXRTdGFydENsYXNzZXMpKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9uRW5kID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBbXSwgb3V0Q2xhc3Nlcy5jb25jYXQob3V0RW5kQ2xhc3NlcykpXG4gICAgICAgICAgRE9NLnB1dFN0aWNreShlbCwgXCJ0b2dnbGVcIiwgY3VycmVudEVsID0+IGN1cnJlbnRFbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIpXG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6aGlkZS1lbmRcIikpXG4gICAgICAgIH1cbiAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6aGlkZS1zdGFydFwiKSlcbiAgICAgICAgaWYoYmxvY2tpbmcgPT09IGZhbHNlKXtcbiAgICAgICAgICBvblN0YXJ0KClcbiAgICAgICAgICBzZXRUaW1lb3V0KG9uRW5kLCB0aW1lKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZpZXcudHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkVuZClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYoZXZlbnRUeXBlID09PSBcInJlbW92ZVwiKXsgcmV0dXJuIH1cbiAgICAgICAgbGV0IG9uU3RhcnQgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIGluU3RhcnRDbGFzc2VzLCBvdXRDbGFzc2VzLmNvbmNhdChvdXRTdGFydENsYXNzZXMpLmNvbmNhdChvdXRFbmRDbGFzc2VzKSlcbiAgICAgICAgICBsZXQgc3RpY2t5RGlzcGxheSA9IGRpc3BsYXkgfHwgdGhpcy5kZWZhdWx0RGlzcGxheShlbClcbiAgICAgICAgICBET00ucHV0U3RpY2t5KGVsLCBcInRvZ2dsZVwiLCBjdXJyZW50RWwgPT4gY3VycmVudEVsLnN0eWxlLmRpc3BsYXkgPSBzdGlja3lEaXNwbGF5KVxuICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIGluQ2xhc3NlcywgW10pXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBpbkVuZENsYXNzZXMsIGluU3RhcnRDbGFzc2VzKSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGxldCBvbkVuZCA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgW10sIGluQ2xhc3Nlcy5jb25jYXQoaW5FbmRDbGFzc2VzKSlcbiAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpzaG93LWVuZFwiKSlcbiAgICAgICAgfVxuICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpzaG93LXN0YXJ0XCIpKVxuICAgICAgICBpZihibG9ja2luZyA9PT0gZmFsc2Upe1xuICAgICAgICAgIG9uU3RhcnQoKVxuICAgICAgICAgIHNldFRpbWVvdXQob25FbmQsIHRpbWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmlldy50cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRW5kKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKHRoaXMuaXNWaXNpYmxlKGVsKSl7XG4gICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OmhpZGUtc3RhcnRcIikpXG4gICAgICAgIERPTS5wdXRTdGlja3koZWwsIFwidG9nZ2xlXCIsIGN1cnJlbnRFbCA9PiBjdXJyZW50RWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiKVxuICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpoaWRlLWVuZFwiKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OnNob3ctc3RhcnRcIikpXG4gICAgICAgIGxldCBzdGlja3lEaXNwbGF5ID0gZGlzcGxheSB8fCB0aGlzLmRlZmF1bHREaXNwbGF5KGVsKVxuICAgICAgICBET00ucHV0U3RpY2t5KGVsLCBcInRvZ2dsZVwiLCBjdXJyZW50RWwgPT4gY3VycmVudEVsLnN0eWxlLmRpc3BsYXkgPSBzdGlja3lEaXNwbGF5KVxuICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpzaG93LWVuZFwiKSlcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdG9nZ2xlQ2xhc3NlcyhlbCwgY2xhc3NlcywgdHJhbnNpdGlvbiwgdGltZSwgdmlldywgYmxvY2tpbmcpe1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgbGV0IFtwcmV2QWRkcywgcHJldlJlbW92ZXNdID0gRE9NLmdldFN0aWNreShlbCwgXCJjbGFzc2VzXCIsIFtbXSwgW11dKVxuICAgICAgbGV0IG5ld0FkZHMgPSBjbGFzc2VzLmZpbHRlcihuYW1lID0+IHByZXZBZGRzLmluZGV4T2YobmFtZSkgPCAwICYmICFlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSkpXG4gICAgICBsZXQgbmV3UmVtb3ZlcyA9IGNsYXNzZXMuZmlsdGVyKG5hbWUgPT4gcHJldlJlbW92ZXMuaW5kZXhPZihuYW1lKSA8IDAgJiYgZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpKVxuICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIG5ld0FkZHMsIG5ld1JlbW92ZXMsIHRyYW5zaXRpb24sIHRpbWUsIHZpZXcsIGJsb2NraW5nKVxuICAgIH0pXG4gIH0sXG5cbiAgdG9nZ2xlQXR0cihlbCwgYXR0ciwgdmFsMSwgdmFsMil7XG4gICAgaWYoZWwuaGFzQXR0cmlidXRlKGF0dHIpKXtcbiAgICAgIGlmKHZhbDIgIT09IHVuZGVmaW5lZCl7XG4gICAgICAgIC8vIHRvZ2dsZSBiZXR3ZWVuIHZhbDEgYW5kIHZhbDJcbiAgICAgICAgaWYoZWwuZ2V0QXR0cmlidXRlKGF0dHIpID09PSB2YWwxKXtcbiAgICAgICAgICB0aGlzLnNldE9yUmVtb3ZlQXR0cnMoZWwsIFtbYXR0ciwgdmFsMl1dLCBbXSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNldE9yUmVtb3ZlQXR0cnMoZWwsIFtbYXR0ciwgdmFsMV1dLCBbXSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVtb3ZlIGF0dHJcbiAgICAgICAgdGhpcy5zZXRPclJlbW92ZUF0dHJzKGVsLCBbXSwgW2F0dHJdKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldE9yUmVtb3ZlQXR0cnMoZWwsIFtbYXR0ciwgdmFsMV1dLCBbXSlcbiAgICB9XG4gIH0sXG5cbiAgYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBhZGRzLCByZW1vdmVzLCB0cmFuc2l0aW9uLCB0aW1lLCB2aWV3LCBibG9ja2luZyl7XG4gICAgdGltZSA9IHRpbWUgfHwgZGVmYXVsdF90cmFuc2l0aW9uX3RpbWVcbiAgICBsZXQgW3RyYW5zaXRpb25SdW4sIHRyYW5zaXRpb25TdGFydCwgdHJhbnNpdGlvbkVuZF0gPSB0cmFuc2l0aW9uIHx8IFtbXSwgW10sIFtdXVxuICAgIGlmKHRyYW5zaXRpb25SdW4ubGVuZ3RoID4gMCl7XG4gICAgICBsZXQgb25TdGFydCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIHRyYW5zaXRpb25TdGFydCwgW10uY29uY2F0KHRyYW5zaXRpb25SdW4pLmNvbmNhdCh0cmFuc2l0aW9uRW5kKSlcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIHRyYW5zaXRpb25SdW4sIFtdKVxuICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIHRyYW5zaXRpb25FbmQsIHRyYW5zaXRpb25TdGFydCkpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBsZXQgb25Eb25lID0gKCkgPT4gdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIGFkZHMuY29uY2F0KHRyYW5zaXRpb25FbmQpLCByZW1vdmVzLmNvbmNhdCh0cmFuc2l0aW9uUnVuKS5jb25jYXQodHJhbnNpdGlvblN0YXJ0KSlcbiAgICAgIGlmKGJsb2NraW5nID09PSBmYWxzZSl7XG4gICAgICAgIG9uU3RhcnQoKVxuICAgICAgICBzZXRUaW1lb3V0KG9uRG9uZSwgdGltZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZpZXcudHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUpXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGxldCBbcHJldkFkZHMsIHByZXZSZW1vdmVzXSA9IERPTS5nZXRTdGlja3koZWwsIFwiY2xhc3Nlc1wiLCBbW10sIFtdXSlcbiAgICAgIGxldCBrZWVwQWRkcyA9IGFkZHMuZmlsdGVyKG5hbWUgPT4gcHJldkFkZHMuaW5kZXhPZihuYW1lKSA8IDAgJiYgIWVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKSlcbiAgICAgIGxldCBrZWVwUmVtb3ZlcyA9IHJlbW92ZXMuZmlsdGVyKG5hbWUgPT4gcHJldlJlbW92ZXMuaW5kZXhPZihuYW1lKSA8IDAgJiYgZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpKVxuICAgICAgbGV0IG5ld0FkZHMgPSBwcmV2QWRkcy5maWx0ZXIobmFtZSA9PiByZW1vdmVzLmluZGV4T2YobmFtZSkgPCAwKS5jb25jYXQoa2VlcEFkZHMpXG4gICAgICBsZXQgbmV3UmVtb3ZlcyA9IHByZXZSZW1vdmVzLmZpbHRlcihuYW1lID0+IGFkZHMuaW5kZXhPZihuYW1lKSA8IDApLmNvbmNhdChrZWVwUmVtb3ZlcylcblxuICAgICAgRE9NLnB1dFN0aWNreShlbCwgXCJjbGFzc2VzXCIsIGN1cnJlbnRFbCA9PiB7XG4gICAgICAgIGN1cnJlbnRFbC5jbGFzc0xpc3QucmVtb3ZlKC4uLm5ld1JlbW92ZXMpXG4gICAgICAgIGN1cnJlbnRFbC5jbGFzc0xpc3QuYWRkKC4uLm5ld0FkZHMpXG4gICAgICAgIHJldHVybiBbbmV3QWRkcywgbmV3UmVtb3Zlc11cbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcblxuICBzZXRPclJlbW92ZUF0dHJzKGVsLCBzZXRzLCByZW1vdmVzKXtcbiAgICBsZXQgW3ByZXZTZXRzLCBwcmV2UmVtb3Zlc10gPSBET00uZ2V0U3RpY2t5KGVsLCBcImF0dHJzXCIsIFtbXSwgW11dKVxuXG4gICAgbGV0IGFsdGVyZWRBdHRycyA9IHNldHMubWFwKChbYXR0ciwgX3ZhbF0pID0+IGF0dHIpLmNvbmNhdChyZW1vdmVzKVxuICAgIGxldCBuZXdTZXRzID0gcHJldlNldHMuZmlsdGVyKChbYXR0ciwgX3ZhbF0pID0+ICFhbHRlcmVkQXR0cnMuaW5jbHVkZXMoYXR0cikpLmNvbmNhdChzZXRzKVxuICAgIGxldCBuZXdSZW1vdmVzID0gcHJldlJlbW92ZXMuZmlsdGVyKChhdHRyKSA9PiAhYWx0ZXJlZEF0dHJzLmluY2x1ZGVzKGF0dHIpKS5jb25jYXQocmVtb3ZlcylcblxuICAgIERPTS5wdXRTdGlja3koZWwsIFwiYXR0cnNcIiwgY3VycmVudEVsID0+IHtcbiAgICAgIG5ld1JlbW92ZXMuZm9yRWFjaChhdHRyID0+IGN1cnJlbnRFbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cikpXG4gICAgICBuZXdTZXRzLmZvckVhY2goKFthdHRyLCB2YWxdKSA9PiBjdXJyZW50RWwuc2V0QXR0cmlidXRlKGF0dHIsIHZhbCkpXG4gICAgICByZXR1cm4gW25ld1NldHMsIG5ld1JlbW92ZXNdXG4gICAgfSlcbiAgfSxcblxuICBoYXNBbGxDbGFzc2VzKGVsLCBjbGFzc2VzKXsgcmV0dXJuIGNsYXNzZXMuZXZlcnkobmFtZSA9PiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSkpIH0sXG5cbiAgaXNUb2dnbGVkT3V0KGVsLCBvdXRDbGFzc2VzKXtcbiAgICByZXR1cm4gIXRoaXMuaXNWaXNpYmxlKGVsKSB8fCB0aGlzLmhhc0FsbENsYXNzZXMoZWwsIG91dENsYXNzZXMpXG4gIH0sXG5cbiAgZmlsdGVyVG9FbHMobGl2ZVNvY2tldCwgc291cmNlRWwsIHt0b30pe1xuICAgIGxldCBkZWZhdWx0UXVlcnkgPSAoKSA9PiB7XG4gICAgICBpZih0eXBlb2YodG8pID09PSBcInN0cmluZ1wiKXtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodG8pXG4gICAgICB9IGVsc2UgaWYodG8uY2xvc2VzdCl7XG4gICAgICAgIGxldCB0b0VsID0gc291cmNlRWwuY2xvc2VzdCh0by5jbG9zZXN0KVxuICAgICAgICByZXR1cm4gdG9FbCA/IFt0b0VsXSA6IFtdXG4gICAgICB9IGVsc2UgaWYodG8uaW5uZXIpe1xuICAgICAgICByZXR1cm4gc291cmNlRWwucXVlcnlTZWxlY3RvckFsbCh0by5pbm5lcilcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvID8gbGl2ZVNvY2tldC5qc1F1ZXJ5U2VsZWN0b3JBbGwoc291cmNlRWwsIHRvLCBkZWZhdWx0UXVlcnkpIDogW3NvdXJjZUVsXVxuICB9LFxuXG4gIGRlZmF1bHREaXNwbGF5KGVsKXtcbiAgICByZXR1cm4ge3RyOiBcInRhYmxlLXJvd1wiLCB0ZDogXCJ0YWJsZS1jZWxsXCJ9W2VsLnRhZ05hbWUudG9Mb3dlckNhc2UoKV0gfHwgXCJibG9ja1wiXG4gIH0sXG5cbiAgdHJhbnNpdGlvbkNsYXNzZXModmFsKXtcbiAgICBpZighdmFsKXsgcmV0dXJuIG51bGwgfVxuXG4gICAgbGV0IFt0cmFucywgdFN0YXJ0LCB0RW5kXSA9IEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbCA6IFt2YWwuc3BsaXQoXCIgXCIpLCBbXSwgW11dXG4gICAgdHJhbnMgPSBBcnJheS5pc0FycmF5KHRyYW5zKSA/IHRyYW5zIDogdHJhbnMuc3BsaXQoXCIgXCIpXG4gICAgdFN0YXJ0ID0gQXJyYXkuaXNBcnJheSh0U3RhcnQpID8gdFN0YXJ0IDogdFN0YXJ0LnNwbGl0KFwiIFwiKVxuICAgIHRFbmQgPSBBcnJheS5pc0FycmF5KHRFbmQpID8gdEVuZCA6IHRFbmQuc3BsaXQoXCIgXCIpXG4gICAgcmV0dXJuIFt0cmFucywgdFN0YXJ0LCB0RW5kXVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEpTXG4iLCAiaW1wb3J0IEpTIGZyb20gXCIuL2pzXCJcbmltcG9ydCBET00gZnJvbSBcIi4vZG9tXCJcblxuY29uc3QgSE9PS19JRCA9IFwiaG9va0lkXCJcblxubGV0IHZpZXdIb29rSUQgPSAxXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaWV3SG9vayB7XG4gIHN0YXRpYyBtYWtlSUQoKXsgcmV0dXJuIHZpZXdIb29rSUQrKyB9XG4gIHN0YXRpYyBlbGVtZW50SUQoZWwpeyByZXR1cm4gRE9NLnByaXZhdGUoZWwsIEhPT0tfSUQpIH1cblxuICBjb25zdHJ1Y3Rvcih2aWV3LCBlbCwgY2FsbGJhY2tzKXtcbiAgICB0aGlzLmVsID0gZWxcbiAgICB0aGlzLl9fYXR0YWNoVmlldyh2aWV3KVxuICAgIHRoaXMuX19jYWxsYmFja3MgPSBjYWxsYmFja3NcbiAgICB0aGlzLl9fbGlzdGVuZXJzID0gbmV3IFNldCgpXG4gICAgdGhpcy5fX2lzRGlzY29ubmVjdGVkID0gZmFsc2VcbiAgICBET00ucHV0UHJpdmF0ZSh0aGlzLmVsLCBIT09LX0lELCB0aGlzLmNvbnN0cnVjdG9yLm1ha2VJRCgpKVxuICAgIGZvcihsZXQga2V5IGluIHRoaXMuX19jYWxsYmFja3MpeyB0aGlzW2tleV0gPSB0aGlzLl9fY2FsbGJhY2tzW2tleV0gfVxuICB9XG5cbiAgX19hdHRhY2hWaWV3KHZpZXcpe1xuICAgIGlmKHZpZXcpe1xuICAgICAgdGhpcy5fX3ZpZXcgPSAoKSA9PiB2aWV3XG4gICAgICB0aGlzLmxpdmVTb2NrZXQgPSB2aWV3LmxpdmVTb2NrZXRcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fX3ZpZXcgPSAoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaG9vayBub3QgeWV0IGF0dGFjaGVkIHRvIGEgbGl2ZSB2aWV3OiAke3RoaXMuZWwub3V0ZXJIVE1MfWApXG4gICAgICB9XG4gICAgICB0aGlzLmxpdmVTb2NrZXQgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgX19tb3VudGVkKCl7IHRoaXMubW91bnRlZCAmJiB0aGlzLm1vdW50ZWQoKSB9XG4gIF9fdXBkYXRlZCgpeyB0aGlzLnVwZGF0ZWQgJiYgdGhpcy51cGRhdGVkKCkgfVxuICBfX2JlZm9yZVVwZGF0ZSgpeyB0aGlzLmJlZm9yZVVwZGF0ZSAmJiB0aGlzLmJlZm9yZVVwZGF0ZSgpIH1cbiAgX19kZXN0cm95ZWQoKXtcbiAgICB0aGlzLmRlc3Ryb3llZCAmJiB0aGlzLmRlc3Ryb3llZCgpXG4gICAgRE9NLmRlbGV0ZVByaXZhdGUodGhpcy5lbCwgSE9PS19JRCkgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Bob2VuaXhmcmFtZXdvcmsvcGhvZW5peF9saXZlX3ZpZXcvaXNzdWVzLzM0OTZcbiAgfVxuICBfX3JlY29ubmVjdGVkKCl7XG4gICAgaWYodGhpcy5fX2lzRGlzY29ubmVjdGVkKXtcbiAgICAgIHRoaXMuX19pc0Rpc2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgICB0aGlzLnJlY29ubmVjdGVkICYmIHRoaXMucmVjb25uZWN0ZWQoKVxuICAgIH1cbiAgfVxuICBfX2Rpc2Nvbm5lY3RlZCgpe1xuICAgIHRoaXMuX19pc0Rpc2Nvbm5lY3RlZCA9IHRydWVcbiAgICB0aGlzLmRpc2Nvbm5lY3RlZCAmJiB0aGlzLmRpc2Nvbm5lY3RlZCgpXG4gIH1cblxuICAvKipcbiAgICogQmluZHMgdGhlIGhvb2sgdG8gSlMgY29tbWFuZHMuXG4gICAqXG4gICAqIEBwYXJhbSB7Vmlld0hvb2t9IGhvb2sgLSBUaGUgVmlld0hvb2sgaW5zdGFuY2UgdG8gYmluZC5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IHdpdGggbWV0aG9kcyB0byBtYW5pcHVsYXRlIHRoZSBET00gYW5kIGV4ZWN1dGUgSmF2YVNjcmlwdC5cbiAgICovXG4gIGpzKCl7XG4gICAgbGV0IGhvb2sgPSB0aGlzXG5cbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBFeGVjdXRlcyBlbmNvZGVkIEphdmFTY3JpcHQgaW4gdGhlIGNvbnRleHQgb2YgdGhlIGhvb2sgZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RlZEpTIC0gVGhlIGVuY29kZWQgSmF2YVNjcmlwdCBzdHJpbmcgdG8gZXhlY3V0ZS5cbiAgICAgICAqL1xuICAgICAgZXhlYyhlbmNvZGVkSlMpe1xuICAgICAgICBob29rLl9fdmlldygpLmxpdmVTb2NrZXQuZXhlY0pTKGhvb2suZWwsIGVuY29kZWRKUywgXCJob29rXCIpXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFNob3dzIGFuIGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgLSBUaGUgZWxlbWVudCB0byBzaG93LlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzPXt9XSAtIE9wdGlvbmFsIHNldHRpbmdzLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmRpc3BsYXldIC0gVGhlIENTUyBkaXNwbGF5IHZhbHVlIHRvIHNldC4gRGVmYXVsdHMgXCJibG9ja1wiLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnRyYW5zaXRpb25dIC0gVGhlIENTUyB0cmFuc2l0aW9uIGNsYXNzZXMgdG8gc2V0IHdoZW4gc2hvd2luZy5cbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy50aW1lXSAtIFRoZSB0cmFuc2l0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy4gRGVmYXVsdHMgMjAwLlxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5ibG9ja2luZ10gLSBUaGUgYm9vbGVhbiBmbGFnIHRvIGJsb2NrIHRoZSBVSSBkdXJpbmcgdGhlIHRyYW5zaXRpb24uXG4gICAgICAgKiAgRGVmYXVsdHMgYHRydWVgLlxuICAgICAgICovXG4gICAgICBzaG93KGVsLCBvcHRzID0ge30pe1xuICAgICAgICBsZXQgb3duZXIgPSBob29rLl9fdmlldygpLmxpdmVTb2NrZXQub3duZXIoZWwpXG4gICAgICAgIEpTLnNob3coXCJob29rXCIsIG93bmVyLCBlbCwgb3B0cy5kaXNwbGF5LCBvcHRzLnRyYW5zaXRpb24sIG9wdHMudGltZSwgb3B0cy5ibG9ja2luZylcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogSGlkZXMgYW4gZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCAtIFRoZSBlbGVtZW50IHRvIGhpZGUuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHM9e31dIC0gT3B0aW9uYWwgc2V0dGluZ3MuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMudHJhbnNpdGlvbl0gLSBUaGUgQ1NTIHRyYW5zaXRpb24gY2xhc3NlcyB0byBzZXQgd2hlbiBoaWRpbmcuXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMudGltZV0gLSBUaGUgdHJhbnNpdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuIERlZmF1bHRzIDIwMC5cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuYmxvY2tpbmddIC0gVGhlIGJvb2xlYW4gZmxhZyB0byBibG9jayB0aGUgVUkgZHVyaW5nIHRoZSB0cmFuc2l0aW9uLlxuICAgICAgICogICBEZWZhdWx0cyBgdHJ1ZWAuXG4gICAgICAgKi9cbiAgICAgIGhpZGUoZWwsIG9wdHMgPSB7fSl7XG4gICAgICAgIGxldCBvd25lciA9IGhvb2suX192aWV3KCkubGl2ZVNvY2tldC5vd25lcihlbClcbiAgICAgICAgSlMuaGlkZShcImhvb2tcIiwgb3duZXIsIGVsLCBudWxsLCBvcHRzLnRyYW5zaXRpb24sIG9wdHMudGltZSwgb3B0cy5ibG9ja2luZylcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlcyB0aGUgdmlzaWJpbGl0eSBvZiBhbiBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIC0gVGhlIGVsZW1lbnQgdG8gdG9nZ2xlLlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzPXt9XSAtIE9wdGlvbmFsIHNldHRpbmdzLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmRpc3BsYXldIC0gVGhlIENTUyBkaXNwbGF5IHZhbHVlIHRvIHNldC4gRGVmYXVsdHMgXCJibG9ja1wiLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmluXSAtIFRoZSBDU1MgdHJhbnNpdGlvbiBjbGFzc2VzIGZvciBzaG93aW5nLlxuICAgICAgICogICBBY2NlcHRzIGVpdGhlciB0aGUgc3RyaW5nIG9mIGNsYXNzZXMgdG8gYXBwbHkgd2hlbiB0b2dnbGluZyBpbiwgb3JcbiAgICAgICAqICAgYSAzLXR1cGxlIGNvbnRhaW5pbmcgdGhlIHRyYW5zaXRpb24gY2xhc3MsIHRoZSBjbGFzcyB0byBhcHBseVxuICAgICAgICogICB0byBzdGFydCB0aGUgdHJhbnNpdGlvbiwgYW5kIHRoZSBlbmRpbmcgdHJhbnNpdGlvbiBjbGFzcywgc3VjaCBhczpcbiAgICAgICAqXG4gICAgICAgKiAgICAgICBbXCJlYXNlLW91dCBkdXJhdGlvbi0zMDBcIiwgXCJvcGFjaXR5LTBcIiwgXCJvcGFjaXR5LTEwMFwiXVxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5vdXRdIC0gVGhlIENTUyB0cmFuc2l0aW9uIGNsYXNzZXMgZm9yIGhpZGluZy5cbiAgICAgICAqICAgQWNjZXB0cyBlaXRoZXIgc3RyaW5nIG9mIGNsYXNzZXMgdG8gYXBwbHkgd2hlbiB0b2dnbGluZyBvdXQsIG9yXG4gICAgICAgKiAgIGEgMy10dXBsZSBjb250YWluaW5nIHRoZSB0cmFuc2l0aW9uIGNsYXNzLCB0aGUgY2xhc3MgdG8gYXBwbHlcbiAgICAgICAqICAgdG8gc3RhcnQgdGhlIHRyYW5zaXRpb24sIGFuZCB0aGUgZW5kaW5nIHRyYW5zaXRpb24gY2xhc3MsIHN1Y2ggYXM6XG4gICAgICAgKlxuICAgICAgICogICAgICAgW1wiZWFzZS1vdXQgZHVyYXRpb24tMzAwXCIsIFwib3BhY2l0eS0xMDBcIiwgXCJvcGFjaXR5LTBcIl1cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMudGltZV0gLSBUaGUgdHJhbnNpdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5ibG9ja2luZ10gLSBUaGUgYm9vbGVhbiBmbGFnIHRvIGJsb2NrIHRoZSBVSSBkdXJpbmcgdGhlIHRyYW5zaXRpb24uXG4gICAgICAgKiAgIERlZmF1bHRzIGB0cnVlYC5cbiAgICAgICAqL1xuICAgICAgdG9nZ2xlKGVsLCBvcHRzID0ge30pe1xuICAgICAgICBsZXQgb3duZXIgPSBob29rLl9fdmlldygpLmxpdmVTb2NrZXQub3duZXIoZWwpXG4gICAgICAgIG9wdHMuaW4gPSBKUy50cmFuc2l0aW9uQ2xhc3NlcyhvcHRzLmluKVxuICAgICAgICBvcHRzLm91dCA9IEpTLnRyYW5zaXRpb25DbGFzc2VzKG9wdHMub3V0KVxuICAgICAgICBKUy50b2dnbGUoXCJob29rXCIsIG93bmVyLCBlbCwgb3B0cy5kaXNwbGF5LCBvcHRzLmluLCBvcHRzLm91dCwgb3B0cy50aW1lLCBvcHRzLmJsb2NraW5nKVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBBZGRzIENTUyBjbGFzc2VzIHRvIGFuIGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgLSBUaGUgZWxlbWVudCB0byBhZGQgY2xhc3NlcyB0by5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBuYW1lcyAtIFRoZSBjbGFzcyBuYW1lKHMpIHRvIGFkZC5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cz17fV0gLSBPcHRpb25hbCBzZXR0aW5ncy5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy50cmFuc2l0aW9uXSAtIFRoZSBDU1MgdHJhbnNpdGlvbiBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICAgKiAgIEFjY2VwdHMgYSBzdHJpbmcgb2YgY2xhc3NlcyB0byBhcHBseSB3aGVuIGFkZGluZyBjbGFzc2VzIG9yXG4gICAgICAgKiAgIGEgMy10dXBsZSBjb250YWluaW5nIHRoZSB0cmFuc2l0aW9uIGNsYXNzLCB0aGUgY2xhc3MgdG8gYXBwbHlcbiAgICAgICAqICAgdG8gc3RhcnQgdGhlIHRyYW5zaXRpb24sIGFuZCB0aGUgZW5kaW5nIHRyYW5zaXRpb24gY2xhc3MsIHN1Y2ggYXM6XG4gICAgICAgKlxuICAgICAgICogICAgICAgW1wiZWFzZS1vdXQgZHVyYXRpb24tMzAwXCIsIFwib3BhY2l0eS0wXCIsIFwib3BhY2l0eS0xMDBcIl1cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMudGltZV0gLSBUaGUgdHJhbnNpdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmJsb2NraW5nXSAtIFRoZSBib29sZWFuIGZsYWcgdG8gYmxvY2sgdGhlIFVJIGR1cmluZyB0aGUgdHJhbnNpdGlvbi5cbiAgICAgICAqICAgRGVmYXVsdHMgYHRydWVgLlxuICAgICAgICovXG4gICAgICBhZGRDbGFzcyhlbCwgbmFtZXMsIG9wdHMgPSB7fSl7XG4gICAgICAgIG5hbWVzID0gQXJyYXkuaXNBcnJheShuYW1lcykgPyBuYW1lcyA6IG5hbWVzLnNwbGl0KFwiIFwiKVxuICAgICAgICBsZXQgb3duZXIgPSBob29rLl9fdmlldygpLmxpdmVTb2NrZXQub3duZXIoZWwpXG4gICAgICAgIEpTLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgbmFtZXMsIFtdLCBvcHRzLnRyYW5zaXRpb24sIG9wdHMudGltZSwgb3duZXIsIG9wdHMuYmxvY2tpbmcpXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZXMgQ1NTIGNsYXNzZXMgZnJvbSBhbiBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIC0gVGhlIGVsZW1lbnQgdG8gcmVtb3ZlIGNsYXNzZXMgZnJvbS5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBuYW1lcyAtIFRoZSBjbGFzcyBuYW1lKHMpIHRvIHJlbW92ZS5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cz17fV0gLSBPcHRpb25hbCBzZXR0aW5ncy5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy50cmFuc2l0aW9uXSAtIFRoZSBDU1MgdHJhbnNpdGlvbiBjbGFzc2VzIHRvIHNldC5cbiAgICAgICAqICAgQWNjZXB0cyBhIHN0cmluZyBvZiBjbGFzc2VzIHRvIGFwcGx5IHdoZW4gcmVtb3ZpbmcgY2xhc3NlcyBvclxuICAgICAgICogICBhIDMtdHVwbGUgY29udGFpbmluZyB0aGUgdHJhbnNpdGlvbiBjbGFzcywgdGhlIGNsYXNzIHRvIGFwcGx5XG4gICAgICAgKiAgIHRvIHN0YXJ0IHRoZSB0cmFuc2l0aW9uLCBhbmQgdGhlIGVuZGluZyB0cmFuc2l0aW9uIGNsYXNzLCBzdWNoIGFzOlxuICAgICAgICpcbiAgICAgICAqICAgICAgIFtcImVhc2Utb3V0IGR1cmF0aW9uLTMwMFwiLCBcIm9wYWNpdHktMTAwXCIsIFwib3BhY2l0eS0wXCJdXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnRpbWVdIC0gVGhlIHRyYW5zaXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5ibG9ja2luZ10gLSBUaGUgYm9vbGVhbiBmbGFnIHRvIGJsb2NrIHRoZSBVSSBkdXJpbmcgdGhlIHRyYW5zaXRpb24uXG4gICAgICAgKiAgIERlZmF1bHRzIGB0cnVlYC5cbiAgICAgICAqL1xuICAgICAgcmVtb3ZlQ2xhc3MoZWwsIG5hbWVzLCBvcHRzID0ge30pe1xuICAgICAgICBvcHRzLnRyYW5zaXRpb24gPSBKUy50cmFuc2l0aW9uQ2xhc3NlcyhvcHRzLnRyYW5zaXRpb24pXG4gICAgICAgIG5hbWVzID0gQXJyYXkuaXNBcnJheShuYW1lcykgPyBuYW1lcyA6IG5hbWVzLnNwbGl0KFwiIFwiKVxuICAgICAgICBsZXQgb3duZXIgPSBob29rLl9fdmlldygpLmxpdmVTb2NrZXQub3duZXIoZWwpXG4gICAgICAgIEpTLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgW10sIG5hbWVzLCBvcHRzLnRyYW5zaXRpb24sIG9wdHMudGltZSwgb3duZXIsIG9wdHMuYmxvY2tpbmcpXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZXMgQ1NTIGNsYXNzZXMgb24gYW4gZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCAtIFRoZSBlbGVtZW50IHRvIHRvZ2dsZSBjbGFzc2VzIG9uLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IG5hbWVzIC0gVGhlIGNsYXNzIG5hbWUocykgdG8gdG9nZ2xlLlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzPXt9XSAtIE9wdGlvbmFsIHNldHRpbmdzLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnRyYW5zaXRpb25dIC0gVGhlIENTUyB0cmFuc2l0aW9uIGNsYXNzZXMgdG8gc2V0LlxuICAgICAgICogICBBY2NlcHRzIGEgc3RyaW5nIG9mIGNsYXNzZXMgdG8gYXBwbHkgd2hlbiB0b2dnbGluZyBjbGFzc2VzIG9yXG4gICAgICAgKiAgIGEgMy10dXBsZSBjb250YWluaW5nIHRoZSB0cmFuc2l0aW9uIGNsYXNzLCB0aGUgY2xhc3MgdG8gYXBwbHlcbiAgICAgICAqICAgdG8gc3RhcnQgdGhlIHRyYW5zaXRpb24sIGFuZCB0aGUgZW5kaW5nIHRyYW5zaXRpb24gY2xhc3MsIHN1Y2ggYXM6XG4gICAgICAgKlxuICAgICAgICogICAgICAgW1wiZWFzZS1vdXQgZHVyYXRpb24tMzAwXCIsIFwib3BhY2l0eS0xMDBcIiwgXCJvcGFjaXR5LTBcIl1cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMudGltZV0gLSBUaGUgdHJhbnNpdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmJsb2NraW5nXSAtIFRoZSBib29sZWFuIGZsYWcgdG8gYmxvY2sgdGhlIFVJIGR1cmluZyB0aGUgdHJhbnNpdGlvbi5cbiAgICAgICAqICAgRGVmYXVsdHMgYHRydWVgLlxuICAgICAgICovXG4gICAgICB0b2dnbGVDbGFzcyhlbCwgbmFtZXMsIG9wdHMgPSB7fSl7XG4gICAgICAgIG9wdHMudHJhbnNpdGlvbiA9IEpTLnRyYW5zaXRpb25DbGFzc2VzKG9wdHMudHJhbnNpdGlvbilcbiAgICAgICAgbmFtZXMgPSBBcnJheS5pc0FycmF5KG5hbWVzKSA/IG5hbWVzIDogbmFtZXMuc3BsaXQoXCIgXCIpXG4gICAgICAgIGxldCBvd25lciA9IGhvb2suX192aWV3KCkubGl2ZVNvY2tldC5vd25lcihlbClcbiAgICAgICAgSlMudG9nZ2xlQ2xhc3NlcyhlbCwgbmFtZXMsIG9wdHMudHJhbnNpdGlvbiwgb3B0cy50aW1lLCBvd25lciwgb3B0cy5ibG9ja2luZylcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQXBwbGllcyBhIENTUyB0cmFuc2l0aW9uIHRvIGFuIGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgLSBUaGUgZWxlbWVudCB0byBhcHBseSB0aGUgdHJhbnNpdGlvbiB0by5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSB0cmFuc2l0aW9uIC0gVGhlIHRyYW5zaXRpb24gY2xhc3MoZXMpIHRvIGFwcGx5LlxuICAgICAgICogICBBY2NlcHRzIGEgc3RyaW5nIG9mIGNsYXNzZXMgdG8gYXBwbHkgd2hlbiB0cmFuc2l0aW9uaW5nIG9yXG4gICAgICAgKiAgIGEgMy10dXBsZSBjb250YWluaW5nIHRoZSB0cmFuc2l0aW9uIGNsYXNzLCB0aGUgY2xhc3MgdG8gYXBwbHlcbiAgICAgICAqICAgdG8gc3RhcnQgdGhlIHRyYW5zaXRpb24sIGFuZCB0aGUgZW5kaW5nIHRyYW5zaXRpb24gY2xhc3MsIHN1Y2ggYXM6XG4gICAgICAgKlxuICAgICAgICogICAgICAgW1wiZWFzZS1vdXQgZHVyYXRpb24tMzAwXCIsIFwib3BhY2l0eS0xMDBcIiwgXCJvcGFjaXR5LTBcIl1cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHM9e31dIC0gT3B0aW9uYWwgc2V0dGluZ3MuXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMudGltZV0gLSBUaGUgdHJhbnNpdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmJsb2NraW5nXSAtIFRoZSBib29sZWFuIGZsYWcgdG8gYmxvY2sgdGhlIFVJIGR1cmluZyB0aGUgdHJhbnNpdGlvbi5cbiAgICAgICAqICAgRGVmYXVsdHMgYHRydWVgLlxuICAgICAgICovXG4gICAgICB0cmFuc2l0aW9uKGVsLCB0cmFuc2l0aW9uLCBvcHRzID0ge30pe1xuICAgICAgICBsZXQgb3duZXIgPSBob29rLl9fdmlldygpLmxpdmVTb2NrZXQub3duZXIoZWwpXG4gICAgICAgIEpTLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgW10sIFtdLCBKUy50cmFuc2l0aW9uQ2xhc3Nlcyh0cmFuc2l0aW9uKSwgb3B0cy50aW1lLCBvd25lciwgb3B0cy5ibG9ja2luZylcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0cyBhbiBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCAtIFRoZSBlbGVtZW50IHRvIHNldCB0aGUgYXR0cmlidXRlIG9uLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHIgLSBUaGUgYXR0cmlidXRlIG5hbWUgdG8gc2V0LlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbCAtIFRoZSB2YWx1ZSB0byBzZXQgZm9yIHRoZSBhdHRyaWJ1dGUuXG4gICAgICAgKi9cbiAgICAgIHNldEF0dHJpYnV0ZShlbCwgYXR0ciwgdmFsKXsgSlMuc2V0T3JSZW1vdmVBdHRycyhlbCwgW1thdHRyLCB2YWxdXSwgW10pIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlcyBhbiBhdHRyaWJ1dGUgZnJvbSBhbiBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIC0gVGhlIGVsZW1lbnQgdG8gcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgZnJvbS5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyIC0gVGhlIGF0dHJpYnV0ZSBuYW1lIHRvIHJlbW92ZS5cbiAgICAgICAqL1xuICAgICAgcmVtb3ZlQXR0cmlidXRlKGVsLCBhdHRyKXsgSlMuc2V0T3JSZW1vdmVBdHRycyhlbCwgW10sIFthdHRyXSkgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGVzIGFuIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50IGJldHdlZW4gdHdvIHZhbHVlcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCAtIFRoZSBlbGVtZW50IHRvIHRvZ2dsZSB0aGUgYXR0cmlidXRlIG9uLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHIgLSBUaGUgYXR0cmlidXRlIG5hbWUgdG8gdG9nZ2xlLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbDEgLSBUaGUgZmlyc3QgdmFsdWUgdG8gdG9nZ2xlIGJldHdlZW4uXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsMiAtIFRoZSBzZWNvbmQgdmFsdWUgdG8gdG9nZ2xlIGJldHdlZW4uXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZUF0dHJpYnV0ZShlbCwgYXR0ciwgdmFsMSwgdmFsMil7IEpTLnRvZ2dsZUF0dHIoZWwsIGF0dHIsIHZhbDEsIHZhbDIpIH0sXG4gICAgfVxuICB9XG5cbiAgcHVzaEV2ZW50KGV2ZW50LCBwYXlsb2FkID0ge30sIG9uUmVwbHkpe1xuICAgIGlmKG9uUmVwbHkgPT09IHVuZGVmaW5lZCl7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlZiA9IHRoaXMuX192aWV3KCkucHVzaEhvb2tFdmVudCh0aGlzLmVsLCBudWxsLCBldmVudCwgcGF5bG9hZCwgKHJlcGx5LCBfcmVmKSA9PiByZXNvbHZlKHJlcGx5KSlcbiAgICAgICAgICBpZihyZWYgPT09IGZhbHNlKXtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJ1bmFibGUgdG8gcHVzaCBob29rIGV2ZW50LiBMaXZlVmlldyBub3QgY29ubmVjdGVkXCIpKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3Ipe1xuICAgICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX192aWV3KCkucHVzaEhvb2tFdmVudCh0aGlzLmVsLCBudWxsLCBldmVudCwgcGF5bG9hZCwgb25SZXBseSlcbiAgfVxuXG4gIHB1c2hFdmVudFRvKHBoeFRhcmdldCwgZXZlbnQsIHBheWxvYWQgPSB7fSwgb25SZXBseSl7XG4gICAgaWYob25SZXBseSA9PT0gdW5kZWZpbmVkKXtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5fX3ZpZXcoKS53aXRoaW5UYXJnZXRzKHBoeFRhcmdldCwgKHZpZXcsIHRhcmdldEN0eCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVmID0gdmlldy5wdXNoSG9va0V2ZW50KHRoaXMuZWwsIHRhcmdldEN0eCwgZXZlbnQsIHBheWxvYWQsIChyZXBseSwgX3JlZikgPT4gcmVzb2x2ZShyZXBseSkpXG4gICAgICAgICAgICBpZihyZWYgPT09IGZhbHNlKXtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcInVuYWJsZSB0byBwdXNoIGhvb2sgZXZlbnQuIExpdmVWaWV3IG5vdCBjb25uZWN0ZWRcIikpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSBjYXRjaCAoZXJyb3Ipe1xuICAgICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX192aWV3KCkud2l0aGluVGFyZ2V0cyhwaHhUYXJnZXQsICh2aWV3LCB0YXJnZXRDdHgpID0+IHtcbiAgICAgIHJldHVybiB2aWV3LnB1c2hIb29rRXZlbnQodGhpcy5lbCwgdGFyZ2V0Q3R4LCBldmVudCwgcGF5bG9hZCwgb25SZXBseSlcbiAgICB9KVxuICB9XG5cbiAgaGFuZGxlRXZlbnQoZXZlbnQsIGNhbGxiYWNrKXtcbiAgICBsZXQgY2FsbGJhY2tSZWYgPSAoY3VzdG9tRXZlbnQsIGJ5cGFzcykgPT4gYnlwYXNzID8gZXZlbnQgOiBjYWxsYmFjayhjdXN0b21FdmVudC5kZXRhaWwpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoYHBoeDoke2V2ZW50fWAsIGNhbGxiYWNrUmVmKVxuICAgIHRoaXMuX19saXN0ZW5lcnMuYWRkKGNhbGxiYWNrUmVmKVxuICAgIHJldHVybiBjYWxsYmFja1JlZlxuICB9XG5cbiAgcmVtb3ZlSGFuZGxlRXZlbnQoY2FsbGJhY2tSZWYpe1xuICAgIGxldCBldmVudCA9IGNhbGxiYWNrUmVmKG51bGwsIHRydWUpXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoYHBoeDoke2V2ZW50fWAsIGNhbGxiYWNrUmVmKVxuICAgIHRoaXMuX19saXN0ZW5lcnMuZGVsZXRlKGNhbGxiYWNrUmVmKVxuICB9XG5cbiAgdXBsb2FkKG5hbWUsIGZpbGVzKXtcbiAgICByZXR1cm4gdGhpcy5fX3ZpZXcoKS5kaXNwYXRjaFVwbG9hZHMobnVsbCwgbmFtZSwgZmlsZXMpXG4gIH1cblxuICB1cGxvYWRUbyhwaHhUYXJnZXQsIG5hbWUsIGZpbGVzKXtcbiAgICByZXR1cm4gdGhpcy5fX3ZpZXcoKS53aXRoaW5UYXJnZXRzKHBoeFRhcmdldCwgKHZpZXcsIHRhcmdldEN0eCkgPT4ge1xuICAgICAgdmlldy5kaXNwYXRjaFVwbG9hZHModGFyZ2V0Q3R4LCBuYW1lLCBmaWxlcylcbiAgICB9KVxuICB9XG5cbiAgX19jbGVhbnVwX18oKXtcbiAgICB0aGlzLl9fbGlzdGVuZXJzLmZvckVhY2goY2FsbGJhY2tSZWYgPT4gdGhpcy5yZW1vdmVIYW5kbGVFdmVudChjYWxsYmFja1JlZikpXG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBCRUZPUkVfVU5MT0FEX0xPQURFUl9USU1FT1VULFxuICBDSEVDS0FCTEVfSU5QVVRTLFxuICBDT05TRUNVVElWRV9SRUxPQURTLFxuICBQSFhfQVVUT19SRUNPVkVSLFxuICBQSFhfQ09NUE9ORU5ULFxuICBQSFhfQ09OTkVDVEVEX0NMQVNTLFxuICBQSFhfRElTQUJMRV9XSVRILFxuICBQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUsXG4gIFBIWF9ESVNBQkxFRCxcbiAgUEhYX0xPQURJTkdfQ0xBU1MsXG4gIFBIWF9FUlJPUl9DTEFTUyxcbiAgUEhYX0NMSUVOVF9FUlJPUl9DTEFTUyxcbiAgUEhYX1NFUlZFUl9FUlJPUl9DTEFTUyxcbiAgUEhYX0hBU19GT0NVU0VELFxuICBQSFhfSEFTX1NVQk1JVFRFRCxcbiAgUEhYX0hPT0ssXG4gIFBIWF9QQVJFTlRfSUQsXG4gIFBIWF9QUk9HUkVTUyxcbiAgUEhYX1JFQURPTkxZLFxuICBQSFhfUkVGX0xPQURJTkcsXG4gIFBIWF9SRUZfU1JDLFxuICBQSFhfUkVGX0xPQ0ssXG4gIFBIWF9ST09UX0lELFxuICBQSFhfU0VTU0lPTixcbiAgUEhYX1NUQVRJQyxcbiAgUEhYX1RSQUNLX1NUQVRJQyxcbiAgUEhYX1RSQUNLX1VQTE9BRFMsXG4gIFBIWF9VUERBVEUsXG4gIFBIWF9VUExPQURfUkVGLFxuICBQSFhfVklFV19TRUxFQ1RPUixcbiAgUEhYX01BSU4sXG4gIFBIWF9NT1VOVEVELFxuICBQVVNIX1RJTUVPVVQsXG4gIFBIWF9WSUVXUE9SVF9UT1AsXG4gIFBIWF9WSUVXUE9SVF9CT1RUT00sXG4gIE1BWF9DSElMRF9KT0lOX0FUVEVNUFRTXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG4gIGNsb25lLFxuICBjbG9zZXN0UGh4QmluZGluZyxcbiAgaXNFbXB0eSxcbiAgaXNFcXVhbE9iaixcbiAgbG9nRXJyb3IsXG4gIG1heWJlLFxuICBpc0NpZCxcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5pbXBvcnQgQnJvd3NlciBmcm9tIFwiLi9icm93c2VyXCJcbmltcG9ydCBET00gZnJvbSBcIi4vZG9tXCJcbmltcG9ydCBFbGVtZW50UmVmIGZyb20gXCIuL2VsZW1lbnRfcmVmXCJcbmltcG9ydCBET01QYXRjaCBmcm9tIFwiLi9kb21fcGF0Y2hcIlxuaW1wb3J0IExpdmVVcGxvYWRlciBmcm9tIFwiLi9saXZlX3VwbG9hZGVyXCJcbmltcG9ydCBSZW5kZXJlZCBmcm9tIFwiLi9yZW5kZXJlZFwiXG5pbXBvcnQgVmlld0hvb2sgZnJvbSBcIi4vdmlld19ob29rXCJcbmltcG9ydCBKUyBmcm9tIFwiLi9qc1wiXG5cbmV4cG9ydCBsZXQgcHJlcGVuZEZvcm1EYXRhS2V5ID0gKGtleSwgcHJlZml4KSA9PiB7XG4gIGxldCBpc0FycmF5ID0ga2V5LmVuZHNXaXRoKFwiW11cIilcbiAgLy8gUmVtb3ZlIHRoZSBcIltdXCIgaWYgaXQncyBhbiBhcnJheVxuICBsZXQgYmFzZUtleSA9IGlzQXJyYXkgPyBrZXkuc2xpY2UoMCwgLTIpIDoga2V5XG4gIC8vIFJlcGxhY2UgbGFzdCBvY2N1cnJlbmNlIG9mIGtleSBiZWZvcmUgYSBjbG9zaW5nIGJyYWNrZXQgb3IgdGhlIGVuZCB3aXRoIGtleSBwbHVzIHN1ZmZpeFxuICBiYXNlS2V5ID0gYmFzZUtleS5yZXBsYWNlKC8oW15cXFtcXF1dKykoXFxdPyQpLywgYCR7cHJlZml4fSQxJDJgKVxuICAvLyBBZGQgYmFjayB0aGUgXCJbXVwiIGlmIGl0IHdhcyBhbiBhcnJheVxuICBpZihpc0FycmF5KXsgYmFzZUtleSArPSBcIltdXCIgfVxuICByZXR1cm4gYmFzZUtleVxufVxuXG5sZXQgc2VyaWFsaXplRm9ybSA9IChmb3JtLCBtZXRhZGF0YSwgb25seU5hbWVzID0gW10pID0+IHtcbiAgY29uc3Qge3N1Ym1pdHRlciwgLi4ubWV0YX0gPSBtZXRhZGF0YVxuXG4gIC8vIFdlIG11c3QgaW5qZWN0IHRoZSBzdWJtaXR0ZXIgaW4gdGhlIG9yZGVyIHRoYXQgaXQgZXhpc3RzIGluIHRoZSBET01cbiAgLy8gcmVsYXRpdmUgdG8gb3RoZXIgaW5wdXRzLiBGb3IgZXhhbXBsZSwgZm9yIGNoZWNrYm94IGdyb3VwcywgdGhlIG9yZGVyIG11c3QgYmUgbWFpbnRhaW5lZC5cbiAgbGV0IGluamVjdGVkRWxlbWVudFxuICBpZihzdWJtaXR0ZXIgJiYgc3VibWl0dGVyLm5hbWUpe1xuICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpXG4gICAgaW5wdXQudHlwZSA9IFwiaGlkZGVuXCJcbiAgICAvLyBzZXQgdGhlIGZvcm0gYXR0cmlidXRlIGlmIHRoZSBzdWJtaXR0ZXIgaGFzIG9uZTtcbiAgICAvLyB0aGlzIGNhbiBoYXBwZW4gaWYgdGhlIGVsZW1lbnQgaXMgb3V0c2lkZSB0aGUgYWN0dWFsIGZvcm0gZWxlbWVudFxuICAgIGNvbnN0IGZvcm1JZCA9IHN1Ym1pdHRlci5nZXRBdHRyaWJ1dGUoXCJmb3JtXCIpXG4gICAgaWYoZm9ybUlkKXtcbiAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcImZvcm1cIiwgZm9ybUlkKVxuICAgIH1cbiAgICBpbnB1dC5uYW1lID0gc3VibWl0dGVyLm5hbWVcbiAgICBpbnB1dC52YWx1ZSA9IHN1Ym1pdHRlci52YWx1ZVxuICAgIHN1Ym1pdHRlci5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZShpbnB1dCwgc3VibWl0dGVyKVxuICAgIGluamVjdGVkRWxlbWVudCA9IGlucHV0XG4gIH1cblxuICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YShmb3JtKVxuICBjb25zdCB0b1JlbW92ZSA9IFtdXG5cbiAgZm9ybURhdGEuZm9yRWFjaCgodmFsLCBrZXksIF9pbmRleCkgPT4ge1xuICAgIGlmKHZhbCBpbnN0YW5jZW9mIEZpbGUpeyB0b1JlbW92ZS5wdXNoKGtleSkgfVxuICB9KVxuXG4gIC8vIENsZWFudXAgYWZ0ZXIgYnVpbGRpbmcgZmlsZURhdGFcbiAgdG9SZW1vdmUuZm9yRWFjaChrZXkgPT4gZm9ybURhdGEuZGVsZXRlKGtleSkpXG5cbiAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpXG5cbiAgbGV0IGVsZW1lbnRzID0gQXJyYXkuZnJvbShmb3JtLmVsZW1lbnRzKVxuICBmb3IobGV0IFtrZXksIHZhbF0gb2YgZm9ybURhdGEuZW50cmllcygpKXtcbiAgICBpZihvbmx5TmFtZXMubGVuZ3RoID09PSAwIHx8IG9ubHlOYW1lcy5pbmRleE9mKGtleSkgPj0gMCl7XG4gICAgICBsZXQgaW5wdXRzID0gZWxlbWVudHMuZmlsdGVyKGlucHV0ID0+IGlucHV0Lm5hbWUgPT09IGtleSlcbiAgICAgIGxldCBpc1VudXNlZCA9ICFpbnB1dHMuc29tZShpbnB1dCA9PiAoRE9NLnByaXZhdGUoaW5wdXQsIFBIWF9IQVNfRk9DVVNFRCkgfHwgRE9NLnByaXZhdGUoaW5wdXQsIFBIWF9IQVNfU1VCTUlUVEVEKSkpXG4gICAgICBsZXQgaGlkZGVuID0gaW5wdXRzLmV2ZXJ5KGlucHV0ID0+IGlucHV0LnR5cGUgPT09IFwiaGlkZGVuXCIpXG4gICAgICBpZihpc1VudXNlZCAmJiAhKHN1Ym1pdHRlciAmJiBzdWJtaXR0ZXIubmFtZSA9PSBrZXkpICYmICFoaWRkZW4pe1xuICAgICAgICBwYXJhbXMuYXBwZW5kKHByZXBlbmRGb3JtRGF0YUtleShrZXksIFwiX3VudXNlZF9cIiksIFwiXCIpXG4gICAgICB9XG4gICAgICBwYXJhbXMuYXBwZW5kKGtleSwgdmFsKVxuICAgIH1cbiAgfVxuXG4gIC8vIHJlbW92ZSB0aGUgaW5qZWN0ZWQgZWxlbWVudCBhZ2FpblxuICAvLyAoaXQgd291bGQgYmUgcmVtb3ZlZCBieSB0aGUgbmV4dCBkb20gcGF0Y2ggYW55d2F5LCBidXQgdGhpcyBpcyBjbGVhbmVyKVxuICBpZihzdWJtaXR0ZXIgJiYgaW5qZWN0ZWRFbGVtZW50KXtcbiAgICBzdWJtaXR0ZXIucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChpbmplY3RlZEVsZW1lbnQpXG4gIH1cblxuICBmb3IobGV0IG1ldGFLZXkgaW4gbWV0YSl7IHBhcmFtcy5hcHBlbmQobWV0YUtleSwgbWV0YVttZXRhS2V5XSkgfVxuXG4gIHJldHVybiBwYXJhbXMudG9TdHJpbmcoKVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaWV3IHtcbiAgc3RhdGljIGNsb3Nlc3RWaWV3KGVsKXtcbiAgICBsZXQgbGl2ZVZpZXdFbCA9IGVsLmNsb3Nlc3QoUEhYX1ZJRVdfU0VMRUNUT1IpXG4gICAgcmV0dXJuIGxpdmVWaWV3RWwgPyBET00ucHJpdmF0ZShsaXZlVmlld0VsLCBcInZpZXdcIikgOiBudWxsXG4gIH1cblxuICBjb25zdHJ1Y3RvcihlbCwgbGl2ZVNvY2tldCwgcGFyZW50VmlldywgZmxhc2gsIGxpdmVSZWZlcmVyKXtcbiAgICB0aGlzLmlzRGVhZCA9IGZhbHNlXG4gICAgdGhpcy5saXZlU29ja2V0ID0gbGl2ZVNvY2tldFxuICAgIHRoaXMuZmxhc2ggPSBmbGFzaFxuICAgIHRoaXMucGFyZW50ID0gcGFyZW50Vmlld1xuICAgIHRoaXMucm9vdCA9IHBhcmVudFZpZXcgPyBwYXJlbnRWaWV3LnJvb3QgOiB0aGlzXG4gICAgdGhpcy5lbCA9IGVsXG4gICAgRE9NLnB1dFByaXZhdGUodGhpcy5lbCwgXCJ2aWV3XCIsIHRoaXMpXG4gICAgdGhpcy5pZCA9IHRoaXMuZWwuaWRcbiAgICB0aGlzLnJlZiA9IDBcbiAgICB0aGlzLmxhc3RBY2tSZWYgPSBudWxsXG4gICAgdGhpcy5jaGlsZEpvaW5zID0gMFxuICAgIHRoaXMubG9hZGVyVGltZXIgPSBudWxsXG4gICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXVxuICAgIHRoaXMucGVuZGluZ0Zvcm1zID0gbmV3IFNldCgpXG4gICAgdGhpcy5yZWRpcmVjdCA9IGZhbHNlXG4gICAgdGhpcy5ocmVmID0gbnVsbFxuICAgIHRoaXMuam9pbkNvdW50ID0gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5qb2luQ291bnQgLSAxIDogMFxuICAgIHRoaXMuam9pbkF0dGVtcHRzID0gMFxuICAgIHRoaXMuam9pblBlbmRpbmcgPSB0cnVlXG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZVxuICAgIHRoaXMuam9pbkNhbGxiYWNrID0gZnVuY3Rpb24ob25Eb25lKXsgb25Eb25lICYmIG9uRG9uZSgpIH1cbiAgICB0aGlzLnN0b3BDYWxsYmFjayA9IGZ1bmN0aW9uKCl7IH1cbiAgICB0aGlzLnBlbmRpbmdKb2luT3BzID0gdGhpcy5wYXJlbnQgPyBudWxsIDogW11cbiAgICB0aGlzLnZpZXdIb29rcyA9IHt9XG4gICAgdGhpcy5mb3JtU3VibWl0cyA9IFtdXG4gICAgdGhpcy5jaGlsZHJlbiA9IHRoaXMucGFyZW50ID8gbnVsbCA6IHt9XG4gICAgdGhpcy5yb290LmNoaWxkcmVuW3RoaXMuaWRdID0ge31cbiAgICB0aGlzLmZvcm1zRm9yUmVjb3ZlcnkgPSB7fVxuICAgIHRoaXMuY2hhbm5lbCA9IHRoaXMubGl2ZVNvY2tldC5jaGFubmVsKGBsdjoke3RoaXMuaWR9YCwgKCkgPT4ge1xuICAgICAgbGV0IHVybCA9IHRoaXMuaHJlZiAmJiB0aGlzLmV4cGFuZFVSTCh0aGlzLmhyZWYpXG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWRpcmVjdDogdGhpcy5yZWRpcmVjdCA/IHVybCA6IHVuZGVmaW5lZCxcbiAgICAgICAgdXJsOiB0aGlzLnJlZGlyZWN0ID8gdW5kZWZpbmVkIDogdXJsIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgcGFyYW1zOiB0aGlzLmNvbm5lY3RQYXJhbXMobGl2ZVJlZmVyZXIpLFxuICAgICAgICBzZXNzaW9uOiB0aGlzLmdldFNlc3Npb24oKSxcbiAgICAgICAgc3RhdGljOiB0aGlzLmdldFN0YXRpYygpLFxuICAgICAgICBmbGFzaDogdGhpcy5mbGFzaCxcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgc2V0SHJlZihocmVmKXsgdGhpcy5ocmVmID0gaHJlZiB9XG5cbiAgc2V0UmVkaXJlY3QoaHJlZil7XG4gICAgdGhpcy5yZWRpcmVjdCA9IHRydWVcbiAgICB0aGlzLmhyZWYgPSBocmVmXG4gIH1cblxuICBpc01haW4oKXsgcmV0dXJuIHRoaXMuZWwuaGFzQXR0cmlidXRlKFBIWF9NQUlOKSB9XG5cbiAgY29ubmVjdFBhcmFtcyhsaXZlUmVmZXJlcil7XG4gICAgbGV0IHBhcmFtcyA9IHRoaXMubGl2ZVNvY2tldC5wYXJhbXModGhpcy5lbClcbiAgICBsZXQgbWFuaWZlc3QgPVxuICAgICAgRE9NLmFsbChkb2N1bWVudCwgYFske3RoaXMuYmluZGluZyhQSFhfVFJBQ0tfU1RBVElDKX1dYClcbiAgICAgICAgLm1hcChub2RlID0+IG5vZGUuc3JjIHx8IG5vZGUuaHJlZikuZmlsdGVyKHVybCA9PiB0eXBlb2YgKHVybCkgPT09IFwic3RyaW5nXCIpXG5cbiAgICBpZihtYW5pZmVzdC5sZW5ndGggPiAwKXsgcGFyYW1zW1wiX3RyYWNrX3N0YXRpY1wiXSA9IG1hbmlmZXN0IH1cbiAgICBwYXJhbXNbXCJfbW91bnRzXCJdID0gdGhpcy5qb2luQ291bnRcbiAgICBwYXJhbXNbXCJfbW91bnRfYXR0ZW1wdHNcIl0gPSB0aGlzLmpvaW5BdHRlbXB0c1xuICAgIHBhcmFtc1tcIl9saXZlX3JlZmVyZXJcIl0gPSBsaXZlUmVmZXJlclxuICAgIHRoaXMuam9pbkF0dGVtcHRzKytcblxuICAgIHJldHVybiBwYXJhbXNcbiAgfVxuXG4gIGlzQ29ubmVjdGVkKCl7IHJldHVybiB0aGlzLmNoYW5uZWwuY2FuUHVzaCgpIH1cblxuICBnZXRTZXNzaW9uKCl7IHJldHVybiB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfU0VTU0lPTikgfVxuXG4gIGdldFN0YXRpYygpe1xuICAgIGxldCB2YWwgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfU1RBVElDKVxuICAgIHJldHVybiB2YWwgPT09IFwiXCIgPyBudWxsIDogdmFsXG4gIH1cblxuICBkZXN0cm95KGNhbGxiYWNrID0gZnVuY3Rpb24gKCl7IH0pe1xuICAgIHRoaXMuZGVzdHJveUFsbENoaWxkcmVuKClcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWVcbiAgICBkZWxldGUgdGhpcy5yb290LmNoaWxkcmVuW3RoaXMuaWRdXG4gICAgaWYodGhpcy5wYXJlbnQpeyBkZWxldGUgdGhpcy5yb290LmNoaWxkcmVuW3RoaXMucGFyZW50LmlkXVt0aGlzLmlkXSB9XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubG9hZGVyVGltZXIpXG4gICAgbGV0IG9uRmluaXNoZWQgPSAoKSA9PiB7XG4gICAgICBjYWxsYmFjaygpXG4gICAgICBmb3IobGV0IGlkIGluIHRoaXMudmlld0hvb2tzKXtcbiAgICAgICAgdGhpcy5kZXN0cm95SG9vayh0aGlzLnZpZXdIb29rc1tpZF0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgRE9NLm1hcmtQaHhDaGlsZERlc3Ryb3llZCh0aGlzLmVsKVxuXG4gICAgdGhpcy5sb2coXCJkZXN0cm95ZWRcIiwgKCkgPT4gW1widGhlIGNoaWxkIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcGFyZW50XCJdKVxuICAgIHRoaXMuY2hhbm5lbC5sZWF2ZSgpXG4gICAgICAucmVjZWl2ZShcIm9rXCIsIG9uRmluaXNoZWQpXG4gICAgICAucmVjZWl2ZShcImVycm9yXCIsIG9uRmluaXNoZWQpXG4gICAgICAucmVjZWl2ZShcInRpbWVvdXRcIiwgb25GaW5pc2hlZClcbiAgfVxuXG4gIHNldENvbnRhaW5lckNsYXNzZXMoLi4uY2xhc3Nlcyl7XG4gICAgdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgUEhYX0NPTk5FQ1RFRF9DTEFTUyxcbiAgICAgIFBIWF9MT0FESU5HX0NMQVNTLFxuICAgICAgUEhYX0VSUk9SX0NMQVNTLFxuICAgICAgUEhYX0NMSUVOVF9FUlJPUl9DTEFTUyxcbiAgICAgIFBIWF9TRVJWRVJfRVJST1JfQ0xBU1NcbiAgICApXG4gICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzZXMpXG4gIH1cblxuICBzaG93TG9hZGVyKHRpbWVvdXQpe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmxvYWRlclRpbWVyKVxuICAgIGlmKHRpbWVvdXQpe1xuICAgICAgdGhpcy5sb2FkZXJUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zaG93TG9hZGVyKCksIHRpbWVvdXQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcihsZXQgaWQgaW4gdGhpcy52aWV3SG9va3MpeyB0aGlzLnZpZXdIb29rc1tpZF0uX19kaXNjb25uZWN0ZWQoKSB9XG4gICAgICB0aGlzLnNldENvbnRhaW5lckNsYXNzZXMoUEhYX0xPQURJTkdfQ0xBU1MpXG4gICAgfVxuICB9XG5cbiAgZXhlY0FsbChiaW5kaW5nKXtcbiAgICBET00uYWxsKHRoaXMuZWwsIGBbJHtiaW5kaW5nfV1gLCBlbCA9PiB0aGlzLmxpdmVTb2NrZXQuZXhlY0pTKGVsLCBlbC5nZXRBdHRyaWJ1dGUoYmluZGluZykpKVxuICB9XG5cbiAgaGlkZUxvYWRlcigpe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmxvYWRlclRpbWVyKVxuICAgIHRoaXMuc2V0Q29udGFpbmVyQ2xhc3NlcyhQSFhfQ09OTkVDVEVEX0NMQVNTKVxuICAgIHRoaXMuZXhlY0FsbCh0aGlzLmJpbmRpbmcoXCJjb25uZWN0ZWRcIikpXG4gIH1cblxuICB0cmlnZ2VyUmVjb25uZWN0ZWQoKXtcbiAgICBmb3IobGV0IGlkIGluIHRoaXMudmlld0hvb2tzKXsgdGhpcy52aWV3SG9va3NbaWRdLl9fcmVjb25uZWN0ZWQoKSB9XG4gIH1cblxuICBsb2coa2luZCwgbXNnQ2FsbGJhY2spe1xuICAgIHRoaXMubGl2ZVNvY2tldC5sb2codGhpcywga2luZCwgbXNnQ2FsbGJhY2spXG4gIH1cblxuICB0cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSA9IGZ1bmN0aW9uKCl7fSl7XG4gICAgdGhpcy5saXZlU29ja2V0LnRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lKVxuICB9XG5cbiAgLy8gY2FsbHMgdGhlIGNhbGxiYWNrIHdpdGggdGhlIHZpZXcgYW5kIHRhcmdldCBlbGVtZW50IGZvciB0aGUgZ2l2ZW4gcGh4VGFyZ2V0XG4gIC8vIHRhcmdldHMgY2FuIGJlOlxuICAvLyAgKiBhbiBlbGVtZW50IGl0c2VsZiwgdGhlbiBpdCBpcyBzaW1wbHkgcGFzc2VkIHRvIGxpdmVTb2NrZXQub3duZXI7XG4gIC8vICAqIGEgQ0lEIChDb21wb25lbnQgSUQpLCB0aGVuIHdlIGZpcnN0IHNlYXJjaCB0aGUgY29tcG9uZW50J3MgZWxlbWVudCBpbiB0aGUgRE9NXG4gIC8vICAqIGEgc2VsZWN0b3IsIHRoZW4gd2Ugc2VhcmNoIHRoZSBzZWxlY3RvciBpbiB0aGUgRE9NIGFuZCBjYWxsIHRoZSBjYWxsYmFja1xuICAvLyAgICBmb3IgZWFjaCBlbGVtZW50IGZvdW5kIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgb3duZXIgdmlld1xuICB3aXRoaW5UYXJnZXRzKHBoeFRhcmdldCwgY2FsbGJhY2ssIGRvbSA9IGRvY3VtZW50LCB2aWV3RWwpe1xuICAgIC8vIGluIHRoZSBmb3JtIHJlY292ZXJ5IGNhc2Ugd2Ugc2VhcmNoIGluIGEgdGVtcGxhdGUgZnJhZ21lbnQgaW5zdGVhZCBvZlxuICAgIC8vIHRoZSByZWFsIGRvbSwgdGhlcmVmb3JlIHdlIG9wdGlvbmFsbHkgcGFzcyBkb20gYW5kIHZpZXdFbFxuXG4gICAgaWYocGh4VGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgcGh4VGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudCl7XG4gICAgICByZXR1cm4gdGhpcy5saXZlU29ja2V0Lm93bmVyKHBoeFRhcmdldCwgdmlldyA9PiBjYWxsYmFjayh2aWV3LCBwaHhUYXJnZXQpKVxuICAgIH1cblxuICAgIGlmKGlzQ2lkKHBoeFRhcmdldCkpe1xuICAgICAgbGV0IHRhcmdldHMgPSBET00uZmluZENvbXBvbmVudE5vZGVMaXN0KHZpZXdFbCB8fCB0aGlzLmVsLCBwaHhUYXJnZXQpXG4gICAgICBpZih0YXJnZXRzLmxlbmd0aCA9PT0gMCl7XG4gICAgICAgIGxvZ0Vycm9yKGBubyBjb21wb25lbnQgZm91bmQgbWF0Y2hpbmcgcGh4LXRhcmdldCBvZiAke3BoeFRhcmdldH1gKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sodGhpcywgcGFyc2VJbnQocGh4VGFyZ2V0KSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHRhcmdldHMgPSBBcnJheS5mcm9tKGRvbS5xdWVyeVNlbGVjdG9yQWxsKHBoeFRhcmdldCkpXG4gICAgICBpZih0YXJnZXRzLmxlbmd0aCA9PT0gMCl7IGxvZ0Vycm9yKGBub3RoaW5nIGZvdW5kIG1hdGNoaW5nIHRoZSBwaHgtdGFyZ2V0IHNlbGVjdG9yIFwiJHtwaHhUYXJnZXR9XCJgKSB9XG4gICAgICB0YXJnZXRzLmZvckVhY2godGFyZ2V0ID0+IHRoaXMubGl2ZVNvY2tldC5vd25lcih0YXJnZXQsIHZpZXcgPT4gY2FsbGJhY2sodmlldywgdGFyZ2V0KSkpXG4gICAgfVxuICB9XG5cbiAgYXBwbHlEaWZmKHR5cGUsIHJhd0RpZmYsIGNhbGxiYWNrKXtcbiAgICB0aGlzLmxvZyh0eXBlLCAoKSA9PiBbXCJcIiwgY2xvbmUocmF3RGlmZildKVxuICAgIGxldCB7ZGlmZiwgcmVwbHksIGV2ZW50cywgdGl0bGV9ID0gUmVuZGVyZWQuZXh0cmFjdChyYXdEaWZmKVxuICAgIGNhbGxiYWNrKHtkaWZmLCByZXBseSwgZXZlbnRzfSlcbiAgICBpZih0eXBlb2YgdGl0bGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZSA9PSBcIm1vdW50XCIpeyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IERPTS5wdXRUaXRsZSh0aXRsZSkpIH1cbiAgfVxuXG4gIG9uSm9pbihyZXNwKXtcbiAgICBsZXQge3JlbmRlcmVkLCBjb250YWluZXIsIGxpdmV2aWV3X3ZlcnNpb259ID0gcmVzcFxuICAgIGlmKGNvbnRhaW5lcil7XG4gICAgICBsZXQgW3RhZywgYXR0cnNdID0gY29udGFpbmVyXG4gICAgICB0aGlzLmVsID0gRE9NLnJlcGxhY2VSb290Q29udGFpbmVyKHRoaXMuZWwsIHRhZywgYXR0cnMpXG4gICAgfVxuICAgIHRoaXMuY2hpbGRKb2lucyA9IDBcbiAgICB0aGlzLmpvaW5QZW5kaW5nID0gdHJ1ZVxuICAgIHRoaXMuZmxhc2ggPSBudWxsXG4gICAgaWYodGhpcy5yb290ID09PSB0aGlzKXtcbiAgICAgIHRoaXMuZm9ybXNGb3JSZWNvdmVyeSA9IHRoaXMuZ2V0Rm9ybXNGb3JSZWNvdmVyeSgpXG4gICAgfVxuICAgIGlmKHRoaXMuaXNNYWluKCkgJiYgd2luZG93Lmhpc3Rvcnkuc3RhdGUgPT09IG51bGwpe1xuICAgICAgLy8gc2V0IGluaXRpYWwgaGlzdG9yeSBlbnRyeSBpZiB0aGlzIGlzIHRoZSBmaXJzdCBwYWdlIGxvYWQgKG5vIGhpc3RvcnkpXG4gICAgICBCcm93c2VyLnB1c2hTdGF0ZShcInJlcGxhY2VcIiwge1xuICAgICAgICB0eXBlOiBcInBhdGNoXCIsXG4gICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICBwb3NpdGlvbjogdGhpcy5saXZlU29ja2V0LmN1cnJlbnRIaXN0b3J5UG9zaXRpb25cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYobGl2ZXZpZXdfdmVyc2lvbiAhPT0gdGhpcy5saXZlU29ja2V0LnZlcnNpb24oKSl7XG4gICAgICBjb25zb2xlLmVycm9yKGBMaXZlVmlldyBhc3NldCB2ZXJzaW9uIG1pc21hdGNoLiBKYXZhU2NyaXB0IHZlcnNpb24gJHt0aGlzLmxpdmVTb2NrZXQudmVyc2lvbigpfSB2cy4gc2VydmVyICR7bGl2ZXZpZXdfdmVyc2lvbn0uIFRvIGF2b2lkIGlzc3VlcywgcGxlYXNlIGVuc3VyZSB0aGF0IHlvdXIgYXNzZXRzIHVzZSB0aGUgc2FtZSB2ZXJzaW9uIGFzIHRoZSBzZXJ2ZXIuYClcbiAgICB9XG5cbiAgICBCcm93c2VyLmRyb3BMb2NhbCh0aGlzLmxpdmVTb2NrZXQubG9jYWxTdG9yYWdlLCB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUsIENPTlNFQ1VUSVZFX1JFTE9BRFMpXG4gICAgdGhpcy5hcHBseURpZmYoXCJtb3VudFwiLCByZW5kZXJlZCwgKHtkaWZmLCBldmVudHN9KSA9PiB7XG4gICAgICB0aGlzLnJlbmRlcmVkID0gbmV3IFJlbmRlcmVkKHRoaXMuaWQsIGRpZmYpXG4gICAgICBsZXQgW2h0bWwsIHN0cmVhbXNdID0gdGhpcy5yZW5kZXJDb250YWluZXIobnVsbCwgXCJqb2luXCIpXG4gICAgICB0aGlzLmRyb3BQZW5kaW5nUmVmcygpXG4gICAgICB0aGlzLmpvaW5Db3VudCsrXG4gICAgICB0aGlzLmpvaW5BdHRlbXB0cyA9IDBcblxuICAgICAgdGhpcy5tYXliZVJlY292ZXJGb3JtcyhodG1sLCAoKSA9PiB7XG4gICAgICAgIHRoaXMub25Kb2luQ29tcGxldGUocmVzcCwgaHRtbCwgc3RyZWFtcywgZXZlbnRzKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgZHJvcFBlbmRpbmdSZWZzKCl7XG4gICAgRE9NLmFsbChkb2N1bWVudCwgYFske1BIWF9SRUZfU1JDfT1cIiR7dGhpcy5yZWZTcmMoKX1cIl1gLCBlbCA9PiB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFRl9MT0FESU5HKVxuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9SRUZfU1JDKVxuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9SRUZfTE9DSylcbiAgICB9KVxuICB9XG5cbiAgb25Kb2luQ29tcGxldGUoe2xpdmVfcGF0Y2h9LCBodG1sLCBzdHJlYW1zLCBldmVudHMpe1xuICAgIC8vIEluIG9yZGVyIHRvIHByb3ZpZGUgYSBiZXR0ZXIgZXhwZXJpZW5jZSwgd2Ugd2FudCB0byBqb2luXG4gICAgLy8gYWxsIExpdmVWaWV3cyBmaXJzdCBhbmQgb25seSB0aGVuIGFwcGx5IHRoZWlyIHBhdGNoZXMuXG4gICAgaWYodGhpcy5qb2luQ291bnQgPiAxIHx8ICh0aGlzLnBhcmVudCAmJiAhdGhpcy5wYXJlbnQuaXNKb2luUGVuZGluZygpKSl7XG4gICAgICByZXR1cm4gdGhpcy5hcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBzdHJlYW1zLCBldmVudHMpXG4gICAgfVxuXG4gICAgLy8gT25lIGRvd25zaWRlIG9mIHRoaXMgYXBwcm9hY2ggaXMgdGhhdCB3ZSBuZWVkIHRvIGZpbmQgcGh4Q2hpbGRyZW5cbiAgICAvLyBpbiB0aGUgaHRtbCBmcmFnbWVudCwgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgRE9NLiBUaGUgZnJhZ21lbnRcbiAgICAvLyBhbHNvIGRvZXMgbm90IGluY2x1ZGUgUEhYX1NUQVRJQywgc28gd2UgbmVlZCB0byBjb3B5IGl0IG92ZXIgZnJvbVxuICAgIC8vIHRoZSBET00uXG4gICAgbGV0IG5ld0NoaWxkcmVuID0gRE9NLmZpbmRQaHhDaGlsZHJlbkluRnJhZ21lbnQoaHRtbCwgdGhpcy5pZCkuZmlsdGVyKHRvRWwgPT4ge1xuICAgICAgbGV0IGZyb21FbCA9IHRvRWwuaWQgJiYgdGhpcy5lbC5xdWVyeVNlbGVjdG9yKGBbaWQ9XCIke3RvRWwuaWR9XCJdYClcbiAgICAgIGxldCBwaHhTdGF0aWMgPSBmcm9tRWwgJiYgZnJvbUVsLmdldEF0dHJpYnV0ZShQSFhfU1RBVElDKVxuICAgICAgaWYocGh4U3RhdGljKXsgdG9FbC5zZXRBdHRyaWJ1dGUoUEhYX1NUQVRJQywgcGh4U3RhdGljKSB9XG4gICAgICAvLyBzZXQgUEhYX1JPT1RfSUQgdG8gcHJldmVudCBldmVudHMgZnJvbSBiZWluZyBkaXNwYXRjaGVkIHRvIHRoZSByb290IHZpZXdcbiAgICAgIC8vIHdoaWxlIHRoZSBjaGlsZCBqb2luIGlzIHN0aWxsIHBlbmRpbmdcbiAgICAgIGlmKGZyb21FbCl7IGZyb21FbC5zZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQsIHRoaXMucm9vdC5pZCkgfVxuICAgICAgcmV0dXJuIHRoaXMuam9pbkNoaWxkKHRvRWwpXG4gICAgfSlcblxuICAgIGlmKG5ld0NoaWxkcmVuLmxlbmd0aCA9PT0gMCl7XG4gICAgICBpZih0aGlzLnBhcmVudCl7XG4gICAgICAgIHRoaXMucm9vdC5wZW5kaW5nSm9pbk9wcy5wdXNoKFt0aGlzLCAoKSA9PiB0aGlzLmFwcGx5Sm9pblBhdGNoKGxpdmVfcGF0Y2gsIGh0bWwsIHN0cmVhbXMsIGV2ZW50cyldKVxuICAgICAgICB0aGlzLnBhcmVudC5hY2tKb2luKHRoaXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uQWxsQ2hpbGRKb2luc0NvbXBsZXRlKClcbiAgICAgICAgdGhpcy5hcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBzdHJlYW1zLCBldmVudHMpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucm9vdC5wZW5kaW5nSm9pbk9wcy5wdXNoKFt0aGlzLCAoKSA9PiB0aGlzLmFwcGx5Sm9pblBhdGNoKGxpdmVfcGF0Y2gsIGh0bWwsIHN0cmVhbXMsIGV2ZW50cyldKVxuICAgIH1cbiAgfVxuXG4gIGF0dGFjaFRydWVEb2NFbCgpe1xuICAgIHRoaXMuZWwgPSBET00uYnlJZCh0aGlzLmlkKVxuICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKFBIWF9ST09UX0lELCB0aGlzLnJvb3QuaWQpXG4gIH1cblxuICAvLyB0aGlzIGlzIGludm9rZWQgZm9yIGRlYWQgYW5kIGxpdmUgdmlld3MsIHNvIHdlIG11c3QgZmlsdGVyIGJ5XG4gIC8vIGJ5IG93bmVyIHRvIGVuc3VyZSB3ZSBhcmVuJ3QgZHVwbGljYXRpbmcgaG9va3MgYWNyb3NzIGRpc2Nvbm5lY3RcbiAgLy8gYW5kIGNvbm5lY3RlZCBzdGF0ZXMuIFRoaXMgYWxzbyBoYW5kbGVzIGNhc2VzIHdoZXJlIGhvb2tzIGV4aXN0XG4gIC8vIGluIGEgcm9vdCBsYXlvdXQgd2l0aCBhIExWIGluIHRoZSBib2R5XG4gIGV4ZWNOZXdNb3VudGVkKHBhcmVudCA9IHRoaXMuZWwpe1xuICAgIGxldCBwaHhWaWV3cG9ydFRvcCA9IHRoaXMuYmluZGluZyhQSFhfVklFV1BPUlRfVE9QKVxuICAgIGxldCBwaHhWaWV3cG9ydEJvdHRvbSA9IHRoaXMuYmluZGluZyhQSFhfVklFV1BPUlRfQk9UVE9NKVxuICAgIERPTS5hbGwocGFyZW50LCBgWyR7cGh4Vmlld3BvcnRUb3B9XSwgWyR7cGh4Vmlld3BvcnRCb3R0b219XWAsIGhvb2tFbCA9PiB7XG4gICAgICBpZih0aGlzLm93bnNFbGVtZW50KGhvb2tFbCkpe1xuICAgICAgICBET00ubWFpbnRhaW5Qcml2YXRlSG9va3MoaG9va0VsLCBob29rRWwsIHBoeFZpZXdwb3J0VG9wLCBwaHhWaWV3cG9ydEJvdHRvbSlcbiAgICAgICAgdGhpcy5tYXliZUFkZE5ld0hvb2soaG9va0VsKVxuICAgICAgfVxuICAgIH0pXG4gICAgRE9NLmFsbChwYXJlbnQsIGBbJHt0aGlzLmJpbmRpbmcoUEhYX0hPT0spfV0sIFtkYXRhLXBoeC0ke1BIWF9IT09LfV1gLCBob29rRWwgPT4ge1xuICAgICAgaWYodGhpcy5vd25zRWxlbWVudChob29rRWwpKXtcbiAgICAgICAgdGhpcy5tYXliZUFkZE5ld0hvb2soaG9va0VsKVxuICAgICAgfVxuICAgIH0pXG4gICAgRE9NLmFsbChwYXJlbnQsIGBbJHt0aGlzLmJpbmRpbmcoUEhYX01PVU5URUQpfV1gLCBlbCA9PiB7XG4gICAgICBpZih0aGlzLm93bnNFbGVtZW50KGVsKSl7XG4gICAgICAgIHRoaXMubWF5YmVNb3VudGVkKGVsKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBhcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBzdHJlYW1zLCBldmVudHMpe1xuICAgIHRoaXMuYXR0YWNoVHJ1ZURvY0VsKClcbiAgICBsZXQgcGF0Y2ggPSBuZXcgRE9NUGF0Y2godGhpcywgdGhpcy5lbCwgdGhpcy5pZCwgaHRtbCwgc3RyZWFtcywgbnVsbClcbiAgICBwYXRjaC5tYXJrUHJ1bmFibGVDb250ZW50Rm9yUmVtb3ZhbCgpXG4gICAgdGhpcy5wZXJmb3JtUGF0Y2gocGF0Y2gsIGZhbHNlLCB0cnVlKVxuICAgIHRoaXMuam9pbk5ld0NoaWxkcmVuKClcbiAgICB0aGlzLmV4ZWNOZXdNb3VudGVkKClcblxuICAgIHRoaXMuam9pblBlbmRpbmcgPSBmYWxzZVxuICAgIHRoaXMubGl2ZVNvY2tldC5kaXNwYXRjaEV2ZW50cyhldmVudHMpXG4gICAgdGhpcy5hcHBseVBlbmRpbmdVcGRhdGVzKClcblxuICAgIGlmKGxpdmVfcGF0Y2gpe1xuICAgICAgbGV0IHtraW5kLCB0b30gPSBsaXZlX3BhdGNoXG4gICAgICB0aGlzLmxpdmVTb2NrZXQuaGlzdG9yeVBhdGNoKHRvLCBraW5kKVxuICAgIH1cbiAgICB0aGlzLmhpZGVMb2FkZXIoKVxuICAgIGlmKHRoaXMuam9pbkNvdW50ID4gMSl7IHRoaXMudHJpZ2dlclJlY29ubmVjdGVkKCkgfVxuICAgIHRoaXMuc3RvcENhbGxiYWNrKClcbiAgfVxuXG4gIHRyaWdnZXJCZWZvcmVVcGRhdGVIb29rKGZyb21FbCwgdG9FbCl7XG4gICAgdGhpcy5saXZlU29ja2V0LnRyaWdnZXJET00oXCJvbkJlZm9yZUVsVXBkYXRlZFwiLCBbZnJvbUVsLCB0b0VsXSlcbiAgICBsZXQgaG9vayA9IHRoaXMuZ2V0SG9vayhmcm9tRWwpXG4gICAgbGV0IGlzSWdub3JlZCA9IGhvb2sgJiYgRE9NLmlzSWdub3JlZChmcm9tRWwsIHRoaXMuYmluZGluZyhQSFhfVVBEQVRFKSlcbiAgICBpZihob29rICYmICFmcm9tRWwuaXNFcXVhbE5vZGUodG9FbCkgJiYgIShpc0lnbm9yZWQgJiYgaXNFcXVhbE9iaihmcm9tRWwuZGF0YXNldCwgdG9FbC5kYXRhc2V0KSkpe1xuICAgICAgaG9vay5fX2JlZm9yZVVwZGF0ZSgpXG4gICAgICByZXR1cm4gaG9va1xuICAgIH1cbiAgfVxuXG4gIG1heWJlTW91bnRlZChlbCl7XG4gICAgbGV0IHBoeE1vdW50ZWQgPSBlbC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9NT1VOVEVEKSlcbiAgICBsZXQgaGFzQmVlbkludm9rZWQgPSBwaHhNb3VudGVkICYmIERPTS5wcml2YXRlKGVsLCBcIm1vdW50ZWRcIilcbiAgICBpZihwaHhNb3VudGVkICYmICFoYXNCZWVuSW52b2tlZCl7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQuZXhlY0pTKGVsLCBwaHhNb3VudGVkKVxuICAgICAgRE9NLnB1dFByaXZhdGUoZWwsIFwibW91bnRlZFwiLCB0cnVlKVxuICAgIH1cbiAgfVxuXG4gIG1heWJlQWRkTmV3SG9vayhlbCl7XG4gICAgbGV0IG5ld0hvb2sgPSB0aGlzLmFkZEhvb2soZWwpXG4gICAgaWYobmV3SG9vayl7IG5ld0hvb2suX19tb3VudGVkKCkgfVxuICB9XG5cbiAgcGVyZm9ybVBhdGNoKHBhdGNoLCBwcnVuZUNpZHMsIGlzSm9pblBhdGNoID0gZmFsc2Upe1xuICAgIGxldCByZW1vdmVkRWxzID0gW11cbiAgICBsZXQgcGh4Q2hpbGRyZW5BZGRlZCA9IGZhbHNlXG4gICAgbGV0IHVwZGF0ZWRIb29rSWRzID0gbmV3IFNldCgpXG5cbiAgICB0aGlzLmxpdmVTb2NrZXQudHJpZ2dlckRPTShcIm9uUGF0Y2hTdGFydFwiLCBbcGF0Y2gudGFyZ2V0Q29udGFpbmVyXSlcblxuICAgIHBhdGNoLmFmdGVyKFwiYWRkZWRcIiwgZWwgPT4ge1xuICAgICAgdGhpcy5saXZlU29ja2V0LnRyaWdnZXJET00oXCJvbk5vZGVBZGRlZFwiLCBbZWxdKVxuICAgICAgbGV0IHBoeFZpZXdwb3J0VG9wID0gdGhpcy5iaW5kaW5nKFBIWF9WSUVXUE9SVF9UT1ApXG4gICAgICBsZXQgcGh4Vmlld3BvcnRCb3R0b20gPSB0aGlzLmJpbmRpbmcoUEhYX1ZJRVdQT1JUX0JPVFRPTSlcbiAgICAgIERPTS5tYWludGFpblByaXZhdGVIb29rcyhlbCwgZWwsIHBoeFZpZXdwb3J0VG9wLCBwaHhWaWV3cG9ydEJvdHRvbSlcbiAgICAgIHRoaXMubWF5YmVBZGROZXdIb29rKGVsKVxuICAgICAgaWYoZWwuZ2V0QXR0cmlidXRlKXsgdGhpcy5tYXliZU1vdW50ZWQoZWwpIH1cbiAgICB9KVxuXG4gICAgcGF0Y2guYWZ0ZXIoXCJwaHhDaGlsZEFkZGVkXCIsIGVsID0+IHtcbiAgICAgIGlmKERPTS5pc1BoeFN0aWNreShlbCkpe1xuICAgICAgICB0aGlzLmxpdmVTb2NrZXQuam9pblJvb3RWaWV3cygpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwaHhDaGlsZHJlbkFkZGVkID0gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBwYXRjaC5iZWZvcmUoXCJ1cGRhdGVkXCIsIChmcm9tRWwsIHRvRWwpID0+IHtcbiAgICAgIGxldCBob29rID0gdGhpcy50cmlnZ2VyQmVmb3JlVXBkYXRlSG9vayhmcm9tRWwsIHRvRWwpXG4gICAgICBpZihob29rKXsgdXBkYXRlZEhvb2tJZHMuYWRkKGZyb21FbC5pZCkgfVxuICAgIH0pXG5cbiAgICBwYXRjaC5hZnRlcihcInVwZGF0ZWRcIiwgZWwgPT4ge1xuICAgICAgaWYodXBkYXRlZEhvb2tJZHMuaGFzKGVsLmlkKSl7IHRoaXMuZ2V0SG9vayhlbCkuX191cGRhdGVkKCkgfVxuICAgIH0pXG5cbiAgICBwYXRjaC5hZnRlcihcImRpc2NhcmRlZFwiLCAoZWwpID0+IHtcbiAgICAgIGlmKGVsLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSl7IHJlbW92ZWRFbHMucHVzaChlbCkgfVxuICAgIH0pXG5cbiAgICBwYXRjaC5hZnRlcihcInRyYW5zaXRpb25zRGlzY2FyZGVkXCIsIGVscyA9PiB0aGlzLmFmdGVyRWxlbWVudHNSZW1vdmVkKGVscywgcHJ1bmVDaWRzKSlcbiAgICBwYXRjaC5wZXJmb3JtKGlzSm9pblBhdGNoKVxuICAgIHRoaXMuYWZ0ZXJFbGVtZW50c1JlbW92ZWQocmVtb3ZlZEVscywgcHJ1bmVDaWRzKVxuXG4gICAgdGhpcy5saXZlU29ja2V0LnRyaWdnZXJET00oXCJvblBhdGNoRW5kXCIsIFtwYXRjaC50YXJnZXRDb250YWluZXJdKVxuICAgIHJldHVybiBwaHhDaGlsZHJlbkFkZGVkXG4gIH1cblxuICBhZnRlckVsZW1lbnRzUmVtb3ZlZChlbGVtZW50cywgcHJ1bmVDaWRzKXtcbiAgICBsZXQgZGVzdHJveWVkQ0lEcyA9IFtdXG4gICAgZWxlbWVudHMuZm9yRWFjaChwYXJlbnQgPT4ge1xuICAgICAgbGV0IGNvbXBvbmVudHMgPSBET00uYWxsKHBhcmVudCwgYFske1BIWF9DT01QT05FTlR9XWApXG4gICAgICBsZXQgaG9va3MgPSBET00uYWxsKHBhcmVudCwgYFske3RoaXMuYmluZGluZyhQSFhfSE9PSyl9XSwgW2RhdGEtcGh4LWhvb2tdYClcbiAgICAgIGNvbXBvbmVudHMuY29uY2F0KHBhcmVudCkuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIGxldCBjaWQgPSB0aGlzLmNvbXBvbmVudElEKGVsKVxuICAgICAgICBpZihpc0NpZChjaWQpICYmIGRlc3Ryb3llZENJRHMuaW5kZXhPZihjaWQpID09PSAtMSl7IGRlc3Ryb3llZENJRHMucHVzaChjaWQpIH1cbiAgICAgIH0pXG4gICAgICBob29rcy5jb25jYXQocGFyZW50KS5mb3JFYWNoKGhvb2tFbCA9PiB7XG4gICAgICAgIGxldCBob29rID0gdGhpcy5nZXRIb29rKGhvb2tFbClcbiAgICAgICAgaG9vayAmJiB0aGlzLmRlc3Ryb3lIb29rKGhvb2spXG4gICAgICB9KVxuICAgIH0pXG4gICAgLy8gV2Ugc2hvdWxkIG5vdCBwcnVuZUNpZHMgb24gam9pbnMuIE90aGVyd2lzZSwgaW4gY2FzZSBvZlxuICAgIC8vIHJlam9pbnMsIHdlIG1heSBub3RpZnkgY2lkcyB0aGF0IG5vIGxvbmdlciBiZWxvbmcgdG8gdGhlXG4gICAgLy8gY3VycmVudCBMaXZlVmlldyB0byBiZSByZW1vdmVkLlxuICAgIGlmKHBydW5lQ2lkcyl7XG4gICAgICB0aGlzLm1heWJlUHVzaENvbXBvbmVudHNEZXN0cm95ZWQoZGVzdHJveWVkQ0lEcylcbiAgICB9XG4gIH1cblxuICBqb2luTmV3Q2hpbGRyZW4oKXtcbiAgICBET00uZmluZFBoeENoaWxkcmVuKHRoaXMuZWwsIHRoaXMuaWQpLmZvckVhY2goZWwgPT4gdGhpcy5qb2luQ2hpbGQoZWwpKVxuICB9XG5cbiAgbWF5YmVSZWNvdmVyRm9ybXMoaHRtbCwgY2FsbGJhY2spe1xuICAgIGNvbnN0IHBoeENoYW5nZSA9IHRoaXMuYmluZGluZyhcImNoYW5nZVwiKVxuICAgIGNvbnN0IG9sZEZvcm1zID0gdGhpcy5yb290LmZvcm1zRm9yUmVjb3ZlcnlcbiAgICAvLyBTbyB3aHkgZG8gd2UgY3JlYXRlIGEgdGVtcGxhdGUgZWxlbWVudCBoZXJlP1xuICAgIC8vIE9uZSB3YXkgdG8gcmVjb3ZlciBmb3JtcyB3b3VsZCBiZSB0byBpbW1lZGlhdGVseSBhcHBseSB0aGUgbW91bnRcbiAgICAvLyBwYXRjaCBhbmQgdGhlbiBhZnRlcndhcmRzIHJlY292ZXIgdGhlIGZvcm1zLiBIb3dldmVyLCB0aGlzIHdvdWxkXG4gICAgLy8gY2F1c2UgYSBmbGlja2VyLCBiZWNhdXNlIHRoZSBtb3VudCBwYXRjaCB3b3VsZCByZW1vdmUgdGhlIGZvcm0gY29udGVudFxuICAgIC8vIHVudGlsIGl0IGlzIHJlc3RvcmVkLiBUaGVyZWZvcmUgTFYgZGVjaWRlZCB0byBkbyBmb3JtIHJlY292ZXJ5IHdpdGggdGhlXG4gICAgLy8gcmF3IEhUTUwgYmVmb3JlIGl0IGlzIGFwcGxpZWQgYW5kIGRlbGF5IHRoZSBtb3VudCBwYXRjaCB1bnRpbCB0aGUgZm9ybVxuICAgIC8vIHJlY292ZXJ5IGV2ZW50cyBhcmUgZG9uZS5cbiAgICBsZXQgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIilcbiAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBodG1sXG4gICAgLy8gYmVjYXVzZSB3ZSB3b3JrIHdpdGggYSB0ZW1wbGF0ZSBlbGVtZW50LCB3ZSBtdXN0IG1hbnVhbGx5IGNvcHkgdGhlIGF0dHJpYnV0ZXNcbiAgICAvLyBvdGhlcndpc2UgdGhlIG93bmVyIC8gdGFyZ2V0IGhlbHBlcnMgZG9uJ3Qgd29yayBwcm9wZXJseVxuICAgIGNvbnN0IHJvb3RFbCA9IHRlbXBsYXRlLmNvbnRlbnQuZmlyc3RFbGVtZW50Q2hpbGRcbiAgICByb290RWwuaWQgPSB0aGlzLmlkXG4gICAgcm9vdEVsLnNldEF0dHJpYnV0ZShQSFhfUk9PVF9JRCwgdGhpcy5yb290LmlkKVxuICAgIHJvb3RFbC5zZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04sIHRoaXMuZ2V0U2Vzc2lvbigpKVxuICAgIHJvb3RFbC5zZXRBdHRyaWJ1dGUoUEhYX1NUQVRJQywgdGhpcy5nZXRTdGF0aWMoKSlcbiAgICByb290RWwuc2V0QXR0cmlidXRlKFBIWF9QQVJFTlRfSUQsIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuaWQgOiBudWxsKVxuXG4gICAgLy8gd2UgZ28gb3ZlciBhbGwgZm9ybSBlbGVtZW50cyBpbiB0aGUgbmV3IEhUTUwgZm9yIHRoZSBMVlxuICAgIC8vIGFuZCBsb29rIGZvciBvbGQgZm9ybXMgaW4gdGhlIGBmb3Jtc0ZvclJlY292ZXJ5YCBvYmplY3Q7XG4gICAgLy8gdGhlIGZvcm1zRm9yUmVjb3ZlcnkgY2FuIGFsc28gY29udGFpbiBmb3JtcyBmcm9tIGNoaWxkIHZpZXdzXG4gICAgY29uc3QgZm9ybXNUb1JlY292ZXIgPVxuICAgICAgLy8gd2UgZ28gb3ZlciBhbGwgZm9ybXMgaW4gdGhlIG5ldyBET007IGJlY2F1c2UgdGhpcyBpcyBvbmx5IHRoZSBIVE1MIGZvciB0aGUgY3VycmVudFxuICAgICAgLy8gdmlldywgd2UgY2FuIGJlIHN1cmUgdGhhdCBhbGwgZm9ybXMgYXJlIG93bmVkIGJ5IHRoaXMgdmlldzpcbiAgICAgIERPTS5hbGwodGVtcGxhdGUuY29udGVudCwgXCJmb3JtXCIpXG4gICAgICAgIC8vIG9ubHkgcmVjb3ZlciBmb3JtcyB0aGF0IGhhdmUgYW4gaWQgYW5kIGFyZSBpbiB0aGUgb2xkIERPTVxuICAgICAgICAuZmlsdGVyKG5ld0Zvcm0gPT4gbmV3Rm9ybS5pZCAmJiBvbGRGb3Jtc1tuZXdGb3JtLmlkXSlcbiAgICAgICAgLy8gYWJhbmRvbiBmb3JtcyB3ZSBhbHJlYWR5IHRyaWVkIHRvIHJlY292ZXIgdG8gcHJldmVudCBsb29waW5nIGEgZmFpbGVkIHN0YXRlXG4gICAgICAgIC5maWx0ZXIobmV3Rm9ybSA9PiAhdGhpcy5wZW5kaW5nRm9ybXMuaGFzKG5ld0Zvcm0uaWQpKVxuICAgICAgICAvLyBvbmx5IHJlY292ZXIgaWYgdGhlIGZvcm0gaGFzIHRoZSBzYW1lIHBoeC1jaGFuZ2UgdmFsdWVcbiAgICAgICAgLmZpbHRlcihuZXdGb3JtID0+IG9sZEZvcm1zW25ld0Zvcm0uaWRdLmdldEF0dHJpYnV0ZShwaHhDaGFuZ2UpID09PSBuZXdGb3JtLmdldEF0dHJpYnV0ZShwaHhDaGFuZ2UpKVxuICAgICAgICAubWFwKG5ld0Zvcm0gPT4ge1xuICAgICAgICAgIHJldHVybiBbb2xkRm9ybXNbbmV3Rm9ybS5pZF0sIG5ld0Zvcm1dXG4gICAgICAgIH0pXG5cbiAgICBpZihmb3Jtc1RvUmVjb3Zlci5sZW5ndGggPT09IDApe1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKClcbiAgICB9XG5cbiAgICBmb3Jtc1RvUmVjb3Zlci5mb3JFYWNoKChbb2xkRm9ybSwgbmV3Rm9ybV0sIGkpID0+IHtcbiAgICAgIHRoaXMucGVuZGluZ0Zvcm1zLmFkZChuZXdGb3JtLmlkKVxuICAgICAgLy8gaXQgaXMgaW1wb3J0YW50IHRvIHVzZSB0aGUgZmlyc3RFbGVtZW50Q2hpbGQgb2YgdGhlIHRlbXBsYXRlIGNvbnRlbnRcbiAgICAgIC8vIGJlY2F1c2Ugd2hlbiB0cmF2ZXJzaW5nIGEgZG9jdW1lbnRGcmFnbWVudCB1c2luZyBwYXJlbnROb2RlLCB3ZSB3b24ndCBldmVyIGFycml2ZSBhdFxuICAgICAgLy8gdGhlIGZyYWdtZW50OyBhcyB0aGUgdGVtcGxhdGUgaXMgYWx3YXlzIGEgTGl2ZVZpZXcsIHdlIGNhbiBiZSBzdXJlIHRoYXQgdGhlcmUgaXMgb25seVxuICAgICAgLy8gb25lIGNoaWxkIG9uIHRoZSByb290IGxldmVsXG4gICAgICB0aGlzLnB1c2hGb3JtUmVjb3Zlcnkob2xkRm9ybSwgbmV3Rm9ybSwgdGVtcGxhdGUuY29udGVudC5maXJzdEVsZW1lbnRDaGlsZCwgKCkgPT4ge1xuICAgICAgICB0aGlzLnBlbmRpbmdGb3Jtcy5kZWxldGUobmV3Rm9ybS5pZClcbiAgICAgICAgLy8gd2Ugb25seSBjYWxsIHRoZSBjYWxsYmFjayBvbmNlIGFsbCBmb3JtcyBoYXZlIGJlZW4gcmVjb3ZlcmVkXG4gICAgICAgIGlmKGkgPT09IGZvcm1zVG9SZWNvdmVyLmxlbmd0aCAtIDEpe1xuICAgICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgZ2V0Q2hpbGRCeUlkKGlkKXsgcmV0dXJuIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLmlkXVtpZF0gfVxuXG4gIGdldERlc2NlbmRlbnRCeUVsKGVsKXtcbiAgICBpZihlbC5pZCA9PT0gdGhpcy5pZCl7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltlbC5nZXRBdHRyaWJ1dGUoUEhYX1BBUkVOVF9JRCldPy5bZWwuaWRdXG4gICAgfVxuICB9XG5cbiAgZGVzdHJveURlc2NlbmRlbnQoaWQpe1xuICAgIGZvcihsZXQgcGFyZW50SWQgaW4gdGhpcy5yb290LmNoaWxkcmVuKXtcbiAgICAgIGZvcihsZXQgY2hpbGRJZCBpbiB0aGlzLnJvb3QuY2hpbGRyZW5bcGFyZW50SWRdKXtcbiAgICAgICAgaWYoY2hpbGRJZCA9PT0gaWQpeyByZXR1cm4gdGhpcy5yb290LmNoaWxkcmVuW3BhcmVudElkXVtjaGlsZElkXS5kZXN0cm95KCkgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGpvaW5DaGlsZChlbCl7XG4gICAgbGV0IGNoaWxkID0gdGhpcy5nZXRDaGlsZEJ5SWQoZWwuaWQpXG4gICAgaWYoIWNoaWxkKXtcbiAgICAgIGxldCB2aWV3ID0gbmV3IFZpZXcoZWwsIHRoaXMubGl2ZVNvY2tldCwgdGhpcylcbiAgICAgIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLmlkXVt2aWV3LmlkXSA9IHZpZXdcbiAgICAgIHZpZXcuam9pbigpXG4gICAgICB0aGlzLmNoaWxkSm9pbnMrK1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICBpc0pvaW5QZW5kaW5nKCl7IHJldHVybiB0aGlzLmpvaW5QZW5kaW5nIH1cblxuICBhY2tKb2luKF9jaGlsZCl7XG4gICAgdGhpcy5jaGlsZEpvaW5zLS1cblxuICAgIGlmKHRoaXMuY2hpbGRKb2lucyA9PT0gMCl7XG4gICAgICBpZih0aGlzLnBhcmVudCl7XG4gICAgICAgIHRoaXMucGFyZW50LmFja0pvaW4odGhpcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub25BbGxDaGlsZEpvaW5zQ29tcGxldGUoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uQWxsQ2hpbGRKb2luc0NvbXBsZXRlKCl7XG4gICAgLy8gd2UgY2FuIGNsZWFyIHBlbmRpbmcgZm9ybSByZWNvdmVyaWVzIG5vdyB0aGF0IHdlJ3ZlIGpvaW5lZC5cbiAgICAvLyBUaGV5IGVpdGhlciBhbGwgcmVzb2x2ZWQgb3Igd2VyZSBhYmFuZG9uZWRcbiAgICB0aGlzLnBlbmRpbmdGb3Jtcy5jbGVhcigpXG4gICAgLy8gd2UgY2FuIGFsc28gY2xlYXIgdGhlIGZvcm1zRm9yUmVjb3Zlcnkgb2JqZWN0IHRvIG5vdCBrZWVwIG9sZCBmb3JtIGVsZW1lbnRzIGFyb3VuZFxuICAgIHRoaXMuZm9ybXNGb3JSZWNvdmVyeSA9IHt9XG4gICAgdGhpcy5qb2luQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgdGhpcy5wZW5kaW5nSm9pbk9wcy5mb3JFYWNoKChbdmlldywgb3BdKSA9PiB7XG4gICAgICAgIGlmKCF2aWV3LmlzRGVzdHJveWVkKCkpeyBvcCgpIH1cbiAgICAgIH0pXG4gICAgICB0aGlzLnBlbmRpbmdKb2luT3BzID0gW11cbiAgICB9KVxuICB9XG5cbiAgdXBkYXRlKGRpZmYsIGV2ZW50cyl7XG4gICAgaWYodGhpcy5pc0pvaW5QZW5kaW5nKCkgfHwgKHRoaXMubGl2ZVNvY2tldC5oYXNQZW5kaW5nTGluaygpICYmIHRoaXMucm9vdC5pc01haW4oKSkpe1xuICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ0RpZmZzLnB1c2goe2RpZmYsIGV2ZW50c30pXG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJlZC5tZXJnZURpZmYoZGlmZilcbiAgICBsZXQgcGh4Q2hpbGRyZW5BZGRlZCA9IGZhbHNlXG5cbiAgICAvLyBXaGVuIHRoZSBkaWZmIG9ubHkgY29udGFpbnMgY29tcG9uZW50IGRpZmZzLCB0aGVuIHdhbGsgY29tcG9uZW50c1xuICAgIC8vIGFuZCBwYXRjaCBvbmx5IHRoZSBwYXJlbnQgY29tcG9uZW50IGNvbnRhaW5lcnMgZm91bmQgaW4gdGhlIGRpZmYuXG4gICAgLy8gT3RoZXJ3aXNlLCBwYXRjaCBlbnRpcmUgTFYgY29udGFpbmVyLlxuICAgIGlmKHRoaXMucmVuZGVyZWQuaXNDb21wb25lbnRPbmx5RGlmZihkaWZmKSl7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQudGltZShcImNvbXBvbmVudCBwYXRjaCBjb21wbGV0ZVwiLCAoKSA9PiB7XG4gICAgICAgIGxldCBwYXJlbnRDaWRzID0gRE9NLmZpbmRFeGlzdGluZ1BhcmVudENJRHModGhpcy5lbCwgdGhpcy5yZW5kZXJlZC5jb21wb25lbnRDSURzKGRpZmYpKVxuICAgICAgICBwYXJlbnRDaWRzLmZvckVhY2gocGFyZW50Q0lEID0+IHtcbiAgICAgICAgICBpZih0aGlzLmNvbXBvbmVudFBhdGNoKHRoaXMucmVuZGVyZWQuZ2V0Q29tcG9uZW50KGRpZmYsIHBhcmVudENJRCksIHBhcmVudENJRCkpeyBwaHhDaGlsZHJlbkFkZGVkID0gdHJ1ZSB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0gZWxzZSBpZighaXNFbXB0eShkaWZmKSl7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQudGltZShcImZ1bGwgcGF0Y2ggY29tcGxldGVcIiwgKCkgPT4ge1xuICAgICAgICBsZXQgW2h0bWwsIHN0cmVhbXNdID0gdGhpcy5yZW5kZXJDb250YWluZXIoZGlmZiwgXCJ1cGRhdGVcIilcbiAgICAgICAgbGV0IHBhdGNoID0gbmV3IERPTVBhdGNoKHRoaXMsIHRoaXMuZWwsIHRoaXMuaWQsIGh0bWwsIHN0cmVhbXMsIG51bGwpXG4gICAgICAgIHBoeENoaWxkcmVuQWRkZWQgPSB0aGlzLnBlcmZvcm1QYXRjaChwYXRjaCwgdHJ1ZSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5saXZlU29ja2V0LmRpc3BhdGNoRXZlbnRzKGV2ZW50cylcbiAgICBpZihwaHhDaGlsZHJlbkFkZGVkKXsgdGhpcy5qb2luTmV3Q2hpbGRyZW4oKSB9XG4gIH1cblxuICByZW5kZXJDb250YWluZXIoZGlmZiwga2luZCl7XG4gICAgcmV0dXJuIHRoaXMubGl2ZVNvY2tldC50aW1lKGB0b1N0cmluZyBkaWZmICgke2tpbmR9KWAsICgpID0+IHtcbiAgICAgIGxldCB0YWcgPSB0aGlzLmVsLnRhZ05hbWVcbiAgICAgIC8vIERvbid0IHNraXAgYW55IGNvbXBvbmVudCBpbiB0aGUgZGlmZiBub3IgYW55IG1hcmtlZCBhcyBwcnVuZWRcbiAgICAgIC8vIChhcyB0aGV5IG1heSBoYXZlIGJlZW4gYWRkZWQgYmFjaylcbiAgICAgIGxldCBjaWRzID0gZGlmZiA/IHRoaXMucmVuZGVyZWQuY29tcG9uZW50Q0lEcyhkaWZmKSA6IG51bGxcbiAgICAgIGxldCBbaHRtbCwgc3RyZWFtc10gPSB0aGlzLnJlbmRlcmVkLnRvU3RyaW5nKGNpZHMpXG4gICAgICByZXR1cm4gW2A8JHt0YWd9PiR7aHRtbH08LyR7dGFnfT5gLCBzdHJlYW1zXVxuICAgIH0pXG4gIH1cblxuICBjb21wb25lbnRQYXRjaChkaWZmLCBjaWQpe1xuICAgIGlmKGlzRW1wdHkoZGlmZikpIHJldHVybiBmYWxzZVxuICAgIGxldCBbaHRtbCwgc3RyZWFtc10gPSB0aGlzLnJlbmRlcmVkLmNvbXBvbmVudFRvU3RyaW5nKGNpZClcbiAgICBsZXQgcGF0Y2ggPSBuZXcgRE9NUGF0Y2godGhpcywgdGhpcy5lbCwgdGhpcy5pZCwgaHRtbCwgc3RyZWFtcywgY2lkKVxuICAgIGxldCBjaGlsZHJlbkFkZGVkID0gdGhpcy5wZXJmb3JtUGF0Y2gocGF0Y2gsIHRydWUpXG4gICAgcmV0dXJuIGNoaWxkcmVuQWRkZWRcbiAgfVxuXG4gIGdldEhvb2soZWwpeyByZXR1cm4gdGhpcy52aWV3SG9va3NbVmlld0hvb2suZWxlbWVudElEKGVsKV0gfVxuXG4gIGFkZEhvb2soZWwpe1xuICAgIGxldCBob29rRWxJZCA9IFZpZXdIb29rLmVsZW1lbnRJRChlbClcblxuICAgIC8vIG9ubHkgZXZlciB0cnkgdG8gYWRkIGhvb2tzIHRvIGVsZW1lbnRzIG93bmVkIGJ5IHRoaXMgdmlld1xuICAgIGlmKGVsLmdldEF0dHJpYnV0ZSAmJiAhdGhpcy5vd25zRWxlbWVudChlbCkpeyByZXR1cm4gfVxuXG4gICAgaWYoaG9va0VsSWQgJiYgIXRoaXMudmlld0hvb2tzW2hvb2tFbElkXSl7XG4gICAgICAvLyBob29rIGNyZWF0ZWQsIGJ1dCBub3QgYXR0YWNoZWQgKGNyZWF0ZUhvb2sgZm9yIHdlYiBjb21wb25lbnQpXG4gICAgICBsZXQgaG9vayA9IERPTS5nZXRDdXN0b21FbEhvb2soZWwpIHx8IGxvZ0Vycm9yKGBubyBob29rIGZvdW5kIGZvciBjdXN0b20gZWxlbWVudDogJHtlbC5pZH1gKVxuICAgICAgdGhpcy52aWV3SG9va3NbaG9va0VsSWRdID0gaG9va1xuICAgICAgaG9vay5fX2F0dGFjaFZpZXcodGhpcylcbiAgICAgIHJldHVybiBob29rXG4gICAgfVxuICAgIGVsc2UgaWYoaG9va0VsSWQgfHwgIWVsLmdldEF0dHJpYnV0ZSl7XG4gICAgICAvLyBubyBob29rIGZvdW5kXG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbmV3IGhvb2sgZm91bmQgd2l0aCBwaHgtaG9vayBhdHRyaWJ1dGVcbiAgICAgIGxldCBob29rTmFtZSA9IGVsLmdldEF0dHJpYnV0ZShgZGF0YS1waHgtJHtQSFhfSE9PS31gKSB8fCBlbC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9IT09LKSlcbiAgICAgIGxldCBjYWxsYmFja3MgPSB0aGlzLmxpdmVTb2NrZXQuZ2V0SG9va0NhbGxiYWNrcyhob29rTmFtZSlcblxuICAgICAgaWYoY2FsbGJhY2tzKXtcbiAgICAgICAgaWYoIWVsLmlkKXsgbG9nRXJyb3IoYG5vIERPTSBJRCBmb3IgaG9vayBcIiR7aG9va05hbWV9XCIuIEhvb2tzIHJlcXVpcmUgYSB1bmlxdWUgSUQgb24gZWFjaCBlbGVtZW50LmAsIGVsKSB9XG4gICAgICAgIGxldCBob29rID0gbmV3IFZpZXdIb29rKHRoaXMsIGVsLCBjYWxsYmFja3MpXG4gICAgICAgIHRoaXMudmlld0hvb2tzW1ZpZXdIb29rLmVsZW1lbnRJRChob29rLmVsKV0gPSBob29rXG4gICAgICAgIHJldHVybiBob29rXG4gICAgICB9IGVsc2UgaWYoaG9va05hbWUgIT09IG51bGwpe1xuICAgICAgICBsb2dFcnJvcihgdW5rbm93biBob29rIGZvdW5kIGZvciBcIiR7aG9va05hbWV9XCJgLCBlbClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZXN0cm95SG9vayhob29rKXtcbiAgICAvLyBfX2Rlc3Ryb3llZCBjbGVhcnMgdGhlIGVsZW1lbnRJRCBmcm9tIHRoZSBob29rLCB0aGVyZWZvcmVcbiAgICAvLyB3ZSBuZWVkIHRvIGdldCBpdCBiZWZvcmUgY2FsbGluZyBfX2Rlc3Ryb3llZFxuICAgIGNvbnN0IGhvb2tJZCA9IFZpZXdIb29rLmVsZW1lbnRJRChob29rLmVsKVxuICAgIGhvb2suX19kZXN0cm95ZWQoKVxuICAgIGhvb2suX19jbGVhbnVwX18oKVxuICAgIGRlbGV0ZSB0aGlzLnZpZXdIb29rc1tob29rSWRdXG4gIH1cblxuICBhcHBseVBlbmRpbmdVcGRhdGVzKCl7XG4gICAgdGhpcy5wZW5kaW5nRGlmZnMuZm9yRWFjaCgoe2RpZmYsIGV2ZW50c30pID0+IHRoaXMudXBkYXRlKGRpZmYsIGV2ZW50cykpXG4gICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXVxuICAgIHRoaXMuZWFjaENoaWxkKGNoaWxkID0+IGNoaWxkLmFwcGx5UGVuZGluZ1VwZGF0ZXMoKSlcbiAgfVxuXG4gIGVhY2hDaGlsZChjYWxsYmFjayl7XG4gICAgbGV0IGNoaWxkcmVuID0gdGhpcy5yb290LmNoaWxkcmVuW3RoaXMuaWRdIHx8IHt9XG4gICAgZm9yKGxldCBpZCBpbiBjaGlsZHJlbil7IGNhbGxiYWNrKHRoaXMuZ2V0Q2hpbGRCeUlkKGlkKSkgfVxuICB9XG5cbiAgb25DaGFubmVsKGV2ZW50LCBjYil7XG4gICAgdGhpcy5saXZlU29ja2V0Lm9uQ2hhbm5lbCh0aGlzLmNoYW5uZWwsIGV2ZW50LCByZXNwID0+IHtcbiAgICAgIGlmKHRoaXMuaXNKb2luUGVuZGluZygpKXtcbiAgICAgICAgdGhpcy5yb290LnBlbmRpbmdKb2luT3BzLnB1c2goW3RoaXMsICgpID0+IGNiKHJlc3ApXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGl2ZVNvY2tldC5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IGNiKHJlc3ApKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBiaW5kQ2hhbm5lbCgpe1xuICAgIC8vIFRoZSBkaWZmIGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoZSByZWd1bGFyIHVwZGF0ZSBvcGVyYXRpb25zLlxuICAgIC8vIEFsbCBvdGhlciBvcGVyYXRpb25zIGFyZSBxdWV1ZWQgdG8gYmUgYXBwbGllZCBvbmx5IGFmdGVyIGpvaW4uXG4gICAgdGhpcy5saXZlU29ja2V0Lm9uQ2hhbm5lbCh0aGlzLmNoYW5uZWwsIFwiZGlmZlwiLCAocmF3RGlmZikgPT4ge1xuICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICB0aGlzLmFwcGx5RGlmZihcInVwZGF0ZVwiLCByYXdEaWZmLCAoe2RpZmYsIGV2ZW50c30pID0+IHRoaXMudXBkYXRlKGRpZmYsIGV2ZW50cykpXG4gICAgICB9KVxuICAgIH0pXG4gICAgdGhpcy5vbkNoYW5uZWwoXCJyZWRpcmVjdFwiLCAoe3RvLCBmbGFzaH0pID0+IHRoaXMub25SZWRpcmVjdCh7dG8sIGZsYXNofSkpXG4gICAgdGhpcy5vbkNoYW5uZWwoXCJsaXZlX3BhdGNoXCIsIChyZWRpcikgPT4gdGhpcy5vbkxpdmVQYXRjaChyZWRpcikpXG4gICAgdGhpcy5vbkNoYW5uZWwoXCJsaXZlX3JlZGlyZWN0XCIsIChyZWRpcikgPT4gdGhpcy5vbkxpdmVSZWRpcmVjdChyZWRpcikpXG4gICAgdGhpcy5jaGFubmVsLm9uRXJyb3IocmVhc29uID0+IHRoaXMub25FcnJvcihyZWFzb24pKVxuICAgIHRoaXMuY2hhbm5lbC5vbkNsb3NlKHJlYXNvbiA9PiB0aGlzLm9uQ2xvc2UocmVhc29uKSlcbiAgfVxuXG4gIGRlc3Ryb3lBbGxDaGlsZHJlbigpeyB0aGlzLmVhY2hDaGlsZChjaGlsZCA9PiBjaGlsZC5kZXN0cm95KCkpIH1cblxuICBvbkxpdmVSZWRpcmVjdChyZWRpcil7XG4gICAgbGV0IHt0bywga2luZCwgZmxhc2h9ID0gcmVkaXJcbiAgICBsZXQgdXJsID0gdGhpcy5leHBhbmRVUkwodG8pXG4gICAgbGV0IGUgPSBuZXcgQ3VzdG9tRXZlbnQoXCJwaHg6c2VydmVyLW5hdmlnYXRlXCIsIHtkZXRhaWw6IHt0bywga2luZCwgZmxhc2h9fSlcbiAgICB0aGlzLmxpdmVTb2NrZXQuaGlzdG9yeVJlZGlyZWN0KGUsIHVybCwga2luZCwgZmxhc2gpXG4gIH1cblxuICBvbkxpdmVQYXRjaChyZWRpcil7XG4gICAgbGV0IHt0bywga2luZH0gPSByZWRpclxuICAgIHRoaXMuaHJlZiA9IHRoaXMuZXhwYW5kVVJMKHRvKVxuICAgIHRoaXMubGl2ZVNvY2tldC5oaXN0b3J5UGF0Y2godG8sIGtpbmQpXG4gIH1cblxuICBleHBhbmRVUkwodG8pe1xuICAgIHJldHVybiB0by5zdGFydHNXaXRoKFwiL1wiKSA/IGAke3dpbmRvdy5sb2NhdGlvbi5wcm90b2NvbH0vLyR7d2luZG93LmxvY2F0aW9uLmhvc3R9JHt0b31gIDogdG9cbiAgfVxuXG4gIG9uUmVkaXJlY3Qoe3RvLCBmbGFzaCwgcmVsb2FkVG9rZW59KXsgdGhpcy5saXZlU29ja2V0LnJlZGlyZWN0KHRvLCBmbGFzaCwgcmVsb2FkVG9rZW4pIH1cblxuICBpc0Rlc3Ryb3llZCgpeyByZXR1cm4gdGhpcy5kZXN0cm95ZWQgfVxuXG4gIGpvaW5EZWFkKCl7IHRoaXMuaXNEZWFkID0gdHJ1ZSB9XG5cbiAgam9pblB1c2goKXtcbiAgICB0aGlzLmpvaW5QdXNoID0gdGhpcy5qb2luUHVzaCB8fCB0aGlzLmNoYW5uZWwuam9pbigpXG4gICAgcmV0dXJuIHRoaXMuam9pblB1c2hcbiAgfVxuXG4gIGpvaW4oY2FsbGJhY2spe1xuICAgIHRoaXMuc2hvd0xvYWRlcih0aGlzLmxpdmVTb2NrZXQubG9hZGVyVGltZW91dClcbiAgICB0aGlzLmJpbmRDaGFubmVsKClcbiAgICBpZih0aGlzLmlzTWFpbigpKXtcbiAgICAgIHRoaXMuc3RvcENhbGxiYWNrID0gdGhpcy5saXZlU29ja2V0LndpdGhQYWdlTG9hZGluZyh7dG86IHRoaXMuaHJlZiwga2luZDogXCJpbml0aWFsXCJ9KVxuICAgIH1cbiAgICB0aGlzLmpvaW5DYWxsYmFjayA9IChvbkRvbmUpID0+IHtcbiAgICAgIG9uRG9uZSA9IG9uRG9uZSB8fCBmdW5jdGlvbigpe31cbiAgICAgIGNhbGxiYWNrID8gY2FsbGJhY2sodGhpcy5qb2luQ291bnQsIG9uRG9uZSkgOiBvbkRvbmUoKVxuICAgIH1cblxuICAgIHRoaXMud3JhcFB1c2goKCkgPT4gdGhpcy5jaGFubmVsLmpvaW4oKSwge1xuICAgICAgb2s6IChyZXNwKSA9PiB0aGlzLmxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB0aGlzLm9uSm9pbihyZXNwKSksXG4gICAgICBlcnJvcjogKGVycm9yKSA9PiB0aGlzLm9uSm9pbkVycm9yKGVycm9yKSxcbiAgICAgIHRpbWVvdXQ6ICgpID0+IHRoaXMub25Kb2luRXJyb3Ioe3JlYXNvbjogXCJ0aW1lb3V0XCJ9KVxuICAgIH0pXG4gIH1cblxuICBvbkpvaW5FcnJvcihyZXNwKXtcbiAgICBpZihyZXNwLnJlYXNvbiA9PT0gXCJyZWxvYWRcIil7XG4gICAgICB0aGlzLmxvZyhcImVycm9yXCIsICgpID0+IFtgZmFpbGVkIG1vdW50IHdpdGggJHtyZXNwLnN0YXR1c30uIEZhbGxpbmcgYmFjayB0byBwYWdlIHJlbG9hZGAsIHJlc3BdKVxuICAgICAgdGhpcy5vblJlZGlyZWN0KHt0bzogdGhpcy5yb290LmhyZWYsIHJlbG9hZFRva2VuOiByZXNwLnRva2VufSlcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSBpZihyZXNwLnJlYXNvbiA9PT0gXCJ1bmF1dGhvcml6ZWRcIiB8fCByZXNwLnJlYXNvbiA9PT0gXCJzdGFsZVwiKXtcbiAgICAgIHRoaXMubG9nKFwiZXJyb3JcIiwgKCkgPT4gW1widW5hdXRob3JpemVkIGxpdmVfcmVkaXJlY3QuIEZhbGxpbmcgYmFjayB0byBwYWdlIHJlcXVlc3RcIiwgcmVzcF0pXG4gICAgICB0aGlzLm9uUmVkaXJlY3Qoe3RvOiB0aGlzLnJvb3QuaHJlZn0pXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYocmVzcC5yZWRpcmVjdCB8fCByZXNwLmxpdmVfcmVkaXJlY3Qpe1xuICAgICAgdGhpcy5qb2luUGVuZGluZyA9IGZhbHNlXG4gICAgICB0aGlzLmNoYW5uZWwubGVhdmUoKVxuICAgIH1cbiAgICBpZihyZXNwLnJlZGlyZWN0KXsgcmV0dXJuIHRoaXMub25SZWRpcmVjdChyZXNwLnJlZGlyZWN0KSB9XG4gICAgaWYocmVzcC5saXZlX3JlZGlyZWN0KXsgcmV0dXJuIHRoaXMub25MaXZlUmVkaXJlY3QocmVzcC5saXZlX3JlZGlyZWN0KSB9XG4gICAgdGhpcy5sb2coXCJlcnJvclwiLCAoKSA9PiBbXCJ1bmFibGUgdG8gam9pblwiLCByZXNwXSlcbiAgICBpZih0aGlzLmlzTWFpbigpKXtcbiAgICAgIHRoaXMuZGlzcGxheUVycm9yKFtQSFhfTE9BRElOR19DTEFTUywgUEhYX0VSUk9SX0NMQVNTLCBQSFhfU0VSVkVSX0VSUk9SX0NMQVNTXSlcbiAgICAgIGlmKHRoaXMubGl2ZVNvY2tldC5pc0Nvbm5lY3RlZCgpKXsgdGhpcy5saXZlU29ja2V0LnJlbG9hZFdpdGhKaXR0ZXIodGhpcykgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZih0aGlzLmpvaW5BdHRlbXB0cyA+PSBNQVhfQ0hJTERfSk9JTl9BVFRFTVBUUyl7XG4gICAgICAgIC8vIHB1dCB0aGUgcm9vdCByZXZpZXcgaW50byBwZXJtYW5lbnQgZXJyb3Igc3RhdGUsIGJ1dCBkb24ndCBkZXN0cm95IGl0IGFzIGl0IGNhbiByZW1haW4gYWN0aXZlXG4gICAgICAgIHRoaXMucm9vdC5kaXNwbGF5RXJyb3IoW1BIWF9MT0FESU5HX0NMQVNTLCBQSFhfRVJST1JfQ0xBU1MsIFBIWF9TRVJWRVJfRVJST1JfQ0xBU1NdKVxuICAgICAgICB0aGlzLmxvZyhcImVycm9yXCIsICgpID0+IFtgZ2l2aW5nIHVwIHRyeWluZyB0byBtb3VudCBhZnRlciAke01BWF9DSElMRF9KT0lOX0FUVEVNUFRTfSB0cmllc2AsIHJlc3BdKVxuICAgICAgICB0aGlzLmRlc3Ryb3koKVxuICAgICAgfVxuICAgICAgbGV0IHRydWVDaGlsZEVsID0gRE9NLmJ5SWQodGhpcy5lbC5pZClcbiAgICAgIGlmKHRydWVDaGlsZEVsKXtcbiAgICAgICAgRE9NLm1lcmdlQXR0cnModHJ1ZUNoaWxkRWwsIHRoaXMuZWwpXG4gICAgICAgIHRoaXMuZGlzcGxheUVycm9yKFtQSFhfTE9BRElOR19DTEFTUywgUEhYX0VSUk9SX0NMQVNTLCBQSFhfU0VSVkVSX0VSUk9SX0NMQVNTXSlcbiAgICAgICAgdGhpcy5lbCA9IHRydWVDaGlsZEVsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlc3Ryb3koKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uQ2xvc2UocmVhc29uKXtcbiAgICBpZih0aGlzLmlzRGVzdHJveWVkKCkpeyByZXR1cm4gfVxuICAgIGlmKHRoaXMuaXNNYWluKCkgJiYgdGhpcy5saXZlU29ja2V0Lmhhc1BlbmRpbmdMaW5rKCkgJiYgcmVhc29uICE9PSBcImxlYXZlXCIpe1xuICAgICAgcmV0dXJuIHRoaXMubGl2ZVNvY2tldC5yZWxvYWRXaXRoSml0dGVyKHRoaXMpXG4gICAgfVxuICAgIHRoaXMuZGVzdHJveUFsbENoaWxkcmVuKClcbiAgICB0aGlzLmxpdmVTb2NrZXQuZHJvcEFjdGl2ZUVsZW1lbnQodGhpcylcbiAgICAvLyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGNhbiBiZSBudWxsIGluIEludGVybmV0IEV4cGxvcmVyIDExXG4gICAgaWYoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCl7IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpIH1cbiAgICBpZih0aGlzLmxpdmVTb2NrZXQuaXNVbmxvYWRlZCgpKXtcbiAgICAgIHRoaXMuc2hvd0xvYWRlcihCRUZPUkVfVU5MT0FEX0xPQURFUl9USU1FT1VUKVxuICAgIH1cbiAgfVxuXG4gIG9uRXJyb3IocmVhc29uKXtcbiAgICB0aGlzLm9uQ2xvc2UocmVhc29uKVxuICAgIGlmKHRoaXMubGl2ZVNvY2tldC5pc0Nvbm5lY3RlZCgpKXsgdGhpcy5sb2coXCJlcnJvclwiLCAoKSA9PiBbXCJ2aWV3IGNyYXNoZWRcIiwgcmVhc29uXSkgfVxuICAgIGlmKCF0aGlzLmxpdmVTb2NrZXQuaXNVbmxvYWRlZCgpKXtcbiAgICAgIGlmKHRoaXMubGl2ZVNvY2tldC5pc0Nvbm5lY3RlZCgpKXtcbiAgICAgICAgdGhpcy5kaXNwbGF5RXJyb3IoW1BIWF9MT0FESU5HX0NMQVNTLCBQSFhfRVJST1JfQ0xBU1MsIFBIWF9TRVJWRVJfRVJST1JfQ0xBU1NdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaXNwbGF5RXJyb3IoW1BIWF9MT0FESU5HX0NMQVNTLCBQSFhfRVJST1JfQ0xBU1MsIFBIWF9DTElFTlRfRVJST1JfQ0xBU1NdKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRpc3BsYXlFcnJvcihjbGFzc2VzKXtcbiAgICBpZih0aGlzLmlzTWFpbigpKXsgRE9NLmRpc3BhdGNoRXZlbnQod2luZG93LCBcInBoeDpwYWdlLWxvYWRpbmctc3RhcnRcIiwge2RldGFpbDoge3RvOiB0aGlzLmhyZWYsIGtpbmQ6IFwiZXJyb3JcIn19KSB9XG4gICAgdGhpcy5zaG93TG9hZGVyKClcbiAgICB0aGlzLnNldENvbnRhaW5lckNsYXNzZXMoLi4uY2xhc3NlcylcbiAgICB0aGlzLmV4ZWNBbGwodGhpcy5iaW5kaW5nKFwiZGlzY29ubmVjdGVkXCIpKVxuICB9XG5cbiAgd3JhcFB1c2goY2FsbGVyUHVzaCwgcmVjZWl2ZXMpe1xuICAgIGxldCBsYXRlbmN5ID0gdGhpcy5saXZlU29ja2V0LmdldExhdGVuY3lTaW0oKVxuICAgIGxldCB3aXRoTGF0ZW5jeSA9IGxhdGVuY3kgP1xuICAgICAgKGNiKSA9PiBzZXRUaW1lb3V0KCgpID0+ICF0aGlzLmlzRGVzdHJveWVkKCkgJiYgY2IoKSwgbGF0ZW5jeSkgOlxuICAgICAgKGNiKSA9PiAhdGhpcy5pc0Rlc3Ryb3llZCgpICYmIGNiKClcblxuICAgIHdpdGhMYXRlbmN5KCgpID0+IHtcbiAgICAgIGNhbGxlclB1c2goKVxuICAgICAgICAucmVjZWl2ZShcIm9rXCIsIHJlc3AgPT4gd2l0aExhdGVuY3koKCkgPT4gcmVjZWl2ZXMub2sgJiYgcmVjZWl2ZXMub2socmVzcCkpKVxuICAgICAgICAucmVjZWl2ZShcImVycm9yXCIsIHJlYXNvbiA9PiB3aXRoTGF0ZW5jeSgoKSA9PiByZWNlaXZlcy5lcnJvciAmJiByZWNlaXZlcy5lcnJvcihyZWFzb24pKSlcbiAgICAgICAgLnJlY2VpdmUoXCJ0aW1lb3V0XCIsICgpID0+IHdpdGhMYXRlbmN5KCgpID0+IHJlY2VpdmVzLnRpbWVvdXQgJiYgcmVjZWl2ZXMudGltZW91dCgpKSlcbiAgICB9KVxuICB9XG5cbiAgcHVzaFdpdGhSZXBseShyZWZHZW5lcmF0b3IsIGV2ZW50LCBwYXlsb2FkKXtcbiAgICBpZighdGhpcy5pc0Nvbm5lY3RlZCgpKXsgcmV0dXJuIFByb21pc2UucmVqZWN0KHtlcnJvcjogXCJub2Nvbm5lY3Rpb25cIn0pIH1cblxuICAgIGxldCBbcmVmLCBbZWxdLCBvcHRzXSA9IHJlZkdlbmVyYXRvciA/IHJlZkdlbmVyYXRvcigpIDogW251bGwsIFtdLCB7fV1cbiAgICBsZXQgb2xkSm9pbkNvdW50ID0gdGhpcy5qb2luQ291bnRcbiAgICBsZXQgb25Mb2FkaW5nRG9uZSA9IGZ1bmN0aW9uKCl7fVxuICAgIGlmKG9wdHMucGFnZV9sb2FkaW5nKXtcbiAgICAgIG9uTG9hZGluZ0RvbmUgPSB0aGlzLmxpdmVTb2NrZXQud2l0aFBhZ2VMb2FkaW5nKHtraW5kOiBcImVsZW1lbnRcIiwgdGFyZ2V0OiBlbH0pXG4gICAgfVxuXG4gICAgaWYodHlwZW9mIChwYXlsb2FkLmNpZCkgIT09IFwibnVtYmVyXCIpeyBkZWxldGUgcGF5bG9hZC5jaWQgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMud3JhcFB1c2goKCkgPT4gdGhpcy5jaGFubmVsLnB1c2goZXZlbnQsIHBheWxvYWQsIFBVU0hfVElNRU9VVCksIHtcbiAgICAgICAgb2s6IChyZXNwKSA9PiB7XG4gICAgICAgICAgaWYocmVmICE9PSBudWxsKXsgdGhpcy5sYXN0QWNrUmVmID0gcmVmIH1cbiAgICAgICAgICBsZXQgZmluaXNoID0gKGhvb2tSZXBseSkgPT4ge1xuICAgICAgICAgICAgaWYocmVzcC5yZWRpcmVjdCl7IHRoaXMub25SZWRpcmVjdChyZXNwLnJlZGlyZWN0KSB9XG4gICAgICAgICAgICBpZihyZXNwLmxpdmVfcGF0Y2gpeyB0aGlzLm9uTGl2ZVBhdGNoKHJlc3AubGl2ZV9wYXRjaCkgfVxuICAgICAgICAgICAgaWYocmVzcC5saXZlX3JlZGlyZWN0KXsgdGhpcy5vbkxpdmVSZWRpcmVjdChyZXNwLmxpdmVfcmVkaXJlY3QpIH1cbiAgICAgICAgICAgIG9uTG9hZGluZ0RvbmUoKVxuICAgICAgICAgICAgcmVzb2x2ZSh7cmVzcDogcmVzcCwgcmVwbHk6IGhvb2tSZXBseX0pXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHJlc3AuZGlmZil7XG4gICAgICAgICAgICB0aGlzLmxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuYXBwbHlEaWZmKFwidXBkYXRlXCIsIHJlc3AuZGlmZiwgKHtkaWZmLCByZXBseSwgZXZlbnRzfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmKHJlZiAhPT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICB0aGlzLnVuZG9SZWZzKHJlZiwgcGF5bG9hZC5ldmVudClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoZGlmZiwgZXZlbnRzKVxuICAgICAgICAgICAgICAgIGZpbmlzaChyZXBseSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKHJlZiAhPT0gbnVsbCl7IHRoaXMudW5kb1JlZnMocmVmLCBwYXlsb2FkLmV2ZW50KSB9XG4gICAgICAgICAgICBmaW5pc2gobnVsbClcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiAocmVhc29uKSA9PiByZWplY3Qoe2Vycm9yOiByZWFzb259KSxcbiAgICAgICAgdGltZW91dDogKCkgPT4ge1xuICAgICAgICAgIHJlamVjdCh7dGltZW91dDogdHJ1ZX0pXG4gICAgICAgICAgaWYodGhpcy5qb2luQ291bnQgPT09IG9sZEpvaW5Db3VudCl7XG4gICAgICAgICAgICB0aGlzLmxpdmVTb2NrZXQucmVsb2FkV2l0aEppdHRlcih0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMubG9nKFwidGltZW91dFwiLCAoKSA9PiBbXCJyZWNlaXZlZCB0aW1lb3V0IHdoaWxlIGNvbW11bmljYXRpbmcgd2l0aCBzZXJ2ZXIuIEZhbGxpbmcgYmFjayB0byBoYXJkIHJlZnJlc2ggZm9yIHJlY292ZXJ5XCJdKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHVuZG9SZWZzKHJlZiwgcGh4RXZlbnQsIG9ubHlFbHMpe1xuICAgIGlmKCF0aGlzLmlzQ29ubmVjdGVkKCkpeyByZXR1cm4gfSAvLyBleGl0IGlmIGV4dGVybmFsIGZvcm0gdHJpZ2dlcmVkXG4gICAgbGV0IHNlbGVjdG9yID0gYFske1BIWF9SRUZfU1JDfT1cIiR7dGhpcy5yZWZTcmMoKX1cIl1gXG5cbiAgICBpZihvbmx5RWxzKXtcbiAgICAgIG9ubHlFbHMgPSBuZXcgU2V0KG9ubHlFbHMpXG4gICAgICBET00uYWxsKGRvY3VtZW50LCBzZWxlY3RvciwgcGFyZW50ID0+IHtcbiAgICAgICAgaWYob25seUVscyAmJiAhb25seUVscy5oYXMocGFyZW50KSl7IHJldHVybiB9XG4gICAgICAgIC8vIHVuZG8gYW55IGNoaWxkIHJlZnMgd2l0aGluIHBhcmVudCBmaXJzdFxuICAgICAgICBET00uYWxsKHBhcmVudCwgc2VsZWN0b3IsIGNoaWxkID0+IHRoaXMudW5kb0VsUmVmKGNoaWxkLCByZWYsIHBoeEV2ZW50KSlcbiAgICAgICAgdGhpcy51bmRvRWxSZWYocGFyZW50LCByZWYsIHBoeEV2ZW50KVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgRE9NLmFsbChkb2N1bWVudCwgc2VsZWN0b3IsIGVsID0+IHRoaXMudW5kb0VsUmVmKGVsLCByZWYsIHBoeEV2ZW50KSlcbiAgICB9XG4gIH1cblxuICB1bmRvRWxSZWYoZWwsIHJlZiwgcGh4RXZlbnQpe1xuICAgIGxldCBlbFJlZiA9IG5ldyBFbGVtZW50UmVmKGVsKVxuXG4gICAgZWxSZWYubWF5YmVVbmRvKHJlZiwgcGh4RXZlbnQsIGNsb25lZFRyZWUgPT4ge1xuICAgICAgLy8gd2UgbmVlZCB0byBwZXJmb3JtIGEgZnVsbCBwYXRjaCBvbiB1bmxvY2tlZCBlbGVtZW50c1xuICAgICAgLy8gdG8gcGVyZm9ybSBhbGwgdGhlIG5lY2Vzc2FyeSBsb2dpYyAobGlrZSBjYWxsaW5nIHVwZGF0ZWQgZm9yIGhvb2tzLCBldGMuKVxuICAgICAgbGV0IHBhdGNoID0gbmV3IERPTVBhdGNoKHRoaXMsIGVsLCB0aGlzLmlkLCBjbG9uZWRUcmVlLCBbXSwgbnVsbCwge3VuZG9SZWY6IHJlZn0pXG4gICAgICBjb25zdCBwaHhDaGlsZHJlbkFkZGVkID0gdGhpcy5wZXJmb3JtUGF0Y2gocGF0Y2gsIHRydWUpXG4gICAgICBET00uYWxsKGVsLCBgWyR7UEhYX1JFRl9TUkN9PVwiJHt0aGlzLnJlZlNyYygpfVwiXWAsIGNoaWxkID0+IHRoaXMudW5kb0VsUmVmKGNoaWxkLCByZWYsIHBoeEV2ZW50KSlcbiAgICAgIGlmKHBoeENoaWxkcmVuQWRkZWQpeyB0aGlzLmpvaW5OZXdDaGlsZHJlbigpIH1cbiAgICB9KVxuICB9XG5cbiAgcmVmU3JjKCl7IHJldHVybiB0aGlzLmVsLmlkIH1cblxuICBwdXRSZWYoZWxlbWVudHMsIHBoeEV2ZW50LCBldmVudFR5cGUsIG9wdHMgPSB7fSl7XG4gICAgbGV0IG5ld1JlZiA9IHRoaXMucmVmKytcbiAgICBsZXQgZGlzYWJsZVdpdGggPSB0aGlzLmJpbmRpbmcoUEhYX0RJU0FCTEVfV0lUSClcbiAgICBpZihvcHRzLmxvYWRpbmcpe1xuICAgICAgbGV0IGxvYWRpbmdFbHMgPSBET00uYWxsKGRvY3VtZW50LCBvcHRzLmxvYWRpbmcpLm1hcChlbCA9PiB7XG4gICAgICAgIHJldHVybiB7ZWwsIGxvY2s6IHRydWUsIGxvYWRpbmc6IHRydWV9XG4gICAgICB9KVxuICAgICAgZWxlbWVudHMgPSBlbGVtZW50cy5jb25jYXQobG9hZGluZ0VscylcbiAgICB9XG5cbiAgICBmb3IobGV0IHtlbCwgbG9jaywgbG9hZGluZ30gb2YgZWxlbWVudHMpe1xuICAgICAgaWYoIWxvY2sgJiYgIWxvYWRpbmcpeyB0aHJvdyBuZXcgRXJyb3IoXCJwdXRSZWYgcmVxdWlyZXMgbG9jayBvciBsb2FkaW5nXCIpIH1cbiAgICAgIGVsLnNldEF0dHJpYnV0ZShQSFhfUkVGX1NSQywgdGhpcy5yZWZTcmMoKSlcbiAgICAgIGlmKGxvYWRpbmcpeyBlbC5zZXRBdHRyaWJ1dGUoUEhYX1JFRl9MT0FESU5HLCBuZXdSZWYpIH1cbiAgICAgIGlmKGxvY2speyBlbC5zZXRBdHRyaWJ1dGUoUEhYX1JFRl9MT0NLLCBuZXdSZWYpIH1cblxuICAgICAgaWYoIWxvYWRpbmcgfHwgKG9wdHMuc3VibWl0dGVyICYmICEoZWwgPT09IG9wdHMuc3VibWl0dGVyIHx8IGVsID09PSBvcHRzLmZvcm0pKSl7IGNvbnRpbnVlIH1cblxuICAgICAgbGV0IGxvY2tDb21wbGV0ZVByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihgcGh4OnVuZG8tbG9jazoke25ld1JlZn1gLCAoKSA9PiByZXNvbHZlKGRldGFpbCksIHtvbmNlOiB0cnVlfSlcbiAgICAgIH0pXG5cbiAgICAgIGxldCBsb2FkaW5nQ29tcGxldGVQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoYHBoeDp1bmRvLWxvYWRpbmc6JHtuZXdSZWZ9YCwgKCkgPT4gcmVzb2x2ZShkZXRhaWwpLCB7b25jZTogdHJ1ZX0pXG4gICAgICB9KVxuXG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGBwaHgtJHtldmVudFR5cGV9LWxvYWRpbmdgKVxuICAgICAgbGV0IGRpc2FibGVUZXh0ID0gZWwuZ2V0QXR0cmlidXRlKGRpc2FibGVXaXRoKVxuICAgICAgaWYoZGlzYWJsZVRleHQgIT09IG51bGwpe1xuICAgICAgICBpZighZWwuZ2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSkpe1xuICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUsIGVsLmlubmVyVGV4dClcbiAgICAgICAgfVxuICAgICAgICBpZihkaXNhYmxlVGV4dCAhPT0gXCJcIil7IGVsLmlubmVyVGV4dCA9IGRpc2FibGVUZXh0IH1cbiAgICAgICAgLy8gUEhYX0RJU0FCTEVEIGNvdWxkIGhhdmUgYWxyZWFkeSBiZWVuIHNldCBpbiBkaXNhYmxlRm9ybVxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVELCBlbC5nZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVEKSB8fCBlbC5kaXNhYmxlZClcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJcIilcbiAgICAgIH1cblxuICAgICAgbGV0IGRldGFpbCA9IHtcbiAgICAgICAgZXZlbnQ6IHBoeEV2ZW50LFxuICAgICAgICBldmVudFR5cGU6IGV2ZW50VHlwZSxcbiAgICAgICAgcmVmOiBuZXdSZWYsXG4gICAgICAgIGlzTG9hZGluZzogbG9hZGluZyxcbiAgICAgICAgaXNMb2NrZWQ6IGxvY2ssXG4gICAgICAgIGxvY2tFbGVtZW50czogZWxlbWVudHMuZmlsdGVyKCh7bG9ja30pID0+IGxvY2spLm1hcCgoe2VsfSkgPT4gZWwpLFxuICAgICAgICBsb2FkaW5nRWxlbWVudHM6IGVsZW1lbnRzLmZpbHRlcigoe2xvYWRpbmd9KSA9PiBsb2FkaW5nKS5tYXAoKHtlbH0pID0+IGVsKSxcbiAgICAgICAgdW5sb2NrOiAoZWxzKSA9PiB7XG4gICAgICAgICAgZWxzID0gQXJyYXkuaXNBcnJheShlbHMpID8gZWxzIDogW2Vsc11cbiAgICAgICAgICB0aGlzLnVuZG9SZWZzKG5ld1JlZiwgcGh4RXZlbnQsIGVscylcbiAgICAgICAgfSxcbiAgICAgICAgbG9ja0NvbXBsZXRlOiBsb2NrQ29tcGxldGVQcm9taXNlLFxuICAgICAgICBsb2FkaW5nQ29tcGxldGU6IGxvYWRpbmdDb21wbGV0ZVByb21pc2UsXG4gICAgICAgIGxvY2s6IChsb2NrRWwpID0+IHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBpZih0aGlzLmlzQWNrZWQobmV3UmVmKSl7IHJldHVybiByZXNvbHZlKGRldGFpbCkgfVxuICAgICAgICAgICAgbG9ja0VsLnNldEF0dHJpYnV0ZShQSFhfUkVGX0xPQ0ssIG5ld1JlZilcbiAgICAgICAgICAgIGxvY2tFbC5zZXRBdHRyaWJ1dGUoUEhYX1JFRl9TUkMsIHRoaXMucmVmU3JjKCkpXG4gICAgICAgICAgICBsb2NrRWwuYWRkRXZlbnRMaXN0ZW5lcihgcGh4OmxvY2stc3RvcDoke25ld1JlZn1gLCAoKSA9PiByZXNvbHZlKGRldGFpbCksIHtvbmNlOiB0cnVlfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcInBoeDpwdXNoXCIsIHtcbiAgICAgICAgZGV0YWlsOiBkZXRhaWwsXG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgICB9KSlcbiAgICAgIGlmKHBoeEV2ZW50KXtcbiAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoYHBoeDpwdXNoOiR7cGh4RXZlbnR9YCwge1xuICAgICAgICAgIGRldGFpbDogZGV0YWlsLFxuICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICAgICAgfSkpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbbmV3UmVmLCBlbGVtZW50cy5tYXAoKHtlbH0pID0+IGVsKSwgb3B0c11cbiAgfVxuXG4gIGlzQWNrZWQocmVmKXsgcmV0dXJuIHRoaXMubGFzdEFja1JlZiAhPT0gbnVsbCAmJiB0aGlzLmxhc3RBY2tSZWYgPj0gcmVmIH1cblxuICBjb21wb25lbnRJRChlbCl7XG4gICAgbGV0IGNpZCA9IGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVClcbiAgICByZXR1cm4gY2lkID8gcGFyc2VJbnQoY2lkKSA6IG51bGxcbiAgfVxuXG4gIHRhcmdldENvbXBvbmVudElEKHRhcmdldCwgdGFyZ2V0Q3R4LCBvcHRzID0ge30pe1xuICAgIGlmKGlzQ2lkKHRhcmdldEN0eCkpeyByZXR1cm4gdGFyZ2V0Q3R4IH1cblxuICAgIGxldCBjaWRPclNlbGVjdG9yID0gb3B0cy50YXJnZXQgfHwgdGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJ0YXJnZXRcIikpXG4gICAgaWYoaXNDaWQoY2lkT3JTZWxlY3Rvcikpe1xuICAgICAgcmV0dXJuIHBhcnNlSW50KGNpZE9yU2VsZWN0b3IpXG4gICAgfSBlbHNlIGlmKHRhcmdldEN0eCAmJiAoY2lkT3JTZWxlY3RvciAhPT0gbnVsbCB8fCBvcHRzLnRhcmdldCkpe1xuICAgICAgcmV0dXJuIHRoaXMuY2xvc2VzdENvbXBvbmVudElEKHRhcmdldEN0eClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICBjbG9zZXN0Q29tcG9uZW50SUQodGFyZ2V0Q3R4KXtcbiAgICBpZihpc0NpZCh0YXJnZXRDdHgpKXtcbiAgICAgIHJldHVybiB0YXJnZXRDdHhcbiAgICB9IGVsc2UgaWYodGFyZ2V0Q3R4KXtcbiAgICAgIHJldHVybiBtYXliZSh0YXJnZXRDdHguY2xvc2VzdChgWyR7UEhYX0NPTVBPTkVOVH1dYCksIGVsID0+IHRoaXMub3duc0VsZW1lbnQoZWwpICYmIHRoaXMuY29tcG9uZW50SUQoZWwpKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHB1c2hIb29rRXZlbnQoZWwsIHRhcmdldEN0eCwgZXZlbnQsIHBheWxvYWQsIG9uUmVwbHkpe1xuICAgIGlmKCF0aGlzLmlzQ29ubmVjdGVkKCkpe1xuICAgICAgdGhpcy5sb2coXCJob29rXCIsICgpID0+IFtcInVuYWJsZSB0byBwdXNoIGhvb2sgZXZlbnQuIExpdmVWaWV3IG5vdCBjb25uZWN0ZWRcIiwgZXZlbnQsIHBheWxvYWRdKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGxldCBbcmVmLCBlbHMsIG9wdHNdID0gdGhpcy5wdXRSZWYoW3tlbCwgbG9hZGluZzogdHJ1ZSwgbG9jazogdHJ1ZX1dLCBldmVudCwgXCJob29rXCIpXG4gICAgdGhpcy5wdXNoV2l0aFJlcGx5KCgpID0+IFtyZWYsIGVscywgb3B0c10sIFwiZXZlbnRcIiwge1xuICAgICAgdHlwZTogXCJob29rXCIsXG4gICAgICBldmVudDogZXZlbnQsXG4gICAgICB2YWx1ZTogcGF5bG9hZCxcbiAgICAgIGNpZDogdGhpcy5jbG9zZXN0Q29tcG9uZW50SUQodGFyZ2V0Q3R4KVxuICAgIH0pLnRoZW4oKHtyZXNwOiBfcmVzcCwgcmVwbHk6IGhvb2tSZXBseX0pID0+IG9uUmVwbHkoaG9va1JlcGx5LCByZWYpKVxuXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgZXh0cmFjdE1ldGEoZWwsIG1ldGEsIHZhbHVlKXtcbiAgICBsZXQgcHJlZml4ID0gdGhpcy5iaW5kaW5nKFwidmFsdWUtXCIpXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGVsLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspe1xuICAgICAgaWYoIW1ldGEpeyBtZXRhID0ge30gfVxuICAgICAgbGV0IG5hbWUgPSBlbC5hdHRyaWJ1dGVzW2ldLm5hbWVcbiAgICAgIGlmKG5hbWUuc3RhcnRzV2l0aChwcmVmaXgpKXsgbWV0YVtuYW1lLnJlcGxhY2UocHJlZml4LCBcIlwiKV0gPSBlbC5nZXRBdHRyaWJ1dGUobmFtZSkgfVxuICAgIH1cbiAgICBpZihlbC52YWx1ZSAhPT0gdW5kZWZpbmVkICYmICEoZWwgaW5zdGFuY2VvZiBIVE1MRm9ybUVsZW1lbnQpKXtcbiAgICAgIGlmKCFtZXRhKXsgbWV0YSA9IHt9IH1cbiAgICAgIG1ldGEudmFsdWUgPSBlbC52YWx1ZVxuXG4gICAgICBpZihlbC50YWdOYW1lID09PSBcIklOUFVUXCIgJiYgQ0hFQ0tBQkxFX0lOUFVUUy5pbmRleE9mKGVsLnR5cGUpID49IDAgJiYgIWVsLmNoZWNrZWQpe1xuICAgICAgICBkZWxldGUgbWV0YS52YWx1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZih2YWx1ZSl7XG4gICAgICBpZighbWV0YSl7IG1ldGEgPSB7fSB9XG4gICAgICBmb3IobGV0IGtleSBpbiB2YWx1ZSl7IG1ldGFba2V5XSA9IHZhbHVlW2tleV0gfVxuICAgIH1cbiAgICByZXR1cm4gbWV0YVxuICB9XG5cbiAgcHVzaEV2ZW50KHR5cGUsIGVsLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBtZXRhLCBvcHRzID0ge30sIG9uUmVwbHkpe1xuICAgIHRoaXMucHVzaFdpdGhSZXBseSgoKSA9PiB0aGlzLnB1dFJlZihbe2VsLCBsb2FkaW5nOiB0cnVlLCBsb2NrOiB0cnVlfV0sIHBoeEV2ZW50LCB0eXBlLCBvcHRzKSwgXCJldmVudFwiLCB7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgZXZlbnQ6IHBoeEV2ZW50LFxuICAgICAgdmFsdWU6IHRoaXMuZXh0cmFjdE1ldGEoZWwsIG1ldGEsIG9wdHMudmFsdWUpLFxuICAgICAgY2lkOiB0aGlzLnRhcmdldENvbXBvbmVudElEKGVsLCB0YXJnZXRDdHgsIG9wdHMpXG4gICAgfSkudGhlbigoe3JlcGx5fSkgPT4gb25SZXBseSAmJiBvblJlcGx5KHJlcGx5KSlcbiAgfVxuXG4gIHB1c2hGaWxlUHJvZ3Jlc3MoZmlsZUVsLCBlbnRyeVJlZiwgcHJvZ3Jlc3MsIG9uUmVwbHkgPSBmdW5jdGlvbiAoKXsgfSl7XG4gICAgdGhpcy5saXZlU29ja2V0LndpdGhpbk93bmVycyhmaWxlRWwuZm9ybSwgKHZpZXcsIHRhcmdldEN0eCkgPT4ge1xuICAgICAgdmlldy5wdXNoV2l0aFJlcGx5KG51bGwsIFwicHJvZ3Jlc3NcIiwge1xuICAgICAgICBldmVudDogZmlsZUVsLmdldEF0dHJpYnV0ZSh2aWV3LmJpbmRpbmcoUEhYX1BST0dSRVNTKSksXG4gICAgICAgIHJlZjogZmlsZUVsLmdldEF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRiksXG4gICAgICAgIGVudHJ5X3JlZjogZW50cnlSZWYsXG4gICAgICAgIHByb2dyZXNzOiBwcm9ncmVzcyxcbiAgICAgICAgY2lkOiB2aWV3LnRhcmdldENvbXBvbmVudElEKGZpbGVFbC5mb3JtLCB0YXJnZXRDdHgpXG4gICAgICB9KS50aGVuKCh7cmVzcH0pID0+IG9uUmVwbHkocmVzcCkpXG4gICAgfSlcbiAgfVxuXG4gIHB1c2hJbnB1dChpbnB1dEVsLCB0YXJnZXRDdHgsIGZvcmNlQ2lkLCBwaHhFdmVudCwgb3B0cywgY2FsbGJhY2spe1xuICAgIGlmKCFpbnB1dEVsLmZvcm0pe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZm9ybSBldmVudHMgcmVxdWlyZSB0aGUgaW5wdXQgdG8gYmUgaW5zaWRlIGEgZm9ybVwiKVxuICAgIH1cblxuICAgIGxldCB1cGxvYWRzXG4gICAgbGV0IGNpZCA9IGlzQ2lkKGZvcmNlQ2lkKSA/IGZvcmNlQ2lkIDogdGhpcy50YXJnZXRDb21wb25lbnRJRChpbnB1dEVsLmZvcm0sIHRhcmdldEN0eCwgb3B0cylcbiAgICBsZXQgcmVmR2VuZXJhdG9yID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMucHV0UmVmKFtcbiAgICAgICAge2VsOiBpbnB1dEVsLCBsb2FkaW5nOiB0cnVlLCBsb2NrOiB0cnVlfSxcbiAgICAgICAge2VsOiBpbnB1dEVsLmZvcm0sIGxvYWRpbmc6IHRydWUsIGxvY2s6IHRydWV9XG4gICAgICBdLCBwaHhFdmVudCwgXCJjaGFuZ2VcIiwgb3B0cylcbiAgICB9XG4gICAgbGV0IGZvcm1EYXRhXG4gICAgbGV0IG1ldGEgID0gdGhpcy5leHRyYWN0TWV0YShpbnB1dEVsLmZvcm0pXG4gICAgaWYoaW5wdXRFbCBpbnN0YW5jZW9mIEhUTUxCdXR0b25FbGVtZW50KXsgbWV0YS5zdWJtaXR0ZXIgPSBpbnB1dEVsIH1cbiAgICBpZihpbnB1dEVsLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJjaGFuZ2VcIikpKXtcbiAgICAgIGZvcm1EYXRhID0gc2VyaWFsaXplRm9ybShpbnB1dEVsLmZvcm0sIHtfdGFyZ2V0OiBvcHRzLl90YXJnZXQsIC4uLm1ldGF9LCBbaW5wdXRFbC5uYW1lXSlcbiAgICB9IGVsc2Uge1xuICAgICAgZm9ybURhdGEgPSBzZXJpYWxpemVGb3JtKGlucHV0RWwuZm9ybSwge190YXJnZXQ6IG9wdHMuX3RhcmdldCwgLi4ubWV0YX0pXG4gICAgfVxuICAgIGlmKERPTS5pc1VwbG9hZElucHV0KGlucHV0RWwpICYmIGlucHV0RWwuZmlsZXMgJiYgaW5wdXRFbC5maWxlcy5sZW5ndGggPiAwKXtcbiAgICAgIExpdmVVcGxvYWRlci50cmFja0ZpbGVzKGlucHV0RWwsIEFycmF5LmZyb20oaW5wdXRFbC5maWxlcykpXG4gICAgfVxuICAgIHVwbG9hZHMgPSBMaXZlVXBsb2FkZXIuc2VyaWFsaXplVXBsb2FkcyhpbnB1dEVsKVxuXG4gICAgbGV0IGV2ZW50ID0ge1xuICAgICAgdHlwZTogXCJmb3JtXCIsXG4gICAgICBldmVudDogcGh4RXZlbnQsXG4gICAgICB2YWx1ZTogZm9ybURhdGEsXG4gICAgICB1cGxvYWRzOiB1cGxvYWRzLFxuICAgICAgY2lkOiBjaWRcbiAgICB9XG4gICAgdGhpcy5wdXNoV2l0aFJlcGx5KHJlZkdlbmVyYXRvciwgXCJldmVudFwiLCBldmVudCkudGhlbigoe3Jlc3B9KSA9PiB7XG4gICAgICBpZihET00uaXNVcGxvYWRJbnB1dChpbnB1dEVsKSAmJiBET00uaXNBdXRvVXBsb2FkKGlucHV0RWwpKXtcbiAgICAgICAgLy8gdGhlIGVsZW1lbnQgY291bGQgYmUgaW5zaWRlIGEgbG9ja2VkIHBhcmVudCBmb3Igb3RoZXIgdW5yZWxhdGVkIGNoYW5nZXM7XG4gICAgICAgIC8vIHdlIGNhbiBvbmx5IHN0YXJ0IHVwbG9hZHMgd2hlbiB0aGUgdHJlZSBpcyB1bmxvY2tlZCBhbmQgdGhlXG4gICAgICAgIC8vIG5lY2Vzc2FyeSBkYXRhIGF0dHJpYnV0ZXMgYXJlIHNldCBpbiB0aGUgcmVhbCBET01cbiAgICAgICAgRWxlbWVudFJlZi5vblVubG9jayhpbnB1dEVsLCAoKSA9PiB7XG4gICAgICAgICAgaWYoTGl2ZVVwbG9hZGVyLmZpbGVzQXdhaXRpbmdQcmVmbGlnaHQoaW5wdXRFbCkubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICBsZXQgW3JlZiwgX2Vsc10gPSByZWZHZW5lcmF0b3IoKVxuICAgICAgICAgICAgdGhpcy51bmRvUmVmcyhyZWYsIHBoeEV2ZW50LCBbaW5wdXRFbC5mb3JtXSlcbiAgICAgICAgICAgIHRoaXMudXBsb2FkRmlsZXMoaW5wdXRFbC5mb3JtLCBwaHhFdmVudCwgdGFyZ2V0Q3R4LCByZWYsIGNpZCwgKF91cGxvYWRzKSA9PiB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3ApXG4gICAgICAgICAgICAgIHRoaXMudHJpZ2dlckF3YWl0aW5nU3VibWl0KGlucHV0RWwuZm9ybSwgcGh4RXZlbnQpXG4gICAgICAgICAgICAgIHRoaXMudW5kb1JlZnMocmVmLCBwaHhFdmVudClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socmVzcClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgdHJpZ2dlckF3YWl0aW5nU3VibWl0KGZvcm1FbCwgcGh4RXZlbnQpe1xuICAgIGxldCBhd2FpdGluZ1N1Ym1pdCA9IHRoaXMuZ2V0U2NoZWR1bGVkU3VibWl0KGZvcm1FbClcbiAgICBpZihhd2FpdGluZ1N1Ym1pdCl7XG4gICAgICBsZXQgW19lbCwgX3JlZiwgX29wdHMsIGNhbGxiYWNrXSA9IGF3YWl0aW5nU3VibWl0XG4gICAgICB0aGlzLmNhbmNlbFN1Ym1pdChmb3JtRWwsIHBoeEV2ZW50KVxuICAgICAgY2FsbGJhY2soKVxuICAgIH1cbiAgfVxuXG4gIGdldFNjaGVkdWxlZFN1Ym1pdChmb3JtRWwpe1xuICAgIHJldHVybiB0aGlzLmZvcm1TdWJtaXRzLmZpbmQoKFtlbCwgX3JlZiwgX29wdHMsIF9jYWxsYmFja10pID0+IGVsLmlzU2FtZU5vZGUoZm9ybUVsKSlcbiAgfVxuXG4gIHNjaGVkdWxlU3VibWl0KGZvcm1FbCwgcmVmLCBvcHRzLCBjYWxsYmFjayl7XG4gICAgaWYodGhpcy5nZXRTY2hlZHVsZWRTdWJtaXQoZm9ybUVsKSl7IHJldHVybiB0cnVlIH1cbiAgICB0aGlzLmZvcm1TdWJtaXRzLnB1c2goW2Zvcm1FbCwgcmVmLCBvcHRzLCBjYWxsYmFja10pXG4gIH1cblxuICBjYW5jZWxTdWJtaXQoZm9ybUVsLCBwaHhFdmVudCl7XG4gICAgdGhpcy5mb3JtU3VibWl0cyA9IHRoaXMuZm9ybVN1Ym1pdHMuZmlsdGVyKChbZWwsIHJlZiwgX29wdHMsIF9jYWxsYmFja10pID0+IHtcbiAgICAgIGlmKGVsLmlzU2FtZU5vZGUoZm9ybUVsKSl7XG4gICAgICAgIHRoaXMudW5kb1JlZnMocmVmLCBwaHhFdmVudClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBkaXNhYmxlRm9ybShmb3JtRWwsIHBoeEV2ZW50LCBvcHRzID0ge30pe1xuICAgIGxldCBmaWx0ZXJJZ25vcmVkID0gZWwgPT4ge1xuICAgICAgbGV0IHVzZXJJZ25vcmVkID0gY2xvc2VzdFBoeEJpbmRpbmcoZWwsIGAke3RoaXMuYmluZGluZyhQSFhfVVBEQVRFKX09aWdub3JlYCwgZWwuZm9ybSlcbiAgICAgIHJldHVybiAhKHVzZXJJZ25vcmVkIHx8IGNsb3Nlc3RQaHhCaW5kaW5nKGVsLCBcImRhdGEtcGh4LXVwZGF0ZT1pZ25vcmVcIiwgZWwuZm9ybSkpXG4gICAgfVxuICAgIGxldCBmaWx0ZXJEaXNhYmxlcyA9IGVsID0+IHtcbiAgICAgIHJldHVybiBlbC5oYXNBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9ESVNBQkxFX1dJVEgpKVxuICAgIH1cbiAgICBsZXQgZmlsdGVyQnV0dG9uID0gZWwgPT4gZWwudGFnTmFtZSA9PSBcIkJVVFRPTlwiXG5cbiAgICBsZXQgZmlsdGVySW5wdXQgPSBlbCA9PiBbXCJJTlBVVFwiLCBcIlRFWFRBUkVBXCIsIFwiU0VMRUNUXCJdLmluY2x1ZGVzKGVsLnRhZ05hbWUpXG5cbiAgICBsZXQgZm9ybUVsZW1lbnRzID0gQXJyYXkuZnJvbShmb3JtRWwuZWxlbWVudHMpXG4gICAgbGV0IGRpc2FibGVzID0gZm9ybUVsZW1lbnRzLmZpbHRlcihmaWx0ZXJEaXNhYmxlcylcbiAgICBsZXQgYnV0dG9ucyA9IGZvcm1FbGVtZW50cy5maWx0ZXIoZmlsdGVyQnV0dG9uKS5maWx0ZXIoZmlsdGVySWdub3JlZClcbiAgICBsZXQgaW5wdXRzID0gZm9ybUVsZW1lbnRzLmZpbHRlcihmaWx0ZXJJbnB1dCkuZmlsdGVyKGZpbHRlcklnbm9yZWQpXG5cbiAgICBidXR0b25zLmZvckVhY2goYnV0dG9uID0+IHtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVELCBidXR0b24uZGlzYWJsZWQpXG4gICAgICBidXR0b24uZGlzYWJsZWQgPSB0cnVlXG4gICAgfSlcbiAgICBpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoUEhYX1JFQURPTkxZLCBpbnB1dC5yZWFkT25seSlcbiAgICAgIGlucHV0LnJlYWRPbmx5ID0gdHJ1ZVxuICAgICAgaWYoaW5wdXQuZmlsZXMpe1xuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVELCBpbnB1dC5kaXNhYmxlZClcbiAgICAgICAgaW5wdXQuZGlzYWJsZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfSlcbiAgICBsZXQgZm9ybUVscyA9IGRpc2FibGVzLmNvbmNhdChidXR0b25zKS5jb25jYXQoaW5wdXRzKS5tYXAoZWwgPT4ge1xuICAgICAgcmV0dXJuIHtlbCwgbG9hZGluZzogdHJ1ZSwgbG9jazogdHJ1ZX1cbiAgICB9KVxuXG4gICAgLy8gd2UgcmV2ZXJzZSB0aGUgb3JkZXIgc28gZm9ybSBjaGlsZHJlbiBhcmUgYWxyZWFkeSBsb2NrZWQgYnkgdGhlIHRpbWVcbiAgICAvLyB0aGUgZm9ybSBpcyBsb2NrZWRcbiAgICBsZXQgZWxzID0gW3tlbDogZm9ybUVsLCBsb2FkaW5nOiB0cnVlLCBsb2NrOiBmYWxzZX1dLmNvbmNhdChmb3JtRWxzKS5yZXZlcnNlKClcbiAgICByZXR1cm4gdGhpcy5wdXRSZWYoZWxzLCBwaHhFdmVudCwgXCJzdWJtaXRcIiwgb3B0cylcbiAgfVxuXG4gIHB1c2hGb3JtU3VibWl0KGZvcm1FbCwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgc3VibWl0dGVyLCBvcHRzLCBvblJlcGx5KXtcbiAgICBsZXQgcmVmR2VuZXJhdG9yID0gKCkgPT4gdGhpcy5kaXNhYmxlRm9ybShmb3JtRWwsIHBoeEV2ZW50LCB7XG4gICAgICAuLi5vcHRzLFxuICAgICAgZm9ybTogZm9ybUVsLFxuICAgICAgc3VibWl0dGVyOiBzdWJtaXR0ZXJcbiAgICB9KVxuICAgIGxldCBjaWQgPSB0aGlzLnRhcmdldENvbXBvbmVudElEKGZvcm1FbCwgdGFyZ2V0Q3R4KVxuICAgIGlmKExpdmVVcGxvYWRlci5oYXNVcGxvYWRzSW5Qcm9ncmVzcyhmb3JtRWwpKXtcbiAgICAgIGxldCBbcmVmLCBfZWxzXSA9IHJlZkdlbmVyYXRvcigpXG4gICAgICBsZXQgcHVzaCA9ICgpID0+IHRoaXMucHVzaEZvcm1TdWJtaXQoZm9ybUVsLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBzdWJtaXR0ZXIsIG9wdHMsIG9uUmVwbHkpXG4gICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZVN1Ym1pdChmb3JtRWwsIHJlZiwgb3B0cywgcHVzaClcbiAgICB9IGVsc2UgaWYoTGl2ZVVwbG9hZGVyLmlucHV0c0F3YWl0aW5nUHJlZmxpZ2h0KGZvcm1FbCkubGVuZ3RoID4gMCl7XG4gICAgICBsZXQgW3JlZiwgZWxzXSA9IHJlZkdlbmVyYXRvcigpXG4gICAgICBsZXQgcHJveHlSZWZHZW4gPSAoKSA9PiBbcmVmLCBlbHMsIG9wdHNdXG4gICAgICB0aGlzLnVwbG9hZEZpbGVzKGZvcm1FbCwgcGh4RXZlbnQsIHRhcmdldEN0eCwgcmVmLCBjaWQsIChfdXBsb2FkcykgPT4ge1xuICAgICAgICAvLyBpZiB3ZSBzdGlsbCBoYXZpbmcgcGVuZGluZyBwcmVmbGlnaHRzIGl0IG1lYW5zIHdlIGhhdmUgaW52YWxpZCBlbnRyaWVzXG4gICAgICAgIC8vIGFuZCB0aGUgcGh4LXN1Ym1pdCBjYW5ub3QgYmUgY29tcGxldGVkXG4gICAgICAgIGlmKExpdmVVcGxvYWRlci5pbnB1dHNBd2FpdGluZ1ByZWZsaWdodChmb3JtRWwpLmxlbmd0aCA+IDApe1xuICAgICAgICAgIHJldHVybiB0aGlzLnVuZG9SZWZzKHJlZiwgcGh4RXZlbnQpXG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGEgPSB0aGlzLmV4dHJhY3RNZXRhKGZvcm1FbClcbiAgICAgICAgbGV0IGZvcm1EYXRhID0gc2VyaWFsaXplRm9ybShmb3JtRWwsIHtzdWJtaXR0ZXIsIC4uLm1ldGF9KVxuICAgICAgICB0aGlzLnB1c2hXaXRoUmVwbHkocHJveHlSZWZHZW4sIFwiZXZlbnRcIiwge1xuICAgICAgICAgIHR5cGU6IFwiZm9ybVwiLFxuICAgICAgICAgIGV2ZW50OiBwaHhFdmVudCxcbiAgICAgICAgICB2YWx1ZTogZm9ybURhdGEsXG4gICAgICAgICAgY2lkOiBjaWRcbiAgICAgICAgfSkudGhlbigoe3Jlc3B9KSA9PiBvblJlcGx5KHJlc3ApKVxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYoIShmb3JtRWwuaGFzQXR0cmlidXRlKFBIWF9SRUZfU1JDKSAmJiBmb3JtRWwuY2xhc3NMaXN0LmNvbnRhaW5zKFwicGh4LXN1Ym1pdC1sb2FkaW5nXCIpKSl7XG4gICAgICBsZXQgbWV0YSA9IHRoaXMuZXh0cmFjdE1ldGEoZm9ybUVsKVxuICAgICAgbGV0IGZvcm1EYXRhID0gc2VyaWFsaXplRm9ybShmb3JtRWwsIHtzdWJtaXR0ZXIsIC4uLm1ldGF9KVxuICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KHJlZkdlbmVyYXRvciwgXCJldmVudFwiLCB7XG4gICAgICAgIHR5cGU6IFwiZm9ybVwiLFxuICAgICAgICBldmVudDogcGh4RXZlbnQsXG4gICAgICAgIHZhbHVlOiBmb3JtRGF0YSxcbiAgICAgICAgY2lkOiBjaWRcbiAgICAgIH0pLnRoZW4oKHtyZXNwfSkgPT4gb25SZXBseShyZXNwKSlcbiAgICB9XG4gIH1cblxuICB1cGxvYWRGaWxlcyhmb3JtRWwsIHBoeEV2ZW50LCB0YXJnZXRDdHgsIHJlZiwgY2lkLCBvbkNvbXBsZXRlKXtcbiAgICBsZXQgam9pbkNvdW50QXRVcGxvYWQgPSB0aGlzLmpvaW5Db3VudFxuICAgIGxldCBpbnB1dEVscyA9IExpdmVVcGxvYWRlci5hY3RpdmVGaWxlSW5wdXRzKGZvcm1FbClcbiAgICBsZXQgbnVtRmlsZUlucHV0c0luUHJvZ3Jlc3MgPSBpbnB1dEVscy5sZW5ndGhcblxuICAgIC8vIGdldCBlYWNoIGZpbGUgaW5wdXRcbiAgICBpbnB1dEVscy5mb3JFYWNoKGlucHV0RWwgPT4ge1xuICAgICAgbGV0IHVwbG9hZGVyID0gbmV3IExpdmVVcGxvYWRlcihpbnB1dEVsLCB0aGlzLCAoKSA9PiB7XG4gICAgICAgIG51bUZpbGVJbnB1dHNJblByb2dyZXNzLS1cbiAgICAgICAgaWYobnVtRmlsZUlucHV0c0luUHJvZ3Jlc3MgPT09IDApeyBvbkNvbXBsZXRlKCkgfVxuICAgICAgfSlcblxuICAgICAgbGV0IGVudHJpZXMgPSB1cGxvYWRlci5lbnRyaWVzKCkubWFwKGVudHJ5ID0+IGVudHJ5LnRvUHJlZmxpZ2h0UGF5bG9hZCgpKVxuXG4gICAgICBpZihlbnRyaWVzLmxlbmd0aCA9PT0gMCl7XG4gICAgICAgIG51bUZpbGVJbnB1dHNJblByb2dyZXNzLS1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGxldCBwYXlsb2FkID0ge1xuICAgICAgICByZWY6IGlucHV0RWwuZ2V0QXR0cmlidXRlKFBIWF9VUExPQURfUkVGKSxcbiAgICAgICAgZW50cmllczogZW50cmllcyxcbiAgICAgICAgY2lkOiB0aGlzLnRhcmdldENvbXBvbmVudElEKGlucHV0RWwuZm9ybSwgdGFyZ2V0Q3R4KVxuICAgICAgfVxuXG4gICAgICB0aGlzLmxvZyhcInVwbG9hZFwiLCAoKSA9PiBbXCJzZW5kaW5nIHByZWZsaWdodCByZXF1ZXN0XCIsIHBheWxvYWRdKVxuXG4gICAgICB0aGlzLnB1c2hXaXRoUmVwbHkobnVsbCwgXCJhbGxvd191cGxvYWRcIiwgcGF5bG9hZCkudGhlbigoe3Jlc3B9KSA9PiB7XG4gICAgICAgIHRoaXMubG9nKFwidXBsb2FkXCIsICgpID0+IFtcImdvdCBwcmVmbGlnaHQgcmVzcG9uc2VcIiwgcmVzcF0pXG4gICAgICAgIC8vIHRoZSBwcmVmbGlnaHQgd2lsbCByZWplY3QgZW50cmllcyBiZXlvbmQgdGhlIG1heCBlbnRyaWVzXG4gICAgICAgIC8vIHNvIHdlIGVycm9yIGFuZCBjYW5jZWwgZW50cmllcyBvbiB0aGUgY2xpZW50IHRoYXQgYXJlIG1pc3NpbmcgZnJvbSB0aGUgcmVzcG9uc2VcbiAgICAgICAgdXBsb2FkZXIuZW50cmllcygpLmZvckVhY2goZW50cnkgPT4ge1xuICAgICAgICAgIGlmKHJlc3AuZW50cmllcyAmJiAhcmVzcC5lbnRyaWVzW2VudHJ5LnJlZl0pe1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVGYWlsZWRFbnRyeVByZWZsaWdodChlbnRyeS5yZWYsIFwiZmFpbGVkIHByZWZsaWdodFwiLCB1cGxvYWRlcilcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC8vIGZvciBhdXRvIHVwbG9hZHMsIHdlIG1heSBoYXZlIGFuIGVtcHR5IGVudHJpZXMgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyXG4gICAgICAgIC8vIGZvciBmb3JtIHN1Ym1pdHMgdGhhdCBjb250YWluIGludmFsaWQgZW50cmllc1xuICAgICAgICBpZihyZXNwLmVycm9yIHx8IE9iamVjdC5rZXlzKHJlc3AuZW50cmllcykubGVuZ3RoID09PSAwKXtcbiAgICAgICAgICB0aGlzLnVuZG9SZWZzKHJlZiwgcGh4RXZlbnQpXG4gICAgICAgICAgbGV0IGVycm9ycyA9IHJlc3AuZXJyb3IgfHwgW11cbiAgICAgICAgICBlcnJvcnMubWFwKChbZW50cnlfcmVmLCByZWFzb25dKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUZhaWxlZEVudHJ5UHJlZmxpZ2h0KGVudHJ5X3JlZiwgcmVhc29uLCB1cGxvYWRlcilcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBvbkVycm9yID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWwub25FcnJvcigoKSA9PiB7XG4gICAgICAgICAgICAgIGlmKHRoaXMuam9pbkNvdW50ID09PSBqb2luQ291bnRBdFVwbG9hZCl7IGNhbGxiYWNrKCkgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBsb2FkZXIuaW5pdEFkYXB0ZXJVcGxvYWQocmVzcCwgb25FcnJvciwgdGhpcy5saXZlU29ja2V0KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBoYW5kbGVGYWlsZWRFbnRyeVByZWZsaWdodCh1cGxvYWRSZWYsIHJlYXNvbiwgdXBsb2FkZXIpe1xuICAgIGlmKHVwbG9hZGVyLmlzQXV0b1VwbG9hZCgpKXtcbiAgICAgIC8vIHVwbG9hZFJlZiBtYXkgYmUgdG9wIGxldmVsIHVwbG9hZCBjb25maWcgcmVmIG9yIGVudHJ5IHJlZlxuICAgICAgbGV0IGVudHJ5ID0gdXBsb2FkZXIuZW50cmllcygpLmZpbmQoZW50cnkgPT4gZW50cnkucmVmID09PSB1cGxvYWRSZWYudG9TdHJpbmcoKSlcbiAgICAgIGlmKGVudHJ5KXsgZW50cnkuY2FuY2VsKCkgfVxuICAgIH0gZWxzZSB7XG4gICAgICB1cGxvYWRlci5lbnRyaWVzKCkubWFwKGVudHJ5ID0+IGVudHJ5LmNhbmNlbCgpKVxuICAgIH1cbiAgICB0aGlzLmxvZyhcInVwbG9hZFwiLCAoKSA9PiBbYGVycm9yIGZvciBlbnRyeSAke3VwbG9hZFJlZn1gLCByZWFzb25dKVxuICB9XG5cbiAgZGlzcGF0Y2hVcGxvYWRzKHRhcmdldEN0eCwgbmFtZSwgZmlsZXNPckJsb2JzKXtcbiAgICBsZXQgdGFyZ2V0RWxlbWVudCA9IHRoaXMudGFyZ2V0Q3R4RWxlbWVudCh0YXJnZXRDdHgpIHx8IHRoaXMuZWxcbiAgICBsZXQgaW5wdXRzID0gRE9NLmZpbmRVcGxvYWRJbnB1dHModGFyZ2V0RWxlbWVudCkuZmlsdGVyKGVsID0+IGVsLm5hbWUgPT09IG5hbWUpXG4gICAgaWYoaW5wdXRzLmxlbmd0aCA9PT0gMCl7IGxvZ0Vycm9yKGBubyBsaXZlIGZpbGUgaW5wdXRzIGZvdW5kIG1hdGNoaW5nIHRoZSBuYW1lIFwiJHtuYW1lfVwiYCkgfVxuICAgIGVsc2UgaWYoaW5wdXRzLmxlbmd0aCA+IDEpeyBsb2dFcnJvcihgZHVwbGljYXRlIGxpdmUgZmlsZSBpbnB1dHMgZm91bmQgbWF0Y2hpbmcgdGhlIG5hbWUgXCIke25hbWV9XCJgKSB9XG4gICAgZWxzZSB7IERPTS5kaXNwYXRjaEV2ZW50KGlucHV0c1swXSwgUEhYX1RSQUNLX1VQTE9BRFMsIHtkZXRhaWw6IHtmaWxlczogZmlsZXNPckJsb2JzfX0pIH1cbiAgfVxuXG4gIHRhcmdldEN0eEVsZW1lbnQodGFyZ2V0Q3R4KXtcbiAgICBpZihpc0NpZCh0YXJnZXRDdHgpKXtcbiAgICAgIGxldCBbdGFyZ2V0XSA9IERPTS5maW5kQ29tcG9uZW50Tm9kZUxpc3QodGhpcy5lbCwgdGFyZ2V0Q3R4KVxuICAgICAgcmV0dXJuIHRhcmdldFxuICAgIH0gZWxzZSBpZih0YXJnZXRDdHgpe1xuICAgICAgcmV0dXJuIHRhcmdldEN0eFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHB1c2hGb3JtUmVjb3Zlcnkob2xkRm9ybSwgbmV3Rm9ybSwgdGVtcGxhdGVEb20sIGNhbGxiYWNrKXtcbiAgICAvLyB3ZSBhcmUgb25seSByZWNvdmVyaW5nIGZvcm1zIGluc2lkZSB0aGUgY3VycmVudCB2aWV3LCB0aGVyZWZvcmUgaXQgaXMgc2FmZSB0b1xuICAgIC8vIHNraXAgd2l0aGluT3duZXJzIGhlcmUgYW5kIGFsd2F5cyB1c2UgdGhpcyB3aGVuIHJlZmVycmluZyB0byB0aGUgdmlld1xuICAgIGNvbnN0IHBoeENoYW5nZSA9IHRoaXMuYmluZGluZyhcImNoYW5nZVwiKVxuICAgIGNvbnN0IHBoeFRhcmdldCA9IG5ld0Zvcm0uZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhcInRhcmdldFwiKSkgfHwgbmV3Rm9ybVxuICAgIGNvbnN0IHBoeEV2ZW50ID0gbmV3Rm9ybS5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9BVVRPX1JFQ09WRVIpKSB8fCBuZXdGb3JtLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJjaGFuZ2VcIikpXG4gICAgY29uc3QgaW5wdXRzID0gQXJyYXkuZnJvbShvbGRGb3JtLmVsZW1lbnRzKS5maWx0ZXIoZWwgPT4gRE9NLmlzRm9ybUlucHV0KGVsKSAmJiBlbC5uYW1lICYmICFlbC5oYXNBdHRyaWJ1dGUocGh4Q2hhbmdlKSlcbiAgICBpZihpbnB1dHMubGVuZ3RoID09PSAwKXsgcmV0dXJuIH1cblxuICAgIC8vIHdlIG11c3QgY2xlYXIgdHJhY2tlZCB1cGxvYWRzIGJlZm9yZSByZWNvdmVyeSBhcyB0aGV5IG5vIGxvbmdlciBoYXZlIHZhbGlkIHJlZnNcbiAgICBpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiBpbnB1dC5oYXNBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpICYmIExpdmVVcGxvYWRlci5jbGVhckZpbGVzKGlucHV0KSlcbiAgICAvLyBwdXNoSW5wdXQgYXNzdW1lcyB0aGF0IHRoZXJlIGlzIGEgc291cmNlIGVsZW1lbnQgdGhhdCBpbml0aWF0ZWQgdGhlIGNoYW5nZTtcbiAgICAvLyBiZWNhdXNlIHRoaXMgaXMgbm90IHRoZSBjYXNlIHdoZW4gd2UgcmVjb3ZlciBmb3Jtcywgd2UgcHJvdmlkZSB0aGUgZmlyc3QgaW5wdXQgd2UgZmluZFxuICAgIGxldCBpbnB1dCA9IGlucHV0cy5maW5kKGVsID0+IGVsLnR5cGUgIT09IFwiaGlkZGVuXCIpIHx8IGlucHV0c1swXVxuXG4gICAgLy8gaW4gdGhlIGNhc2UgdGhhdCB0aGVyZSBhcmUgbXVsdGlwbGUgdGFyZ2V0cywgd2UgY291bnQgdGhlIG51bWJlciBvZiBwZW5kaW5nIHJlY292ZXJ5IGV2ZW50c1xuICAgIC8vIGFuZCBvbmx5IGNhbGwgdGhlIGNhbGxiYWNrIG9uY2UgYWxsIGV2ZW50cyBoYXZlIGJlZW4gcHJvY2Vzc2VkXG4gICAgbGV0IHBlbmRpbmcgPSAwXG4gICAgLy8gd2l0aGluVGFyZ2V0cyhwaHhUYXJnZXQsIGNhbGxiYWNrLCBkb20sIHZpZXdFbClcbiAgICB0aGlzLndpdGhpblRhcmdldHMocGh4VGFyZ2V0LCAodGFyZ2V0VmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICBjb25zdCBjaWQgPSB0aGlzLnRhcmdldENvbXBvbmVudElEKG5ld0Zvcm0sIHRhcmdldEN0eClcbiAgICAgIHBlbmRpbmcrK1xuICAgICAgbGV0IGUgPSBuZXcgQ3VzdG9tRXZlbnQoXCJwaHg6Zm9ybS1yZWNvdmVyeVwiLCB7ZGV0YWlsOiB7c291cmNlRWxlbWVudDogb2xkRm9ybX19KVxuICAgICAgSlMuZXhlYyhlLCBcImNoYW5nZVwiLCBwaHhFdmVudCwgdGhpcywgaW5wdXQsIFtcInB1c2hcIiwge1xuICAgICAgICBfdGFyZ2V0OiBpbnB1dC5uYW1lLFxuICAgICAgICB0YXJnZXRWaWV3LFxuICAgICAgICB0YXJnZXRDdHgsXG4gICAgICAgIG5ld0NpZDogY2lkLFxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgIHBlbmRpbmctLVxuICAgICAgICAgIGlmKHBlbmRpbmcgPT09IDApeyBjYWxsYmFjaygpIH1cbiAgICAgICAgfVxuICAgICAgfV0pXG4gICAgfSwgdGVtcGxhdGVEb20sIHRlbXBsYXRlRG9tKVxuICB9XG5cbiAgcHVzaExpbmtQYXRjaChlLCBocmVmLCB0YXJnZXRFbCwgY2FsbGJhY2spe1xuICAgIGxldCBsaW5rUmVmID0gdGhpcy5saXZlU29ja2V0LnNldFBlbmRpbmdMaW5rKGhyZWYpXG4gICAgLy8gb25seSBhZGQgbG9hZGluZyBzdGF0ZXMgaWYgZXZlbnQgaXMgdHJ1c3RlZCAoaXQgd2FzIHRyaWdnZXJlZCBieSB1c2VyLCBzdWNoIGFzIGNsaWNrKSBhbmRcbiAgICAvLyBpdCdzIG5vdCBhIGZvcndhcmQvYmFjayBuYXZpZ2F0aW9uIGZyb20gcG9wc3RhdGVcbiAgICBsZXQgbG9hZGluZyA9IGUuaXNUcnVzdGVkICYmIGUudHlwZSAhPT0gXCJwb3BzdGF0ZVwiXG4gICAgbGV0IHJlZkdlbiA9IHRhcmdldEVsID8gKCkgPT4gdGhpcy5wdXRSZWYoW3tlbDogdGFyZ2V0RWwsIGxvYWRpbmc6IGxvYWRpbmcsIGxvY2s6IHRydWV9XSwgbnVsbCwgXCJjbGlja1wiKSA6IG51bGxcbiAgICBsZXQgZmFsbGJhY2sgPSAoKSA9PiB0aGlzLmxpdmVTb2NrZXQucmVkaXJlY3Qod2luZG93LmxvY2F0aW9uLmhyZWYpXG4gICAgbGV0IHVybCA9IGhyZWYuc3RhcnRzV2l0aChcIi9cIikgPyBgJHtsb2NhdGlvbi5wcm90b2NvbH0vLyR7bG9jYXRpb24uaG9zdH0ke2hyZWZ9YCA6IGhyZWZcblxuICAgIHRoaXMucHVzaFdpdGhSZXBseShyZWZHZW4sIFwibGl2ZV9wYXRjaFwiLCB7dXJsfSkudGhlbihcbiAgICAgICh7cmVzcH0pID0+IHtcbiAgICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICAgIGlmKHJlc3AubGlua19yZWRpcmVjdCl7XG4gICAgICAgICAgICB0aGlzLmxpdmVTb2NrZXQucmVwbGFjZU1haW4oaHJlZiwgbnVsbCwgY2FsbGJhY2ssIGxpbmtSZWYpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKHRoaXMubGl2ZVNvY2tldC5jb21taXRQZW5kaW5nTGluayhsaW5rUmVmKSl7XG4gICAgICAgICAgICAgIHRoaXMuaHJlZiA9IGhyZWZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXBwbHlQZW5kaW5nVXBkYXRlcygpXG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhsaW5rUmVmKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICAoe2Vycm9yOiBfZXJyb3IsIHRpbWVvdXQ6IF90aW1lb3V0fSkgPT4gZmFsbGJhY2soKVxuICAgIClcbiAgfVxuXG4gIGdldEZvcm1zRm9yUmVjb3ZlcnkoKXtcbiAgICBpZih0aGlzLmpvaW5Db3VudCA9PT0gMCl7IHJldHVybiB7fSB9XG5cbiAgICBsZXQgcGh4Q2hhbmdlID0gdGhpcy5iaW5kaW5nKFwiY2hhbmdlXCIpXG5cbiAgICByZXR1cm4gRE9NLmFsbCh0aGlzLmVsLCBgZm9ybVske3BoeENoYW5nZX1dYClcbiAgICAgIC5maWx0ZXIoZm9ybSA9PiBmb3JtLmlkKVxuICAgICAgLmZpbHRlcihmb3JtID0+IGZvcm0uZWxlbWVudHMubGVuZ3RoID4gMClcbiAgICAgIC5maWx0ZXIoZm9ybSA9PiBmb3JtLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0FVVE9fUkVDT1ZFUikpICE9PSBcImlnbm9yZVwiKVxuICAgICAgLm1hcChmb3JtID0+IGZvcm0uY2xvbmVOb2RlKHRydWUpKVxuICAgICAgLnJlZHVjZSgoYWNjLCBmb3JtKSA9PiB7XG4gICAgICAgIGFjY1tmb3JtLmlkXSA9IGZvcm1cbiAgICAgICAgcmV0dXJuIGFjY1xuICAgICAgfSwge30pXG4gIH1cblxuICBtYXliZVB1c2hDb21wb25lbnRzRGVzdHJveWVkKGRlc3Ryb3llZENJRHMpe1xuICAgIGxldCB3aWxsRGVzdHJveUNJRHMgPSBkZXN0cm95ZWRDSURzLmZpbHRlcihjaWQgPT4ge1xuICAgICAgcmV0dXJuIERPTS5maW5kQ29tcG9uZW50Tm9kZUxpc3QodGhpcy5lbCwgY2lkKS5sZW5ndGggPT09IDBcbiAgICB9KVxuXG4gICAgaWYod2lsbERlc3Ryb3lDSURzLmxlbmd0aCA+IDApe1xuICAgICAgLy8gd2UgbXVzdCByZXNldCB0aGUgcmVuZGVyIGNoYW5nZSB0cmFja2luZyBmb3IgY2lkcyB0aGF0XG4gICAgICAvLyBjb3VsZCBiZSBhZGRlZCBiYWNrIGZyb20gdGhlIHNlcnZlciBzbyB3ZSBkb24ndCBza2lwIHRoZW1cbiAgICAgIHdpbGxEZXN0cm95Q0lEcy5mb3JFYWNoKGNpZCA9PiB0aGlzLnJlbmRlcmVkLnJlc2V0UmVuZGVyKGNpZCkpXG5cbiAgICAgIHRoaXMucHVzaFdpdGhSZXBseShudWxsLCBcImNpZHNfd2lsbF9kZXN0cm95XCIsIHtjaWRzOiB3aWxsRGVzdHJveUNJRHN9KS50aGVuKCgpID0+IHtcbiAgICAgICAgLy8gd2UgbXVzdCB3YWl0IGZvciBwZW5kaW5nIHRyYW5zaXRpb25zIHRvIGNvbXBsZXRlIGJlZm9yZSBkZXRlcm1pbmluZ1xuICAgICAgICAvLyBpZiB0aGUgY2lkcyB3ZXJlIGFkZGVkIGJhY2sgdG8gdGhlIERPTSBpbiB0aGUgbWVhbnRpbWUgKCMzMTM5KVxuICAgICAgICB0aGlzLmxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgLy8gU2VlIGlmIGFueSBvZiB0aGUgY2lkcyB3ZSB3YW50ZWQgdG8gZGVzdHJveSB3ZXJlIGFkZGVkIGJhY2ssXG4gICAgICAgICAgLy8gaWYgdGhleSB3ZXJlIGFkZGVkIGJhY2ssIHdlIGRvbid0IGFjdHVhbGx5IGRlc3Ryb3kgdGhlbS5cbiAgICAgICAgICBsZXQgY29tcGxldGVseURlc3Ryb3lDSURzID0gd2lsbERlc3Ryb3lDSURzLmZpbHRlcihjaWQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIERPTS5maW5kQ29tcG9uZW50Tm9kZUxpc3QodGhpcy5lbCwgY2lkKS5sZW5ndGggPT09IDBcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgaWYoY29tcGxldGVseURlc3Ryb3lDSURzLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KG51bGwsIFwiY2lkc19kZXN0cm95ZWRcIiwge2NpZHM6IGNvbXBsZXRlbHlEZXN0cm95Q0lEc30pLnRoZW4oKHtyZXNwfSkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVkLnBydW5lQ0lEcyhyZXNwLmNpZHMpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgb3duc0VsZW1lbnQoZWwpe1xuICAgIGxldCBwYXJlbnRWaWV3RWwgPSBlbC5jbG9zZXN0KFBIWF9WSUVXX1NFTEVDVE9SKVxuICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoUEhYX1BBUkVOVF9JRCkgPT09IHRoaXMuaWQgfHxcbiAgICAgIChwYXJlbnRWaWV3RWwgJiYgcGFyZW50Vmlld0VsLmlkID09PSB0aGlzLmlkKSB8fFxuICAgICAgKCFwYXJlbnRWaWV3RWwgJiYgdGhpcy5pc0RlYWQpXG4gIH1cblxuICBzdWJtaXRGb3JtKGZvcm0sIHRhcmdldEN0eCwgcGh4RXZlbnQsIHN1Ym1pdHRlciwgb3B0cyA9IHt9KXtcbiAgICBET00ucHV0UHJpdmF0ZShmb3JtLCBQSFhfSEFTX1NVQk1JVFRFRCwgdHJ1ZSlcbiAgICBjb25zdCBpbnB1dHMgPSBBcnJheS5mcm9tKGZvcm0uZWxlbWVudHMpXG4gICAgaW5wdXRzLmZvckVhY2goaW5wdXQgPT4gRE9NLnB1dFByaXZhdGUoaW5wdXQsIFBIWF9IQVNfU1VCTUlUVEVELCB0cnVlKSlcbiAgICB0aGlzLmxpdmVTb2NrZXQuYmx1ckFjdGl2ZUVsZW1lbnQodGhpcylcbiAgICB0aGlzLnB1c2hGb3JtU3VibWl0KGZvcm0sIHRhcmdldEN0eCwgcGh4RXZlbnQsIHN1Ym1pdHRlciwgb3B0cywgKCkgPT4ge1xuICAgICAgdGhpcy5saXZlU29ja2V0LnJlc3RvcmVQcmV2aW91c2x5QWN0aXZlRm9jdXMoKVxuICAgIH0pXG4gIH1cblxuICBiaW5kaW5nKGtpbmQpeyByZXR1cm4gdGhpcy5saXZlU29ja2V0LmJpbmRpbmcoa2luZCkgfVxufVxuIiwgIi8qKiBJbml0aWFsaXplcyB0aGUgTGl2ZVNvY2tldFxuICpcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5kUG9pbnQgLSBUaGUgc3RyaW5nIFdlYlNvY2tldCBlbmRwb2ludCwgaWUsIGBcIndzczovL2V4YW1wbGUuY29tL2xpdmVcImAsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFwiL2xpdmVcImAgKGluaGVyaXRlZCBob3N0ICYgcHJvdG9jb2wpXG4gKiBAcGFyYW0ge1Bob2VuaXguU29ja2V0fSBzb2NrZXQgLSB0aGUgcmVxdWlyZWQgUGhvZW5peCBTb2NrZXQgY2xhc3MgaW1wb3J0ZWQgZnJvbSBcInBob2VuaXhcIi4gRm9yIGV4YW1wbGU6XG4gKlxuICogICAgIGltcG9ydCB7U29ja2V0fSBmcm9tIFwicGhvZW5peFwiXG4gKiAgICAgaW1wb3J0IHtMaXZlU29ja2V0fSBmcm9tIFwicGhvZW5peF9saXZlX3ZpZXdcIlxuICogICAgIGxldCBsaXZlU29ja2V0ID0gbmV3IExpdmVTb2NrZXQoXCIvbGl2ZVwiLCBTb2NrZXQsIHsuLi59KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBPcHRpb25hbCBjb25maWd1cmF0aW9uLiBPdXRzaWRlIG9mIGtleXMgbGlzdGVkIGJlbG93LCBhbGxcbiAqIGNvbmZpZ3VyYXRpb24gaXMgcGFzc2VkIGRpcmVjdGx5IHRvIHRoZSBQaG9lbml4IFNvY2tldCBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5kZWZhdWx0c10gLSBUaGUgb3B0aW9uYWwgZGVmYXVsdHMgdG8gdXNlIGZvciB2YXJpb3VzIGJpbmRpbmdzLFxuICogc3VjaCBhcyBgcGh4LWRlYm91bmNlYC4gU3VwcG9ydHMgdGhlIGZvbGxvd2luZyBrZXlzOlxuICpcbiAqICAgLSBkZWJvdW5jZSAtIHRoZSBtaWxsaXNlY29uZCBwaHgtZGVib3VuY2UgdGltZS4gRGVmYXVsdHMgMzAwXG4gKiAgIC0gdGhyb3R0bGUgLSB0aGUgbWlsbGlzZWNvbmQgcGh4LXRocm90dGxlIHRpbWUuIERlZmF1bHRzIDMwMFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLnBhcmFtc10gLSBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gZm9yIHBhc3NpbmcgY29ubmVjdCBwYXJhbXMuXG4gKiBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gTGl2ZVZpZXcuIEZvciBleGFtcGxlOlxuICpcbiAqICAgICAoZWwpID0+IHt2aWV3OiBlbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW15LXZpZXctbmFtZVwiLCB0b2tlbjogd2luZG93Lm15VG9rZW59XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJpbmRpbmdQcmVmaXhdIC0gVGhlIG9wdGlvbmFsIHByZWZpeCB0byB1c2UgZm9yIGFsbCBwaHggRE9NIGFubm90YXRpb25zLlxuICogRGVmYXVsdHMgdG8gXCJwaHgtXCIuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHMuaG9va3NdIC0gVGhlIG9wdGlvbmFsIG9iamVjdCBmb3IgcmVmZXJlbmNpbmcgTGl2ZVZpZXcgaG9vayBjYWxsYmFja3MuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHMudXBsb2FkZXJzXSAtIFRoZSBvcHRpb25hbCBvYmplY3QgZm9yIHJlZmVyZW5jaW5nIExpdmVWaWV3IHVwbG9hZGVyIGNhbGxiYWNrcy5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdHMubG9hZGVyVGltZW91dF0gLSBUaGUgb3B0aW9uYWwgZGVsYXkgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIGFwcGx5XG4gKiBsb2FkaW5nIHN0YXRlcy5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdHMubWF4UmVsb2Fkc10gLSBUaGUgbWF4aW11bSByZWxvYWRzIGJlZm9yZSBlbnRlcmluZyBmYWlsc2FmZSBtb2RlLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0cy5yZWxvYWRKaXR0ZXJNaW5dIC0gVGhlIG1pbmltdW0gdGltZSBiZXR3ZWVuIG5vcm1hbCByZWxvYWQgYXR0ZW1wdHMuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRzLnJlbG9hZEppdHRlck1heF0gLSBUaGUgbWF4aW11bSB0aW1lIGJldHdlZW4gbm9ybWFsIHJlbG9hZCBhdHRlbXB0cy5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdHMuZmFpbHNhZmVKaXR0ZXJdIC0gVGhlIHRpbWUgYmV0d2VlbiByZWxvYWQgYXR0ZW1wdHMgaW4gZmFpbHNhZmUgbW9kZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLnZpZXdMb2dnZXJdIC0gVGhlIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGxvZyBkZWJ1ZyBpbmZvcm1hdGlvbi4gRm9yIGV4YW1wbGU6XG4gKlxuICogICAgICh2aWV3LCBraW5kLCBtc2csIG9iaikgPT4gY29uc29sZS5sb2coYCR7dmlldy5pZH0gJHtraW5kfTogJHttc2d9IC0gYCwgb2JqKVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5tZXRhZGF0YV0gLSBUaGUgb3B0aW9uYWwgb2JqZWN0IG1hcHBpbmcgZXZlbnQgbmFtZXMgdG8gZnVuY3Rpb25zIGZvclxuICogcG9wdWxhdGluZyBldmVudCBtZXRhZGF0YS4gRm9yIGV4YW1wbGU6XG4gKlxuICogICAgIG1ldGFkYXRhOiB7XG4gKiAgICAgICBjbGljazogKGUsIGVsKSA9PiB7XG4gKiAgICAgICAgIHJldHVybiB7XG4gKiAgICAgICAgICAgY3RybEtleTogZS5jdHJsS2V5LFxuICogICAgICAgICAgIG1ldGFLZXk6IGUubWV0YUtleSxcbiAqICAgICAgICAgICBkZXRhaWw6IGUuZGV0YWlsIHx8IDEsXG4gKiAgICAgICAgIH1cbiAqICAgICAgIH0sXG4gKiAgICAgICBrZXlkb3duOiAoZSwgZWwpID0+IHtcbiAqICAgICAgICAgcmV0dXJuIHtcbiAqICAgICAgICAgICBrZXk6IGUua2V5LFxuICogICAgICAgICAgIGN0cmxLZXk6IGUuY3RybEtleSxcbiAqICAgICAgICAgICBtZXRhS2V5OiBlLm1ldGFLZXksXG4gKiAgICAgICAgICAgc2hpZnRLZXk6IGUuc2hpZnRLZXlcbiAqICAgICAgICAgfVxuICogICAgICAgfVxuICogICAgIH1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5zZXNzaW9uU3RvcmFnZV0gLSBBbiBvcHRpb25hbCBTdG9yYWdlIGNvbXBhdGlibGUgb2JqZWN0XG4gKiBVc2VmdWwgd2hlbiBMaXZlVmlldyB3b24ndCBoYXZlIGFjY2VzcyB0byBgc2Vzc2lvblN0b3JhZ2VgLiAgRm9yIGV4YW1wbGUsIFRoaXMgY291bGRcbiAqIGhhcHBlbiBpZiBhIHNpdGUgbG9hZHMgYSBjcm9zcy1kb21haW4gTGl2ZVZpZXcgaW4gYW4gaWZyYW1lLiAgRXhhbXBsZSB1c2FnZTpcbiAqXG4gKiAgICAgY2xhc3MgSW5NZW1vcnlTdG9yYWdlIHtcbiAqICAgICAgIGNvbnN0cnVjdG9yKCkgeyB0aGlzLnN0b3JhZ2UgPSB7fSB9XG4gKiAgICAgICBnZXRJdGVtKGtleU5hbWUpIHsgcmV0dXJuIHRoaXMuc3RvcmFnZVtrZXlOYW1lXSB8fCBudWxsIH1cbiAqICAgICAgIHJlbW92ZUl0ZW0oa2V5TmFtZSkgeyBkZWxldGUgdGhpcy5zdG9yYWdlW2tleU5hbWVdIH1cbiAqICAgICAgIHNldEl0ZW0oa2V5TmFtZSwga2V5VmFsdWUpIHsgdGhpcy5zdG9yYWdlW2tleU5hbWVdID0ga2V5VmFsdWUgfVxuICogICAgIH1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHMubG9jYWxTdG9yYWdlXSAtIEFuIG9wdGlvbmFsIFN0b3JhZ2UgY29tcGF0aWJsZSBvYmplY3RcbiAqIFVzZWZ1bCBmb3Igd2hlbiBMaXZlVmlldyB3b24ndCBoYXZlIGFjY2VzcyB0byBgbG9jYWxTdG9yYWdlYC5cbiAqIFNlZSBgb3B0cy5zZXNzaW9uU3RvcmFnZWAgZm9yIGV4YW1wbGVzLlxuKi9cblxuaW1wb3J0IHtcbiAgQklORElOR19QUkVGSVgsXG4gIENPTlNFQ1VUSVZFX1JFTE9BRFMsXG4gIERFRkFVTFRTLFxuICBGQUlMU0FGRV9KSVRURVIsXG4gIExPQURFUl9USU1FT1VULFxuICBNQVhfUkVMT0FEUyxcbiAgUEhYX0RFQk9VTkNFLFxuICBQSFhfRFJPUF9UQVJHRVQsXG4gIFBIWF9IQVNfRk9DVVNFRCxcbiAgUEhYX0tFWSxcbiAgUEhYX0xJTktfU1RBVEUsXG4gIFBIWF9MSVZFX0xJTkssXG4gIFBIWF9MVl9ERUJVRyxcbiAgUEhYX0xWX0xBVEVOQ1lfU0lNLFxuICBQSFhfTFZfUFJPRklMRSxcbiAgUEhYX0xWX0hJU1RPUllfUE9TSVRJT04sXG4gIFBIWF9NQUlOLFxuICBQSFhfUEFSRU5UX0lELFxuICBQSFhfVklFV19TRUxFQ1RPUixcbiAgUEhYX1JPT1RfSUQsXG4gIFBIWF9USFJPVFRMRSxcbiAgUEhYX1RSQUNLX1VQTE9BRFMsXG4gIFBIWF9TRVNTSU9OLFxuICBSRUxPQURfSklUVEVSX01JTixcbiAgUkVMT0FEX0pJVFRFUl9NQVgsXG4gIFBIWF9SRUZfU1JDLFxuICBQSFhfUkVMT0FEX1NUQVRVU1xufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xuICBjbG9uZSxcbiAgY2xvc2VzdFBoeEJpbmRpbmcsXG4gIGNsb3N1cmUsXG4gIGRlYnVnLFxuICBtYXliZVxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmltcG9ydCBCcm93c2VyIGZyb20gXCIuL2Jyb3dzZXJcIlxuaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIlxuaW1wb3J0IEhvb2tzIGZyb20gXCIuL2hvb2tzXCJcbmltcG9ydCBMaXZlVXBsb2FkZXIgZnJvbSBcIi4vbGl2ZV91cGxvYWRlclwiXG5pbXBvcnQgVmlldyBmcm9tIFwiLi92aWV3XCJcbmltcG9ydCBKUyBmcm9tIFwiLi9qc1wiXG5cbmV4cG9ydCBsZXQgaXNVc2VkSW5wdXQgPSAoZWwpID0+IERPTS5pc1VzZWRJbnB1dChlbClcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGl2ZVNvY2tldCB7XG4gIGNvbnN0cnVjdG9yKHVybCwgcGh4U29ja2V0LCBvcHRzID0ge30pe1xuICAgIHRoaXMudW5sb2FkZWQgPSBmYWxzZVxuICAgIGlmKCFwaHhTb2NrZXQgfHwgcGh4U29ja2V0LmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiT2JqZWN0XCIpe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBcbiAgICAgIGEgcGhvZW5peCBTb2NrZXQgbXVzdCBiZSBwcm92aWRlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIHRoZSBMaXZlU29ja2V0IGNvbnN0cnVjdG9yLiBGb3IgZXhhbXBsZTpcblxuICAgICAgICAgIGltcG9ydCB7U29ja2V0fSBmcm9tIFwicGhvZW5peFwiXG4gICAgICAgICAgaW1wb3J0IHtMaXZlU29ja2V0fSBmcm9tIFwicGhvZW5peF9saXZlX3ZpZXdcIlxuICAgICAgICAgIGxldCBsaXZlU29ja2V0ID0gbmV3IExpdmVTb2NrZXQoXCIvbGl2ZVwiLCBTb2NrZXQsIHsuLi59KVxuICAgICAgYClcbiAgICB9XG4gICAgdGhpcy5zb2NrZXQgPSBuZXcgcGh4U29ja2V0KHVybCwgb3B0cylcbiAgICB0aGlzLmJpbmRpbmdQcmVmaXggPSBvcHRzLmJpbmRpbmdQcmVmaXggfHwgQklORElOR19QUkVGSVhcbiAgICB0aGlzLm9wdHMgPSBvcHRzXG4gICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKG9wdHMucGFyYW1zIHx8IHt9KVxuICAgIHRoaXMudmlld0xvZ2dlciA9IG9wdHMudmlld0xvZ2dlclxuICAgIHRoaXMubWV0YWRhdGFDYWxsYmFja3MgPSBvcHRzLm1ldGFkYXRhIHx8IHt9XG4gICAgdGhpcy5kZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oY2xvbmUoREVGQVVMVFMpLCBvcHRzLmRlZmF1bHRzIHx8IHt9KVxuICAgIHRoaXMuYWN0aXZlRWxlbWVudCA9IG51bGxcbiAgICB0aGlzLnByZXZBY3RpdmUgPSBudWxsXG4gICAgdGhpcy5zaWxlbmNlZCA9IGZhbHNlXG4gICAgdGhpcy5tYWluID0gbnVsbFxuICAgIHRoaXMub3V0Z29pbmdNYWluRWwgPSBudWxsXG4gICAgdGhpcy5jbGlja1N0YXJ0ZWRBdFRhcmdldCA9IG51bGxcbiAgICB0aGlzLmxpbmtSZWYgPSAxXG4gICAgdGhpcy5yb290cyA9IHt9XG4gICAgdGhpcy5ocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWZcbiAgICB0aGlzLnBlbmRpbmdMaW5rID0gbnVsbFxuICAgIHRoaXMuY3VycmVudExvY2F0aW9uID0gY2xvbmUod2luZG93LmxvY2F0aW9uKVxuICAgIHRoaXMuaG9va3MgPSBvcHRzLmhvb2tzIHx8IHt9XG4gICAgdGhpcy51cGxvYWRlcnMgPSBvcHRzLnVwbG9hZGVycyB8fCB7fVxuICAgIHRoaXMubG9hZGVyVGltZW91dCA9IG9wdHMubG9hZGVyVGltZW91dCB8fCBMT0FERVJfVElNRU9VVFxuICAgIHRoaXMucmVsb2FkV2l0aEppdHRlclRpbWVyID0gbnVsbFxuICAgIHRoaXMubWF4UmVsb2FkcyA9IG9wdHMubWF4UmVsb2FkcyB8fCBNQVhfUkVMT0FEU1xuICAgIHRoaXMucmVsb2FkSml0dGVyTWluID0gb3B0cy5yZWxvYWRKaXR0ZXJNaW4gfHwgUkVMT0FEX0pJVFRFUl9NSU5cbiAgICB0aGlzLnJlbG9hZEppdHRlck1heCA9IG9wdHMucmVsb2FkSml0dGVyTWF4IHx8IFJFTE9BRF9KSVRURVJfTUFYXG4gICAgdGhpcy5mYWlsc2FmZUppdHRlciA9IG9wdHMuZmFpbHNhZmVKaXR0ZXIgfHwgRkFJTFNBRkVfSklUVEVSXG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UgPSBvcHRzLmxvY2FsU3RvcmFnZSB8fCB3aW5kb3cubG9jYWxTdG9yYWdlXG4gICAgdGhpcy5zZXNzaW9uU3RvcmFnZSA9IG9wdHMuc2Vzc2lvblN0b3JhZ2UgfHwgd2luZG93LnNlc3Npb25TdG9yYWdlXG4gICAgdGhpcy5ib3VuZFRvcExldmVsRXZlbnRzID0gZmFsc2VcbiAgICB0aGlzLmJvdW5kRXZlbnROYW1lcyA9IG5ldyBTZXQoKVxuICAgIHRoaXMuc2VydmVyQ2xvc2VSZWYgPSBudWxsXG4gICAgdGhpcy5kb21DYWxsYmFja3MgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGpzUXVlcnlTZWxlY3RvckFsbDogbnVsbCxcbiAgICAgIG9uUGF0Y2hTdGFydDogY2xvc3VyZSgpLFxuICAgICAgb25QYXRjaEVuZDogY2xvc3VyZSgpLFxuICAgICAgb25Ob2RlQWRkZWQ6IGNsb3N1cmUoKSxcbiAgICAgIG9uQmVmb3JlRWxVcGRhdGVkOiBjbG9zdXJlKCl9LFxuICAgIG9wdHMuZG9tIHx8IHt9KVxuICAgIHRoaXMudHJhbnNpdGlvbnMgPSBuZXcgVHJhbnNpdGlvblNldCgpXG4gICAgdGhpcy5jdXJyZW50SGlzdG9yeVBvc2l0aW9uID0gcGFyc2VJbnQodGhpcy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFBIWF9MVl9ISVNUT1JZX1BPU0lUSU9OKSkgfHwgMFxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgX2UgPT4ge1xuICAgICAgdGhpcy51bmxvYWRlZCA9IHRydWVcbiAgICB9KVxuICAgIHRoaXMuc29ja2V0Lm9uT3BlbigoKSA9PiB7XG4gICAgICBpZih0aGlzLmlzVW5sb2FkZWQoKSl7XG4gICAgICAgIC8vIHJlbG9hZCBwYWdlIGlmIGJlaW5nIHJlc3RvcmVkIGZyb20gYmFjay9mb3J3YXJkIGNhY2hlIGFuZCBicm93c2VyIGRvZXMgbm90IGVtaXQgXCJwYWdlc2hvd1wiXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvLyBwdWJsaWNcblxuICB2ZXJzaW9uKCl7IHJldHVybiBMVl9WU04gfVxuXG4gIGlzUHJvZmlsZUVuYWJsZWQoKXsgcmV0dXJuIHRoaXMuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShQSFhfTFZfUFJPRklMRSkgPT09IFwidHJ1ZVwiIH1cblxuICBpc0RlYnVnRW5hYmxlZCgpeyByZXR1cm4gdGhpcy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFBIWF9MVl9ERUJVRykgPT09IFwidHJ1ZVwiIH1cblxuICBpc0RlYnVnRGlzYWJsZWQoKXsgcmV0dXJuIHRoaXMuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShQSFhfTFZfREVCVUcpID09PSBcImZhbHNlXCIgfVxuXG4gIGVuYWJsZURlYnVnKCl7IHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfREVCVUcsIFwidHJ1ZVwiKSB9XG5cbiAgZW5hYmxlUHJvZmlsaW5nKCl7IHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfUFJPRklMRSwgXCJ0cnVlXCIpIH1cblxuICBkaXNhYmxlRGVidWcoKXsgdGhpcy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFBIWF9MVl9ERUJVRywgXCJmYWxzZVwiKSB9XG5cbiAgZGlzYWJsZVByb2ZpbGluZygpeyB0aGlzLnNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oUEhYX0xWX1BST0ZJTEUpIH1cblxuICBlbmFibGVMYXRlbmN5U2ltKHVwcGVyQm91bmRNcyl7XG4gICAgdGhpcy5lbmFibGVEZWJ1ZygpXG4gICAgY29uc29sZS5sb2coXCJsYXRlbmN5IHNpbXVsYXRvciBlbmFibGVkIGZvciB0aGUgZHVyYXRpb24gb2YgdGhpcyBicm93c2VyIHNlc3Npb24uIENhbGwgZGlzYWJsZUxhdGVuY3lTaW0oKSB0byBkaXNhYmxlXCIpXG4gICAgdGhpcy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFBIWF9MVl9MQVRFTkNZX1NJTSwgdXBwZXJCb3VuZE1zKVxuICB9XG5cbiAgZGlzYWJsZUxhdGVuY3lTaW0oKXsgdGhpcy5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKFBIWF9MVl9MQVRFTkNZX1NJTSkgfVxuXG4gIGdldExhdGVuY3lTaW0oKXtcbiAgICBsZXQgc3RyID0gdGhpcy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFBIWF9MVl9MQVRFTkNZX1NJTSlcbiAgICByZXR1cm4gc3RyID8gcGFyc2VJbnQoc3RyKSA6IG51bGxcbiAgfVxuXG4gIGdldFNvY2tldCgpeyByZXR1cm4gdGhpcy5zb2NrZXQgfVxuXG4gIGNvbm5lY3QoKXtcbiAgICAvLyBlbmFibGUgZGVidWcgYnkgZGVmYXVsdCBpZiBvbiBsb2NhbGhvc3QgYW5kIG5vdCBleHBsaWNpdGx5IGRpc2FibGVkXG4gICAgaWYod2luZG93LmxvY2F0aW9uLmhvc3RuYW1lID09PSBcImxvY2FsaG9zdFwiICYmICF0aGlzLmlzRGVidWdEaXNhYmxlZCgpKXsgdGhpcy5lbmFibGVEZWJ1ZygpIH1cbiAgICBsZXQgZG9Db25uZWN0ID0gKCkgPT4ge1xuICAgICAgdGhpcy5yZXNldFJlbG9hZFN0YXR1cygpXG4gICAgICBpZih0aGlzLmpvaW5Sb290Vmlld3MoKSl7XG4gICAgICAgIHRoaXMuYmluZFRvcExldmVsRXZlbnRzKClcbiAgICAgICAgdGhpcy5zb2NrZXQuY29ubmVjdCgpXG4gICAgICB9IGVsc2UgaWYodGhpcy5tYWluKXtcbiAgICAgICAgdGhpcy5zb2NrZXQuY29ubmVjdCgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJpbmRUb3BMZXZlbEV2ZW50cyh7ZGVhZDogdHJ1ZX0pXG4gICAgICB9XG4gICAgICB0aGlzLmpvaW5EZWFkVmlldygpXG4gICAgfVxuICAgIGlmKFtcImNvbXBsZXRlXCIsIFwibG9hZGVkXCIsIFwiaW50ZXJhY3RpdmVcIl0uaW5kZXhPZihkb2N1bWVudC5yZWFkeVN0YXRlKSA+PSAwKXtcbiAgICAgIGRvQ29ubmVjdCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsICgpID0+IGRvQ29ubmVjdCgpKVxuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3QoY2FsbGJhY2spe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnJlbG9hZFdpdGhKaXR0ZXJUaW1lcilcbiAgICAvLyByZW1vdmUgdGhlIHNvY2tldCBjbG9zZSBsaXN0ZW5lciB0byBhdm9pZCB0cnlpbmcgdG8gaGFuZGxlXG4gICAgLy8gYSBzZXJ2ZXIgY2xvc2UgZXZlbnQgd2hlbiBpdCBpcyBhY3R1YWxseSBjYXVzZWQgYnkgdXMgZGlzY29ubmVjdGluZ1xuICAgIGlmKHRoaXMuc2VydmVyQ2xvc2VSZWYpe1xuICAgICAgdGhpcy5zb2NrZXQub2ZmKHRoaXMuc2VydmVyQ2xvc2VSZWYpXG4gICAgICB0aGlzLnNlcnZlckNsb3NlUmVmID0gbnVsbFxuICAgIH1cbiAgICB0aGlzLnNvY2tldC5kaXNjb25uZWN0KGNhbGxiYWNrKVxuICB9XG5cbiAgcmVwbGFjZVRyYW5zcG9ydCh0cmFuc3BvcnQpe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnJlbG9hZFdpdGhKaXR0ZXJUaW1lcilcbiAgICB0aGlzLnNvY2tldC5yZXBsYWNlVHJhbnNwb3J0KHRyYW5zcG9ydClcbiAgICB0aGlzLmNvbm5lY3QoKVxuICB9XG5cbiAgZXhlY0pTKGVsLCBlbmNvZGVkSlMsIGV2ZW50VHlwZSA9IG51bGwpe1xuICAgIGxldCBlID0gbmV3IEN1c3RvbUV2ZW50KFwicGh4OmV4ZWNcIiwge2RldGFpbDoge3NvdXJjZUVsZW1lbnQ6IGVsfX0pXG4gICAgdGhpcy5vd25lcihlbCwgdmlldyA9PiBKUy5leGVjKGUsIGV2ZW50VHlwZSwgZW5jb2RlZEpTLCB2aWV3LCBlbCkpXG4gIH1cblxuICAvLyBwcml2YXRlXG5cbiAgZXhlY0pTSG9va1B1c2goZWwsIHBoeEV2ZW50LCBkYXRhLCBjYWxsYmFjayl7XG4gICAgdGhpcy53aXRoaW5Pd25lcnMoZWwsIHZpZXcgPT4ge1xuICAgICAgbGV0IGUgPSBuZXcgQ3VzdG9tRXZlbnQoXCJwaHg6ZXhlY1wiLCB7ZGV0YWlsOiB7c291cmNlRWxlbWVudDogZWx9fSlcbiAgICAgIEpTLmV4ZWMoZSwgXCJob29rXCIsIHBoeEV2ZW50LCB2aWV3LCBlbCwgW1wicHVzaFwiLCB7ZGF0YSwgY2FsbGJhY2t9XSlcbiAgICB9KVxuICB9XG5cbiAgdW5sb2FkKCl7XG4gICAgaWYodGhpcy51bmxvYWRlZCl7IHJldHVybiB9XG4gICAgaWYodGhpcy5tYWluICYmIHRoaXMuaXNDb25uZWN0ZWQoKSl7IHRoaXMubG9nKHRoaXMubWFpbiwgXCJzb2NrZXRcIiwgKCkgPT4gW1wiZGlzY29ubmVjdCBmb3IgcGFnZSBuYXZcIl0pIH1cbiAgICB0aGlzLnVubG9hZGVkID0gdHJ1ZVxuICAgIHRoaXMuZGVzdHJveUFsbFZpZXdzKClcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICB9XG5cbiAgdHJpZ2dlckRPTShraW5kLCBhcmdzKXsgdGhpcy5kb21DYWxsYmFja3Nba2luZF0oLi4uYXJncykgfVxuXG4gIHRpbWUobmFtZSwgZnVuYyl7XG4gICAgaWYoIXRoaXMuaXNQcm9maWxlRW5hYmxlZCgpIHx8ICFjb25zb2xlLnRpbWUpeyByZXR1cm4gZnVuYygpIH1cbiAgICBjb25zb2xlLnRpbWUobmFtZSlcbiAgICBsZXQgcmVzdWx0ID0gZnVuYygpXG4gICAgY29uc29sZS50aW1lRW5kKG5hbWUpXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgbG9nKHZpZXcsIGtpbmQsIG1zZ0NhbGxiYWNrKXtcbiAgICBpZih0aGlzLnZpZXdMb2dnZXIpe1xuICAgICAgbGV0IFttc2csIG9ial0gPSBtc2dDYWxsYmFjaygpXG4gICAgICB0aGlzLnZpZXdMb2dnZXIodmlldywga2luZCwgbXNnLCBvYmopXG4gICAgfSBlbHNlIGlmKHRoaXMuaXNEZWJ1Z0VuYWJsZWQoKSl7XG4gICAgICBsZXQgW21zZywgb2JqXSA9IG1zZ0NhbGxiYWNrKClcbiAgICAgIGRlYnVnKHZpZXcsIGtpbmQsIG1zZywgb2JqKVxuICAgIH1cbiAgfVxuXG4gIHJlcXVlc3RET01VcGRhdGUoY2FsbGJhY2spe1xuICAgIHRoaXMudHJhbnNpdGlvbnMuYWZ0ZXIoY2FsbGJhY2spXG4gIH1cblxuICB0cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSA9IGZ1bmN0aW9uKCl7fSl7XG4gICAgdGhpcy50cmFuc2l0aW9ucy5hZGRUcmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSlcbiAgfVxuXG4gIG9uQ2hhbm5lbChjaGFubmVsLCBldmVudCwgY2Ipe1xuICAgIGNoYW5uZWwub24oZXZlbnQsIGRhdGEgPT4ge1xuICAgICAgbGV0IGxhdGVuY3kgPSB0aGlzLmdldExhdGVuY3lTaW0oKVxuICAgICAgaWYoIWxhdGVuY3kpe1xuICAgICAgICBjYihkYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBjYihkYXRhKSwgbGF0ZW5jeSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgcmVsb2FkV2l0aEppdHRlcih2aWV3LCBsb2cpe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnJlbG9hZFdpdGhKaXR0ZXJUaW1lcilcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgIGxldCBtaW5NcyA9IHRoaXMucmVsb2FkSml0dGVyTWluXG4gICAgbGV0IG1heE1zID0gdGhpcy5yZWxvYWRKaXR0ZXJNYXhcbiAgICBsZXQgYWZ0ZXJNcyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXhNcyAtIG1pbk1zICsgMSkpICsgbWluTXNcbiAgICBsZXQgdHJpZXMgPSBCcm93c2VyLnVwZGF0ZUxvY2FsKHRoaXMubG9jYWxTdG9yYWdlLCB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUsIENPTlNFQ1VUSVZFX1JFTE9BRFMsIDAsIGNvdW50ID0+IGNvdW50ICsgMSlcbiAgICBpZih0cmllcyA+PSB0aGlzLm1heFJlbG9hZHMpe1xuICAgICAgYWZ0ZXJNcyA9IHRoaXMuZmFpbHNhZmVKaXR0ZXJcbiAgICB9XG4gICAgdGhpcy5yZWxvYWRXaXRoSml0dGVyVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIC8vIGlmIHZpZXcgaGFzIHJlY292ZXJlZCwgc3VjaCBhcyB0cmFuc3BvcnQgcmVwbGFjZWQsIHRoZW4gY2FuY2VsXG4gICAgICBpZih2aWV3LmlzRGVzdHJveWVkKCkgfHwgdmlldy5pc0Nvbm5lY3RlZCgpKXsgcmV0dXJuIH1cbiAgICAgIHZpZXcuZGVzdHJveSgpXG4gICAgICBsb2cgPyBsb2coKSA6IHRoaXMubG9nKHZpZXcsIFwiam9pblwiLCAoKSA9PiBbYGVuY291bnRlcmVkICR7dHJpZXN9IGNvbnNlY3V0aXZlIHJlbG9hZHNgXSlcbiAgICAgIGlmKHRyaWVzID49IHRoaXMubWF4UmVsb2Fkcyl7XG4gICAgICAgIHRoaXMubG9nKHZpZXcsIFwiam9pblwiLCAoKSA9PiBbYGV4Y2VlZGVkICR7dGhpcy5tYXhSZWxvYWRzfSBjb25zZWN1dGl2ZSByZWxvYWRzLiBFbnRlcmluZyBmYWlsc2FmZSBtb2RlYF0pXG4gICAgICB9XG4gICAgICBpZih0aGlzLmhhc1BlbmRpbmdMaW5rKCkpe1xuICAgICAgICB3aW5kb3cubG9jYXRpb24gPSB0aGlzLnBlbmRpbmdMaW5rXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICAgIH1cbiAgICB9LCBhZnRlck1zKVxuICB9XG5cbiAgZ2V0SG9va0NhbGxiYWNrcyhuYW1lKXtcbiAgICByZXR1cm4gbmFtZSAmJiBuYW1lLnN0YXJ0c1dpdGgoXCJQaG9lbml4LlwiKSA/IEhvb2tzW25hbWUuc3BsaXQoXCIuXCIpWzFdXSA6IHRoaXMuaG9va3NbbmFtZV1cbiAgfVxuXG4gIGlzVW5sb2FkZWQoKXsgcmV0dXJuIHRoaXMudW5sb2FkZWQgfVxuXG4gIGlzQ29ubmVjdGVkKCl7IHJldHVybiB0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpIH1cblxuICBnZXRCaW5kaW5nUHJlZml4KCl7IHJldHVybiB0aGlzLmJpbmRpbmdQcmVmaXggfVxuXG4gIGJpbmRpbmcoa2luZCl7IHJldHVybiBgJHt0aGlzLmdldEJpbmRpbmdQcmVmaXgoKX0ke2tpbmR9YCB9XG5cbiAgY2hhbm5lbCh0b3BpYywgcGFyYW1zKXsgcmV0dXJuIHRoaXMuc29ja2V0LmNoYW5uZWwodG9waWMsIHBhcmFtcykgfVxuXG4gIGpvaW5EZWFkVmlldygpe1xuICAgIGxldCBib2R5ID0gZG9jdW1lbnQuYm9keVxuICAgIGlmKGJvZHkgJiYgIXRoaXMuaXNQaHhWaWV3KGJvZHkpICYmICF0aGlzLmlzUGh4Vmlldyhkb2N1bWVudC5maXJzdEVsZW1lbnRDaGlsZCkpe1xuICAgICAgbGV0IHZpZXcgPSB0aGlzLm5ld1Jvb3RWaWV3KGJvZHkpXG4gICAgICB2aWV3LnNldEhyZWYodGhpcy5nZXRIcmVmKCkpXG4gICAgICB2aWV3LmpvaW5EZWFkKClcbiAgICAgIGlmKCF0aGlzLm1haW4peyB0aGlzLm1haW4gPSB2aWV3IH1cbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB2aWV3LmV4ZWNOZXdNb3VudGVkKClcbiAgICAgICAgLy8gcmVzdG9yZSBzY3JvbGwgcG9zaXRpb24gd2hlbiBuYXZpZ2F0aW5nIGZyb20gYW4gZXh0ZXJuYWwgLyBub24tbGl2ZSBwYWdlXG4gICAgICAgIHRoaXMubWF5YmVTY3JvbGwoaGlzdG9yeS5zdGF0ZT8uc2Nyb2xsKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBqb2luUm9vdFZpZXdzKCl7XG4gICAgbGV0IHJvb3RzRm91bmQgPSBmYWxzZVxuICAgIERPTS5hbGwoZG9jdW1lbnQsIGAke1BIWF9WSUVXX1NFTEVDVE9SfTpub3QoWyR7UEhYX1BBUkVOVF9JRH1dKWAsIHJvb3RFbCA9PiB7XG4gICAgICBpZighdGhpcy5nZXRSb290QnlJZChyb290RWwuaWQpKXtcbiAgICAgICAgbGV0IHZpZXcgPSB0aGlzLm5ld1Jvb3RWaWV3KHJvb3RFbClcbiAgICAgICAgLy8gc3RpY2tpZXMgY2Fubm90IGJlIG1vdW50ZWQgYXQgdGhlIHJvdXRlciBhbmQgdGhlcmVmb3JlIHNob3VsZCBub3RcbiAgICAgICAgLy8gZ2V0IGEgaHJlZiBzZXQgb24gdGhlbVxuICAgICAgICBpZighRE9NLmlzUGh4U3RpY2t5KHJvb3RFbCkpeyB2aWV3LnNldEhyZWYodGhpcy5nZXRIcmVmKCkpIH1cbiAgICAgICAgdmlldy5qb2luKClcbiAgICAgICAgaWYocm9vdEVsLmhhc0F0dHJpYnV0ZShQSFhfTUFJTikpeyB0aGlzLm1haW4gPSB2aWV3IH1cbiAgICAgIH1cbiAgICAgIHJvb3RzRm91bmQgPSB0cnVlXG4gICAgfSlcbiAgICByZXR1cm4gcm9vdHNGb3VuZFxuICB9XG5cbiAgcmVkaXJlY3QodG8sIGZsYXNoLCByZWxvYWRUb2tlbil7XG4gICAgaWYocmVsb2FkVG9rZW4peyBCcm93c2VyLnNldENvb2tpZShQSFhfUkVMT0FEX1NUQVRVUywgcmVsb2FkVG9rZW4sIDYwKSB9XG4gICAgdGhpcy51bmxvYWQoKVxuICAgIEJyb3dzZXIucmVkaXJlY3QodG8sIGZsYXNoKVxuICB9XG5cbiAgcmVwbGFjZU1haW4oaHJlZiwgZmxhc2gsIGNhbGxiYWNrID0gbnVsbCwgbGlua1JlZiA9IHRoaXMuc2V0UGVuZGluZ0xpbmsoaHJlZikpe1xuICAgIGNvbnN0IGxpdmVSZWZlcmVyID0gdGhpcy5jdXJyZW50TG9jYXRpb24uaHJlZlxuICAgIHRoaXMub3V0Z29pbmdNYWluRWwgPSB0aGlzLm91dGdvaW5nTWFpbkVsIHx8IHRoaXMubWFpbi5lbFxuXG4gICAgY29uc3Qgc3RpY2tpZXMgPSBET00uZmluZFBoeFN0aWNreShkb2N1bWVudCkgfHwgW11cbiAgICBjb25zdCByZW1vdmVFbHMgPSBET00uYWxsKHRoaXMub3V0Z29pbmdNYWluRWwsIGBbJHt0aGlzLmJpbmRpbmcoXCJyZW1vdmVcIil9XWApXG4gICAgICAuZmlsdGVyKGVsID0+ICFET00uaXNDaGlsZE9mQW55KGVsLCBzdGlja2llcykpXG5cbiAgICBjb25zdCBuZXdNYWluRWwgPSBET00uY2xvbmVOb2RlKHRoaXMub3V0Z29pbmdNYWluRWwsIFwiXCIpXG4gICAgdGhpcy5tYWluLnNob3dMb2FkZXIodGhpcy5sb2FkZXJUaW1lb3V0KVxuICAgIHRoaXMubWFpbi5kZXN0cm95KClcblxuICAgIHRoaXMubWFpbiA9IHRoaXMubmV3Um9vdFZpZXcobmV3TWFpbkVsLCBmbGFzaCwgbGl2ZVJlZmVyZXIpXG4gICAgdGhpcy5tYWluLnNldFJlZGlyZWN0KGhyZWYpXG4gICAgdGhpcy50cmFuc2l0aW9uUmVtb3ZlcyhyZW1vdmVFbHMpXG4gICAgdGhpcy5tYWluLmpvaW4oKGpvaW5Db3VudCwgb25Eb25lKSA9PiB7XG4gICAgICBpZihqb2luQ291bnQgPT09IDEgJiYgdGhpcy5jb21taXRQZW5kaW5nTGluayhsaW5rUmVmKSl7XG4gICAgICAgIHRoaXMucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHBoeC1yZW1vdmUgZWxzIHJpZ2h0IGJlZm9yZSB3ZSByZXBsYWNlIHRoZSBtYWluIGVsZW1lbnRcbiAgICAgICAgICByZW1vdmVFbHMuZm9yRWFjaChlbCA9PiBlbC5yZW1vdmUoKSlcbiAgICAgICAgICBzdGlja2llcy5mb3JFYWNoKGVsID0+IG5ld01haW5FbC5hcHBlbmRDaGlsZChlbCkpXG4gICAgICAgICAgdGhpcy5vdXRnb2luZ01haW5FbC5yZXBsYWNlV2l0aChuZXdNYWluRWwpXG4gICAgICAgICAgdGhpcy5vdXRnb2luZ01haW5FbCA9IG51bGxcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhsaW5rUmVmKVxuICAgICAgICAgIG9uRG9uZSgpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHRyYW5zaXRpb25SZW1vdmVzKGVsZW1lbnRzLCBjYWxsYmFjayl7XG4gICAgbGV0IHJlbW92ZUF0dHIgPSB0aGlzLmJpbmRpbmcoXCJyZW1vdmVcIilcbiAgICBsZXQgc2lsZW5jZUV2ZW50cyA9IChlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcbiAgICB9XG4gICAgZWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAvLyBwcmV2ZW50IGFsbCBsaXN0ZW5lcnMgd2UgY2FyZSBhYm91dCBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvd1xuICAgICAgLy8gc2luY2Ugd2UgYXJlIHJlbW92aW5nIHRoZSBlbGVtZW50XG4gICAgICBmb3IobGV0IGV2ZW50IG9mIHRoaXMuYm91bmRFdmVudE5hbWVzKXtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgc2lsZW5jZUV2ZW50cywgdHJ1ZSlcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhlY0pTKGVsLCBlbC5nZXRBdHRyaWJ1dGUocmVtb3ZlQXR0ciksIFwicmVtb3ZlXCIpXG4gICAgfSlcbiAgICAvLyByZW1vdmUgdGhlIHNpbGVuY2VkIGxpc3RlbmVycyB3aGVuIHRyYW5zaXRpb25zIGFyZSBkb25lIGluY2FzZSB0aGUgZWxlbWVudCBpcyByZS11c2VkXG4gICAgLy8gYW5kIGNhbGwgY2FsbGVyJ3MgY2FsbGJhY2sgYXMgc29vbiBhcyB3ZSBhcmUgZG9uZSB3aXRoIHRyYW5zaXRpb25zXG4gICAgdGhpcy5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgIGVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBmb3IobGV0IGV2ZW50IG9mIHRoaXMuYm91bmRFdmVudE5hbWVzKXtcbiAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBzaWxlbmNlRXZlbnRzLCB0cnVlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgIH0pXG4gIH1cblxuICBpc1BoeFZpZXcoZWwpeyByZXR1cm4gZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShQSFhfU0VTU0lPTikgIT09IG51bGwgfVxuXG4gIG5ld1Jvb3RWaWV3KGVsLCBmbGFzaCwgbGl2ZVJlZmVyZXIpe1xuICAgIGxldCB2aWV3ID0gbmV3IFZpZXcoZWwsIHRoaXMsIG51bGwsIGZsYXNoLCBsaXZlUmVmZXJlcilcbiAgICB0aGlzLnJvb3RzW3ZpZXcuaWRdID0gdmlld1xuICAgIHJldHVybiB2aWV3XG4gIH1cblxuICBvd25lcihjaGlsZEVsLCBjYWxsYmFjayl7XG4gICAgbGV0IHZpZXcgPSBtYXliZShjaGlsZEVsLmNsb3Nlc3QoUEhYX1ZJRVdfU0VMRUNUT1IpLCBlbCA9PiB0aGlzLmdldFZpZXdCeUVsKGVsKSkgfHwgdGhpcy5tYWluXG4gICAgcmV0dXJuIHZpZXcgJiYgY2FsbGJhY2sgPyBjYWxsYmFjayh2aWV3KSA6IHZpZXdcbiAgfVxuXG4gIHdpdGhpbk93bmVycyhjaGlsZEVsLCBjYWxsYmFjayl7XG4gICAgdGhpcy5vd25lcihjaGlsZEVsLCB2aWV3ID0+IGNhbGxiYWNrKHZpZXcsIGNoaWxkRWwpKVxuICB9XG5cbiAgZ2V0Vmlld0J5RWwoZWwpe1xuICAgIGxldCByb290SWQgPSBlbC5nZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQpXG4gICAgcmV0dXJuIG1heWJlKHRoaXMuZ2V0Um9vdEJ5SWQocm9vdElkKSwgcm9vdCA9PiByb290LmdldERlc2NlbmRlbnRCeUVsKGVsKSlcbiAgfVxuXG4gIGdldFJvb3RCeUlkKGlkKXsgcmV0dXJuIHRoaXMucm9vdHNbaWRdIH1cblxuICBkZXN0cm95QWxsVmlld3MoKXtcbiAgICBmb3IobGV0IGlkIGluIHRoaXMucm9vdHMpe1xuICAgICAgdGhpcy5yb290c1tpZF0uZGVzdHJveSgpXG4gICAgICBkZWxldGUgdGhpcy5yb290c1tpZF1cbiAgICB9XG4gICAgdGhpcy5tYWluID0gbnVsbFxuICB9XG5cbiAgZGVzdHJveVZpZXdCeUVsKGVsKXtcbiAgICBsZXQgcm9vdCA9IHRoaXMuZ2V0Um9vdEJ5SWQoZWwuZ2V0QXR0cmlidXRlKFBIWF9ST09UX0lEKSlcbiAgICBpZihyb290ICYmIHJvb3QuaWQgPT09IGVsLmlkKXtcbiAgICAgIHJvb3QuZGVzdHJveSgpXG4gICAgICBkZWxldGUgdGhpcy5yb290c1tyb290LmlkXVxuICAgIH0gZWxzZSBpZihyb290KXtcbiAgICAgIHJvb3QuZGVzdHJveURlc2NlbmRlbnQoZWwuaWQpXG4gICAgfVxuICB9XG5cbiAgZ2V0QWN0aXZlRWxlbWVudCgpe1xuICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50XG4gIH1cblxuICBkcm9wQWN0aXZlRWxlbWVudCh2aWV3KXtcbiAgICBpZih0aGlzLnByZXZBY3RpdmUgJiYgdmlldy5vd25zRWxlbWVudCh0aGlzLnByZXZBY3RpdmUpKXtcbiAgICAgIHRoaXMucHJldkFjdGl2ZSA9IG51bGxcbiAgICB9XG4gIH1cblxuICByZXN0b3JlUHJldmlvdXNseUFjdGl2ZUZvY3VzKCl7XG4gICAgaWYodGhpcy5wcmV2QWN0aXZlICYmIHRoaXMucHJldkFjdGl2ZSAhPT0gZG9jdW1lbnQuYm9keSl7XG4gICAgICB0aGlzLnByZXZBY3RpdmUuZm9jdXMoKVxuICAgIH1cbiAgfVxuXG4gIGJsdXJBY3RpdmVFbGVtZW50KCl7XG4gICAgdGhpcy5wcmV2QWN0aXZlID0gdGhpcy5nZXRBY3RpdmVFbGVtZW50KClcbiAgICBpZih0aGlzLnByZXZBY3RpdmUgIT09IGRvY3VtZW50LmJvZHkpeyB0aGlzLnByZXZBY3RpdmUuYmx1cigpIH1cbiAgfVxuXG4gIGJpbmRUb3BMZXZlbEV2ZW50cyh7ZGVhZH0gPSB7fSl7XG4gICAgaWYodGhpcy5ib3VuZFRvcExldmVsRXZlbnRzKXsgcmV0dXJuIH1cblxuICAgIHRoaXMuYm91bmRUb3BMZXZlbEV2ZW50cyA9IHRydWVcbiAgICAvLyBlbnRlciBmYWlsc2FmZSByZWxvYWQgaWYgc2VydmVyIGhhcyBnb25lIGF3YXkgaW50ZW50aW9uYWxseSwgc3VjaCBhcyBcImRpc2Nvbm5lY3RcIiBicm9hZGNhc3RcbiAgICB0aGlzLnNlcnZlckNsb3NlUmVmID0gdGhpcy5zb2NrZXQub25DbG9zZShldmVudCA9PiB7XG4gICAgICAvLyBmYWlsc2FmZSByZWxvYWQgaWYgbm9ybWFsIGNsb3N1cmUgYW5kIHdlIHN0aWxsIGhhdmUgYSBtYWluIExWXG4gICAgICBpZihldmVudCAmJiBldmVudC5jb2RlID09PSAxMDAwICYmIHRoaXMubWFpbil7IHJldHVybiB0aGlzLnJlbG9hZFdpdGhKaXR0ZXIodGhpcy5tYWluKSB9XG4gICAgfSlcbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoKXsgfSkgLy8gZW5zdXJlIGFsbCBjbGljayBldmVudHMgYnViYmxlIGZvciBtb2JpbGUgU2FmYXJpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlc2hvd1wiLCBlID0+IHtcbiAgICAgIGlmKGUucGVyc2lzdGVkKXsgLy8gcmVsb2FkIHBhZ2UgaWYgYmVpbmcgcmVzdG9yZWQgZnJvbSBiYWNrL2ZvcndhcmQgY2FjaGVcbiAgICAgICAgdGhpcy5nZXRTb2NrZXQoKS5kaXNjb25uZWN0KClcbiAgICAgICAgdGhpcy53aXRoUGFnZUxvYWRpbmcoe3RvOiB3aW5kb3cubG9jYXRpb24uaHJlZiwga2luZDogXCJyZWRpcmVjdFwifSlcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gICAgICB9XG4gICAgfSwgdHJ1ZSlcbiAgICBpZighZGVhZCl7IHRoaXMuYmluZE5hdigpIH1cbiAgICB0aGlzLmJpbmRDbGlja3MoKVxuICAgIGlmKCFkZWFkKXsgdGhpcy5iaW5kRm9ybXMoKSB9XG4gICAgdGhpcy5iaW5kKHtrZXl1cDogXCJrZXl1cFwiLCBrZXlkb3duOiBcImtleWRvd25cIn0sIChlLCB0eXBlLCB2aWV3LCB0YXJnZXRFbCwgcGh4RXZlbnQsIF9waHhUYXJnZXQpID0+IHtcbiAgICAgIGxldCBtYXRjaEtleSA9IHRhcmdldEVsLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0tFWSkpXG4gICAgICBsZXQgcHJlc3NlZEtleSA9IGUua2V5ICYmIGUua2V5LnRvTG93ZXJDYXNlKCkgLy8gY2hyb21lIGNsaWNrZWQgYXV0b2NvbXBsZXRlcyBzZW5kIGEga2V5ZG93biB3aXRob3V0IGtleVxuICAgICAgaWYobWF0Y2hLZXkgJiYgbWF0Y2hLZXkudG9Mb3dlckNhc2UoKSAhPT0gcHJlc3NlZEtleSl7IHJldHVybiB9XG5cbiAgICAgIGxldCBkYXRhID0ge2tleTogZS5rZXksIC4uLnRoaXMuZXZlbnRNZXRhKHR5cGUsIGUsIHRhcmdldEVsKX1cbiAgICAgIEpTLmV4ZWMoZSwgdHlwZSwgcGh4RXZlbnQsIHZpZXcsIHRhcmdldEVsLCBbXCJwdXNoXCIsIHtkYXRhfV0pXG4gICAgfSlcbiAgICB0aGlzLmJpbmQoe2JsdXI6IFwiZm9jdXNvdXRcIiwgZm9jdXM6IFwiZm9jdXNpblwifSwgKGUsIHR5cGUsIHZpZXcsIHRhcmdldEVsLCBwaHhFdmVudCwgcGh4VGFyZ2V0KSA9PiB7XG4gICAgICBpZighcGh4VGFyZ2V0KXtcbiAgICAgICAgbGV0IGRhdGEgPSB7a2V5OiBlLmtleSwgLi4udGhpcy5ldmVudE1ldGEodHlwZSwgZSwgdGFyZ2V0RWwpfVxuICAgICAgICBKUy5leGVjKGUsIHR5cGUsIHBoeEV2ZW50LCB2aWV3LCB0YXJnZXRFbCwgW1wicHVzaFwiLCB7ZGF0YX1dKVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5iaW5kKHtibHVyOiBcImJsdXJcIiwgZm9jdXM6IFwiZm9jdXNcIn0sIChlLCB0eXBlLCB2aWV3LCB0YXJnZXRFbCwgcGh4RXZlbnQsIHBoeFRhcmdldCkgPT4ge1xuICAgICAgLy8gYmx1ciBhbmQgZm9jdXMgYXJlIHRyaWdnZXJlZCBvbiBkb2N1bWVudCBhbmQgd2luZG93LiBEaXNjYXJkIG9uZSB0byBhdm9pZCBkdXBzXG4gICAgICBpZihwaHhUYXJnZXQgPT09IFwid2luZG93XCIpe1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZXZlbnRNZXRhKHR5cGUsIGUsIHRhcmdldEVsKVxuICAgICAgICBKUy5leGVjKGUsIHR5cGUsIHBoeEV2ZW50LCB2aWV3LCB0YXJnZXRFbCwgW1wicHVzaFwiLCB7ZGF0YX1dKVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5vbihcImRyYWdvdmVyXCIsIGUgPT4gZS5wcmV2ZW50RGVmYXVsdCgpKVxuICAgIHRoaXMub24oXCJkcm9wXCIsIGUgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBsZXQgZHJvcFRhcmdldElkID0gbWF5YmUoY2xvc2VzdFBoeEJpbmRpbmcoZS50YXJnZXQsIHRoaXMuYmluZGluZyhQSFhfRFJPUF9UQVJHRVQpKSwgdHJ1ZVRhcmdldCA9PiB7XG4gICAgICAgIHJldHVybiB0cnVlVGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0RST1BfVEFSR0VUKSlcbiAgICAgIH0pXG4gICAgICBsZXQgZHJvcFRhcmdldCA9IGRyb3BUYXJnZXRJZCAmJiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkcm9wVGFyZ2V0SWQpXG4gICAgICBsZXQgZmlsZXMgPSBBcnJheS5mcm9tKGUuZGF0YVRyYW5zZmVyLmZpbGVzIHx8IFtdKVxuICAgICAgaWYoIWRyb3BUYXJnZXQgfHwgZHJvcFRhcmdldC5kaXNhYmxlZCB8fCBmaWxlcy5sZW5ndGggPT09IDAgfHwgIShkcm9wVGFyZ2V0LmZpbGVzIGluc3RhbmNlb2YgRmlsZUxpc3QpKXsgcmV0dXJuIH1cblxuICAgICAgTGl2ZVVwbG9hZGVyLnRyYWNrRmlsZXMoZHJvcFRhcmdldCwgZmlsZXMsIGUuZGF0YVRyYW5zZmVyKVxuICAgICAgZHJvcFRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImlucHV0XCIsIHtidWJibGVzOiB0cnVlfSkpXG4gICAgfSlcbiAgICB0aGlzLm9uKFBIWF9UUkFDS19VUExPQURTLCBlID0+IHtcbiAgICAgIGxldCB1cGxvYWRUYXJnZXQgPSBlLnRhcmdldFxuICAgICAgaWYoIURPTS5pc1VwbG9hZElucHV0KHVwbG9hZFRhcmdldCkpeyByZXR1cm4gfVxuICAgICAgbGV0IGZpbGVzID0gQXJyYXkuZnJvbShlLmRldGFpbC5maWxlcyB8fCBbXSkuZmlsdGVyKGYgPT4gZiBpbnN0YW5jZW9mIEZpbGUgfHwgZiBpbnN0YW5jZW9mIEJsb2IpXG4gICAgICBMaXZlVXBsb2FkZXIudHJhY2tGaWxlcyh1cGxvYWRUYXJnZXQsIGZpbGVzKVxuICAgICAgdXBsb2FkVGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiaW5wdXRcIiwge2J1YmJsZXM6IHRydWV9KSlcbiAgICB9KVxuICB9XG5cbiAgZXZlbnRNZXRhKGV2ZW50TmFtZSwgZSwgdGFyZ2V0RWwpe1xuICAgIGxldCBjYWxsYmFjayA9IHRoaXMubWV0YWRhdGFDYWxsYmFja3NbZXZlbnROYW1lXVxuICAgIHJldHVybiBjYWxsYmFjayA/IGNhbGxiYWNrKGUsIHRhcmdldEVsKSA6IHt9XG4gIH1cblxuICBzZXRQZW5kaW5nTGluayhocmVmKXtcbiAgICB0aGlzLmxpbmtSZWYrK1xuICAgIHRoaXMucGVuZGluZ0xpbmsgPSBocmVmXG4gICAgdGhpcy5yZXNldFJlbG9hZFN0YXR1cygpXG4gICAgcmV0dXJuIHRoaXMubGlua1JlZlxuICB9XG5cbiAgLy8gYW55dGltZSB3ZSBhcmUgbmF2aWdhdGluZyBvciBjb25uZWN0aW5nLCBkcm9wIHJlbG9hZCBjb29raWUgaW4gY2FzZVxuICAvLyB3ZSBpc3N1ZSB0aGUgY29va2llIGJ1dCB0aGUgbmV4dCByZXF1ZXN0IHdhcyBpbnRlcnJ1cHRlZCBhbmQgdGhlIHNlcnZlciBuZXZlciBkcm9wcGVkIGl0XG4gIHJlc2V0UmVsb2FkU3RhdHVzKCl7IEJyb3dzZXIuZGVsZXRlQ29va2llKFBIWF9SRUxPQURfU1RBVFVTKSB9XG5cbiAgY29tbWl0UGVuZGluZ0xpbmsobGlua1JlZil7XG4gICAgaWYodGhpcy5saW5rUmVmICE9PSBsaW5rUmVmKXtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhyZWYgPSB0aGlzLnBlbmRpbmdMaW5rXG4gICAgICB0aGlzLnBlbmRpbmdMaW5rID0gbnVsbFxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICBnZXRIcmVmKCl7IHJldHVybiB0aGlzLmhyZWYgfVxuXG4gIGhhc1BlbmRpbmdMaW5rKCl7IHJldHVybiAhIXRoaXMucGVuZGluZ0xpbmsgfVxuXG4gIGJpbmQoZXZlbnRzLCBjYWxsYmFjayl7XG4gICAgZm9yKGxldCBldmVudCBpbiBldmVudHMpe1xuICAgICAgbGV0IGJyb3dzZXJFdmVudE5hbWUgPSBldmVudHNbZXZlbnRdXG5cbiAgICAgIHRoaXMub24oYnJvd3NlckV2ZW50TmFtZSwgZSA9PiB7XG4gICAgICAgIGxldCBiaW5kaW5nID0gdGhpcy5iaW5kaW5nKGV2ZW50KVxuICAgICAgICBsZXQgd2luZG93QmluZGluZyA9IHRoaXMuYmluZGluZyhgd2luZG93LSR7ZXZlbnR9YClcbiAgICAgICAgbGV0IHRhcmdldFBoeEV2ZW50ID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlICYmIGUudGFyZ2V0LmdldEF0dHJpYnV0ZShiaW5kaW5nKVxuICAgICAgICBpZih0YXJnZXRQaHhFdmVudCl7XG4gICAgICAgICAgdGhpcy5kZWJvdW5jZShlLnRhcmdldCwgZSwgYnJvd3NlckV2ZW50TmFtZSwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy53aXRoaW5Pd25lcnMoZS50YXJnZXQsIHZpZXcgPT4ge1xuICAgICAgICAgICAgICBjYWxsYmFjayhlLCBldmVudCwgdmlldywgZS50YXJnZXQsIHRhcmdldFBoeEV2ZW50LCBudWxsKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIERPTS5hbGwoZG9jdW1lbnQsIGBbJHt3aW5kb3dCaW5kaW5nfV1gLCBlbCA9PiB7XG4gICAgICAgICAgICBsZXQgcGh4RXZlbnQgPSBlbC5nZXRBdHRyaWJ1dGUod2luZG93QmluZGluZylcbiAgICAgICAgICAgIHRoaXMuZGVib3VuY2UoZWwsIGUsIGJyb3dzZXJFdmVudE5hbWUsICgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy53aXRoaW5Pd25lcnMoZWwsIHZpZXcgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUsIGV2ZW50LCB2aWV3LCBlbCwgcGh4RXZlbnQsIFwid2luZG93XCIpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgYmluZENsaWNrcygpe1xuICAgIHRoaXMub24oXCJtb3VzZWRvd25cIiwgZSA9PiB0aGlzLmNsaWNrU3RhcnRlZEF0VGFyZ2V0ID0gZS50YXJnZXQpXG4gICAgdGhpcy5iaW5kQ2xpY2soXCJjbGlja1wiLCBcImNsaWNrXCIpXG4gIH1cblxuICBiaW5kQ2xpY2soZXZlbnROYW1lLCBiaW5kaW5nTmFtZSl7XG4gICAgbGV0IGNsaWNrID0gdGhpcy5iaW5kaW5nKGJpbmRpbmdOYW1lKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZSA9PiB7XG4gICAgICBsZXQgdGFyZ2V0ID0gbnVsbFxuICAgICAgLy8gYSBzeW50aGV0aWMgY2xpY2sgZXZlbnQgKGRldGFpbCAwKSB3aWxsIG5vdCBoYXZlIGNhdXNlZCBhIG1vdXNlZG93biBldmVudCxcbiAgICAgIC8vIHRoZXJlZm9yZSB0aGUgY2xpY2tTdGFydGVkQXRUYXJnZXQgaXMgc3RhbGVcbiAgICAgIGlmKGUuZGV0YWlsID09PSAwKSB0aGlzLmNsaWNrU3RhcnRlZEF0VGFyZ2V0ID0gZS50YXJnZXRcbiAgICAgIGxldCBjbGlja1N0YXJ0ZWRBdFRhcmdldCA9IHRoaXMuY2xpY2tTdGFydGVkQXRUYXJnZXQgfHwgZS50YXJnZXRcbiAgICAgIC8vIHdoZW4gc2VhcmNoaW5nIHRoZSB0YXJnZXQgZm9yIHRoZSBjbGljayBldmVudCwgd2UgYWx3YXlzIHdhbnQgdG9cbiAgICAgIC8vIHVzZSB0aGUgYWN0dWFsIGV2ZW50IHRhcmdldCwgc2VlICMzMzcyXG4gICAgICB0YXJnZXQgPSBjbG9zZXN0UGh4QmluZGluZyhlLnRhcmdldCwgY2xpY2spXG4gICAgICB0aGlzLmRpc3BhdGNoQ2xpY2tBd2F5KGUsIGNsaWNrU3RhcnRlZEF0VGFyZ2V0KVxuICAgICAgdGhpcy5jbGlja1N0YXJ0ZWRBdFRhcmdldCA9IG51bGxcbiAgICAgIGxldCBwaHhFdmVudCA9IHRhcmdldCAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKGNsaWNrKVxuICAgICAgaWYoIXBoeEV2ZW50KXtcbiAgICAgICAgaWYoRE9NLmlzTmV3UGFnZUNsaWNrKGUsIHdpbmRvdy5sb2NhdGlvbikpeyB0aGlzLnVubG9hZCgpIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmKHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIil7IGUucHJldmVudERlZmF1bHQoKSB9XG5cbiAgICAgIC8vIG5vb3AgaWYgd2UgYXJlIGluIHRoZSBtaWRkbGUgb2YgYXdhaXRpbmcgYW4gYWNrIGZvciB0aGlzIGVsIGFscmVhZHlcbiAgICAgIGlmKHRhcmdldC5oYXNBdHRyaWJ1dGUoUEhYX1JFRl9TUkMpKXsgcmV0dXJuIH1cblxuICAgICAgdGhpcy5kZWJvdW5jZSh0YXJnZXQsIGUsIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLndpdGhpbk93bmVycyh0YXJnZXQsIHZpZXcgPT4ge1xuICAgICAgICAgIEpTLmV4ZWMoZSwgXCJjbGlja1wiLCBwaHhFdmVudCwgdmlldywgdGFyZ2V0LCBbXCJwdXNoXCIsIHtkYXRhOiB0aGlzLmV2ZW50TWV0YShcImNsaWNrXCIsIGUsIHRhcmdldCl9XSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSwgZmFsc2UpXG4gIH1cblxuICBkaXNwYXRjaENsaWNrQXdheShlLCBjbGlja1N0YXJ0ZWRBdCl7XG4gICAgbGV0IHBoeENsaWNrQXdheSA9IHRoaXMuYmluZGluZyhcImNsaWNrLWF3YXlcIilcbiAgICBET00uYWxsKGRvY3VtZW50LCBgWyR7cGh4Q2xpY2tBd2F5fV1gLCBlbCA9PiB7XG4gICAgICBpZighKGVsLmlzU2FtZU5vZGUoY2xpY2tTdGFydGVkQXQpIHx8IGVsLmNvbnRhaW5zKGNsaWNrU3RhcnRlZEF0KSkpe1xuICAgICAgICB0aGlzLndpdGhpbk93bmVycyhlbCwgdmlldyA9PiB7XG4gICAgICAgICAgbGV0IHBoeEV2ZW50ID0gZWwuZ2V0QXR0cmlidXRlKHBoeENsaWNrQXdheSlcbiAgICAgICAgICBpZihKUy5pc1Zpc2libGUoZWwpICYmIEpTLmlzSW5WaWV3cG9ydChlbCkpe1xuICAgICAgICAgICAgSlMuZXhlYyhlLCBcImNsaWNrXCIsIHBoeEV2ZW50LCB2aWV3LCBlbCwgW1wicHVzaFwiLCB7ZGF0YTogdGhpcy5ldmVudE1ldGEoXCJjbGlja1wiLCBlLCBlLnRhcmdldCl9XSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGJpbmROYXYoKXtcbiAgICBpZighQnJvd3Nlci5jYW5QdXNoU3RhdGUoKSl7IHJldHVybiB9XG4gICAgaWYoaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbil7IGhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcIm1hbnVhbFwiIH1cbiAgICBsZXQgc2Nyb2xsVGltZXIgPSBudWxsXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgX2UgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHNjcm9sbFRpbWVyKVxuICAgICAgc2Nyb2xsVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgQnJvd3Nlci51cGRhdGVDdXJyZW50U3RhdGUoc3RhdGUgPT4gT2JqZWN0LmFzc2lnbihzdGF0ZSwge3Njcm9sbDogd2luZG93LnNjcm9sbFl9KSlcbiAgICAgIH0sIDEwMClcbiAgICB9KVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgZXZlbnQgPT4ge1xuICAgICAgaWYoIXRoaXMucmVnaXN0ZXJOZXdMb2NhdGlvbih3aW5kb3cubG9jYXRpb24pKXsgcmV0dXJuIH1cbiAgICAgIGxldCB7dHlwZSwgYmFja1R5cGUsIGlkLCBzY3JvbGwsIHBvc2l0aW9ufSA9IGV2ZW50LnN0YXRlIHx8IHt9XG4gICAgICBsZXQgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmXG5cbiAgICAgIC8vIENvbXBhcmUgcG9zaXRpb25zIHRvIGRldGVybWluZSBkaXJlY3Rpb25cbiAgICAgIGxldCBpc0ZvcndhcmQgPSBwb3NpdGlvbiA+IHRoaXMuY3VycmVudEhpc3RvcnlQb3NpdGlvblxuXG4gICAgICB0eXBlID0gaXNGb3J3YXJkID8gdHlwZSA6IChiYWNrVHlwZSB8fCB0eXBlKVxuXG4gICAgICAvLyBVcGRhdGUgY3VycmVudCBwb3NpdGlvblxuICAgICAgdGhpcy5jdXJyZW50SGlzdG9yeVBvc2l0aW9uID0gcG9zaXRpb24gfHwgMFxuICAgICAgdGhpcy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFBIWF9MVl9ISVNUT1JZX1BPU0lUSU9OLCB0aGlzLmN1cnJlbnRIaXN0b3J5UG9zaXRpb24udG9TdHJpbmcoKSlcblxuICAgICAgRE9NLmRpc3BhdGNoRXZlbnQod2luZG93LCBcInBoeDpuYXZpZ2F0ZVwiLCB7ZGV0YWlsOiB7aHJlZiwgcGF0Y2g6IHR5cGUgPT09IFwicGF0Y2hcIiwgcG9wOiB0cnVlLCBkaXJlY3Rpb246IGlzRm9yd2FyZCA/IFwiZm9yd2FyZFwiIDogXCJiYWNrd2FyZFwifX0pXG4gICAgICB0aGlzLnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHsgdGhpcy5tYXliZVNjcm9sbChzY3JvbGwpIH1cbiAgICAgICAgaWYodGhpcy5tYWluLmlzQ29ubmVjdGVkKCkgJiYgKHR5cGUgPT09IFwicGF0Y2hcIiAmJiBpZCA9PT0gdGhpcy5tYWluLmlkKSl7XG4gICAgICAgICAgdGhpcy5tYWluLnB1c2hMaW5rUGF0Y2goZXZlbnQsIGhyZWYsIG51bGwsIGNhbGxiYWNrKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVwbGFjZU1haW4oaHJlZiwgbnVsbCwgY2FsbGJhY2spXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSwgZmFsc2UpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBlID0+IHtcbiAgICAgIGxldCB0YXJnZXQgPSBjbG9zZXN0UGh4QmluZGluZyhlLnRhcmdldCwgUEhYX0xJVkVfTElOSylcbiAgICAgIGxldCB0eXBlID0gdGFyZ2V0ICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoUEhYX0xJVkVfTElOSylcbiAgICAgIGlmKCF0eXBlIHx8ICF0aGlzLmlzQ29ubmVjdGVkKCkgfHwgIXRoaXMubWFpbiB8fCBET00ud2FudHNOZXdUYWIoZSkpeyByZXR1cm4gfVxuXG4gICAgICAvLyBXaGVuIHdyYXBwaW5nIGFuIFNWRyBlbGVtZW50IGluIGFuIGFuY2hvciB0YWcsIHRoZSBocmVmIGNhbiBiZSBhbiBTVkdBbmltYXRlZFN0cmluZ1xuICAgICAgbGV0IGhyZWYgPSB0YXJnZXQuaHJlZiBpbnN0YW5jZW9mIFNWR0FuaW1hdGVkU3RyaW5nID8gdGFyZ2V0LmhyZWYuYmFzZVZhbCA6IHRhcmdldC5ocmVmXG5cbiAgICAgIGxldCBsaW5rU3RhdGUgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFBIWF9MSU5LX1NUQVRFKVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIC8vIGRvIG5vdCBidWJibGUgY2xpY2sgdG8gcmVndWxhciBwaHgtY2xpY2sgYmluZGluZ3NcbiAgICAgIGlmKHRoaXMucGVuZGluZ0xpbmsgPT09IGhyZWYpeyByZXR1cm4gfVxuXG4gICAgICB0aGlzLnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICBpZih0eXBlID09PSBcInBhdGNoXCIpe1xuICAgICAgICAgIHRoaXMucHVzaEhpc3RvcnlQYXRjaChlLCBocmVmLCBsaW5rU3RhdGUsIHRhcmdldClcbiAgICAgICAgfSBlbHNlIGlmKHR5cGUgPT09IFwicmVkaXJlY3RcIil7XG4gICAgICAgICAgdGhpcy5oaXN0b3J5UmVkaXJlY3QoZSwgaHJlZiwgbGlua1N0YXRlLCBudWxsLCB0YXJnZXQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke1BIWF9MSVZFX0xJTkt9IHRvIGJlIFwicGF0Y2hcIiBvciBcInJlZGlyZWN0XCIsIGdvdDogJHt0eXBlfWApXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBoeENsaWNrID0gdGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJjbGlja1wiKSlcbiAgICAgICAgaWYocGh4Q2xpY2spe1xuICAgICAgICAgIHRoaXMucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB0aGlzLmV4ZWNKUyh0YXJnZXQsIHBoeENsaWNrLCBcImNsaWNrXCIpKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sIGZhbHNlKVxuICB9XG5cbiAgbWF5YmVTY3JvbGwoc2Nyb2xsKXtcbiAgICBpZih0eXBlb2Yoc2Nyb2xsKSA9PT0gXCJudW1iZXJcIil7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgc2Nyb2xsKVxuICAgICAgfSkgLy8gdGhlIGJvZHkgbmVlZHMgdG8gcmVuZGVyIGJlZm9yZSB3ZSBzY3JvbGwuXG4gICAgfVxuICB9XG5cbiAgZGlzcGF0Y2hFdmVudChldmVudCwgcGF5bG9hZCA9IHt9KXtcbiAgICBET00uZGlzcGF0Y2hFdmVudCh3aW5kb3csIGBwaHg6JHtldmVudH1gLCB7ZGV0YWlsOiBwYXlsb2FkfSlcbiAgfVxuXG4gIGRpc3BhdGNoRXZlbnRzKGV2ZW50cyl7XG4gICAgZXZlbnRzLmZvckVhY2goKFtldmVudCwgcGF5bG9hZF0pID0+IHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCwgcGF5bG9hZCkpXG4gIH1cblxuICB3aXRoUGFnZUxvYWRpbmcoaW5mbywgY2FsbGJhY2spe1xuICAgIERPTS5kaXNwYXRjaEV2ZW50KHdpbmRvdywgXCJwaHg6cGFnZS1sb2FkaW5nLXN0YXJ0XCIsIHtkZXRhaWw6IGluZm99KVxuICAgIGxldCBkb25lID0gKCkgPT4gRE9NLmRpc3BhdGNoRXZlbnQod2luZG93LCBcInBoeDpwYWdlLWxvYWRpbmctc3RvcFwiLCB7ZGV0YWlsOiBpbmZvfSlcbiAgICByZXR1cm4gY2FsbGJhY2sgPyBjYWxsYmFjayhkb25lKSA6IGRvbmVcbiAgfVxuXG4gIHB1c2hIaXN0b3J5UGF0Y2goZSwgaHJlZiwgbGlua1N0YXRlLCB0YXJnZXRFbCl7XG4gICAgaWYoIXRoaXMuaXNDb25uZWN0ZWQoKSB8fCAhdGhpcy5tYWluLmlzTWFpbigpKXsgcmV0dXJuIEJyb3dzZXIucmVkaXJlY3QoaHJlZikgfVxuXG4gICAgdGhpcy53aXRoUGFnZUxvYWRpbmcoe3RvOiBocmVmLCBraW5kOiBcInBhdGNoXCJ9LCBkb25lID0+IHtcbiAgICAgIHRoaXMubWFpbi5wdXNoTGlua1BhdGNoKGUsIGhyZWYsIHRhcmdldEVsLCBsaW5rUmVmID0+IHtcbiAgICAgICAgdGhpcy5oaXN0b3J5UGF0Y2goaHJlZiwgbGlua1N0YXRlLCBsaW5rUmVmKVxuICAgICAgICBkb25lKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIGhpc3RvcnlQYXRjaChocmVmLCBsaW5rU3RhdGUsIGxpbmtSZWYgPSB0aGlzLnNldFBlbmRpbmdMaW5rKGhyZWYpKXtcbiAgICBpZighdGhpcy5jb21taXRQZW5kaW5nTGluayhsaW5rUmVmKSl7IHJldHVybiB9XG5cbiAgICAvLyBJbmNyZW1lbnQgcG9zaXRpb24gZm9yIG5ldyBzdGF0ZVxuICAgIHRoaXMuY3VycmVudEhpc3RvcnlQb3NpdGlvbisrXG4gICAgdGhpcy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFBIWF9MVl9ISVNUT1JZX1BPU0lUSU9OLCB0aGlzLmN1cnJlbnRIaXN0b3J5UG9zaXRpb24udG9TdHJpbmcoKSlcblxuICAgIC8vIHN0b3JlIHRoZSB0eXBlIGZvciBiYWNrIG5hdmlnYXRpb25cbiAgICBCcm93c2VyLnVwZGF0ZUN1cnJlbnRTdGF0ZSgoc3RhdGUpID0+ICh7Li4uc3RhdGUsIGJhY2tUeXBlOiBcInBhdGNoXCJ9KSlcblxuICAgIEJyb3dzZXIucHVzaFN0YXRlKGxpbmtTdGF0ZSwge1xuICAgICAgdHlwZTogXCJwYXRjaFwiLFxuICAgICAgaWQ6IHRoaXMubWFpbi5pZCxcbiAgICAgIHBvc2l0aW9uOiB0aGlzLmN1cnJlbnRIaXN0b3J5UG9zaXRpb25cbiAgICB9LCBocmVmKVxuXG4gICAgRE9NLmRpc3BhdGNoRXZlbnQod2luZG93LCBcInBoeDpuYXZpZ2F0ZVwiLCB7ZGV0YWlsOiB7cGF0Y2g6IHRydWUsIGhyZWYsIHBvcDogZmFsc2UsIGRpcmVjdGlvbjogXCJmb3J3YXJkXCJ9fSlcbiAgICB0aGlzLnJlZ2lzdGVyTmV3TG9jYXRpb24od2luZG93LmxvY2F0aW9uKVxuICB9XG5cbiAgaGlzdG9yeVJlZGlyZWN0KGUsIGhyZWYsIGxpbmtTdGF0ZSwgZmxhc2gsIHRhcmdldEVsKXtcbiAgICBjb25zdCBjbGlja0xvYWRpbmcgPSB0YXJnZXRFbCAmJiBlLmlzVHJ1c3RlZCAmJiBlLnR5cGUgIT09IFwicG9wc3RhdGVcIlxuICAgIGlmKGNsaWNrTG9hZGluZyl7IHRhcmdldEVsLmNsYXNzTGlzdC5hZGQoXCJwaHgtY2xpY2stbG9hZGluZ1wiKSB9XG4gICAgaWYoIXRoaXMuaXNDb25uZWN0ZWQoKSB8fCAhdGhpcy5tYWluLmlzTWFpbigpKXsgcmV0dXJuIEJyb3dzZXIucmVkaXJlY3QoaHJlZiwgZmxhc2gpIH1cblxuICAgIC8vIGNvbnZlcnQgdG8gZnVsbCBocmVmIGlmIG9ubHkgcGF0aCBwcmVmaXhcbiAgICBpZigvXlxcLyR8XlxcL1teXFwvXSsuKiQvLnRlc3QoaHJlZikpe1xuICAgICAgbGV0IHtwcm90b2NvbCwgaG9zdH0gPSB3aW5kb3cubG9jYXRpb25cbiAgICAgIGhyZWYgPSBgJHtwcm90b2NvbH0vLyR7aG9zdH0ke2hyZWZ9YFxuICAgIH1cbiAgICBsZXQgc2Nyb2xsID0gd2luZG93LnNjcm9sbFlcbiAgICB0aGlzLndpdGhQYWdlTG9hZGluZyh7dG86IGhyZWYsIGtpbmQ6IFwicmVkaXJlY3RcIn0sIGRvbmUgPT4ge1xuICAgICAgdGhpcy5yZXBsYWNlTWFpbihocmVmLCBmbGFzaCwgKGxpbmtSZWYpID0+IHtcbiAgICAgICAgaWYobGlua1JlZiA9PT0gdGhpcy5saW5rUmVmKXtcbiAgICAgICAgICAvLyBJbmNyZW1lbnQgcG9zaXRpb24gZm9yIG5ldyBzdGF0ZVxuICAgICAgICAgIHRoaXMuY3VycmVudEhpc3RvcnlQb3NpdGlvbisrXG4gICAgICAgICAgdGhpcy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFBIWF9MVl9ISVNUT1JZX1BPU0lUSU9OLCB0aGlzLmN1cnJlbnRIaXN0b3J5UG9zaXRpb24udG9TdHJpbmcoKSlcblxuICAgICAgICAgIC8vIHN0b3JlIHRoZSB0eXBlIGZvciBiYWNrIG5hdmlnYXRpb25cbiAgICAgICAgICBCcm93c2VyLnVwZGF0ZUN1cnJlbnRTdGF0ZSgoc3RhdGUpID0+ICh7Li4uc3RhdGUsIGJhY2tUeXBlOiBcInJlZGlyZWN0XCJ9KSlcblxuICAgICAgICAgIEJyb3dzZXIucHVzaFN0YXRlKGxpbmtTdGF0ZSwge1xuICAgICAgICAgICAgdHlwZTogXCJyZWRpcmVjdFwiLFxuICAgICAgICAgICAgaWQ6IHRoaXMubWFpbi5pZCxcbiAgICAgICAgICAgIHNjcm9sbDogc2Nyb2xsLFxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMuY3VycmVudEhpc3RvcnlQb3NpdGlvblxuICAgICAgICAgIH0sIGhyZWYpXG5cbiAgICAgICAgICBET00uZGlzcGF0Y2hFdmVudCh3aW5kb3csIFwicGh4Om5hdmlnYXRlXCIsIHtkZXRhaWw6IHtocmVmLCBwYXRjaDogZmFsc2UsIHBvcDogZmFsc2UsIGRpcmVjdGlvbjogXCJmb3J3YXJkXCJ9fSlcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyTmV3TG9jYXRpb24od2luZG93LmxvY2F0aW9uKVxuICAgICAgICB9XG4gICAgICAgIC8vIGV4cGxpY2l0bHkgdW5kbyBjbGljay1sb2FkaW5nIGNsYXNzXG4gICAgICAgIC8vIChpbiBjYXNlIGl0IG9yaWdpbmF0ZWQgaW4gYSBzdGlja3kgbGl2ZSB2aWV3LCBvdGhlcndpc2UgaXQgd291bGQgYmUgcmVtb3ZlZCBhbnl3YXkpXG4gICAgICAgIGlmKGNsaWNrTG9hZGluZyl7IHRhcmdldEVsLmNsYXNzTGlzdC5yZW1vdmUoXCJwaHgtY2xpY2stbG9hZGluZ1wiKSB9XG4gICAgICAgIGRvbmUoKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgcmVnaXN0ZXJOZXdMb2NhdGlvbihuZXdMb2NhdGlvbil7XG4gICAgbGV0IHtwYXRobmFtZSwgc2VhcmNofSA9IHRoaXMuY3VycmVudExvY2F0aW9uXG4gICAgaWYocGF0aG5hbWUgKyBzZWFyY2ggPT09IG5ld0xvY2F0aW9uLnBhdGhuYW1lICsgbmV3TG9jYXRpb24uc2VhcmNoKXtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN1cnJlbnRMb2NhdGlvbiA9IGNsb25lKG5ld0xvY2F0aW9uKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICBiaW5kRm9ybXMoKXtcbiAgICBsZXQgaXRlcmF0aW9ucyA9IDBcbiAgICBsZXQgZXh0ZXJuYWxGb3JtU3VibWl0dGVkID0gZmFsc2VcblxuICAgIC8vIGRpc2FibGUgZm9ybXMgb24gc3VibWl0IHRoYXQgdHJhY2sgcGh4LWNoYW5nZSBidXQgcGVyZm9ybSBleHRlcm5hbCBzdWJtaXRcbiAgICB0aGlzLm9uKFwic3VibWl0XCIsIGUgPT4ge1xuICAgICAgbGV0IHBoeFN1Ym1pdCA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJzdWJtaXRcIikpXG4gICAgICBsZXQgcGh4Q2hhbmdlID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhcImNoYW5nZVwiKSlcbiAgICAgIGlmKCFleHRlcm5hbEZvcm1TdWJtaXR0ZWQgJiYgcGh4Q2hhbmdlICYmICFwaHhTdWJtaXQpe1xuICAgICAgICBleHRlcm5hbEZvcm1TdWJtaXR0ZWQgPSB0cnVlXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICB0aGlzLndpdGhpbk93bmVycyhlLnRhcmdldCwgdmlldyA9PiB7XG4gICAgICAgICAgdmlldy5kaXNhYmxlRm9ybShlLnRhcmdldClcbiAgICAgICAgICAvLyBzYWZhcmkgbmVlZHMgbmV4dCB0aWNrXG4gICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICBpZihET00uaXNVbmxvYWRhYmxlRm9ybVN1Ym1pdChlKSl7IHRoaXMudW5sb2FkKCkgfVxuICAgICAgICAgICAgZS50YXJnZXQuc3VibWl0KClcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLm9uKFwic3VibWl0XCIsIGUgPT4ge1xuICAgICAgbGV0IHBoeEV2ZW50ID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhcInN1Ym1pdFwiKSlcbiAgICAgIGlmKCFwaHhFdmVudCl7XG4gICAgICAgIGlmKERPTS5pc1VubG9hZGFibGVGb3JtU3VibWl0KGUpKXsgdGhpcy51bmxvYWQoKSB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBlLnRhcmdldC5kaXNhYmxlZCA9IHRydWVcbiAgICAgIHRoaXMud2l0aGluT3duZXJzKGUudGFyZ2V0LCB2aWV3ID0+IHtcbiAgICAgICAgSlMuZXhlYyhlLCBcInN1Ym1pdFwiLCBwaHhFdmVudCwgdmlldywgZS50YXJnZXQsIFtcInB1c2hcIiwge3N1Ym1pdHRlcjogZS5zdWJtaXR0ZXJ9XSlcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGZvcihsZXQgdHlwZSBvZiBbXCJjaGFuZ2VcIiwgXCJpbnB1dFwiXSl7XG4gICAgICB0aGlzLm9uKHR5cGUsIGUgPT4ge1xuICAgICAgICBpZihlIGluc3RhbmNlb2YgQ3VzdG9tRXZlbnQgJiYgZS50YXJnZXQuZm9ybSA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAvLyB0aHJvdyBvbiBpbnZhbGlkIEpTLmRpc3BhdGNoIHRhcmdldCBhbmQgbm9vcCBpZiBDdXN0b21FdmVudCB0cmlnZ2VyZWQgb3V0c2lkZSBKUy5kaXNwYXRjaFxuICAgICAgICAgIGlmKGUuZGV0YWlsICYmIGUuZGV0YWlsLmRpc3BhdGNoZXIpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaXNwYXRjaGluZyBhIGN1c3RvbSAke3R5cGV9IGV2ZW50IGlzIG9ubHkgc3VwcG9ydGVkIG9uIGlucHV0IGVsZW1lbnRzIGluc2lkZSBhIGZvcm1gKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBsZXQgcGh4Q2hhbmdlID0gdGhpcy5iaW5kaW5nKFwiY2hhbmdlXCIpXG4gICAgICAgIGxldCBpbnB1dCA9IGUudGFyZ2V0XG4gICAgICAgIC8vIGRvIG5vdCBmaXJlIHBoeC1jaGFuZ2UgaWYgd2UgYXJlIGluIHRoZSBtaWRkbGUgb2YgYSBjb21wb3NpdGlvbiBzZXNzaW9uXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L2lzQ29tcG9zaW5nXG4gICAgICAgIC8vIFNhZmFyaSBoYXMgaXNzdWVzIGlmIHRoZSBpbnB1dCBpcyB1cGRhdGVkIHdoaWxlIGNvbXBvc2luZ1xuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3Bob2VuaXhmcmFtZXdvcmsvcGhvZW5peF9saXZlX3ZpZXcvaXNzdWVzLzMzMjJcbiAgICAgICAgaWYoZS5pc0NvbXBvc2luZyl7XG4gICAgICAgICAgY29uc3Qga2V5ID0gYGNvbXBvc2l0aW9uLWxpc3RlbmVyLSR7dHlwZX1gXG4gICAgICAgICAgaWYoIURPTS5wcml2YXRlKGlucHV0LCBrZXkpKXtcbiAgICAgICAgICAgIERPTS5wdXRQcml2YXRlKGlucHV0LCBrZXksIHRydWUpXG4gICAgICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY29tcG9zaXRpb25lbmRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAvLyB0cmlnZ2VyIGEgbmV3IGlucHV0L2NoYW5nZSBldmVudFxuICAgICAgICAgICAgICBpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCh0eXBlLCB7YnViYmxlczogdHJ1ZX0pKVxuICAgICAgICAgICAgICBET00uZGVsZXRlUHJpdmF0ZShpbnB1dCwga2V5KVxuICAgICAgICAgICAgfSwge29uY2U6IHRydWV9KVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5wdXRFdmVudCA9IGlucHV0LmdldEF0dHJpYnV0ZShwaHhDaGFuZ2UpXG4gICAgICAgIGxldCBmb3JtRXZlbnQgPSBpbnB1dC5mb3JtICYmIGlucHV0LmZvcm0uZ2V0QXR0cmlidXRlKHBoeENoYW5nZSlcbiAgICAgICAgbGV0IHBoeEV2ZW50ID0gaW5wdXRFdmVudCB8fCBmb3JtRXZlbnRcbiAgICAgICAgaWYoIXBoeEV2ZW50KXsgcmV0dXJuIH1cbiAgICAgICAgaWYoaW5wdXQudHlwZSA9PT0gXCJudW1iZXJcIiAmJiBpbnB1dC52YWxpZGl0eSAmJiBpbnB1dC52YWxpZGl0eS5iYWRJbnB1dCl7IHJldHVybiB9XG5cbiAgICAgICAgbGV0IGRpc3BhdGNoZXIgPSBpbnB1dEV2ZW50ID8gaW5wdXQgOiBpbnB1dC5mb3JtXG4gICAgICAgIGxldCBjdXJyZW50SXRlcmF0aW9ucyA9IGl0ZXJhdGlvbnNcbiAgICAgICAgaXRlcmF0aW9ucysrXG4gICAgICAgIGxldCB7YXQ6IGF0LCB0eXBlOiBsYXN0VHlwZX0gPSBET00ucHJpdmF0ZShpbnB1dCwgXCJwcmV2LWl0ZXJhdGlvblwiKSB8fCB7fVxuICAgICAgICAvLyBCcm93c2VycyBzaG91bGQgYWx3YXlzIGZpcmUgYXQgbGVhc3Qgb25lIFwiaW5wdXRcIiBldmVudCBiZWZvcmUgZXZlcnkgXCJjaGFuZ2VcIlxuICAgICAgICAvLyBJZ25vcmUgXCJjaGFuZ2VcIiBldmVudHMsIHVubGVzcyB0aGVyZSB3YXMgbm8gcHJpb3IgXCJpbnB1dFwiIGV2ZW50LlxuICAgICAgICAvLyBUaGlzIGNvdWxkIGhhcHBlbiBpZiB1c2VyIGNvZGUgdHJpZ2dlcnMgYSBcImNoYW5nZVwiIGV2ZW50LCBvciBpZiB0aGUgYnJvd3NlciBpcyBub24tY29uZm9ybWluZy5cbiAgICAgICAgaWYoYXQgPT09IGN1cnJlbnRJdGVyYXRpb25zIC0gMSAmJiB0eXBlID09PSBcImNoYW5nZVwiICYmIGxhc3RUeXBlID09PSBcImlucHV0XCIpeyByZXR1cm4gfVxuXG4gICAgICAgIERPTS5wdXRQcml2YXRlKGlucHV0LCBcInByZXYtaXRlcmF0aW9uXCIsIHthdDogY3VycmVudEl0ZXJhdGlvbnMsIHR5cGU6IHR5cGV9KVxuXG4gICAgICAgIHRoaXMuZGVib3VuY2UoaW5wdXQsIGUsIHR5cGUsICgpID0+IHtcbiAgICAgICAgICB0aGlzLndpdGhpbk93bmVycyhkaXNwYXRjaGVyLCB2aWV3ID0+IHtcbiAgICAgICAgICAgIERPTS5wdXRQcml2YXRlKGlucHV0LCBQSFhfSEFTX0ZPQ1VTRUQsIHRydWUpXG4gICAgICAgICAgICBKUy5leGVjKGUsIFwiY2hhbmdlXCIsIHBoeEV2ZW50LCB2aWV3LCBpbnB1dCwgW1wicHVzaFwiLCB7X3RhcmdldDogZS50YXJnZXQubmFtZSwgZGlzcGF0Y2hlcjogZGlzcGF0Y2hlcn1dKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cbiAgICB0aGlzLm9uKFwicmVzZXRcIiwgKGUpID0+IHtcbiAgICAgIGxldCBmb3JtID0gZS50YXJnZXRcbiAgICAgIERPTS5yZXNldEZvcm0oZm9ybSlcbiAgICAgIGxldCBpbnB1dCA9IEFycmF5LmZyb20oZm9ybS5lbGVtZW50cykuZmluZChlbCA9PiBlbC50eXBlID09PSBcInJlc2V0XCIpXG4gICAgICBpZihpbnB1dCl7XG4gICAgICAgIC8vIHdhaXQgdW50aWwgbmV4dCB0aWNrIHRvIGdldCB1cGRhdGVkIGlucHV0IHZhbHVlXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIGlucHV0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiaW5wdXRcIiwge2J1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IGZhbHNlfSkpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGRlYm91bmNlKGVsLCBldmVudCwgZXZlbnRUeXBlLCBjYWxsYmFjayl7XG4gICAgaWYoZXZlbnRUeXBlID09PSBcImJsdXJcIiB8fCBldmVudFR5cGUgPT09IFwiZm9jdXNvdXRcIil7IHJldHVybiBjYWxsYmFjaygpIH1cblxuICAgIGxldCBwaHhEZWJvdW5jZSA9IHRoaXMuYmluZGluZyhQSFhfREVCT1VOQ0UpXG4gICAgbGV0IHBoeFRocm90dGxlID0gdGhpcy5iaW5kaW5nKFBIWF9USFJPVFRMRSlcbiAgICBsZXQgZGVmYXVsdERlYm91bmNlID0gdGhpcy5kZWZhdWx0cy5kZWJvdW5jZS50b1N0cmluZygpXG4gICAgbGV0IGRlZmF1bHRUaHJvdHRsZSA9IHRoaXMuZGVmYXVsdHMudGhyb3R0bGUudG9TdHJpbmcoKVxuXG4gICAgdGhpcy53aXRoaW5Pd25lcnMoZWwsIHZpZXcgPT4ge1xuICAgICAgbGV0IGFzeW5jRmlsdGVyID0gKCkgPT4gIXZpZXcuaXNEZXN0cm95ZWQoKSAmJiBkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGVsKVxuICAgICAgRE9NLmRlYm91bmNlKGVsLCBldmVudCwgcGh4RGVib3VuY2UsIGRlZmF1bHREZWJvdW5jZSwgcGh4VGhyb3R0bGUsIGRlZmF1bHRUaHJvdHRsZSwgYXN5bmNGaWx0ZXIsICgpID0+IHtcbiAgICAgICAgY2FsbGJhY2soKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgc2lsZW5jZUV2ZW50cyhjYWxsYmFjayl7XG4gICAgdGhpcy5zaWxlbmNlZCA9IHRydWVcbiAgICBjYWxsYmFjaygpXG4gICAgdGhpcy5zaWxlbmNlZCA9IGZhbHNlXG4gIH1cblxuICBvbihldmVudCwgY2FsbGJhY2spe1xuICAgIHRoaXMuYm91bmRFdmVudE5hbWVzLmFkZChldmVudClcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZSA9PiB7XG4gICAgICBpZighdGhpcy5zaWxlbmNlZCl7IGNhbGxiYWNrKGUpIH1cbiAgICB9KVxuICB9XG5cbiAganNRdWVyeVNlbGVjdG9yQWxsKHNvdXJjZUVsLCBxdWVyeSwgZGVmYXVsdFF1ZXJ5KXtcbiAgICBsZXQgYWxsID0gdGhpcy5kb21DYWxsYmFja3MuanNRdWVyeVNlbGVjdG9yQWxsXG4gICAgcmV0dXJuIGFsbCA/IGFsbChzb3VyY2VFbCwgcXVlcnksIGRlZmF1bHRRdWVyeSkgOiBkZWZhdWx0UXVlcnkoKVxuICB9XG59XG5cbmNsYXNzIFRyYW5zaXRpb25TZXQge1xuICBjb25zdHJ1Y3Rvcigpe1xuICAgIHRoaXMudHJhbnNpdGlvbnMgPSBuZXcgU2V0KClcbiAgICB0aGlzLnBlbmRpbmdPcHMgPSBbXVxuICB9XG5cbiAgcmVzZXQoKXtcbiAgICB0aGlzLnRyYW5zaXRpb25zLmZvckVhY2godGltZXIgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKVxuICAgICAgdGhpcy50cmFuc2l0aW9ucy5kZWxldGUodGltZXIpXG4gICAgfSlcbiAgICB0aGlzLmZsdXNoUGVuZGluZ09wcygpXG4gIH1cblxuICBhZnRlcihjYWxsYmFjayl7XG4gICAgaWYodGhpcy5zaXplKCkgPT09IDApe1xuICAgICAgY2FsbGJhY2soKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2hQZW5kaW5nT3AoY2FsbGJhY2spXG4gICAgfVxuICB9XG5cbiAgYWRkVHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUpe1xuICAgIG9uU3RhcnQoKVxuICAgIGxldCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy50cmFuc2l0aW9ucy5kZWxldGUodGltZXIpXG4gICAgICBvbkRvbmUoKVxuICAgICAgdGhpcy5mbHVzaFBlbmRpbmdPcHMoKVxuICAgIH0sIHRpbWUpXG4gICAgdGhpcy50cmFuc2l0aW9ucy5hZGQodGltZXIpXG4gIH1cblxuICBwdXNoUGVuZGluZ09wKG9wKXsgdGhpcy5wZW5kaW5nT3BzLnB1c2gob3ApIH1cblxuICBzaXplKCl7IHJldHVybiB0aGlzLnRyYW5zaXRpb25zLnNpemUgfVxuXG4gIGZsdXNoUGVuZGluZ09wcygpe1xuICAgIGlmKHRoaXMuc2l6ZSgpID4gMCl7IHJldHVybiB9XG4gICAgbGV0IG9wID0gdGhpcy5wZW5kaW5nT3BzLnNoaWZ0KClcbiAgICBpZihvcCl7XG4gICAgICBvcCgpXG4gICAgICB0aGlzLmZsdXNoUGVuZGluZ09wcygpXG4gICAgfVxuICB9XG59XG4iLCAiLypcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5QaG9lbml4IExpdmVWaWV3IEphdmFTY3JpcHQgQ2xpZW50XG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5TZWUgdGhlIGhleGRvY3MgYXQgYGh0dHBzOi8vaGV4ZG9jcy5wbS9waG9lbml4X2xpdmVfdmlld2AgZm9yIGRvY3VtZW50YXRpb24uXG5cbiovXG5cbmltcG9ydCBMaXZlU29ja2V0LCB7aXNVc2VkSW5wdXR9IGZyb20gXCIuL2xpdmVfc29ja2V0XCJcbmltcG9ydCBET00gZnJvbSBcIi4vZG9tXCJcbmltcG9ydCBWaWV3SG9vayBmcm9tIFwiLi92aWV3X2hvb2tcIlxuaW1wb3J0IFZpZXcgZnJvbSBcIi4vdmlld1wiXG5cbi8qKiBDcmVhdGVzIGEgVmlld0hvb2sgaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBlbGVtZW50IGFuZCBjYWxsYmFja3MuXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgLSBUaGUgZWxlbWVudCB0byBhc3NvY2lhdGUgd2l0aCB0aGUgaG9vay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY2FsbGJhY2tzXSAtIFRoZSBsaXN0IG9mIGhvb2sgY2FsbGJhY2tzLCBzdWNoIGFzIG1vdW50ZWQsXG4gKiAgIHVwZGF0ZWQsIGRlc3Ryb3llZCwgZXRjLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogY2xhc3MgTXlDb21wb25lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gKiAgIGNvbm5lY3RlZENhbGxiYWNrKCl7XG4gKiAgICAgbGV0IG9uTGl2ZVZpZXdNb3VudGVkID0gKCkgPT4gdGhpcy5ob29rLnB1c2hFdmVudCguLi4pKVxuICogICAgIHRoaXMuaG9vayA9IGNyZWF0ZUhvb2sodGhpcywge21vdW50ZWQ6IG9uTGl2ZVZpZXdNb3VudGVkfSlcbiAqICAgfVxuICogfVxuICpcbiAqICpOb3RlKjogYGNyZWF0ZUhvb2tgIG11c3QgYmUgY2FsbGVkIGZyb20gdGhlIGBjb25uZWN0ZWRDYWxsYmFja2AgbGlmZWN5Y2xlXG4gKiB3aGljaCBpcyB0cmlnZ2VyZWQgYWZ0ZXIgdGhlIGVsZW1lbnQgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIERPTS4gSWYgeW91IHRyeVxuICogdG8gY2FsbCBgY3JlYXRlSG9va2AgZnJvbSB0aGUgY29uc3RydWN0b3IsIGFuIGVycm9yIHdpbGwgYmUgbG9nZ2VkLlxuICpcbiAqIEByZXR1cm5zIHtWaWV3SG9va30gUmV0dXJucyB0aGUgVmlld0hvb2sgaW5zdGFuY2UgZm9yIHRoZSBjdXN0b20gZWxlbWVudC5cbiAqL1xubGV0IGNyZWF0ZUhvb2sgPSAoZWwsIGNhbGxiYWNrcyA9IHt9KSA9PiB7XG4gIGxldCBleGlzdGluZ0hvb2sgPSBET00uZ2V0Q3VzdG9tRWxIb29rKGVsKVxuICBpZihleGlzdGluZ0hvb2speyByZXR1cm4gZXhpc3RpbmdIb29rIH1cblxuICBsZXQgaG9vayA9IG5ldyBWaWV3SG9vayhWaWV3LmNsb3Nlc3RWaWV3KGVsKSwgZWwsIGNhbGxiYWNrcylcbiAgRE9NLnB1dEN1c3RvbUVsSG9vayhlbCwgaG9vaylcbiAgcmV0dXJuIGhvb2tcbn1cblxuZXhwb3J0IHtcbiAgTGl2ZVNvY2tldCxcbiAgaXNVc2VkSW5wdXQsXG4gIGNyZWF0ZUhvb2tcbn1cbiIsICIvLyBJZiB5b3Ugd2FudCB0byB1c2UgUGhvZW5peCBjaGFubmVscywgcnVuIGBtaXggaGVscCBwaHguZ2VuLmNoYW5uZWxgXG4vLyB0byBnZXQgc3RhcnRlZCBhbmQgdGhlbiB1bmNvbW1lbnQgdGhlIGxpbmUgYmVsb3cuXG4vLyBpbXBvcnQgXCIuL3VzZXJfc29ja2V0LmpzXCJcblxuLy8gWW91IGNhbiBpbmNsdWRlIGRlcGVuZGVuY2llcyBpbiB0d28gd2F5cy5cbi8vXG4vLyBUaGUgc2ltcGxlc3Qgb3B0aW9uIGlzIHRvIHB1dCB0aGVtIGluIGFzc2V0cy92ZW5kb3IgYW5kXG4vLyBpbXBvcnQgdGhlbSB1c2luZyByZWxhdGl2ZSBwYXRoczpcbi8vXG4vLyAgICAgaW1wb3J0IFwiLi4vdmVuZG9yL3NvbWUtcGFja2FnZS5qc1wiXG4vL1xuLy8gQWx0ZXJuYXRpdmVseSwgeW91IGNhbiBgbnBtIGluc3RhbGwgc29tZS1wYWNrYWdlIC0tcHJlZml4IGFzc2V0c2AgYW5kIGltcG9ydFxuLy8gdGhlbSB1c2luZyBhIHBhdGggc3RhcnRpbmcgd2l0aCB0aGUgcGFja2FnZSBuYW1lOlxuLy9cbi8vICAgICBpbXBvcnQgXCJzb21lLXBhY2thZ2VcIlxuLy9cblxuLy8gSW5jbHVkZSBwaG9lbml4X2h0bWwgdG8gaGFuZGxlIG1ldGhvZD1QVVQvREVMRVRFIGluIGZvcm1zIGFuZCBidXR0b25zLlxuaW1wb3J0IFwicGhvZW5peF9odG1sXCJcbi8vIEVzdGFibGlzaCBQaG9lbml4IFNvY2tldCBhbmQgTGl2ZVZpZXcgY29uZmlndXJhdGlvbi5cbmltcG9ydCB7U29ja2V0fSBmcm9tIFwicGhvZW5peFwiXG5pbXBvcnQge0xpdmVTb2NrZXR9IGZyb20gXCJwaG9lbml4X2xpdmVfdmlld1wiXG5pbXBvcnQgdG9wYmFyIGZyb20gXCIuLi92ZW5kb3IvdG9wYmFyXCJcblxuaW1wb3J0IEF1ZGlvUGxheWVyIGZyb20gXCIuL2F1ZGlvX3BsYXllclwiXG5pbXBvcnQgSGFsZkdhdWdlIGZyb20gXCIuL2hhbGZfZ2F1Z2VcIlxuaW1wb3J0IExldHRlckdhdWdlIGZyb20gXCIuL2xldHRlcl9nYXVnZVwiXG5pbXBvcnQgUHJvZ3Jlc3NCYXIgZnJvbSBcIi4vcHJvZ3Jlc3NzX2JhclwiXG5pbXBvcnQgVmlkZW9QbGF5ZXIgZnJvbSBcIi4vdmlkZW9fcGxheWVyXCJcbmltcG9ydCBDb250cm9sUGxheSBmcm9tIFwiLi9jb250cm9sX3BsYXlcIlxuaW1wb3J0IFNjcm9sbEludG8gZnJvbSBcIi4vc2Nyb2xsX2ludG9fdmlkZW9cIlxuXG5sZXQgaG9va3MgPSB7fVxuaG9va3MuQXVkaW9QbGF5ZXIgPSBBdWRpb1BsYXllclxuaG9va3MuSGFsZkdhdWdlID0gSGFsZkdhdWdlXG5ob29rcy5MZXR0ZXJHYXVnZSA9IExldHRlckdhdWdlXG5ob29rcy5Qcm9ncmVzc0JhciA9IFByb2dyZXNzQmFyXG5ob29rcy5WaWRlb1BsYXllciA9IFZpZGVvUGxheWVyXG5ob29rcy5Db250cm9sUGxheSA9IENvbnRyb2xQbGF5XG5ob29rcy5TY3JvbGxJbnRvID0gU2Nyb2xsSW50b1xuXG5cbmxldCBjc3JmVG9rZW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibWV0YVtuYW1lPSdjc3JmLXRva2VuJ11cIikuZ2V0QXR0cmlidXRlKFwiY29udGVudFwiKVxubGV0IGxpdmVTb2NrZXQgPSBuZXcgTGl2ZVNvY2tldChcIi9saXZlXCIsIFNvY2tldCwge1xuICBob29rczogaG9va3MsXG4gIGxvbmdQb2xsRmFsbGJhY2tNczogMjUwMCxcbiAgcGFyYW1zOiB7X2NzcmZfdG9rZW46IGNzcmZUb2tlbn1cbn0pXG5cbi8vIFNob3cgcHJvZ3Jlc3MgYmFyIG9uIGxpdmUgbmF2aWdhdGlvbiBhbmQgZm9ybSBzdWJtaXRzXG50b3BiYXIuY29uZmlnKHtiYXJDb2xvcnM6IHswOiBcIiMyOWRcIn0sIHNoYWRvd0NvbG9yOiBcInJnYmEoMCwgMCwgMCwgLjMpXCJ9KVxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwaHg6cGFnZS1sb2FkaW5nLXN0YXJ0XCIsIF9pbmZvID0+IHRvcGJhci5zaG93KDMwMCkpXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBoeDpwYWdlLWxvYWRpbmctc3RvcFwiLCBfaW5mbyA9PiB0b3BiYXIuaGlkZSgpKVxuXG4vLyBjb25uZWN0IGlmIHRoZXJlIGFyZSBhbnkgTGl2ZVZpZXdzIG9uIHRoZSBwYWdlXG5saXZlU29ja2V0LmNvbm5lY3QoKVxuXG4vLyBleHBvc2UgbGl2ZVNvY2tldCBvbiB3aW5kb3cgZm9yIHdlYiBjb25zb2xlIGRlYnVnIGxvZ3MgYW5kIGxhdGVuY3kgc2ltdWxhdGlvbjpcbi8vID4+IGxpdmVTb2NrZXQuZW5hYmxlRGVidWcoKVxuLy8gPj4gbGl2ZVNvY2tldC5lbmFibGVMYXRlbmN5U2ltKDEwMDApICAvLyBlbmFibGVkIGZvciBkdXJhdGlvbiBvZiBicm93c2VyIHNlc3Npb25cbi8vID4+IGxpdmVTb2NrZXQuZGlzYWJsZUxhdGVuY3lTaW0oKVxud2luZG93LmxpdmVTb2NrZXQgPSBsaXZlU29ja2V0XG5cbiIsICJmdW5jdGlvbiB0KHQsZSxpLHMpe3JldHVybiBuZXcoaXx8KGk9UHJvbWlzZSkpKChmdW5jdGlvbihuLHIpe2Z1bmN0aW9uIG8odCl7dHJ5e2gocy5uZXh0KHQpKX1jYXRjaCh0KXtyKHQpfX1mdW5jdGlvbiBhKHQpe3RyeXtoKHMudGhyb3codCkpfWNhdGNoKHQpe3IodCl9fWZ1bmN0aW9uIGgodCl7dmFyIGU7dC5kb25lP24odC52YWx1ZSk6KGU9dC52YWx1ZSxlIGluc3RhbmNlb2YgaT9lOm5ldyBpKChmdW5jdGlvbih0KXt0KGUpfSkpKS50aGVuKG8sYSl9aCgocz1zLmFwcGx5KHQsZXx8W10pKS5uZXh0KCkpfSkpfVwiZnVuY3Rpb25cIj09dHlwZW9mIFN1cHByZXNzZWRFcnJvciYmU3VwcHJlc3NlZEVycm9yO2NsYXNzIGV7Y29uc3RydWN0b3IoKXt0aGlzLmxpc3RlbmVycz17fX1vbih0LGUsaSl7aWYodGhpcy5saXN0ZW5lcnNbdF18fCh0aGlzLmxpc3RlbmVyc1t0XT1uZXcgU2V0KSx0aGlzLmxpc3RlbmVyc1t0XS5hZGQoZSksbnVsbD09aT92b2lkIDA6aS5vbmNlKXtjb25zdCBpPSgpPT57dGhpcy51bih0LGkpLHRoaXMudW4odCxlKX07cmV0dXJuIHRoaXMub24odCxpKSxpfXJldHVybigpPT50aGlzLnVuKHQsZSl9dW4odCxlKXt2YXIgaTtudWxsPT09KGk9dGhpcy5saXN0ZW5lcnNbdF0pfHx2b2lkIDA9PT1pfHxpLmRlbGV0ZShlKX1vbmNlKHQsZSl7cmV0dXJuIHRoaXMub24odCxlLHtvbmNlOiEwfSl9dW5BbGwoKXt0aGlzLmxpc3RlbmVycz17fX1lbWl0KHQsLi4uZSl7dGhpcy5saXN0ZW5lcnNbdF0mJnRoaXMubGlzdGVuZXJzW3RdLmZvckVhY2goKHQ9PnQoLi4uZSkpKX19Y29uc3QgaT17ZGVjb2RlOmZ1bmN0aW9uKGUsaSl7cmV0dXJuIHQodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtjb25zdCB0PW5ldyBBdWRpb0NvbnRleHQoe3NhbXBsZVJhdGU6aX0pO3JldHVybiB0LmRlY29kZUF1ZGlvRGF0YShlKS5maW5hbGx5KCgoKT0+dC5jbG9zZSgpKSl9KSl9LGNyZWF0ZUJ1ZmZlcjpmdW5jdGlvbih0LGUpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0WzBdJiYodD1bdF0pLGZ1bmN0aW9uKHQpe2NvbnN0IGU9dFswXTtpZihlLnNvbWUoKHQ9PnQ+MXx8dDwtMSkpKXtjb25zdCBpPWUubGVuZ3RoO2xldCBzPTA7Zm9yKGxldCB0PTA7dDxpO3QrKyl7Y29uc3QgaT1NYXRoLmFicyhlW3RdKTtpPnMmJihzPWkpfWZvcihjb25zdCBlIG9mIHQpZm9yKGxldCB0PTA7dDxpO3QrKyllW3RdLz1zfX0odCkse2R1cmF0aW9uOmUsbGVuZ3RoOnRbMF0ubGVuZ3RoLHNhbXBsZVJhdGU6dFswXS5sZW5ndGgvZSxudW1iZXJPZkNoYW5uZWxzOnQubGVuZ3RoLGdldENoYW5uZWxEYXRhOmU9Pm51bGw9PXQ/dm9pZCAwOnRbZV0sY29weUZyb21DaGFubmVsOkF1ZGlvQnVmZmVyLnByb3RvdHlwZS5jb3B5RnJvbUNoYW5uZWwsY29weVRvQ2hhbm5lbDpBdWRpb0J1ZmZlci5wcm90b3R5cGUuY29weVRvQ2hhbm5lbH19fTtmdW5jdGlvbiBzKHQsZSl7Y29uc3QgaT1lLnhtbG5zP2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhlLnhtbG5zLHQpOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodCk7Zm9yKGNvbnN0W3Qsbl1vZiBPYmplY3QuZW50cmllcyhlKSlpZihcImNoaWxkcmVuXCI9PT10KWZvcihjb25zdFt0LG5db2YgT2JqZWN0LmVudHJpZXMoZSkpXCJzdHJpbmdcIj09dHlwZW9mIG4/aS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShuKSk6aS5hcHBlbmRDaGlsZChzKHQsbikpO2Vsc2VcInN0eWxlXCI9PT10P09iamVjdC5hc3NpZ24oaS5zdHlsZSxuKTpcInRleHRDb250ZW50XCI9PT10P2kudGV4dENvbnRlbnQ9bjppLnNldEF0dHJpYnV0ZSh0LG4udG9TdHJpbmcoKSk7cmV0dXJuIGl9ZnVuY3Rpb24gbih0LGUsaSl7Y29uc3Qgbj1zKHQsZXx8e30pO3JldHVybiBudWxsPT1pfHxpLmFwcGVuZENoaWxkKG4pLG59dmFyIHI9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsY3JlYXRlRWxlbWVudDpuLGRlZmF1bHQ6bn0pO2NvbnN0IG89e2ZldGNoQmxvYjpmdW5jdGlvbihlLGkscyl7cmV0dXJuIHQodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtjb25zdCBuPXlpZWxkIGZldGNoKGUscyk7aWYobi5zdGF0dXM+PTQwMCl0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCAke2V9OiAke24uc3RhdHVzfSAoJHtuLnN0YXR1c1RleHR9KWApO3JldHVybiBmdW5jdGlvbihlLGkpe3QodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtpZighZS5ib2R5fHwhZS5oZWFkZXJzKXJldHVybjtjb25zdCBzPWUuYm9keS5nZXRSZWFkZXIoKSxuPU51bWJlcihlLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1MZW5ndGhcIikpfHwwO2xldCByPTA7Y29uc3Qgbz1lPT50KHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7cis9KG51bGw9PWU/dm9pZCAwOmUubGVuZ3RoKXx8MDtjb25zdCB0PU1hdGgucm91bmQoci9uKjEwMCk7aSh0KX0pKSxhPSgpPT50KHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7bGV0IHQ7dHJ5e3Q9eWllbGQgcy5yZWFkKCl9Y2F0Y2godCl7cmV0dXJufXQuZG9uZXx8KG8odC52YWx1ZSkseWllbGQgYSgpKX0pKTthKCl9KSl9KG4uY2xvbmUoKSxpKSxuLmJsb2IoKX0pKX19O2NsYXNzIGEgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy5pc0V4dGVybmFsTWVkaWE9ITEsdC5tZWRpYT8odGhpcy5tZWRpYT10Lm1lZGlhLHRoaXMuaXNFeHRlcm5hbE1lZGlhPSEwKTp0aGlzLm1lZGlhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhdWRpb1wiKSx0Lm1lZGlhQ29udHJvbHMmJih0aGlzLm1lZGlhLmNvbnRyb2xzPSEwKSx0LmF1dG9wbGF5JiYodGhpcy5tZWRpYS5hdXRvcGxheT0hMCksbnVsbCE9dC5wbGF5YmFja1JhdGUmJnRoaXMub25NZWRpYUV2ZW50KFwiY2FucGxheVwiLCgoKT0+e251bGwhPXQucGxheWJhY2tSYXRlJiYodGhpcy5tZWRpYS5wbGF5YmFja1JhdGU9dC5wbGF5YmFja1JhdGUpfSkse29uY2U6ITB9KX1vbk1lZGlhRXZlbnQodCxlLGkpe3JldHVybiB0aGlzLm1lZGlhLmFkZEV2ZW50TGlzdGVuZXIodCxlLGkpLCgpPT50aGlzLm1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIodCxlLGkpfWdldFNyYygpe3JldHVybiB0aGlzLm1lZGlhLmN1cnJlbnRTcmN8fHRoaXMubWVkaWEuc3JjfHxcIlwifXJldm9rZVNyYygpe2NvbnN0IHQ9dGhpcy5nZXRTcmMoKTt0LnN0YXJ0c1dpdGgoXCJibG9iOlwiKSYmVVJMLnJldm9rZU9iamVjdFVSTCh0KX1jYW5QbGF5VHlwZSh0KXtyZXR1cm5cIlwiIT09dGhpcy5tZWRpYS5jYW5QbGF5VHlwZSh0KX1zZXRTcmModCxlKXtjb25zdCBpPXRoaXMuZ2V0U3JjKCk7aWYodCYmaT09PXQpcmV0dXJuO3RoaXMucmV2b2tlU3JjKCk7Y29uc3Qgcz1lIGluc3RhbmNlb2YgQmxvYiYmKHRoaXMuY2FuUGxheVR5cGUoZS50eXBlKXx8IXQpP1VSTC5jcmVhdGVPYmplY3RVUkwoZSk6dDtpJiYodGhpcy5tZWRpYS5zcmM9XCJcIik7dHJ5e3RoaXMubWVkaWEuc3JjPXN9Y2F0Y2goZSl7dGhpcy5tZWRpYS5zcmM9dH19ZGVzdHJveSgpe3RoaXMuaXNFeHRlcm5hbE1lZGlhfHwodGhpcy5tZWRpYS5wYXVzZSgpLHRoaXMubWVkaWEucmVtb3ZlKCksdGhpcy5yZXZva2VTcmMoKSx0aGlzLm1lZGlhLnNyYz1cIlwiLHRoaXMubWVkaWEubG9hZCgpKX1zZXRNZWRpYUVsZW1lbnQodCl7dGhpcy5tZWRpYT10fXBsYXkoKXtyZXR1cm4gdCh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe3JldHVybiB0aGlzLm1lZGlhLnBsYXkoKX0pKX1wYXVzZSgpe3RoaXMubWVkaWEucGF1c2UoKX1pc1BsYXlpbmcoKXtyZXR1cm4hdGhpcy5tZWRpYS5wYXVzZWQmJiF0aGlzLm1lZGlhLmVuZGVkfXNldFRpbWUodCl7dGhpcy5tZWRpYS5jdXJyZW50VGltZT10fWdldER1cmF0aW9uKCl7cmV0dXJuIHRoaXMubWVkaWEuZHVyYXRpb259Z2V0Q3VycmVudFRpbWUoKXtyZXR1cm4gdGhpcy5tZWRpYS5jdXJyZW50VGltZX1nZXRWb2x1bWUoKXtyZXR1cm4gdGhpcy5tZWRpYS52b2x1bWV9c2V0Vm9sdW1lKHQpe3RoaXMubWVkaWEudm9sdW1lPXR9Z2V0TXV0ZWQoKXtyZXR1cm4gdGhpcy5tZWRpYS5tdXRlZH1zZXRNdXRlZCh0KXt0aGlzLm1lZGlhLm11dGVkPXR9Z2V0UGxheWJhY2tSYXRlKCl7cmV0dXJuIHRoaXMubWVkaWEucGxheWJhY2tSYXRlfWlzU2Vla2luZygpe3JldHVybiB0aGlzLm1lZGlhLnNlZWtpbmd9c2V0UGxheWJhY2tSYXRlKHQsZSl7bnVsbCE9ZSYmKHRoaXMubWVkaWEucHJlc2VydmVzUGl0Y2g9ZSksdGhpcy5tZWRpYS5wbGF5YmFja1JhdGU9dH1nZXRNZWRpYUVsZW1lbnQoKXtyZXR1cm4gdGhpcy5tZWRpYX1zZXRTaW5rSWQodCl7cmV0dXJuIHRoaXMubWVkaWEuc2V0U2lua0lkKHQpfX1jbGFzcyBoIGV4dGVuZHMgZXtjb25zdHJ1Y3Rvcih0LGUpe3N1cGVyKCksdGhpcy50aW1lb3V0cz1bXSx0aGlzLmlzU2Nyb2xsYWJsZT0hMSx0aGlzLmF1ZGlvRGF0YT1udWxsLHRoaXMucmVzaXplT2JzZXJ2ZXI9bnVsbCx0aGlzLmxhc3RDb250YWluZXJXaWR0aD0wLHRoaXMuaXNEcmFnZ2luZz0hMSx0aGlzLnN1YnNjcmlwdGlvbnM9W10sdGhpcy51bnN1YnNjcmliZU9uU2Nyb2xsPVtdLHRoaXMuc3Vic2NyaXB0aW9ucz1bXSx0aGlzLm9wdGlvbnM9dDtjb25zdCBpPXRoaXMucGFyZW50RnJvbU9wdGlvbnNDb250YWluZXIodC5jb250YWluZXIpO3RoaXMucGFyZW50PWk7Y29uc3RbcyxuXT10aGlzLmluaXRIdG1sKCk7aS5hcHBlbmRDaGlsZChzKSx0aGlzLmNvbnRhaW5lcj1zLHRoaXMuc2Nyb2xsQ29udGFpbmVyPW4ucXVlcnlTZWxlY3RvcihcIi5zY3JvbGxcIiksdGhpcy53cmFwcGVyPW4ucXVlcnlTZWxlY3RvcihcIi53cmFwcGVyXCIpLHRoaXMuY2FudmFzV3JhcHBlcj1uLnF1ZXJ5U2VsZWN0b3IoXCIuY2FudmFzZXNcIiksdGhpcy5wcm9ncmVzc1dyYXBwZXI9bi5xdWVyeVNlbGVjdG9yKFwiLnByb2dyZXNzXCIpLHRoaXMuY3Vyc29yPW4ucXVlcnlTZWxlY3RvcihcIi5jdXJzb3JcIiksZSYmbi5hcHBlbmRDaGlsZChlKSx0aGlzLmluaXRFdmVudHMoKX1wYXJlbnRGcm9tT3B0aW9uc0NvbnRhaW5lcih0KXtsZXQgZTtpZihcInN0cmluZ1wiPT10eXBlb2YgdD9lPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodCk6dCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50JiYoZT10KSwhZSl0aHJvdyBuZXcgRXJyb3IoXCJDb250YWluZXIgbm90IGZvdW5kXCIpO3JldHVybiBlfWluaXRFdmVudHMoKXtjb25zdCB0PXQ9Pntjb25zdCBlPXRoaXMud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxpPXQuY2xpZW50WC1lLmxlZnQscz10LmNsaWVudFktZS50b3A7cmV0dXJuW2kvZS53aWR0aCxzL2UuaGVpZ2h0XX07aWYodGhpcy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLChlPT57Y29uc3RbaSxzXT10KGUpO3RoaXMuZW1pdChcImNsaWNrXCIsaSxzKX0pKSx0aGlzLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcihcImRibGNsaWNrXCIsKGU9Pntjb25zdFtpLHNdPXQoZSk7dGhpcy5lbWl0KFwiZGJsY2xpY2tcIixpLHMpfSkpLCEwIT09dGhpcy5vcHRpb25zLmRyYWdUb1NlZWsmJlwib2JqZWN0XCIhPXR5cGVvZiB0aGlzLm9wdGlvbnMuZHJhZ1RvU2Vla3x8dGhpcy5pbml0RHJhZygpLHRoaXMuc2Nyb2xsQ29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwoKCk9Pntjb25zdHtzY3JvbGxMZWZ0OnQsc2Nyb2xsV2lkdGg6ZSxjbGllbnRXaWR0aDppfT10aGlzLnNjcm9sbENvbnRhaW5lcixzPXQvZSxuPSh0K2kpL2U7dGhpcy5lbWl0KFwic2Nyb2xsXCIscyxuLHQsdCtpKX0pKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBSZXNpemVPYnNlcnZlcil7Y29uc3QgdD10aGlzLmNyZWF0ZURlbGF5KDEwMCk7dGhpcy5yZXNpemVPYnNlcnZlcj1uZXcgUmVzaXplT2JzZXJ2ZXIoKCgpPT57dCgpLnRoZW4oKCgpPT50aGlzLm9uQ29udGFpbmVyUmVzaXplKCkpKS5jYXRjaCgoKCk9Pnt9KSl9KSksdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuc2Nyb2xsQ29udGFpbmVyKX19b25Db250YWluZXJSZXNpemUoKXtjb25zdCB0PXRoaXMucGFyZW50LmNsaWVudFdpZHRoO3Q9PT10aGlzLmxhc3RDb250YWluZXJXaWR0aCYmXCJhdXRvXCIhPT10aGlzLm9wdGlvbnMuaGVpZ2h0fHwodGhpcy5sYXN0Q29udGFpbmVyV2lkdGg9dCx0aGlzLnJlUmVuZGVyKCkpfWluaXREcmFnKCl7dGhpcy5zdWJzY3JpcHRpb25zLnB1c2goZnVuY3Rpb24odCxlLGkscyxuPTMscj0wLG89MTAwKXtpZighdClyZXR1cm4oKT0+e307Y29uc3QgYT1tYXRjaE1lZGlhKFwiKHBvaW50ZXI6IGNvYXJzZSlcIikubWF0Y2hlcztsZXQgaD0oKT0+e307Y29uc3QgbD1sPT57aWYobC5idXR0b24hPT1yKXJldHVybjtsLnByZXZlbnREZWZhdWx0KCksbC5zdG9wUHJvcGFnYXRpb24oKTtsZXQgZD1sLmNsaWVudFgsYz1sLmNsaWVudFksdT0hMTtjb25zdCBwPURhdGUubm93KCksbT1zPT57aWYocy5wcmV2ZW50RGVmYXVsdCgpLHMuc3RvcFByb3BhZ2F0aW9uKCksYSYmRGF0ZS5ub3coKS1wPG8pcmV0dXJuO2NvbnN0IHI9cy5jbGllbnRYLGg9cy5jbGllbnRZLGw9ci1kLG09aC1jO2lmKHV8fE1hdGguYWJzKGwpPm58fE1hdGguYWJzKG0pPm4pe2NvbnN0IHM9dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSx7bGVmdDpuLHRvcDpvfT1zO3V8fChudWxsPT1pfHxpKGQtbixjLW8pLHU9ITApLGUobCxtLHItbixoLW8pLGQ9cixjPWh9fSxmPWU9PntpZih1KXtjb25zdCBpPWUuY2xpZW50WCxuPWUuY2xpZW50WSxyPXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkse2xlZnQ6byx0b3A6YX09cjtudWxsPT1zfHxzKGktbyxuLWEpfWgoKX0sZz10PT57dC5yZWxhdGVkVGFyZ2V0JiZ0LnJlbGF0ZWRUYXJnZXQhPT1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnR8fGYodCl9LHY9dD0+e3UmJih0LnN0b3BQcm9wYWdhdGlvbigpLHQucHJldmVudERlZmF1bHQoKSl9LGI9dD0+e3UmJnQucHJldmVudERlZmF1bHQoKX07ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsbSksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLGYpLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyb3V0XCIsZyksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJjYW5jZWxcIixnKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsYix7cGFzc2l2ZTohMX0pLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHYse2NhcHR1cmU6ITB9KSxoPSgpPT57ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsbSksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLGYpLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVyb3V0XCIsZyksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJjYW5jZWxcIixnKSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsYiksc2V0VGltZW91dCgoKCk9Pntkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIix2LHtjYXB0dXJlOiEwfSl9KSwxMCl9fTtyZXR1cm4gdC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIixsKSwoKT0+e2goKSx0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLGwpfX0odGhpcy53cmFwcGVyLCgodCxlLGkpPT57dGhpcy5lbWl0KFwiZHJhZ1wiLE1hdGgubWF4KDAsTWF0aC5taW4oMSxpL3RoaXMud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCkpKX0pLCh0PT57dGhpcy5pc0RyYWdnaW5nPSEwLHRoaXMuZW1pdChcImRyYWdzdGFydFwiLE1hdGgubWF4KDAsTWF0aC5taW4oMSx0L3RoaXMud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCkpKX0pLCh0PT57dGhpcy5pc0RyYWdnaW5nPSExLHRoaXMuZW1pdChcImRyYWdlbmRcIixNYXRoLm1heCgwLE1hdGgubWluKDEsdC90aGlzLndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgpKSl9KSkpfWdldEhlaWdodCh0LGUpe3ZhciBpO2NvbnN0IHM9KG51bGw9PT0oaT10aGlzLmF1ZGlvRGF0YSl8fHZvaWQgMD09PWk/dm9pZCAwOmkubnVtYmVyT2ZDaGFubmVscyl8fDE7aWYobnVsbD09dClyZXR1cm4gMTI4O2lmKCFpc05hTihOdW1iZXIodCkpKXJldHVybiBOdW1iZXIodCk7aWYoXCJhdXRvXCI9PT10KXtjb25zdCB0PXRoaXMucGFyZW50LmNsaWVudEhlaWdodHx8MTI4O3JldHVybihudWxsPT1lP3ZvaWQgMDplLmV2ZXJ5KCh0PT4hdC5vdmVybGF5KSkpP3Qvczp0fXJldHVybiAxMjh9aW5pdEh0bWwoKXtjb25zdCB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksZT10LmF0dGFjaFNoYWRvdyh7bW9kZTpcIm9wZW5cIn0pLGk9dGhpcy5vcHRpb25zLmNzcE5vbmNlJiZcInN0cmluZ1wiPT10eXBlb2YgdGhpcy5vcHRpb25zLmNzcE5vbmNlP3RoaXMub3B0aW9ucy5jc3BOb25jZS5yZXBsYWNlKC9cIi9nLFwiXCIpOlwiXCI7cmV0dXJuIGUuaW5uZXJIVE1MPWBcXG4gICAgICA8c3R5bGUke2k/YCBub25jZT1cIiR7aX1cImA6XCJcIn0+XFxuICAgICAgICA6aG9zdCB7XFxuICAgICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xcbiAgICAgICAgICBtaW4td2lkdGg6IDFweDtcXG4gICAgICAgIH1cXG4gICAgICAgIDpob3N0IGF1ZGlvIHtcXG4gICAgICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgICAgfVxcbiAgICAgICAgOmhvc3QgLnNjcm9sbCB7XFxuICAgICAgICAgIG92ZXJmbG93LXg6IGF1dG87XFxuICAgICAgICAgIG92ZXJmbG93LXk6IGhpZGRlbjtcXG4gICAgICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIDpob3N0IC5ub1Njcm9sbGJhciB7XFxuICAgICAgICAgIHNjcm9sbGJhci1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgICAgIHNjcm9sbGJhci13aWR0aDogbm9uZTtcXG4gICAgICAgIH1cXG4gICAgICAgIDpob3N0IC5ub1Njcm9sbGJhcjo6LXdlYmtpdC1zY3JvbGxiYXIge1xcbiAgICAgICAgICBkaXNwbGF5OiBub25lO1xcbiAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAgICAgICB9XFxuICAgICAgICA6aG9zdCAud3JhcHBlciB7XFxuICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgICAgICAgb3ZlcmZsb3c6IHZpc2libGU7XFxuICAgICAgICAgIHotaW5kZXg6IDI7XFxuICAgICAgICB9XFxuICAgICAgICA6aG9zdCAuY2FudmFzZXMge1xcbiAgICAgICAgICBtaW4taGVpZ2h0OiAke3RoaXMuZ2V0SGVpZ2h0KHRoaXMub3B0aW9ucy5oZWlnaHQsdGhpcy5vcHRpb25zLnNwbGl0Q2hhbm5lbHMpfXB4O1xcbiAgICAgICAgfVxcbiAgICAgICAgOmhvc3QgLmNhbnZhc2VzID4gZGl2IHtcXG4gICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgICAgfVxcbiAgICAgICAgOmhvc3QgY2FudmFzIHtcXG4gICAgICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgICAgdG9wOiAwO1xcbiAgICAgICAgICBpbWFnZS1yZW5kZXJpbmc6IHBpeGVsYXRlZDtcXG4gICAgICAgIH1cXG4gICAgICAgIDpob3N0IC5wcm9ncmVzcyB7XFxuICAgICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICAgIHotaW5kZXg6IDI7XFxuICAgICAgICAgIHRvcDogMDtcXG4gICAgICAgICAgbGVmdDogMDtcXG4gICAgICAgICAgd2lkdGg6IDA7XFxuICAgICAgICAgIGhlaWdodDogMTAwJTtcXG4gICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgICAgIH1cXG4gICAgICAgIDpob3N0IC5wcm9ncmVzcyA+IGRpdiB7XFxuICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIDpob3N0IC5jdXJzb3Ige1xcbiAgICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgICB6LWluZGV4OiA1O1xcbiAgICAgICAgICB0b3A6IDA7XFxuICAgICAgICAgIGxlZnQ6IDA7XFxuICAgICAgICAgIGhlaWdodDogMTAwJTtcXG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogMnB4O1xcbiAgICAgICAgfVxcbiAgICAgIDwvc3R5bGU+XFxuXFxuICAgICAgPGRpdiBjbGFzcz1cInNjcm9sbFwiIHBhcnQ9XCJzY3JvbGxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ3cmFwcGVyXCIgcGFydD1cIndyYXBwZXJcIj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNhbnZhc2VzXCIgcGFydD1cImNhbnZhc2VzXCI+PC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzc1wiIHBhcnQ9XCJwcm9ncmVzc1wiPjwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiY3Vyc29yXCIgcGFydD1cImN1cnNvclwiPjwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIGAsW3QsZV19c2V0T3B0aW9ucyh0KXtpZih0aGlzLm9wdGlvbnMuY29udGFpbmVyIT09dC5jb250YWluZXIpe2NvbnN0IGU9dGhpcy5wYXJlbnRGcm9tT3B0aW9uc0NvbnRhaW5lcih0LmNvbnRhaW5lcik7ZS5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lciksdGhpcy5wYXJlbnQ9ZX0hMCE9PXQuZHJhZ1RvU2VlayYmXCJvYmplY3RcIiE9dHlwZW9mIHRoaXMub3B0aW9ucy5kcmFnVG9TZWVrfHx0aGlzLmluaXREcmFnKCksdGhpcy5vcHRpb25zPXQsdGhpcy5yZVJlbmRlcigpfWdldFdyYXBwZXIoKXtyZXR1cm4gdGhpcy53cmFwcGVyfWdldFdpZHRoKCl7cmV0dXJuIHRoaXMuc2Nyb2xsQ29udGFpbmVyLmNsaWVudFdpZHRofWdldFNjcm9sbCgpe3JldHVybiB0aGlzLnNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0fXNldFNjcm9sbCh0KXt0aGlzLnNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0PXR9c2V0U2Nyb2xsUGVyY2VudGFnZSh0KXtjb25zdHtzY3JvbGxXaWR0aDplfT10aGlzLnNjcm9sbENvbnRhaW5lcixpPWUqdDt0aGlzLnNldFNjcm9sbChpKX1kZXN0cm95KCl7dmFyIHQsZTt0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaCgodD0+dCgpKSksdGhpcy5jb250YWluZXIucmVtb3ZlKCksbnVsbD09PSh0PXRoaXMucmVzaXplT2JzZXJ2ZXIpfHx2b2lkIDA9PT10fHx0LmRpc2Nvbm5lY3QoKSxudWxsPT09KGU9dGhpcy51bnN1YnNjcmliZU9uU2Nyb2xsKXx8dm9pZCAwPT09ZXx8ZS5mb3JFYWNoKCh0PT50KCkpKSx0aGlzLnVuc3Vic2NyaWJlT25TY3JvbGw9W119Y3JlYXRlRGVsYXkodD0xMCl7bGV0IGUsaTtjb25zdCBzPSgpPT57ZSYmY2xlYXJUaW1lb3V0KGUpLGkmJmkoKX07cmV0dXJuIHRoaXMudGltZW91dHMucHVzaChzKSwoKT0+bmV3IFByb21pc2UoKChuLHIpPT57cygpLGk9cixlPXNldFRpbWVvdXQoKCgpPT57ZT12b2lkIDAsaT12b2lkIDAsbigpfSksdCl9KSl9Y29udmVydENvbG9yVmFsdWVzKHQpe2lmKCFBcnJheS5pc0FycmF5KHQpKXJldHVybiB0fHxcIlwiO2lmKHQubGVuZ3RoPDIpcmV0dXJuIHRbMF18fFwiXCI7Y29uc3QgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLGk9ZS5nZXRDb250ZXh0KFwiMmRcIikscz1lLmhlaWdodCood2luZG93LmRldmljZVBpeGVsUmF0aW98fDEpLG49aS5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLDAsMCxzKSxyPTEvKHQubGVuZ3RoLTEpO3JldHVybiB0LmZvckVhY2goKCh0LGUpPT57Y29uc3QgaT1lKnI7bi5hZGRDb2xvclN0b3AoaSx0KX0pKSxufWdldFBpeGVsUmF0aW8oKXtyZXR1cm4gTWF0aC5tYXgoMSx3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb3x8MSl9cmVuZGVyQmFyV2F2ZWZvcm0odCxlLGkscyl7Y29uc3Qgbj10WzBdLHI9dFsxXXx8dFswXSxvPW4ubGVuZ3RoLHt3aWR0aDphLGhlaWdodDpofT1pLmNhbnZhcyxsPWgvMixkPXRoaXMuZ2V0UGl4ZWxSYXRpbygpLGM9ZS5iYXJXaWR0aD9lLmJhcldpZHRoKmQ6MSx1PWUuYmFyR2FwP2UuYmFyR2FwKmQ6ZS5iYXJXaWR0aD9jLzI6MCxwPWUuYmFyUmFkaXVzfHwwLG09YS8oYyt1KS9vLGY9cCYmXCJyb3VuZFJlY3RcImluIGk/XCJyb3VuZFJlY3RcIjpcInJlY3RcIjtpLmJlZ2luUGF0aCgpO2xldCBnPTAsdj0wLGI9MDtmb3IobGV0IHQ9MDt0PD1vO3QrKyl7Y29uc3Qgbz1NYXRoLnJvdW5kKHQqbSk7aWYobz5nKXtjb25zdCB0PU1hdGgucm91bmQodipsKnMpLG49dCtNYXRoLnJvdW5kKGIqbCpzKXx8MTtsZXQgcj1sLXQ7XCJ0b3BcIj09PWUuYmFyQWxpZ24/cj0wOlwiYm90dG9tXCI9PT1lLmJhckFsaWduJiYocj1oLW4pLGlbZl0oZyooYyt1KSxyLGMsbixwKSxnPW8sdj0wLGI9MH1jb25zdCBhPU1hdGguYWJzKG5bdF18fDApLGQ9TWF0aC5hYnMoclt0XXx8MCk7YT52JiYodj1hKSxkPmImJihiPWQpfWkuZmlsbCgpLGkuY2xvc2VQYXRoKCl9cmVuZGVyTGluZVdhdmVmb3JtKHQsZSxpLHMpe2NvbnN0IG49ZT0+e2NvbnN0IG49dFtlXXx8dFswXSxyPW4ubGVuZ3RoLHtoZWlnaHQ6b309aS5jYW52YXMsYT1vLzIsaD1pLmNhbnZhcy53aWR0aC9yO2kubW92ZVRvKDAsYSk7bGV0IGw9MCxkPTA7Zm9yKGxldCB0PTA7dDw9cjt0Kyspe2NvbnN0IHI9TWF0aC5yb3VuZCh0KmgpO2lmKHI+bCl7Y29uc3QgdD1hKyhNYXRoLnJvdW5kKGQqYSpzKXx8MSkqKDA9PT1lPy0xOjEpO2kubGluZVRvKGwsdCksbD1yLGQ9MH1jb25zdCBvPU1hdGguYWJzKG5bdF18fDApO28+ZCYmKGQ9byl9aS5saW5lVG8obCxhKX07aS5iZWdpblBhdGgoKSxuKDApLG4oMSksaS5maWxsKCksaS5jbG9zZVBhdGgoKX1yZW5kZXJXYXZlZm9ybSh0LGUsaSl7aWYoaS5maWxsU3R5bGU9dGhpcy5jb252ZXJ0Q29sb3JWYWx1ZXMoZS53YXZlQ29sb3IpLGUucmVuZGVyRnVuY3Rpb24pcmV0dXJuIHZvaWQgZS5yZW5kZXJGdW5jdGlvbih0LGkpO2xldCBzPWUuYmFySGVpZ2h0fHwxO2lmKGUubm9ybWFsaXplKXtjb25zdCBlPUFycmF5LmZyb20odFswXSkucmVkdWNlKCgodCxlKT0+TWF0aC5tYXgodCxNYXRoLmFicyhlKSkpLDApO3M9ZT8xL2U6MX1lLmJhcldpZHRofHxlLmJhckdhcHx8ZS5iYXJBbGlnbj90aGlzLnJlbmRlckJhcldhdmVmb3JtKHQsZSxpLHMpOnRoaXMucmVuZGVyTGluZVdhdmVmb3JtKHQsZSxpLHMpfXJlbmRlclNpbmdsZUNhbnZhcyh0LGUsaSxzLG4scixvKXtjb25zdCBhPXRoaXMuZ2V0UGl4ZWxSYXRpbygpLGg9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtoLndpZHRoPU1hdGgucm91bmQoaSphKSxoLmhlaWdodD1NYXRoLnJvdW5kKHMqYSksaC5zdHlsZS53aWR0aD1gJHtpfXB4YCxoLnN0eWxlLmhlaWdodD1gJHtzfXB4YCxoLnN0eWxlLmxlZnQ9YCR7TWF0aC5yb3VuZChuKX1weGAsci5hcHBlbmRDaGlsZChoKTtjb25zdCBsPWguZ2V0Q29udGV4dChcIjJkXCIpO2lmKHRoaXMucmVuZGVyV2F2ZWZvcm0odCxlLGwpLGgud2lkdGg+MCYmaC5oZWlnaHQ+MCl7Y29uc3QgdD1oLmNsb25lTm9kZSgpLGk9dC5nZXRDb250ZXh0KFwiMmRcIik7aS5kcmF3SW1hZ2UoaCwwLDApLGkuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uPVwic291cmNlLWluXCIsaS5maWxsU3R5bGU9dGhpcy5jb252ZXJ0Q29sb3JWYWx1ZXMoZS5wcm9ncmVzc0NvbG9yKSxpLmZpbGxSZWN0KDAsMCxoLndpZHRoLGguaGVpZ2h0KSxvLmFwcGVuZENoaWxkKHQpfX1yZW5kZXJNdWx0aUNhbnZhcyh0LGUsaSxzLG4scil7Y29uc3Qgbz10aGlzLmdldFBpeGVsUmF0aW8oKSx7Y2xpZW50V2lkdGg6YX09dGhpcy5zY3JvbGxDb250YWluZXIsbD1pL287bGV0IGQ9TWF0aC5taW4oaC5NQVhfQ0FOVkFTX1dJRFRILGEsbCksYz17fTtpZigwPT09ZClyZXR1cm47aWYoZS5iYXJXaWR0aHx8ZS5iYXJHYXApe2NvbnN0IHQ9ZS5iYXJXaWR0aHx8LjUsaT10KyhlLmJhckdhcHx8dC8yKTtkJWkhPTAmJihkPU1hdGguZmxvb3IoZC9pKSppKX1jb25zdCB1PWk9PntpZihpPDB8fGk+PXApcmV0dXJuO2lmKGNbaV0pcmV0dXJuO2NbaV09ITA7Y29uc3Qgbz1pKmQsYT1NYXRoLm1pbihsLW8sZCk7aWYoYTw9MClyZXR1cm47Y29uc3QgaD10Lm1hcCgodD0+e2NvbnN0IGU9TWF0aC5mbG9vcihvL2wqdC5sZW5ndGgpLGk9TWF0aC5mbG9vcigobythKS9sKnQubGVuZ3RoKTtyZXR1cm4gdC5zbGljZShlLGkpfSkpO3RoaXMucmVuZGVyU2luZ2xlQ2FudmFzKGgsZSxhLHMsbyxuLHIpfSxwPU1hdGguY2VpbChsL2QpO2lmKCF0aGlzLmlzU2Nyb2xsYWJsZSl7Zm9yKGxldCB0PTA7dDxwO3QrKyl1KHQpO3JldHVybn1jb25zdCBtPXRoaXMuc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQvbCxmPU1hdGguZmxvb3IobSpwKTtpZih1KGYtMSksdShmKSx1KGYrMSkscD4xKXtjb25zdCB0PXRoaXMub24oXCJzY3JvbGxcIiwoKCk9Pntjb25zdHtzY3JvbGxMZWZ0OnR9PXRoaXMuc2Nyb2xsQ29udGFpbmVyLGU9TWF0aC5mbG9vcih0L2wqcCk7T2JqZWN0LmtleXMoYykubGVuZ3RoPmguTUFYX05PREVTJiYobi5pbm5lckhUTUw9XCJcIixyLmlubmVySFRNTD1cIlwiLGM9e30pLHUoZS0xKSx1KGUpLHUoZSsxKX0pKTt0aGlzLnVuc3Vic2NyaWJlT25TY3JvbGwucHVzaCh0KX19cmVuZGVyQ2hhbm5lbCh0LGUsaSxzKXt2YXJ7b3ZlcmxheTpufT1lLHI9ZnVuY3Rpb24odCxlKXt2YXIgaT17fTtmb3IodmFyIHMgaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxzKSYmZS5pbmRleE9mKHMpPDAmJihpW3NdPXRbc10pO2lmKG51bGwhPXQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBuPTA7Zm9yKHM9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0KTtuPHMubGVuZ3RoO24rKyllLmluZGV4T2Yoc1tuXSk8MCYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHQsc1tuXSkmJihpW3Nbbl1dPXRbc1tuXV0pfXJldHVybiBpfShlLFtcIm92ZXJsYXlcIl0pO2NvbnN0IG89ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxhPXRoaXMuZ2V0SGVpZ2h0KHIuaGVpZ2h0LHIuc3BsaXRDaGFubmVscyk7by5zdHlsZS5oZWlnaHQ9YCR7YX1weGAsbiYmcz4wJiYoby5zdHlsZS5tYXJnaW5Ub3A9YC0ke2F9cHhgKSx0aGlzLmNhbnZhc1dyYXBwZXIuc3R5bGUubWluSGVpZ2h0PWAke2F9cHhgLHRoaXMuY2FudmFzV3JhcHBlci5hcHBlbmRDaGlsZChvKTtjb25zdCBoPW8uY2xvbmVOb2RlKCk7dGhpcy5wcm9ncmVzc1dyYXBwZXIuYXBwZW5kQ2hpbGQoaCksdGhpcy5yZW5kZXJNdWx0aUNhbnZhcyh0LHIsaSxhLG8saCl9cmVuZGVyKGUpe3JldHVybiB0KHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7dmFyIHQ7dGhpcy50aW1lb3V0cy5mb3JFYWNoKCh0PT50KCkpKSx0aGlzLnRpbWVvdXRzPVtdLHRoaXMuY2FudmFzV3JhcHBlci5pbm5lckhUTUw9XCJcIix0aGlzLnByb2dyZXNzV3JhcHBlci5pbm5lckhUTUw9XCJcIixudWxsIT10aGlzLm9wdGlvbnMud2lkdGgmJih0aGlzLnNjcm9sbENvbnRhaW5lci5zdHlsZS53aWR0aD1cIm51bWJlclwiPT10eXBlb2YgdGhpcy5vcHRpb25zLndpZHRoP2Ake3RoaXMub3B0aW9ucy53aWR0aH1weGA6dGhpcy5vcHRpb25zLndpZHRoKTtjb25zdCBpPXRoaXMuZ2V0UGl4ZWxSYXRpbygpLHM9dGhpcy5zY3JvbGxDb250YWluZXIuY2xpZW50V2lkdGgsbj1NYXRoLmNlaWwoZS5kdXJhdGlvbioodGhpcy5vcHRpb25zLm1pblB4UGVyU2VjfHwwKSk7dGhpcy5pc1Njcm9sbGFibGU9bj5zO2NvbnN0IHI9dGhpcy5vcHRpb25zLmZpbGxQYXJlbnQmJiF0aGlzLmlzU2Nyb2xsYWJsZSxvPShyP3M6bikqaTtpZih0aGlzLndyYXBwZXIuc3R5bGUud2lkdGg9cj9cIjEwMCVcIjpgJHtufXB4YCx0aGlzLnNjcm9sbENvbnRhaW5lci5zdHlsZS5vdmVyZmxvd1g9dGhpcy5pc1Njcm9sbGFibGU/XCJhdXRvXCI6XCJoaWRkZW5cIix0aGlzLnNjcm9sbENvbnRhaW5lci5jbGFzc0xpc3QudG9nZ2xlKFwibm9TY3JvbGxiYXJcIiwhIXRoaXMub3B0aW9ucy5oaWRlU2Nyb2xsYmFyKSx0aGlzLmN1cnNvci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9YCR7dGhpcy5vcHRpb25zLmN1cnNvckNvbG9yfHx0aGlzLm9wdGlvbnMucHJvZ3Jlc3NDb2xvcn1gLHRoaXMuY3Vyc29yLnN0eWxlLndpZHRoPWAke3RoaXMub3B0aW9ucy5jdXJzb3JXaWR0aH1weGAsdGhpcy5hdWRpb0RhdGE9ZSx0aGlzLmVtaXQoXCJyZW5kZXJcIiksdGhpcy5vcHRpb25zLnNwbGl0Q2hhbm5lbHMpZm9yKGxldCBpPTA7aTxlLm51bWJlck9mQ2hhbm5lbHM7aSsrKXtjb25zdCBzPU9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0aGlzLm9wdGlvbnMpLG51bGw9PT0odD10aGlzLm9wdGlvbnMuc3BsaXRDaGFubmVscyl8fHZvaWQgMD09PXQ/dm9pZCAwOnRbaV0pO3RoaXMucmVuZGVyQ2hhbm5lbChbZS5nZXRDaGFubmVsRGF0YShpKV0scyxvLGkpfWVsc2V7Y29uc3QgdD1bZS5nZXRDaGFubmVsRGF0YSgwKV07ZS5udW1iZXJPZkNoYW5uZWxzPjEmJnQucHVzaChlLmdldENoYW5uZWxEYXRhKDEpKSx0aGlzLnJlbmRlckNoYW5uZWwodCx0aGlzLm9wdGlvbnMsbywwKX1Qcm9taXNlLnJlc29sdmUoKS50aGVuKCgoKT0+dGhpcy5lbWl0KFwicmVuZGVyZWRcIikpKX0pKX1yZVJlbmRlcigpe2lmKHRoaXMudW5zdWJzY3JpYmVPblNjcm9sbC5mb3JFYWNoKCh0PT50KCkpKSx0aGlzLnVuc3Vic2NyaWJlT25TY3JvbGw9W10sIXRoaXMuYXVkaW9EYXRhKXJldHVybjtjb25zdHtzY3JvbGxXaWR0aDp0fT10aGlzLnNjcm9sbENvbnRhaW5lcix7cmlnaHQ6ZX09dGhpcy5wcm9ncmVzc1dyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7aWYodGhpcy5yZW5kZXIodGhpcy5hdWRpb0RhdGEpLHRoaXMuaXNTY3JvbGxhYmxlJiZ0IT09dGhpcy5zY3JvbGxDb250YWluZXIuc2Nyb2xsV2lkdGgpe2NvbnN0e3JpZ2h0OnR9PXRoaXMucHJvZ3Jlc3NXcmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2xldCBpPXQtZTtpKj0yLGk9aTwwP01hdGguZmxvb3IoaSk6TWF0aC5jZWlsKGkpLGkvPTIsdGhpcy5zY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCs9aX19em9vbSh0KXt0aGlzLm9wdGlvbnMubWluUHhQZXJTZWM9dCx0aGlzLnJlUmVuZGVyKCl9c2Nyb2xsSW50b1ZpZXcodCxlPSExKXtjb25zdHtzY3JvbGxMZWZ0Omksc2Nyb2xsV2lkdGg6cyxjbGllbnRXaWR0aDpufT10aGlzLnNjcm9sbENvbnRhaW5lcixyPXQqcyxvPWksYT1pK24saD1uLzI7aWYodGhpcy5pc0RyYWdnaW5nKXtjb25zdCB0PTMwO3IrdD5hP3RoaXMuc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQrPXQ6ci10PG8mJih0aGlzLnNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0LT10KX1lbHNleyhyPG98fHI+YSkmJih0aGlzLnNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0PXItKHRoaXMub3B0aW9ucy5hdXRvQ2VudGVyP2g6MCkpO2NvbnN0IHQ9ci1pLWg7ZSYmdGhpcy5vcHRpb25zLmF1dG9DZW50ZXImJnQ+MCYmKHRoaXMuc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQrPU1hdGgubWluKHQsMTApKX17Y29uc3QgdD10aGlzLnNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0LGU9dC9zLGk9KHQrbikvczt0aGlzLmVtaXQoXCJzY3JvbGxcIixlLGksdCx0K24pfX1yZW5kZXJQcm9ncmVzcyh0LGUpe2lmKGlzTmFOKHQpKXJldHVybjtjb25zdCBpPTEwMCp0O3RoaXMuY2FudmFzV3JhcHBlci5zdHlsZS5jbGlwUGF0aD1gcG9seWdvbigke2l9JSAwLCAxMDAlIDAsIDEwMCUgMTAwJSwgJHtpfSUgMTAwJSlgLHRoaXMucHJvZ3Jlc3NXcmFwcGVyLnN0eWxlLndpZHRoPWAke2l9JWAsdGhpcy5jdXJzb3Iuc3R5bGUubGVmdD1gJHtpfSVgLHRoaXMuY3Vyc29yLnN0eWxlLnRyYW5zZm9ybT1gdHJhbnNsYXRlWCgtJHsxMDA9PT1NYXRoLnJvdW5kKGkpP3RoaXMub3B0aW9ucy5jdXJzb3JXaWR0aDowfXB4KWAsdGhpcy5pc1Njcm9sbGFibGUmJnRoaXMub3B0aW9ucy5hdXRvU2Nyb2xsJiZ0aGlzLnNjcm9sbEludG9WaWV3KHQsZSl9ZXhwb3J0SW1hZ2UoZSxpLHMpe3JldHVybiB0KHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7Y29uc3QgdD10aGlzLmNhbnZhc1dyYXBwZXIucXVlcnlTZWxlY3RvckFsbChcImNhbnZhc1wiKTtpZighdC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiTm8gd2F2ZWZvcm0gZGF0YVwiKTtpZihcImRhdGFVUkxcIj09PXMpe2NvbnN0IHM9QXJyYXkuZnJvbSh0KS5tYXAoKHQ9PnQudG9EYXRhVVJMKGUsaSkpKTtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHMpfXJldHVybiBQcm9taXNlLmFsbChBcnJheS5mcm9tKHQpLm1hcCgodD0+bmV3IFByb21pc2UoKChzLG4pPT57dC50b0Jsb2IoKHQ9Pnt0P3ModCk6bihuZXcgRXJyb3IoXCJDb3VsZCBub3QgZXhwb3J0IGltYWdlXCIpKX0pLGUsaSl9KSkpKSl9KSl9fWguTUFYX0NBTlZBU19XSURUSD04ZTMsaC5NQVhfTk9ERVM9MTA7Y2xhc3MgbCBleHRlbmRzIGV7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMudW5zdWJzY3JpYmU9KCk9Pnt9fXN0YXJ0KCl7dGhpcy51bnN1YnNjcmliZT10aGlzLm9uKFwidGlja1wiLCgoKT0+e3JlcXVlc3RBbmltYXRpb25GcmFtZSgoKCk9Pnt0aGlzLmVtaXQoXCJ0aWNrXCIpfSkpfSkpLHRoaXMuZW1pdChcInRpY2tcIil9c3RvcCgpe3RoaXMudW5zdWJzY3JpYmUoKX1kZXN0cm95KCl7dGhpcy51bnN1YnNjcmliZSgpfX1jbGFzcyBkIGV4dGVuZHMgZXtjb25zdHJ1Y3Rvcih0PW5ldyBBdWRpb0NvbnRleHQpe3N1cGVyKCksdGhpcy5idWZmZXJOb2RlPW51bGwsdGhpcy5wbGF5U3RhcnRUaW1lPTAsdGhpcy5wbGF5ZWREdXJhdGlvbj0wLHRoaXMuX211dGVkPSExLHRoaXMuX3BsYXliYWNrUmF0ZT0xLHRoaXMuX2R1cmF0aW9uPXZvaWQgMCx0aGlzLmJ1ZmZlcj1udWxsLHRoaXMuY3VycmVudFNyYz1cIlwiLHRoaXMucGF1c2VkPSEwLHRoaXMuY3Jvc3NPcmlnaW49bnVsbCx0aGlzLnNlZWtpbmc9ITEsdGhpcy5hdXRvcGxheT0hMSx0aGlzLmFkZEV2ZW50TGlzdGVuZXI9dGhpcy5vbix0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXI9dGhpcy51bix0aGlzLmF1ZGlvQ29udGV4dD10LHRoaXMuZ2Fpbk5vZGU9dGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpLHRoaXMuZ2Fpbk5vZGUuY29ubmVjdCh0aGlzLmF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbil9bG9hZCgpe3JldHVybiB0KHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7fSkpfWdldCBzcmMoKXtyZXR1cm4gdGhpcy5jdXJyZW50U3JjfXNldCBzcmModCl7aWYodGhpcy5jdXJyZW50U3JjPXQsdGhpcy5fZHVyYXRpb249dm9pZCAwLCF0KXJldHVybiB0aGlzLmJ1ZmZlcj1udWxsLHZvaWQgdGhpcy5lbWl0KFwiZW1wdGllZFwiKTtmZXRjaCh0KS50aGVuKChlPT57aWYoZS5zdGF0dXM+PTQwMCl0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCAke3R9OiAke2Uuc3RhdHVzfSAoJHtlLnN0YXR1c1RleHR9KWApO3JldHVybiBlLmFycmF5QnVmZmVyKCl9KSkudGhlbigoZT0+dGhpcy5jdXJyZW50U3JjIT09dD9udWxsOnRoaXMuYXVkaW9Db250ZXh0LmRlY29kZUF1ZGlvRGF0YShlKSkpLnRoZW4oKGU9Pnt0aGlzLmN1cnJlbnRTcmM9PT10JiYodGhpcy5idWZmZXI9ZSx0aGlzLmVtaXQoXCJsb2FkZWRtZXRhZGF0YVwiKSx0aGlzLmVtaXQoXCJjYW5wbGF5XCIpLHRoaXMuYXV0b3BsYXkmJnRoaXMucGxheSgpKX0pKX1fcGxheSgpe3ZhciB0O2lmKCF0aGlzLnBhdXNlZClyZXR1cm47dGhpcy5wYXVzZWQ9ITEsbnVsbD09PSh0PXRoaXMuYnVmZmVyTm9kZSl8fHZvaWQgMD09PXR8fHQuZGlzY29ubmVjdCgpLHRoaXMuYnVmZmVyTm9kZT10aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKSx0aGlzLmJ1ZmZlciYmKHRoaXMuYnVmZmVyTm9kZS5idWZmZXI9dGhpcy5idWZmZXIpLHRoaXMuYnVmZmVyTm9kZS5wbGF5YmFja1JhdGUudmFsdWU9dGhpcy5fcGxheWJhY2tSYXRlLHRoaXMuYnVmZmVyTm9kZS5jb25uZWN0KHRoaXMuZ2Fpbk5vZGUpO2xldCBlPXRoaXMucGxheWVkRHVyYXRpb24qdGhpcy5fcGxheWJhY2tSYXRlO2U+PXRoaXMuZHVyYXRpb24mJihlPTAsdGhpcy5wbGF5ZWREdXJhdGlvbj0wKSx0aGlzLmJ1ZmZlck5vZGUuc3RhcnQodGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUsZSksdGhpcy5wbGF5U3RhcnRUaW1lPXRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lLHRoaXMuYnVmZmVyTm9kZS5vbmVuZGVkPSgpPT57dGhpcy5jdXJyZW50VGltZT49dGhpcy5kdXJhdGlvbiYmKHRoaXMucGF1c2UoKSx0aGlzLmVtaXQoXCJlbmRlZFwiKSl9fV9wYXVzZSgpe3ZhciB0O3RoaXMucGF1c2VkPSEwLG51bGw9PT0odD10aGlzLmJ1ZmZlck5vZGUpfHx2b2lkIDA9PT10fHx0LnN0b3AoKSx0aGlzLnBsYXllZER1cmF0aW9uKz10aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZS10aGlzLnBsYXlTdGFydFRpbWV9cGxheSgpe3JldHVybiB0KHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7dGhpcy5wYXVzZWQmJih0aGlzLl9wbGF5KCksdGhpcy5lbWl0KFwicGxheVwiKSl9KSl9cGF1c2UoKXt0aGlzLnBhdXNlZHx8KHRoaXMuX3BhdXNlKCksdGhpcy5lbWl0KFwicGF1c2VcIikpfXN0b3BBdCh0KXt2YXIgZSxpO2NvbnN0IHM9dC10aGlzLmN1cnJlbnRUaW1lO251bGw9PT0oZT10aGlzLmJ1ZmZlck5vZGUpfHx2b2lkIDA9PT1lfHxlLnN0b3AodGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUrcyksbnVsbD09PShpPXRoaXMuYnVmZmVyTm9kZSl8fHZvaWQgMD09PWl8fGkuYWRkRXZlbnRMaXN0ZW5lcihcImVuZGVkXCIsKCgpPT57dGhpcy5idWZmZXJOb2RlPW51bGwsdGhpcy5wYXVzZSgpfSkse29uY2U6ITB9KX1zZXRTaW5rSWQoZSl7cmV0dXJuIHQodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtyZXR1cm4gdGhpcy5hdWRpb0NvbnRleHQuc2V0U2lua0lkKGUpfSkpfWdldCBwbGF5YmFja1JhdGUoKXtyZXR1cm4gdGhpcy5fcGxheWJhY2tSYXRlfXNldCBwbGF5YmFja1JhdGUodCl7dGhpcy5fcGxheWJhY2tSYXRlPXQsdGhpcy5idWZmZXJOb2RlJiYodGhpcy5idWZmZXJOb2RlLnBsYXliYWNrUmF0ZS52YWx1ZT10KX1nZXQgY3VycmVudFRpbWUoKXtyZXR1cm4odGhpcy5wYXVzZWQ/dGhpcy5wbGF5ZWREdXJhdGlvbjp0aGlzLnBsYXllZER1cmF0aW9uKyh0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZS10aGlzLnBsYXlTdGFydFRpbWUpKSp0aGlzLl9wbGF5YmFja1JhdGV9c2V0IGN1cnJlbnRUaW1lKHQpe2NvbnN0IGU9IXRoaXMucGF1c2VkO2UmJnRoaXMuX3BhdXNlKCksdGhpcy5wbGF5ZWREdXJhdGlvbj10L3RoaXMuX3BsYXliYWNrUmF0ZSxlJiZ0aGlzLl9wbGF5KCksdGhpcy5lbWl0KFwic2Vla2luZ1wiKSx0aGlzLmVtaXQoXCJ0aW1ldXBkYXRlXCIpfWdldCBkdXJhdGlvbigpe3ZhciB0LGU7cmV0dXJuIG51bGwhPT0odD10aGlzLl9kdXJhdGlvbikmJnZvaWQgMCE9PXQ/dDoobnVsbD09PShlPXRoaXMuYnVmZmVyKXx8dm9pZCAwPT09ZT92b2lkIDA6ZS5kdXJhdGlvbil8fDB9c2V0IGR1cmF0aW9uKHQpe3RoaXMuX2R1cmF0aW9uPXR9Z2V0IHZvbHVtZSgpe3JldHVybiB0aGlzLmdhaW5Ob2RlLmdhaW4udmFsdWV9c2V0IHZvbHVtZSh0KXt0aGlzLmdhaW5Ob2RlLmdhaW4udmFsdWU9dCx0aGlzLmVtaXQoXCJ2b2x1bWVjaGFuZ2VcIil9Z2V0IG11dGVkKCl7cmV0dXJuIHRoaXMuX211dGVkfXNldCBtdXRlZCh0KXt0aGlzLl9tdXRlZCE9PXQmJih0aGlzLl9tdXRlZD10LHRoaXMuX211dGVkP3RoaXMuZ2Fpbk5vZGUuZGlzY29ubmVjdCgpOnRoaXMuZ2Fpbk5vZGUuY29ubmVjdCh0aGlzLmF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbikpfWNhblBsYXlUeXBlKHQpe3JldHVybi9eKGF1ZGlvfHZpZGVvKVxcLy8udGVzdCh0KX1nZXRHYWluTm9kZSgpe3JldHVybiB0aGlzLmdhaW5Ob2RlfWdldENoYW5uZWxEYXRhKCl7Y29uc3QgdD1bXTtpZighdGhpcy5idWZmZXIpcmV0dXJuIHQ7Y29uc3QgZT10aGlzLmJ1ZmZlci5udW1iZXJPZkNoYW5uZWxzO2ZvcihsZXQgaT0wO2k8ZTtpKyspdC5wdXNoKHRoaXMuYnVmZmVyLmdldENoYW5uZWxEYXRhKGkpKTtyZXR1cm4gdH19Y29uc3QgYz17d2F2ZUNvbG9yOlwiIzk5OVwiLHByb2dyZXNzQ29sb3I6XCIjNTU1XCIsY3Vyc29yV2lkdGg6MSxtaW5QeFBlclNlYzowLGZpbGxQYXJlbnQ6ITAsaW50ZXJhY3Q6ITAsZHJhZ1RvU2VlazohMSxhdXRvU2Nyb2xsOiEwLGF1dG9DZW50ZXI6ITAsc2FtcGxlUmF0ZTo4ZTN9O2NsYXNzIHUgZXh0ZW5kcyBhe3N0YXRpYyBjcmVhdGUodCl7cmV0dXJuIG5ldyB1KHQpfWNvbnN0cnVjdG9yKHQpe2NvbnN0IGU9dC5tZWRpYXx8KFwiV2ViQXVkaW9cIj09PXQuYmFja2VuZD9uZXcgZDp2b2lkIDApO3N1cGVyKHttZWRpYTplLG1lZGlhQ29udHJvbHM6dC5tZWRpYUNvbnRyb2xzLGF1dG9wbGF5OnQuYXV0b3BsYXkscGxheWJhY2tSYXRlOnQuYXVkaW9SYXRlfSksdGhpcy5wbHVnaW5zPVtdLHRoaXMuZGVjb2RlZERhdGE9bnVsbCx0aGlzLnN1YnNjcmlwdGlvbnM9W10sdGhpcy5tZWRpYVN1YnNjcmlwdGlvbnM9W10sdGhpcy5hYm9ydENvbnRyb2xsZXI9bnVsbCx0aGlzLm9wdGlvbnM9T2JqZWN0LmFzc2lnbih7fSxjLHQpLHRoaXMudGltZXI9bmV3IGw7Y29uc3QgaT1lP3ZvaWQgMDp0aGlzLmdldE1lZGlhRWxlbWVudCgpO3RoaXMucmVuZGVyZXI9bmV3IGgodGhpcy5vcHRpb25zLGkpLHRoaXMuaW5pdFBsYXllckV2ZW50cygpLHRoaXMuaW5pdFJlbmRlcmVyRXZlbnRzKCksdGhpcy5pbml0VGltZXJFdmVudHMoKSx0aGlzLmluaXRQbHVnaW5zKCk7Y29uc3Qgcz10aGlzLm9wdGlvbnMudXJsfHx0aGlzLmdldFNyYygpfHxcIlwiO1Byb21pc2UucmVzb2x2ZSgpLnRoZW4oKCgpPT57dGhpcy5lbWl0KFwiaW5pdFwiKTtjb25zdHtwZWFrczp0LGR1cmF0aW9uOmV9PXRoaXMub3B0aW9uczsoc3x8dCYmZSkmJnRoaXMubG9hZChzLHQsZSkuY2F0Y2goKCgpPT5udWxsKSl9KSl9dXBkYXRlUHJvZ3Jlc3ModD10aGlzLmdldEN1cnJlbnRUaW1lKCkpe3JldHVybiB0aGlzLnJlbmRlcmVyLnJlbmRlclByb2dyZXNzKHQvdGhpcy5nZXREdXJhdGlvbigpLHRoaXMuaXNQbGF5aW5nKCkpLHR9aW5pdFRpbWVyRXZlbnRzKCl7dGhpcy5zdWJzY3JpcHRpb25zLnB1c2godGhpcy50aW1lci5vbihcInRpY2tcIiwoKCk9PntpZighdGhpcy5pc1NlZWtpbmcoKSl7Y29uc3QgdD10aGlzLnVwZGF0ZVByb2dyZXNzKCk7dGhpcy5lbWl0KFwidGltZXVwZGF0ZVwiLHQpLHRoaXMuZW1pdChcImF1ZGlvcHJvY2Vzc1wiLHQpfX0pKSl9aW5pdFBsYXllckV2ZW50cygpe3RoaXMuaXNQbGF5aW5nKCkmJih0aGlzLmVtaXQoXCJwbGF5XCIpLHRoaXMudGltZXIuc3RhcnQoKSksdGhpcy5tZWRpYVN1YnNjcmlwdGlvbnMucHVzaCh0aGlzLm9uTWVkaWFFdmVudChcInRpbWV1cGRhdGVcIiwoKCk9Pntjb25zdCB0PXRoaXMudXBkYXRlUHJvZ3Jlc3MoKTt0aGlzLmVtaXQoXCJ0aW1ldXBkYXRlXCIsdCl9KSksdGhpcy5vbk1lZGlhRXZlbnQoXCJwbGF5XCIsKCgpPT57dGhpcy5lbWl0KFwicGxheVwiKSx0aGlzLnRpbWVyLnN0YXJ0KCl9KSksdGhpcy5vbk1lZGlhRXZlbnQoXCJwYXVzZVwiLCgoKT0+e3RoaXMuZW1pdChcInBhdXNlXCIpLHRoaXMudGltZXIuc3RvcCgpfSkpLHRoaXMub25NZWRpYUV2ZW50KFwiZW1wdGllZFwiLCgoKT0+e3RoaXMudGltZXIuc3RvcCgpfSkpLHRoaXMub25NZWRpYUV2ZW50KFwiZW5kZWRcIiwoKCk9Pnt0aGlzLmVtaXQoXCJ0aW1ldXBkYXRlXCIsdGhpcy5nZXREdXJhdGlvbigpKSx0aGlzLmVtaXQoXCJmaW5pc2hcIil9KSksdGhpcy5vbk1lZGlhRXZlbnQoXCJzZWVraW5nXCIsKCgpPT57dGhpcy5lbWl0KFwic2Vla2luZ1wiLHRoaXMuZ2V0Q3VycmVudFRpbWUoKSl9KSksdGhpcy5vbk1lZGlhRXZlbnQoXCJlcnJvclwiLCh0PT57dmFyIGU7dGhpcy5lbWl0KFwiZXJyb3JcIixudWxsIT09KGU9dGhpcy5nZXRNZWRpYUVsZW1lbnQoKS5lcnJvcikmJnZvaWQgMCE9PWU/ZTpuZXcgRXJyb3IoXCJNZWRpYSBlcnJvclwiKSl9KSkpfWluaXRSZW5kZXJlckV2ZW50cygpe3RoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMucmVuZGVyZXIub24oXCJjbGlja1wiLCgodCxlKT0+e3RoaXMub3B0aW9ucy5pbnRlcmFjdCYmKHRoaXMuc2Vla1RvKHQpLHRoaXMuZW1pdChcImludGVyYWN0aW9uXCIsdCp0aGlzLmdldER1cmF0aW9uKCkpLHRoaXMuZW1pdChcImNsaWNrXCIsdCxlKSl9KSksdGhpcy5yZW5kZXJlci5vbihcImRibGNsaWNrXCIsKCh0LGUpPT57dGhpcy5lbWl0KFwiZGJsY2xpY2tcIix0LGUpfSkpLHRoaXMucmVuZGVyZXIub24oXCJzY3JvbGxcIiwoKHQsZSxpLHMpPT57Y29uc3Qgbj10aGlzLmdldER1cmF0aW9uKCk7dGhpcy5lbWl0KFwic2Nyb2xsXCIsdCpuLGUqbixpLHMpfSkpLHRoaXMucmVuZGVyZXIub24oXCJyZW5kZXJcIiwoKCk9Pnt0aGlzLmVtaXQoXCJyZWRyYXdcIil9KSksdGhpcy5yZW5kZXJlci5vbihcInJlbmRlcmVkXCIsKCgpPT57dGhpcy5lbWl0KFwicmVkcmF3Y29tcGxldGVcIil9KSksdGhpcy5yZW5kZXJlci5vbihcImRyYWdzdGFydFwiLCh0PT57dGhpcy5lbWl0KFwiZHJhZ3N0YXJ0XCIsdCl9KSksdGhpcy5yZW5kZXJlci5vbihcImRyYWdlbmRcIiwodD0+e3RoaXMuZW1pdChcImRyYWdlbmRcIix0KX0pKSk7e2xldCB0O3RoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMucmVuZGVyZXIub24oXCJkcmFnXCIsKGU9PntpZighdGhpcy5vcHRpb25zLmludGVyYWN0KXJldHVybjtsZXQgaTt0aGlzLnJlbmRlcmVyLnJlbmRlclByb2dyZXNzKGUpLGNsZWFyVGltZW91dCh0KSx0aGlzLmlzUGxheWluZygpP2k9MDohMD09PXRoaXMub3B0aW9ucy5kcmFnVG9TZWVrP2k9MjAwOlwib2JqZWN0XCI9PXR5cGVvZiB0aGlzLm9wdGlvbnMuZHJhZ1RvU2VlayYmdm9pZCAwIT09dGhpcy5vcHRpb25zLmRyYWdUb1NlZWsmJihpPXRoaXMub3B0aW9ucy5kcmFnVG9TZWVrLmRlYm91bmNlVGltZSksdD1zZXRUaW1lb3V0KCgoKT0+e3RoaXMuc2Vla1RvKGUpfSksaSksdGhpcy5lbWl0KFwiaW50ZXJhY3Rpb25cIixlKnRoaXMuZ2V0RHVyYXRpb24oKSksdGhpcy5lbWl0KFwiZHJhZ1wiLGUpfSkpKX19aW5pdFBsdWdpbnMoKXt2YXIgdDsobnVsbD09PSh0PXRoaXMub3B0aW9ucy5wbHVnaW5zKXx8dm9pZCAwPT09dD92b2lkIDA6dC5sZW5ndGgpJiZ0aGlzLm9wdGlvbnMucGx1Z2lucy5mb3JFYWNoKCh0PT57dGhpcy5yZWdpc3RlclBsdWdpbih0KX0pKX11bnN1YnNjcmliZVBsYXllckV2ZW50cygpe3RoaXMubWVkaWFTdWJzY3JpcHRpb25zLmZvckVhY2goKHQ9PnQoKSkpLHRoaXMubWVkaWFTdWJzY3JpcHRpb25zPVtdfXNldE9wdGlvbnModCl7dGhpcy5vcHRpb25zPU9iamVjdC5hc3NpZ24oe30sdGhpcy5vcHRpb25zLHQpLHQuZHVyYXRpb24mJiF0LnBlYWtzJiYodGhpcy5kZWNvZGVkRGF0YT1pLmNyZWF0ZUJ1ZmZlcih0aGlzLmV4cG9ydFBlYWtzKCksdC5kdXJhdGlvbikpLHQucGVha3MmJnQuZHVyYXRpb24mJih0aGlzLmRlY29kZWREYXRhPWkuY3JlYXRlQnVmZmVyKHQucGVha3MsdC5kdXJhdGlvbikpLHRoaXMucmVuZGVyZXIuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMpLHQuYXVkaW9SYXRlJiZ0aGlzLnNldFBsYXliYWNrUmF0ZSh0LmF1ZGlvUmF0ZSksbnVsbCE9dC5tZWRpYUNvbnRyb2xzJiYodGhpcy5nZXRNZWRpYUVsZW1lbnQoKS5jb250cm9scz10Lm1lZGlhQ29udHJvbHMpfXJlZ2lzdGVyUGx1Z2luKHQpe3JldHVybiB0Ll9pbml0KHRoaXMpLHRoaXMucGx1Z2lucy5wdXNoKHQpLHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKHQub25jZShcImRlc3Ryb3lcIiwoKCk9Pnt0aGlzLnBsdWdpbnM9dGhpcy5wbHVnaW5zLmZpbHRlcigoZT0+ZSE9PXQpKX0pKSksdH1nZXRXcmFwcGVyKCl7cmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0V3JhcHBlcigpfWdldFdpZHRoKCl7cmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0V2lkdGgoKX1nZXRTY3JvbGwoKXtyZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRTY3JvbGwoKX1zZXRTY3JvbGwodCl7cmV0dXJuIHRoaXMucmVuZGVyZXIuc2V0U2Nyb2xsKHQpfXNldFNjcm9sbFRpbWUodCl7Y29uc3QgZT10L3RoaXMuZ2V0RHVyYXRpb24oKTt0aGlzLnJlbmRlcmVyLnNldFNjcm9sbFBlcmNlbnRhZ2UoZSl9Z2V0QWN0aXZlUGx1Z2lucygpe3JldHVybiB0aGlzLnBsdWdpbnN9bG9hZEF1ZGlvKGUscyxuLHIpe3JldHVybiB0KHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7dmFyIHQ7aWYodGhpcy5lbWl0KFwibG9hZFwiLGUpLCF0aGlzLm9wdGlvbnMubWVkaWEmJnRoaXMuaXNQbGF5aW5nKCkmJnRoaXMucGF1c2UoKSx0aGlzLmRlY29kZWREYXRhPW51bGwsIXMmJiFuKXtjb25zdCBpPXRoaXMub3B0aW9ucy5mZXRjaFBhcmFtc3x8e307d2luZG93LkFib3J0Q29udHJvbGxlciYmIWkuc2lnbmFsJiYodGhpcy5hYm9ydENvbnRyb2xsZXI9bmV3IEFib3J0Q29udHJvbGxlcixpLnNpZ25hbD1udWxsPT09KHQ9dGhpcy5hYm9ydENvbnRyb2xsZXIpfHx2b2lkIDA9PT10P3ZvaWQgMDp0LnNpZ25hbCk7Y29uc3Qgbj10PT50aGlzLmVtaXQoXCJsb2FkaW5nXCIsdCk7cz15aWVsZCBvLmZldGNoQmxvYihlLG4saSk7Y29uc3Qgcj10aGlzLm9wdGlvbnMuYmxvYk1pbWVUeXBlO3ImJihzPW5ldyBCbG9iKFtzXSx7dHlwZTpyfSkpfXRoaXMuc2V0U3JjKGUscyk7Y29uc3QgYT15aWVsZCBuZXcgUHJvbWlzZSgodD0+e2NvbnN0IGU9cnx8dGhpcy5nZXREdXJhdGlvbigpO2U/dChlKTp0aGlzLm1lZGlhU3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMub25NZWRpYUV2ZW50KFwibG9hZGVkbWV0YWRhdGFcIiwoKCk9PnQodGhpcy5nZXREdXJhdGlvbigpKSkse29uY2U6ITB9KSl9KSk7aWYoIWUmJiFzKXtjb25zdCB0PXRoaXMuZ2V0TWVkaWFFbGVtZW50KCk7dCBpbnN0YW5jZW9mIGQmJih0LmR1cmF0aW9uPWEpfWlmKG4pdGhpcy5kZWNvZGVkRGF0YT1pLmNyZWF0ZUJ1ZmZlcihuLGF8fDApO2Vsc2UgaWYocyl7Y29uc3QgdD15aWVsZCBzLmFycmF5QnVmZmVyKCk7dGhpcy5kZWNvZGVkRGF0YT15aWVsZCBpLmRlY29kZSh0LHRoaXMub3B0aW9ucy5zYW1wbGVSYXRlKX10aGlzLmRlY29kZWREYXRhJiYodGhpcy5lbWl0KFwiZGVjb2RlXCIsdGhpcy5nZXREdXJhdGlvbigpKSx0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLmRlY29kZWREYXRhKSksdGhpcy5lbWl0KFwicmVhZHlcIix0aGlzLmdldER1cmF0aW9uKCkpfSkpfWxvYWQoZSxpLHMpe3JldHVybiB0KHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7dHJ5e3JldHVybiB5aWVsZCB0aGlzLmxvYWRBdWRpbyhlLHZvaWQgMCxpLHMpfWNhdGNoKHQpe3Rocm93IHRoaXMuZW1pdChcImVycm9yXCIsdCksdH19KSl9bG9hZEJsb2IoZSxpLHMpe3JldHVybiB0KHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7dHJ5e3JldHVybiB5aWVsZCB0aGlzLmxvYWRBdWRpbyhcIlwiLGUsaSxzKX1jYXRjaCh0KXt0aHJvdyB0aGlzLmVtaXQoXCJlcnJvclwiLHQpLHR9fSkpfXpvb20odCl7aWYoIXRoaXMuZGVjb2RlZERhdGEpdGhyb3cgbmV3IEVycm9yKFwiTm8gYXVkaW8gbG9hZGVkXCIpO3RoaXMucmVuZGVyZXIuem9vbSh0KSx0aGlzLmVtaXQoXCJ6b29tXCIsdCl9Z2V0RGVjb2RlZERhdGEoKXtyZXR1cm4gdGhpcy5kZWNvZGVkRGF0YX1leHBvcnRQZWFrcyh7Y2hhbm5lbHM6dD0yLG1heExlbmd0aDplPThlMyxwcmVjaXNpb246aT0xZTR9PXt9KXtpZighdGhpcy5kZWNvZGVkRGF0YSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYXVkaW8gaGFzIG5vdCBiZWVuIGRlY29kZWQgeWV0XCIpO2NvbnN0IHM9TWF0aC5taW4odCx0aGlzLmRlY29kZWREYXRhLm51bWJlck9mQ2hhbm5lbHMpLG49W107Zm9yKGxldCB0PTA7dDxzO3QrKyl7Y29uc3Qgcz10aGlzLmRlY29kZWREYXRhLmdldENoYW5uZWxEYXRhKHQpLHI9W10sbz1zLmxlbmd0aC9lO2ZvcihsZXQgdD0wO3Q8ZTt0Kyspe2NvbnN0IGU9cy5zbGljZShNYXRoLmZsb29yKHQqbyksTWF0aC5jZWlsKCh0KzEpKm8pKTtsZXQgbj0wO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKXtjb25zdCBpPWVbdF07TWF0aC5hYnMoaSk+TWF0aC5hYnMobikmJihuPWkpfXIucHVzaChNYXRoLnJvdW5kKG4qaSkvaSl9bi5wdXNoKHIpfXJldHVybiBufWdldER1cmF0aW9uKCl7bGV0IHQ9c3VwZXIuZ2V0RHVyYXRpb24oKXx8MDtyZXR1cm4gMCE9PXQmJnQhPT0xLzB8fCF0aGlzLmRlY29kZWREYXRhfHwodD10aGlzLmRlY29kZWREYXRhLmR1cmF0aW9uKSx0fXRvZ2dsZUludGVyYWN0aW9uKHQpe3RoaXMub3B0aW9ucy5pbnRlcmFjdD10fXNldFRpbWUodCl7c3VwZXIuc2V0VGltZSh0KSx0aGlzLnVwZGF0ZVByb2dyZXNzKHQpLHRoaXMuZW1pdChcInRpbWV1cGRhdGVcIix0KX1zZWVrVG8odCl7Y29uc3QgZT10aGlzLmdldER1cmF0aW9uKCkqdDt0aGlzLnNldFRpbWUoZSl9cGxheVBhdXNlKCl7cmV0dXJuIHQodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtyZXR1cm4gdGhpcy5pc1BsYXlpbmcoKT90aGlzLnBhdXNlKCk6dGhpcy5wbGF5KCl9KSl9c3RvcCgpe3RoaXMucGF1c2UoKSx0aGlzLnNldFRpbWUoMCl9c2tpcCh0KXt0aGlzLnNldFRpbWUodGhpcy5nZXRDdXJyZW50VGltZSgpK3QpfWVtcHR5KCl7dGhpcy5sb2FkKFwiXCIsW1swXV0sLjAwMSl9c2V0TWVkaWFFbGVtZW50KHQpe3RoaXMudW5zdWJzY3JpYmVQbGF5ZXJFdmVudHMoKSxzdXBlci5zZXRNZWRpYUVsZW1lbnQodCksdGhpcy5pbml0UGxheWVyRXZlbnRzKCl9ZXhwb3J0SW1hZ2UoKXtyZXR1cm4gdCh0aGlzLGFyZ3VtZW50cyx2b2lkIDAsKGZ1bmN0aW9uKih0PVwiaW1hZ2UvcG5nXCIsZT0xLGk9XCJkYXRhVVJMXCIpe3JldHVybiB0aGlzLnJlbmRlcmVyLmV4cG9ydEltYWdlKHQsZSxpKX0pKX1kZXN0cm95KCl7dmFyIHQ7dGhpcy5lbWl0KFwiZGVzdHJveVwiKSxudWxsPT09KHQ9dGhpcy5hYm9ydENvbnRyb2xsZXIpfHx2b2lkIDA9PT10fHx0LmFib3J0KCksdGhpcy5wbHVnaW5zLmZvckVhY2goKHQ9PnQuZGVzdHJveSgpKSksdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goKHQ9PnQoKSkpLHRoaXMudW5zdWJzY3JpYmVQbGF5ZXJFdmVudHMoKSx0aGlzLnRpbWVyLmRlc3Ryb3koKSx0aGlzLnJlbmRlcmVyLmRlc3Ryb3koKSxzdXBlci5kZXN0cm95KCl9fXUuQmFzZVBsdWdpbj1jbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3IodCl7c3VwZXIoKSx0aGlzLnN1YnNjcmlwdGlvbnM9W10sdGhpcy5vcHRpb25zPXR9b25Jbml0KCl7fV9pbml0KHQpe3RoaXMud2F2ZXN1cmZlcj10LHRoaXMub25Jbml0KCl9ZGVzdHJveSgpe3RoaXMuZW1pdChcImRlc3Ryb3lcIiksdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goKHQ9PnQoKSkpfX0sdS5kb209cjtleHBvcnR7dSBhcyBkZWZhdWx0fTtcbiIsICJpbXBvcnQgV2F2ZVN1cmZlciBmcm9tICd3YXZlc3VyZmVyLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBBdWRpb1BsYXllciA9IHtcbiAgICBtb3VudGVkKCkgeyBcbiAgICAgICAgY29uc3QgcGxheUJ1dHRvbiA9IHRoaXMuZWxcbiAgICAgICAgY29uc3QgYXVkaW9fcGF0aCA9IHRoaXMuZWwuZGF0YXNldC5hdWRpb3BhdGhcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5lbC5kYXRhc2V0LmNvbnRhaW5lclxuICAgICAgICBjb25zdCBwcm9ncmVzc0NvbG9yID0gdGhpcy5lbC5kYXRhc2V0LnByb2dyZXNzY29sb3JcbiAgICAgICAgY29uc3QgYXVkaW9Db250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb250YWluZXIpXG4gICAgICAgIC8vVE9ETzogYmluZHMgaHRtbCBlbGVtZW50cy4gc2VlIG9kb28gbW9kdWxlLiFcblxuICAgICAgICBjb25zdCB3YXZlU3VyZmVyID0gV2F2ZVN1cmZlci5jcmVhdGUoe1xuICAgICAgICAgICAgY29udGFpbmVyOiBhdWRpb0NvbnRhaW5lcixcbiAgICAgICAgICAgIGhlaWdodDogNzAsXG4gICAgICAgICAgICB3YXZlQ29sb3I6ICcjRUNGMkZGJyxcbiAgICAgICAgICAgIHByb2dyZXNzQ29sb3I6IHByb2dyZXNzQ29sb3IsXG4gICAgICAgICAgICBiYXJXaWR0aDogNSxcbiAgICAgICAgICAgIGJhckdhcDogMixcbiAgICAgICAgICAgIGJhclJhZGl1czogMTAsXG4gICAgICAgICAgICBjdXJzb3JDb2xvcjogJyM3ODcxODYnLFxuICAgICAgICAgICAgY3Vyc29yV2lkdGg6IDEsXG4gICAgICAgICAgICByZXNwb25zaXZlOiB0cnVlLFxuICAgICAgICAgICAgLy8gcGx1Z2luczogW1RpbWVsaW5lUGx1Z2luLmNyZWF0ZSh7XG4gICAgICAgICAgICAvLyAgIGhlaWdodDogMTcsXG4gICAgICAgICAgICAvLyB9KV0sXG4gICAgICAgIH0pO1xuICAgICAgICAvLyB3YXZlU3VyZmVyLmxvYWQoYXVkaW9fcGF0aCk7XG5cbiAgICAgICAgY29uc3QgdG9rZW4gPSBcInlvdXJfdmFsaWRfdG9rZW5cIjsgXG5cbiAgICAgICAgZmV0Y2goYXVkaW9fcGF0aCwge1xuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmV0d29yayByZXNwb25zZSB3YXMgbm90IG9rJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuYmxvYigpO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbihibG9iID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgICAgICB3YXZlU3VyZmVyLmxvYWQodXJsKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoZXJlIHdhcyBhIHByb2JsZW0gd2l0aCB0aGUgZmV0Y2ggb3BlcmF0aW9uOicsIGVycm9yKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgY2xpY2tQbGF5ID0gKGVsKSA9PiB7XG4gICAgICAgICAgICB3YXZlU3VyZmVyLnBsYXlQYXVzZSgpO1xuICAgICAgICAgICAgZWwudGFyZ2V0LmlubmVySFRNTCA9IHdhdmVTdXJmZXIuaXNQbGF5aW5nKCkgPyBcIlBhdXNlXCIgOiBcIlBsYXlcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdhdmVTdXJmZXIub24oJ3JlYWR5JywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2cod2F2ZVN1cmZlcilcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgZHVtbXkgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIGFsZXJ0KFwiWW91IGNsaWNrZWQuXCIpXG4gICAgICAgIH1cblxuICAgICAgICBwbGF5QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBjbGlja1BsYXkpXG5cbiAgICAgICAgLy8gcmV0dXJuICgpID0+IHtcbiAgICAgICAgLy8gICAgIHdhdmVTdXJmZXIuZGVzdHJveSgpXG4gICAgICAgIC8vICAgICB0aGlzLnBsYXlCdXR0b24uZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGNsaWNrUGxheSlcbiAgICAgICAgLy8gfTtcblxuICAgIH1cbn0iLCAiLyohXG4gKiBAa3Vya2xlL2NvbG9yIHYwLjMuNFxuICogaHR0cHM6Ly9naXRodWIuY29tL2t1cmtsZS9jb2xvciNyZWFkbWVcbiAqIChjKSAyMDI0IEp1a2thIEt1cmtlbGFcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5mdW5jdGlvbiByb3VuZCh2KSB7XG4gIHJldHVybiB2ICsgMC41IHwgMDtcbn1cbmNvbnN0IGxpbSA9ICh2LCBsLCBoKSA9PiBNYXRoLm1heChNYXRoLm1pbih2LCBoKSwgbCk7XG5mdW5jdGlvbiBwMmIodikge1xuICByZXR1cm4gbGltKHJvdW5kKHYgKiAyLjU1KSwgMCwgMjU1KTtcbn1cbmZ1bmN0aW9uIGIycCh2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAvIDIuNTUpLCAwLCAxMDApO1xufVxuZnVuY3Rpb24gbjJiKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2ICogMjU1KSwgMCwgMjU1KTtcbn1cbmZ1bmN0aW9uIGIybih2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAvIDIuNTUpIC8gMTAwLCAwLCAxKTtcbn1cbmZ1bmN0aW9uIG4ycCh2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAqIDEwMCksIDAsIDEwMCk7XG59XG5cbmNvbnN0IG1hcCQxID0gezA6IDAsIDE6IDEsIDI6IDIsIDM6IDMsIDQ6IDQsIDU6IDUsIDY6IDYsIDc6IDcsIDg6IDgsIDk6IDksIEE6IDEwLCBCOiAxMSwgQzogMTIsIEQ6IDEzLCBFOiAxNCwgRjogMTUsIGE6IDEwLCBiOiAxMSwgYzogMTIsIGQ6IDEzLCBlOiAxNCwgZjogMTV9O1xuY29uc3QgaGV4ID0gWy4uLicwMTIzNDU2Nzg5QUJDREVGJ107XG5jb25zdCBoMSA9IGIgPT4gaGV4W2IgJiAweEZdO1xuY29uc3QgaDIgPSBiID0+IGhleFsoYiAmIDB4RjApID4+IDRdICsgaGV4W2IgJiAweEZdO1xuY29uc3QgZXEgPSBiID0+ICgoYiAmIDB4RjApID4+IDQpID09PSAoYiAmIDB4Rik7XG5jb25zdCBpc1Nob3J0ID0gdiA9PiBlcSh2LnIpICYmIGVxKHYuZykgJiYgZXEodi5iKSAmJiBlcSh2LmEpO1xuZnVuY3Rpb24gaGV4UGFyc2Uoc3RyKSB7XG4gIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuICB2YXIgcmV0O1xuICBpZiAoc3RyWzBdID09PSAnIycpIHtcbiAgICBpZiAobGVuID09PSA0IHx8IGxlbiA9PT0gNSkge1xuICAgICAgcmV0ID0ge1xuICAgICAgICByOiAyNTUgJiBtYXAkMVtzdHJbMV1dICogMTcsXG4gICAgICAgIGc6IDI1NSAmIG1hcCQxW3N0clsyXV0gKiAxNyxcbiAgICAgICAgYjogMjU1ICYgbWFwJDFbc3RyWzNdXSAqIDE3LFxuICAgICAgICBhOiBsZW4gPT09IDUgPyBtYXAkMVtzdHJbNF1dICogMTcgOiAyNTVcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDcgfHwgbGVuID09PSA5KSB7XG4gICAgICByZXQgPSB7XG4gICAgICAgIHI6IG1hcCQxW3N0clsxXV0gPDwgNCB8IG1hcCQxW3N0clsyXV0sXG4gICAgICAgIGc6IG1hcCQxW3N0clszXV0gPDwgNCB8IG1hcCQxW3N0cls0XV0sXG4gICAgICAgIGI6IG1hcCQxW3N0cls1XV0gPDwgNCB8IG1hcCQxW3N0cls2XV0sXG4gICAgICAgIGE6IGxlbiA9PT0gOSA/IChtYXAkMVtzdHJbN11dIDw8IDQgfCBtYXAkMVtzdHJbOF1dKSA6IDI1NVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmNvbnN0IGFscGhhID0gKGEsIGYpID0+IGEgPCAyNTUgPyBmKGEpIDogJyc7XG5mdW5jdGlvbiBoZXhTdHJpbmcodikge1xuICB2YXIgZiA9IGlzU2hvcnQodikgPyBoMSA6IGgyO1xuICByZXR1cm4gdlxuICAgID8gJyMnICsgZih2LnIpICsgZih2LmcpICsgZih2LmIpICsgYWxwaGEodi5hLCBmKVxuICAgIDogdW5kZWZpbmVkO1xufVxuXG5jb25zdCBIVUVfUkUgPSAvXihoc2xhP3xod2J8aHN2KVxcKFxccyooWy0rLmVcXGRdKykoPzpkZWcpP1tcXHMsXSsoWy0rLmVcXGRdKyklW1xccyxdKyhbLSsuZVxcZF0rKSUoPzpbXFxzLF0rKFstKy5lXFxkXSspKCUpPyk/XFxzKlxcKSQvO1xuZnVuY3Rpb24gaHNsMnJnYm4oaCwgcywgbCkge1xuICBjb25zdCBhID0gcyAqIE1hdGgubWluKGwsIDEgLSBsKTtcbiAgY29uc3QgZiA9IChuLCBrID0gKG4gKyBoIC8gMzApICUgMTIpID0+IGwgLSBhICogTWF0aC5tYXgoTWF0aC5taW4oayAtIDMsIDkgLSBrLCAxKSwgLTEpO1xuICByZXR1cm4gW2YoMCksIGYoOCksIGYoNCldO1xufVxuZnVuY3Rpb24gaHN2MnJnYm4oaCwgcywgdikge1xuICBjb25zdCBmID0gKG4sIGsgPSAobiArIGggLyA2MCkgJSA2KSA9PiB2IC0gdiAqIHMgKiBNYXRoLm1heChNYXRoLm1pbihrLCA0IC0gaywgMSksIDApO1xuICByZXR1cm4gW2YoNSksIGYoMyksIGYoMSldO1xufVxuZnVuY3Rpb24gaHdiMnJnYm4oaCwgdywgYikge1xuICBjb25zdCByZ2IgPSBoc2wycmdibihoLCAxLCAwLjUpO1xuICBsZXQgaTtcbiAgaWYgKHcgKyBiID4gMSkge1xuICAgIGkgPSAxIC8gKHcgKyBiKTtcbiAgICB3ICo9IGk7XG4gICAgYiAqPSBpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICByZ2JbaV0gKj0gMSAtIHcgLSBiO1xuICAgIHJnYltpXSArPSB3O1xuICB9XG4gIHJldHVybiByZ2I7XG59XG5mdW5jdGlvbiBodWVWYWx1ZShyLCBnLCBiLCBkLCBtYXgpIHtcbiAgaWYgKHIgPT09IG1heCkge1xuICAgIHJldHVybiAoKGcgLSBiKSAvIGQpICsgKGcgPCBiID8gNiA6IDApO1xuICB9XG4gIGlmIChnID09PSBtYXgpIHtcbiAgICByZXR1cm4gKGIgLSByKSAvIGQgKyAyO1xuICB9XG4gIHJldHVybiAociAtIGcpIC8gZCArIDQ7XG59XG5mdW5jdGlvbiByZ2IyaHNsKHYpIHtcbiAgY29uc3QgcmFuZ2UgPSAyNTU7XG4gIGNvbnN0IHIgPSB2LnIgLyByYW5nZTtcbiAgY29uc3QgZyA9IHYuZyAvIHJhbmdlO1xuICBjb25zdCBiID0gdi5iIC8gcmFuZ2U7XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICBjb25zdCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgY29uc3QgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgbGV0IGgsIHMsIGQ7XG4gIGlmIChtYXggIT09IG1pbikge1xuICAgIGQgPSBtYXggLSBtaW47XG4gICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xuICAgIGggPSBodWVWYWx1ZShyLCBnLCBiLCBkLCBtYXgpO1xuICAgIGggPSBoICogNjAgKyAwLjU7XG4gIH1cbiAgcmV0dXJuIFtoIHwgMCwgcyB8fCAwLCBsXTtcbn1cbmZ1bmN0aW9uIGNhbGxuKGYsIGEsIGIsIGMpIHtcbiAgcmV0dXJuIChcbiAgICBBcnJheS5pc0FycmF5KGEpXG4gICAgICA/IGYoYVswXSwgYVsxXSwgYVsyXSlcbiAgICAgIDogZihhLCBiLCBjKVxuICApLm1hcChuMmIpO1xufVxuZnVuY3Rpb24gaHNsMnJnYihoLCBzLCBsKSB7XG4gIHJldHVybiBjYWxsbihoc2wycmdibiwgaCwgcywgbCk7XG59XG5mdW5jdGlvbiBod2IycmdiKGgsIHcsIGIpIHtcbiAgcmV0dXJuIGNhbGxuKGh3YjJyZ2JuLCBoLCB3LCBiKTtcbn1cbmZ1bmN0aW9uIGhzdjJyZ2IoaCwgcywgdikge1xuICByZXR1cm4gY2FsbG4oaHN2MnJnYm4sIGgsIHMsIHYpO1xufVxuZnVuY3Rpb24gaHVlKGgpIHtcbiAgcmV0dXJuIChoICUgMzYwICsgMzYwKSAlIDM2MDtcbn1cbmZ1bmN0aW9uIGh1ZVBhcnNlKHN0cikge1xuICBjb25zdCBtID0gSFVFX1JFLmV4ZWMoc3RyKTtcbiAgbGV0IGEgPSAyNTU7XG4gIGxldCB2O1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1bNV0gIT09IHYpIHtcbiAgICBhID0gbVs2XSA/IHAyYigrbVs1XSkgOiBuMmIoK21bNV0pO1xuICB9XG4gIGNvbnN0IGggPSBodWUoK21bMl0pO1xuICBjb25zdCBwMSA9ICttWzNdIC8gMTAwO1xuICBjb25zdCBwMiA9ICttWzRdIC8gMTAwO1xuICBpZiAobVsxXSA9PT0gJ2h3YicpIHtcbiAgICB2ID0gaHdiMnJnYihoLCBwMSwgcDIpO1xuICB9IGVsc2UgaWYgKG1bMV0gPT09ICdoc3YnKSB7XG4gICAgdiA9IGhzdjJyZ2IoaCwgcDEsIHAyKTtcbiAgfSBlbHNlIHtcbiAgICB2ID0gaHNsMnJnYihoLCBwMSwgcDIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcjogdlswXSxcbiAgICBnOiB2WzFdLFxuICAgIGI6IHZbMl0sXG4gICAgYTogYVxuICB9O1xufVxuZnVuY3Rpb24gcm90YXRlKHYsIGRlZykge1xuICB2YXIgaCA9IHJnYjJoc2wodik7XG4gIGhbMF0gPSBodWUoaFswXSArIGRlZyk7XG4gIGggPSBoc2wycmdiKGgpO1xuICB2LnIgPSBoWzBdO1xuICB2LmcgPSBoWzFdO1xuICB2LmIgPSBoWzJdO1xufVxuZnVuY3Rpb24gaHNsU3RyaW5nKHYpIHtcbiAgaWYgKCF2KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGEgPSByZ2IyaHNsKHYpO1xuICBjb25zdCBoID0gYVswXTtcbiAgY29uc3QgcyA9IG4ycChhWzFdKTtcbiAgY29uc3QgbCA9IG4ycChhWzJdKTtcbiAgcmV0dXJuIHYuYSA8IDI1NVxuICAgID8gYGhzbGEoJHtofSwgJHtzfSUsICR7bH0lLCAke2Iybih2LmEpfSlgXG4gICAgOiBgaHNsKCR7aH0sICR7c30lLCAke2x9JSlgO1xufVxuXG5jb25zdCBtYXAgPSB7XG5cdHg6ICdkYXJrJyxcblx0WjogJ2xpZ2h0Jyxcblx0WTogJ3JlJyxcblx0WDogJ2JsdScsXG5cdFc6ICdncicsXG5cdFY6ICdtZWRpdW0nLFxuXHRVOiAnc2xhdGUnLFxuXHRBOiAnZWUnLFxuXHRUOiAnb2wnLFxuXHRTOiAnb3InLFxuXHRCOiAncmEnLFxuXHRDOiAnbGF0ZWcnLFxuXHREOiAnaWdodHMnLFxuXHRSOiAnaW4nLFxuXHRROiAndHVycXVvaXMnLFxuXHRFOiAnaGknLFxuXHRQOiAncm8nLFxuXHRPOiAnYWwnLFxuXHROOiAnbGUnLFxuXHRNOiAnZGUnLFxuXHRMOiAneWVsbG8nLFxuXHRGOiAnZW4nLFxuXHRLOiAnY2gnLFxuXHRHOiAnYXJrcycsXG5cdEg6ICdlYScsXG5cdEk6ICdpZ2h0ZycsXG5cdEo6ICd3aCdcbn07XG5jb25zdCBuYW1lcyQxID0ge1xuXHRPaWNlWGU6ICdmMGY4ZmYnLFxuXHRhbnRpcXVld0V0ZTogJ2ZhZWJkNycsXG5cdGFxdWE6ICdmZmZmJyxcblx0YXF1YW1hclJlOiAnN2ZmZmQ0Jyxcblx0YXp1WTogJ2YwZmZmZicsXG5cdGJlaWdlOiAnZjVmNWRjJyxcblx0YmlzcXVlOiAnZmZlNGM0Jyxcblx0YmxhY2s6ICcwJyxcblx0YmxhbktlZE9tb25kOiAnZmZlYmNkJyxcblx0WGU6ICdmZicsXG5cdFhldmlUZXQ6ICc4YTJiZTInLFxuXHRiUHduOiAnYTUyYTJhJyxcblx0YnVybHl3b29kOiAnZGViODg3Jyxcblx0Y2FNdFhlOiAnNWY5ZWEwJyxcblx0S2FydFl1c2U6ICc3ZmZmMDAnLFxuXHRLb2NUYXRlOiAnZDI2OTFlJyxcblx0Y1NPOiAnZmY3ZjUwJyxcblx0Y1NuZmxvd2VyWGU6ICc2NDk1ZWQnLFxuXHRjU25zaWxrOiAnZmZmOGRjJyxcblx0Y3JpbXNvbjogJ2RjMTQzYycsXG5cdGN5YW46ICdmZmZmJyxcblx0eFhlOiAnOGInLFxuXHR4Y3lhbjogJzhiOGInLFxuXHR4Z1RNblBkOiAnYjg4NjBiJyxcblx0eFdheTogJ2E5YTlhOScsXG5cdHhnWUY6ICc2NDAwJyxcblx0eGdZeTogJ2E5YTlhOScsXG5cdHhraGFraTogJ2JkYjc2YicsXG5cdHhtYWdGdGE6ICc4YjAwOGInLFxuXHR4VGl2ZWdZRjogJzU1NmIyZicsXG5cdHhTYW5nZTogJ2ZmOGMwMCcsXG5cdHhTY0VkOiAnOTkzMmNjJyxcblx0eFlkOiAnOGIwMDAwJyxcblx0eHNPbW9uOiAnZTk5NjdhJyxcblx0eHNIZ1lGOiAnOGZiYzhmJyxcblx0eFVYZTogJzQ4M2Q4YicsXG5cdHhVV2F5OiAnMmY0ZjRmJyxcblx0eFVnWXk6ICcyZjRmNGYnLFxuXHR4UWU6ICdjZWQxJyxcblx0eHZpVGV0OiAnOTQwMGQzJyxcblx0ZEFwcFJrOiAnZmYxNDkzJyxcblx0ZEFwc2t5WGU6ICdiZmZmJyxcblx0ZGltV2F5OiAnNjk2OTY5Jyxcblx0ZGltZ1l5OiAnNjk2OTY5Jyxcblx0ZG9kZ2VyWGU6ICcxZTkwZmYnLFxuXHRmaVlicmljazogJ2IyMjIyMicsXG5cdGZsU093RXRlOiAnZmZmYWYwJyxcblx0Zm9Zc3RXQW46ICcyMjhiMjInLFxuXHRmdUtzaWE6ICdmZjAwZmYnLFxuXHRnYVJzYlNvOiAnZGNkY2RjJyxcblx0Z2hvc3R3RXRlOiAnZjhmOGZmJyxcblx0Z1RkOiAnZmZkNzAwJyxcblx0Z1RNblBkOiAnZGFhNTIwJyxcblx0V2F5OiAnODA4MDgwJyxcblx0Z1lGOiAnODAwMCcsXG5cdGdZRkx3OiAnYWRmZjJmJyxcblx0Z1l5OiAnODA4MDgwJyxcblx0aG9uZXlNdzogJ2YwZmZmMCcsXG5cdGhvdHBSazogJ2ZmNjliNCcsXG5cdFJkaWFuWWQ6ICdjZDVjNWMnLFxuXHRSZGlnbzogJzRiMDA4MicsXG5cdGl2U3k6ICdmZmZmZjAnLFxuXHRraGFraTogJ2YwZTY4YycsXG5cdGxhdkZNcjogJ2U2ZTZmYScsXG5cdGxhdkZNclhzaDogJ2ZmZjBmNScsXG5cdGxhd25nWUY6ICc3Y2ZjMDAnLFxuXHRObW9uY0VmZm9uOiAnZmZmYWNkJyxcblx0WlhlOiAnYWRkOGU2Jyxcblx0WmNTTzogJ2YwODA4MCcsXG5cdFpjeWFuOiAnZTBmZmZmJyxcblx0WmdUTW5QZEx3OiAnZmFmYWQyJyxcblx0WldheTogJ2QzZDNkMycsXG5cdFpnWUY6ICc5MGVlOTAnLFxuXHRaZ1l5OiAnZDNkM2QzJyxcblx0WnBSazogJ2ZmYjZjMScsXG5cdFpzT21vbjogJ2ZmYTA3YScsXG5cdFpzSGdZRjogJzIwYjJhYScsXG5cdFpza3lYZTogJzg3Y2VmYScsXG5cdFpVV2F5OiAnNzc4ODk5Jyxcblx0WlVnWXk6ICc3Nzg4OTknLFxuXHRac3RBbFhlOiAnYjBjNGRlJyxcblx0Wkx3OiAnZmZmZmUwJyxcblx0bGltZTogJ2ZmMDAnLFxuXHRsaW1lZ1lGOiAnMzJjZDMyJyxcblx0bFJGOiAnZmFmMGU2Jyxcblx0bWFnRnRhOiAnZmYwMGZmJyxcblx0bWFQb246ICc4MDAwMDAnLFxuXHRWYXF1YW1hclJlOiAnNjZjZGFhJyxcblx0VlhlOiAnY2QnLFxuXHRWU2NFZDogJ2JhNTVkMycsXG5cdFZwdXJwTjogJzkzNzBkYicsXG5cdFZzSGdZRjogJzNjYjM3MScsXG5cdFZVWGU6ICc3YjY4ZWUnLFxuXHRWc3ByUmdnWUY6ICdmYTlhJyxcblx0VlFlOiAnNDhkMWNjJyxcblx0VnZpVGV0WWQ6ICdjNzE1ODUnLFxuXHRtaWRuaWdodFhlOiAnMTkxOTcwJyxcblx0bVJ0Y1lhbTogJ2Y1ZmZmYScsXG5cdG1pc3R5UHNlOiAnZmZlNGUxJyxcblx0bW9jY2FzUjogJ2ZmZTRiNScsXG5cdG5hdmFqb3dFdGU6ICdmZmRlYWQnLFxuXHRuYXZ5OiAnODAnLFxuXHRUZGxhY2U6ICdmZGY1ZTYnLFxuXHRUaXZlOiAnODA4MDAwJyxcblx0VGl2ZWRCYjogJzZiOGUyMycsXG5cdFNhbmdlOiAnZmZhNTAwJyxcblx0U2FuZ2VZZDogJ2ZmNDUwMCcsXG5cdFNjRWQ6ICdkYTcwZDYnLFxuXHRwT2VnVE1uUGQ6ICdlZWU4YWEnLFxuXHRwT2VnWUY6ICc5OGZiOTgnLFxuXHRwT2VRZTogJ2FmZWVlZScsXG5cdHBPZXZpVGV0WWQ6ICdkYjcwOTMnLFxuXHRwYXBheWF3RXA6ICdmZmVmZDUnLFxuXHRwSEtwdWZmOiAnZmZkYWI5Jyxcblx0cGVydTogJ2NkODUzZicsXG5cdHBSazogJ2ZmYzBjYicsXG5cdHBsdW06ICdkZGEwZGQnLFxuXHRwb3dNclhlOiAnYjBlMGU2Jyxcblx0cHVycE46ICc4MDAwODAnLFxuXHRZYmVjY2FwdXJwTjogJzY2MzM5OScsXG5cdFlkOiAnZmYwMDAwJyxcblx0UHN5YnJvd246ICdiYzhmOGYnLFxuXHRQeU9YZTogJzQxNjllMScsXG5cdHNhZGROYlB3bjogJzhiNDUxMycsXG5cdHNPbW9uOiAnZmE4MDcyJyxcblx0c2FuZHliUHduOiAnZjRhNDYwJyxcblx0c0hnWUY6ICcyZThiNTcnLFxuXHRzSHNoZWxsOiAnZmZmNWVlJyxcblx0c2lGbmE6ICdhMDUyMmQnLFxuXHRzaWx2ZXI6ICdjMGMwYzAnLFxuXHRza3lYZTogJzg3Y2VlYicsXG5cdFVYZTogJzZhNWFjZCcsXG5cdFVXYXk6ICc3MDgwOTAnLFxuXHRVZ1l5OiAnNzA4MDkwJyxcblx0c25vdzogJ2ZmZmFmYScsXG5cdHNwclJnZ1lGOiAnZmY3ZicsXG5cdHN0QWxYZTogJzQ2ODJiNCcsXG5cdHRhbjogJ2QyYjQ4YycsXG5cdHRlTzogJzgwODAnLFxuXHR0RXN0TjogJ2Q4YmZkOCcsXG5cdHRvbWF0bzogJ2ZmNjM0NycsXG5cdFFlOiAnNDBlMGQwJyxcblx0dmlUZXQ6ICdlZTgyZWUnLFxuXHRKSHQ6ICdmNWRlYjMnLFxuXHR3RXRlOiAnZmZmZmZmJyxcblx0d0V0ZXNtb2tlOiAnZjVmNWY1Jyxcblx0THc6ICdmZmZmMDAnLFxuXHRMd2dZRjogJzlhY2QzMidcbn07XG5mdW5jdGlvbiB1bnBhY2soKSB7XG4gIGNvbnN0IHVucGFja2VkID0ge307XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhuYW1lcyQxKTtcbiAgY29uc3QgdGtleXMgPSBPYmplY3Qua2V5cyhtYXApO1xuICBsZXQgaSwgaiwgaywgb2ssIG5rO1xuICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIG9rID0gbmsgPSBrZXlzW2ldO1xuICAgIGZvciAoaiA9IDA7IGogPCB0a2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgayA9IHRrZXlzW2pdO1xuICAgICAgbmsgPSBuay5yZXBsYWNlKGssIG1hcFtrXSk7XG4gICAgfVxuICAgIGsgPSBwYXJzZUludChuYW1lcyQxW29rXSwgMTYpO1xuICAgIHVucGFja2VkW25rXSA9IFtrID4+IDE2ICYgMHhGRiwgayA+PiA4ICYgMHhGRiwgayAmIDB4RkZdO1xuICB9XG4gIHJldHVybiB1bnBhY2tlZDtcbn1cblxubGV0IG5hbWVzO1xuZnVuY3Rpb24gbmFtZVBhcnNlKHN0cikge1xuICBpZiAoIW5hbWVzKSB7XG4gICAgbmFtZXMgPSB1bnBhY2soKTtcbiAgICBuYW1lcy50cmFuc3BhcmVudCA9IFswLCAwLCAwLCAwXTtcbiAgfVxuICBjb25zdCBhID0gbmFtZXNbc3RyLnRvTG93ZXJDYXNlKCldO1xuICByZXR1cm4gYSAmJiB7XG4gICAgcjogYVswXSxcbiAgICBnOiBhWzFdLFxuICAgIGI6IGFbMl0sXG4gICAgYTogYS5sZW5ndGggPT09IDQgPyBhWzNdIDogMjU1XG4gIH07XG59XG5cbmNvbnN0IFJHQl9SRSA9IC9ecmdiYT9cXChcXHMqKFstKy5cXGRdKykoJSk/W1xccyxdKyhbLSsuZVxcZF0rKSglKT9bXFxzLF0rKFstKy5lXFxkXSspKCUpPyg/OltcXHMsL10rKFstKy5lXFxkXSspKCUpPyk/XFxzKlxcKSQvO1xuZnVuY3Rpb24gcmdiUGFyc2Uoc3RyKSB7XG4gIGNvbnN0IG0gPSBSR0JfUkUuZXhlYyhzdHIpO1xuICBsZXQgYSA9IDI1NTtcbiAgbGV0IHIsIGcsIGI7XG4gIGlmICghbSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobVs3XSAhPT0gcikge1xuICAgIGNvbnN0IHYgPSArbVs3XTtcbiAgICBhID0gbVs4XSA/IHAyYih2KSA6IGxpbSh2ICogMjU1LCAwLCAyNTUpO1xuICB9XG4gIHIgPSArbVsxXTtcbiAgZyA9ICttWzNdO1xuICBiID0gK21bNV07XG4gIHIgPSAyNTUgJiAobVsyXSA/IHAyYihyKSA6IGxpbShyLCAwLCAyNTUpKTtcbiAgZyA9IDI1NSAmIChtWzRdID8gcDJiKGcpIDogbGltKGcsIDAsIDI1NSkpO1xuICBiID0gMjU1ICYgKG1bNl0gPyBwMmIoYikgOiBsaW0oYiwgMCwgMjU1KSk7XG4gIHJldHVybiB7XG4gICAgcjogcixcbiAgICBnOiBnLFxuICAgIGI6IGIsXG4gICAgYTogYVxuICB9O1xufVxuZnVuY3Rpb24gcmdiU3RyaW5nKHYpIHtcbiAgcmV0dXJuIHYgJiYgKFxuICAgIHYuYSA8IDI1NVxuICAgICAgPyBgcmdiYSgke3Yucn0sICR7di5nfSwgJHt2LmJ9LCAke2Iybih2LmEpfSlgXG4gICAgICA6IGByZ2IoJHt2LnJ9LCAke3YuZ30sICR7di5ifSlgXG4gICk7XG59XG5cbmNvbnN0IHRvID0gdiA9PiB2IDw9IDAuMDAzMTMwOCA/IHYgKiAxMi45MiA6IE1hdGgucG93KHYsIDEuMCAvIDIuNCkgKiAxLjA1NSAtIDAuMDU1O1xuY29uc3QgZnJvbSA9IHYgPT4gdiA8PSAwLjA0MDQ1ID8gdiAvIDEyLjkyIDogTWF0aC5wb3coKHYgKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbmZ1bmN0aW9uIGludGVycG9sYXRlKHJnYjEsIHJnYjIsIHQpIHtcbiAgY29uc3QgciA9IGZyb20oYjJuKHJnYjEucikpO1xuICBjb25zdCBnID0gZnJvbShiMm4ocmdiMS5nKSk7XG4gIGNvbnN0IGIgPSBmcm9tKGIybihyZ2IxLmIpKTtcbiAgcmV0dXJuIHtcbiAgICByOiBuMmIodG8ociArIHQgKiAoZnJvbShiMm4ocmdiMi5yKSkgLSByKSkpLFxuICAgIGc6IG4yYih0byhnICsgdCAqIChmcm9tKGIybihyZ2IyLmcpKSAtIGcpKSksXG4gICAgYjogbjJiKHRvKGIgKyB0ICogKGZyb20oYjJuKHJnYjIuYikpIC0gYikpKSxcbiAgICBhOiByZ2IxLmEgKyB0ICogKHJnYjIuYSAtIHJnYjEuYSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gbW9kSFNMKHYsIGksIHJhdGlvKSB7XG4gIGlmICh2KSB7XG4gICAgbGV0IHRtcCA9IHJnYjJoc2wodik7XG4gICAgdG1wW2ldID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odG1wW2ldICsgdG1wW2ldICogcmF0aW8sIGkgPT09IDAgPyAzNjAgOiAxKSk7XG4gICAgdG1wID0gaHNsMnJnYih0bXApO1xuICAgIHYuciA9IHRtcFswXTtcbiAgICB2LmcgPSB0bXBbMV07XG4gICAgdi5iID0gdG1wWzJdO1xuICB9XG59XG5mdW5jdGlvbiBjbG9uZSh2LCBwcm90bykge1xuICByZXR1cm4gdiA/IE9iamVjdC5hc3NpZ24ocHJvdG8gfHwge30sIHYpIDogdjtcbn1cbmZ1bmN0aW9uIGZyb21PYmplY3QoaW5wdXQpIHtcbiAgdmFyIHYgPSB7cjogMCwgZzogMCwgYjogMCwgYTogMjU1fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgaWYgKGlucHV0Lmxlbmd0aCA+PSAzKSB7XG4gICAgICB2ID0ge3I6IGlucHV0WzBdLCBnOiBpbnB1dFsxXSwgYjogaW5wdXRbMl0sIGE6IDI1NX07XG4gICAgICBpZiAoaW5wdXQubGVuZ3RoID4gMykge1xuICAgICAgICB2LmEgPSBuMmIoaW5wdXRbM10pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2ID0gY2xvbmUoaW5wdXQsIHtyOiAwLCBnOiAwLCBiOiAwLCBhOiAxfSk7XG4gICAgdi5hID0gbjJiKHYuYSk7XG4gIH1cbiAgcmV0dXJuIHY7XG59XG5mdW5jdGlvbiBmdW5jdGlvblBhcnNlKHN0cikge1xuICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJ3InKSB7XG4gICAgcmV0dXJuIHJnYlBhcnNlKHN0cik7XG4gIH1cbiAgcmV0dXJuIGh1ZVBhcnNlKHN0cik7XG59XG5jbGFzcyBDb2xvciB7XG4gIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBpbnB1dDtcbiAgICBsZXQgdjtcbiAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHYgPSBmcm9tT2JqZWN0KGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2ID0gaGV4UGFyc2UoaW5wdXQpIHx8IG5hbWVQYXJzZShpbnB1dCkgfHwgZnVuY3Rpb25QYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHRoaXMuX3JnYiA9IHY7XG4gICAgdGhpcy5fdmFsaWQgPSAhIXY7XG4gIH1cbiAgZ2V0IHZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZDtcbiAgfVxuICBnZXQgcmdiKCkge1xuICAgIHZhciB2ID0gY2xvbmUodGhpcy5fcmdiKTtcbiAgICBpZiAodikge1xuICAgICAgdi5hID0gYjJuKHYuYSk7XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9XG4gIHNldCByZ2Iob2JqKSB7XG4gICAgdGhpcy5fcmdiID0gZnJvbU9iamVjdChvYmopO1xuICB9XG4gIHJnYlN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQgPyByZ2JTdHJpbmcodGhpcy5fcmdiKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBoZXhTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkID8gaGV4U3RyaW5nKHRoaXMuX3JnYikgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaHNsU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZCA/IGhzbFN0cmluZyh0aGlzLl9yZ2IpIDogdW5kZWZpbmVkO1xuICB9XG4gIG1peChjb2xvciwgd2VpZ2h0KSB7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBjb25zdCBjMSA9IHRoaXMucmdiO1xuICAgICAgY29uc3QgYzIgPSBjb2xvci5yZ2I7XG4gICAgICBsZXQgdzI7XG4gICAgICBjb25zdCBwID0gd2VpZ2h0ID09PSB3MiA/IDAuNSA6IHdlaWdodDtcbiAgICAgIGNvbnN0IHcgPSAyICogcCAtIDE7XG4gICAgICBjb25zdCBhID0gYzEuYSAtIGMyLmE7XG4gICAgICBjb25zdCB3MSA9ICgodyAqIGEgPT09IC0xID8gdyA6ICh3ICsgYSkgLyAoMSArIHcgKiBhKSkgKyAxKSAvIDIuMDtcbiAgICAgIHcyID0gMSAtIHcxO1xuICAgICAgYzEuciA9IDB4RkYgJiB3MSAqIGMxLnIgKyB3MiAqIGMyLnIgKyAwLjU7XG4gICAgICBjMS5nID0gMHhGRiAmIHcxICogYzEuZyArIHcyICogYzIuZyArIDAuNTtcbiAgICAgIGMxLmIgPSAweEZGICYgdzEgKiBjMS5iICsgdzIgKiBjMi5iICsgMC41O1xuICAgICAgYzEuYSA9IHAgKiBjMS5hICsgKDEgLSBwKSAqIGMyLmE7XG4gICAgICB0aGlzLnJnYiA9IGMxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpbnRlcnBvbGF0ZShjb2xvciwgdCkge1xuICAgIGlmIChjb2xvcikge1xuICAgICAgdGhpcy5fcmdiID0gaW50ZXJwb2xhdGUodGhpcy5fcmdiLCBjb2xvci5fcmdiLCB0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBDb2xvcih0aGlzLnJnYik7XG4gIH1cbiAgYWxwaGEoYSkge1xuICAgIHRoaXMuX3JnYi5hID0gbjJiKGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsZWFyZXIocmF0aW8pIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgcmdiLmEgKj0gMSAtIHJhdGlvO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdyZXlzY2FsZSgpIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgY29uc3QgdmFsID0gcm91bmQocmdiLnIgKiAwLjMgKyByZ2IuZyAqIDAuNTkgKyByZ2IuYiAqIDAuMTEpO1xuICAgIHJnYi5yID0gcmdiLmcgPSByZ2IuYiA9IHZhbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvcGFxdWVyKHJhdGlvKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fcmdiO1xuICAgIHJnYi5hICo9IDEgKyByYXRpbztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBuZWdhdGUoKSB7XG4gICAgY29uc3QgdiA9IHRoaXMuX3JnYjtcbiAgICB2LnIgPSAyNTUgLSB2LnI7XG4gICAgdi5nID0gMjU1IC0gdi5nO1xuICAgIHYuYiA9IDI1NSAtIHYuYjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsaWdodGVuKHJhdGlvKSB7XG4gICAgbW9kSFNMKHRoaXMuX3JnYiwgMiwgcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRhcmtlbihyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDIsIC1yYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2F0dXJhdGUocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAxLCByYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZGVzYXR1cmF0ZShyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDEsIC1yYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcm90YXRlKGRlZykge1xuICAgIHJvdGF0ZSh0aGlzLl9yZ2IsIGRlZyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhfZXNtKGlucHV0KSB7XG4gIHJldHVybiBuZXcgQ29sb3IoaW5wdXQpO1xufVxuXG5leHBvcnQgeyBDb2xvciwgYjJuLCBiMnAsIGluZGV4X2VzbSBhcyBkZWZhdWx0LCBoZXhQYXJzZSwgaGV4U3RyaW5nLCBoc2wycmdiLCBoc2xTdHJpbmcsIGhzdjJyZ2IsIGh1ZVBhcnNlLCBod2IycmdiLCBsaW0sIG4yYiwgbjJwLCBuYW1lUGFyc2UsIHAyYiwgcmdiMmhzbCwgcmdiUGFyc2UsIHJnYlN0cmluZywgcm90YXRlLCByb3VuZCB9O1xuIiwgIi8qKlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzXG4gKi9cblxuaW1wb3J0IHR5cGUge0FueU9iamVjdH0gZnJvbSAnLi4vdHlwZXMvYmFzaWMuanMnO1xuaW1wb3J0IHR5cGUge0FjdGl2ZURhdGFQb2ludCwgQ2hhcnRFdmVudH0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuXG4vKipcbiAqIEFuIGVtcHR5IGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCBmb3Igb3B0aW9uYWwgY2FsbGJhY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub29wKCkge1xuICAvKiBub29wICovXG59XG5cbi8qKlxuICogUmV0dXJucyBhIHVuaXF1ZSBpZCwgc2VxdWVudGlhbGx5IGdlbmVyYXRlZCBmcm9tIGEgZ2xvYmFsIHZhcmlhYmxlLlxuICovXG5leHBvcnQgY29uc3QgdWlkID0gKCgpID0+IHtcbiAgbGV0IGlkID0gMDtcbiAgcmV0dXJuICgpID0+IGlkKys7XG59KSgpO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIG5laXRoZXIgbnVsbCBub3IgdW5kZWZpbmVkLCBlbHNlIHJldHVybnMgZmFsc2UuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOdWxsT3JVbmRlZih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIG51bGwgfCB1bmRlZmluZWQge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSAoaW5jbHVkaW5nIHR5cGVkIGFycmF5cyksIGVsc2UgcmV0dXJucyBmYWxzZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5PFQgPSB1bmtub3duPih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFRbXSB7XG4gIGlmIChBcnJheS5pc0FycmF5ICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh0eXBlLnNsaWNlKDAsIDcpID09PSAnW29iamVjdCcgJiYgdHlwZS5zbGljZSgtNikgPT09ICdBcnJheV0nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCAoZXhjbHVkaW5nIG51bGwpLCBlbHNlIHJldHVybnMgZmFsc2UuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBBbnlPYmplY3Qge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLCBlbHNlIHJldHVybnMgZmFsc2VcbiAqIEBwYXJhbSB2YWx1ZSAgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXJGaW5pdGUodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBudW1iZXIge1xuICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpICYmIGlzRmluaXRlKCt2YWx1ZSk7XG59XG5leHBvcnQge1xuICBpc051bWJlckZpbml0ZSBhcyBpc0Zpbml0ZSxcbn07XG5cbi8qKlxuICogUmV0dXJucyBgdmFsdWVgIGlmIGZpbml0ZSwgZWxzZSByZXR1cm5zIGBkZWZhdWx0VmFsdWVgLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBkZWZpbmVkLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgYHZhbHVlYCBpcyBub3QgZmluaXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluaXRlT3JEZWZhdWx0KHZhbHVlOiB1bmtub3duLCBkZWZhdWx0VmFsdWU6IG51bWJlcikge1xuICByZXR1cm4gaXNOdW1iZXJGaW5pdGUodmFsdWUpID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG59XG5cbi8qKlxuICogUmV0dXJucyBgdmFsdWVgIGlmIGRlZmluZWQsIGVsc2UgcmV0dXJucyBgZGVmYXVsdFZhbHVlYC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgZGVmaW5lZC5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsdWVPckRlZmF1bHQ8VD4odmFsdWU6IFQgfCB1bmRlZmluZWQsIGRlZmF1bHRWYWx1ZTogVCkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xufVxuXG5leHBvcnQgY29uc3QgdG9QZXJjZW50YWdlID0gKHZhbHVlOiBudW1iZXIgfCBzdHJpbmcsIGRpbWVuc2lvbjogbnVtYmVyKSA9PlxuICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKCclJykgP1xuICAgIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwXG4gICAgOiArdmFsdWUgLyBkaW1lbnNpb247XG5cbmV4cG9ydCBjb25zdCB0b0RpbWVuc2lvbiA9ICh2YWx1ZTogbnVtYmVyIHwgc3RyaW5nLCBkaW1lbnNpb246IG51bWJlcikgPT5cbiAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5lbmRzV2l0aCgnJScpID9cbiAgICBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMCAqIGRpbWVuc2lvblxuICAgIDogK3ZhbHVlO1xuXG4vKipcbiAqIENhbGxzIGBmbmAgd2l0aCB0aGUgZ2l2ZW4gYGFyZ3NgIGluIHRoZSBzY29wZSBkZWZpbmVkIGJ5IGB0aGlzQXJnYCBhbmQgcmV0dXJucyB0aGVcbiAqIHZhbHVlIHJldHVybmVkIGJ5IGBmbmAuIElmIGBmbmAgaXMgbm90IGEgZnVuY3Rpb24sIHRoaXMgbWV0aG9kIHJldHVybnMgdW5kZWZpbmVkLlxuICogQHBhcmFtIGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgd2l0aCB3aGljaCBgZm5gIHNob3VsZCBiZSBjYWxsZWQuXG4gKiBAcGFyYW0gW3RoaXNBcmddIC0gVGhlIHZhbHVlIG9mIGB0aGlzYCBwcm92aWRlZCBmb3IgdGhlIGNhbGwgdG8gYGZuYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGxiYWNrPFQgZXh0ZW5kcyAodGhpczogVEEsIC4uLnJlc3RBcmdzOiB1bmtub3duW10pID0+IFIsIFRBLCBSPihcbiAgZm46IFQgfCB1bmRlZmluZWQsXG4gIGFyZ3M6IHVua25vd25bXSxcbiAgdGhpc0FyZz86IFRBXG4pOiBSIHwgdW5kZWZpbmVkIHtcbiAgaWYgKGZuICYmIHR5cGVvZiBmbi5jYWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9XG59XG5cbi8qKlxuICogTm90ZShTQikgZm9yIHBlcmZvcm1hbmNlIHNha2UsIHRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiBsb29wYWJsZSB0eXBlXG4gKiBpcyB1bmtub3duIG9yIGluIG5vbmUgaW50ZW5zaXZlIGNvZGUgKG5vdCBjYWxsZWQgb2Z0ZW4gYW5kIHNtYWxsIGxvb3BhYmxlKS4gRWxzZVxuICogaXQncyBwcmVmZXJhYmxlIHRvIHVzZSBhIHJlZ3VsYXIgZm9yKCkgbG9vcCBhbmQgc2F2ZSBleHRyYSBmdW5jdGlvbiBjYWxscy5cbiAqIEBwYXJhbSBsb29wYWJsZSAtIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gYmUgaXRlcmF0ZWQuXG4gKiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpdGVtLlxuICogQHBhcmFtIFt0aGlzQXJnXSAtIFRoZSB2YWx1ZSBvZiBgdGhpc2AgcHJvdmlkZWQgZm9yIHRoZSBjYWxsIHRvIGBmbmAuXG4gKiBAcGFyYW0gW3JldmVyc2VdIC0gSWYgdHJ1ZSwgaXRlcmF0ZXMgYmFja3dhcmQgb24gdGhlIGxvb3BhYmxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZWFjaDxULCBUQT4oXG4gIGxvb3BhYmxlOiBSZWNvcmQ8c3RyaW5nLCBUPixcbiAgZm46ICh0aGlzOiBUQSwgdjogVCwgaTogc3RyaW5nKSA9PiB2b2lkLFxuICB0aGlzQXJnPzogVEEsXG4gIHJldmVyc2U/OiBib29sZWFuXG4pOiB2b2lkO1xuZXhwb3J0IGZ1bmN0aW9uIGVhY2g8VCwgVEE+KFxuICBsb29wYWJsZTogVFtdLFxuICBmbjogKHRoaXM6IFRBLCB2OiBULCBpOiBudW1iZXIpID0+IHZvaWQsXG4gIHRoaXNBcmc/OiBUQSxcbiAgcmV2ZXJzZT86IGJvb2xlYW5cbik6IHZvaWQ7XG5leHBvcnQgZnVuY3Rpb24gZWFjaDxULCBUQT4oXG4gIGxvb3BhYmxlOiBUW10gfCBSZWNvcmQ8c3RyaW5nLCBUPixcbiAgZm46ICh0aGlzOiBUQSwgdjogVCwgaTogYW55KSA9PiB2b2lkLFxuICB0aGlzQXJnPzogVEEsXG4gIHJldmVyc2U/OiBib29sZWFuXG4pIHtcbiAgbGV0IGk6IG51bWJlciwgbGVuOiBudW1iZXIsIGtleXM6IHN0cmluZ1tdO1xuICBpZiAoaXNBcnJheShsb29wYWJsZSkpIHtcbiAgICBsZW4gPSBsb29wYWJsZS5sZW5ndGg7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxvb3BhYmxlKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyhsb29wYWJsZSk7XG4gICAgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2tleXNbaV1dLCBrZXlzW2ldKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGBhMGAgYW5kIGBhMWAgYXJyYXlzIGhhdmUgdGhlIHNhbWUgY29udGVudCwgZWxzZSByZXR1cm5zIGZhbHNlLlxuICogQHBhcmFtIGEwIC0gVGhlIGFycmF5IHRvIGNvbXBhcmVcbiAqIEBwYXJhbSBhMSAtIFRoZSBhcnJheSB0byBjb21wYXJlXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2VsZW1lbnRzRXF1YWwoYTA6IEFjdGl2ZURhdGFQb2ludFtdLCBhMTogQWN0aXZlRGF0YVBvaW50W10pIHtcbiAgbGV0IGk6IG51bWJlciwgaWxlbjogbnVtYmVyLCB2MDogQWN0aXZlRGF0YVBvaW50LCB2MTogQWN0aXZlRGF0YVBvaW50O1xuXG4gIGlmICghYTAgfHwgIWExIHx8IGEwLmxlbmd0aCAhPT0gYTEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGEwLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIHYwID0gYTBbaV07XG4gICAgdjEgPSBhMVtpXTtcblxuICAgIGlmICh2MC5kYXRhc2V0SW5kZXggIT09IHYxLmRhdGFzZXRJbmRleCB8fCB2MC5pbmRleCAhPT0gdjEuaW5kZXgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZGVlcCBjb3B5IG9mIGBzb3VyY2VgIHdpdGhvdXQga2VlcGluZyByZWZlcmVuY2VzIG9uIG9iamVjdHMgYW5kIGFycmF5cy5cbiAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZTxUPihzb3VyY2U6IFQpOiBUIHtcbiAgaWYgKGlzQXJyYXkoc291cmNlKSkge1xuICAgIHJldHVybiBzb3VyY2UubWFwKGNsb25lKSBhcyB1bmtub3duIGFzIFQ7XG4gIH1cblxuICBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xuICAgIGNvbnN0IHRhcmdldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgY29uc3Qga2xlbiA9IGtleXMubGVuZ3RoO1xuICAgIGxldCBrID0gMDtcblxuICAgIGZvciAoOyBrIDwga2xlbjsgKytrKSB7XG4gICAgICB0YXJnZXRba2V5c1trXV0gPSBjbG9uZShzb3VyY2Vba2V5c1trXV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICByZXR1cm4gc291cmNlO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleTogc3RyaW5nKSB7XG4gIHJldHVybiBbJ19fcHJvdG9fXycsICdwcm90b3R5cGUnLCAnY29uc3RydWN0b3InXS5pbmRleE9mKGtleSkgPT09IC0xO1xufVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IG1lcmdlciB3aGVuIENoYXJ0LmhlbHBlcnMubWVyZ2UgaXMgY2FsbGVkIHdpdGhvdXQgbWVyZ2VyIG9wdGlvbi5cbiAqIE5vdGUoU0IpOiBhbHNvIHVzZWQgYnkgbWVyZ2VDb25maWcgYW5kIG1lcmdlU2NhbGVDb25maWcgYXMgZmFsbGJhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX21lcmdlcihrZXk6IHN0cmluZywgdGFyZ2V0OiBBbnlPYmplY3QsIHNvdXJjZTogQW55T2JqZWN0LCBvcHRpb25zOiBBbnlPYmplY3QpIHtcbiAgaWYgKCFpc1ZhbGlkS2V5KGtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB0dmFsID0gdGFyZ2V0W2tleV07XG4gIGNvbnN0IHN2YWwgPSBzb3VyY2Vba2V5XTtcblxuICBpZiAoaXNPYmplY3QodHZhbCkgJiYgaXNPYmplY3Qoc3ZhbCkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgbWVyZ2UodHZhbCwgc3ZhbCwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0W2tleV0gPSBjbG9uZShzdmFsKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1lcmdlT3B0aW9ucyB7XG4gIG1lcmdlcj86IChrZXk6IHN0cmluZywgdGFyZ2V0OiBBbnlPYmplY3QsIHNvdXJjZTogQW55T2JqZWN0LCBvcHRpb25zPzogQW55T2JqZWN0KSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGRlZXAgY29waWVzIGBzb3VyY2VgIHByb3BlcnRpZXMgaW50byBgdGFyZ2V0YCB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AuXG4gKiBJTVBPUlRBTlQ6IGB0YXJnZXRgIGlzIG5vdCBjbG9uZWQgYW5kIHdpbGwgYmUgdXBkYXRlZCB3aXRoIGBzb3VyY2VgIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QgaW4gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIG1lcmdlZCBpbnRvLlxuICogQHBhcmFtIHNvdXJjZSAtIE9iamVjdChzKSB0byBtZXJnZSBpbnRvIGB0YXJnZXRgLlxuICogQHBhcmFtIFtvcHRpb25zXSAtIE1lcmdpbmcgb3B0aW9uczpcbiAqIEBwYXJhbSBbb3B0aW9ucy5tZXJnZXJdIC0gVGhlIG1lcmdlIG1ldGhvZCAoa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcbiAqIEByZXR1cm5zIFRoZSBgdGFyZ2V0YCBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxUPih0YXJnZXQ6IFQsIHNvdXJjZTogW10sIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBUO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQsIFMxPih0YXJnZXQ6IFQsIHNvdXJjZTogUzEsIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBUICYgUzE7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgUzE+KHRhcmdldDogVCwgc291cmNlOiBbUzFdLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogVCAmIFMxO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQsIFMxLCBTMj4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMSwgUzJdLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogVCAmIFMxICYgUzI7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgUzEsIFMyLCBTMz4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMSwgUzIsIFMzXSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IFQgJiBTMSAmIFMyICYgUzM7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgUzEsIFMyLCBTMywgUzQ+KFxuICB0YXJnZXQ6IFQsXG4gIHNvdXJjZTogW1MxLCBTMiwgUzMsIFM0XSxcbiAgb3B0aW9ucz86IE1lcmdlT3B0aW9uc1xuKTogVCAmIFMxICYgUzIgJiBTMyAmIFM0O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQ+KHRhcmdldDogVCwgc291cmNlOiBBbnlPYmplY3RbXSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IEFueU9iamVjdDtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxUPih0YXJnZXQ6IFQsIHNvdXJjZTogQW55T2JqZWN0W10sIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBBbnlPYmplY3Qge1xuICBjb25zdCBzb3VyY2VzID0gaXNBcnJheShzb3VyY2UpID8gc291cmNlIDogW3NvdXJjZV07XG4gIGNvbnN0IGlsZW4gPSBzb3VyY2VzLmxlbmd0aDtcblxuICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0IGFzIEFueU9iamVjdDtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBtZXJnZXIgPSBvcHRpb25zLm1lcmdlciB8fCBfbWVyZ2VyO1xuICBsZXQgY3VycmVudDogQW55T2JqZWN0O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY3VycmVudCA9IHNvdXJjZXNbaV07XG4gICAgaWYgKCFpc09iamVjdChjdXJyZW50KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGN1cnJlbnQpO1xuICAgIGZvciAobGV0IGsgPSAwLCBrbGVuID0ga2V5cy5sZW5ndGg7IGsgPCBrbGVuOyArK2spIHtcbiAgICAgIG1lcmdlcihrZXlzW2tdLCB0YXJnZXQsIGN1cnJlbnQsIG9wdGlvbnMgYXMgQW55T2JqZWN0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGRlZXAgY29waWVzIGBzb3VyY2VgIHByb3BlcnRpZXMgaW50byBgdGFyZ2V0YCAqb25seSogaWYgbm90IGRlZmluZWQgaW4gdGFyZ2V0LlxuICogSU1QT1JUQU5UOiBgdGFyZ2V0YCBpcyBub3QgY2xvbmVkIGFuZCB3aWxsIGJlIHVwZGF0ZWQgd2l0aCBgc291cmNlYCBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgb2JqZWN0IGluIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSBtZXJnZWQgaW50by5cbiAqIEBwYXJhbSBzb3VyY2UgLSBPYmplY3QocykgdG8gbWVyZ2UgaW50byBgdGFyZ2V0YC5cbiAqIEByZXR1cm5zIFRoZSBgdGFyZ2V0YCBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQ+KHRhcmdldDogVCwgc291cmNlOiBbXSk6IFQ7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJZjxULCBTMT4odGFyZ2V0OiBULCBzb3VyY2U6IFMxKTogVCAmIFMxO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VCwgUzE+KHRhcmdldDogVCwgc291cmNlOiBbUzFdKTogVCAmIFMxO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VCwgUzEsIFMyPih0YXJnZXQ6IFQsIHNvdXJjZTogW1MxLCBTMl0pOiBUICYgUzEgJiBTMjtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQsIFMxLCBTMiwgUzM+KHRhcmdldDogVCwgc291cmNlOiBbUzEsIFMyLCBTM10pOiBUICYgUzEgJiBTMiAmIFMzO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VCwgUzEsIFMyLCBTMywgUzQ+KHRhcmdldDogVCwgc291cmNlOiBbUzEsIFMyLCBTMywgUzRdKTogVCAmIFMxICYgUzIgJiBTMyAmIFM0O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VD4odGFyZ2V0OiBULCBzb3VyY2U6IEFueU9iamVjdFtdKTogQW55T2JqZWN0O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VD4odGFyZ2V0OiBULCBzb3VyY2U6IEFueU9iamVjdFtdKTogQW55T2JqZWN0IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICByZXR1cm4gbWVyZ2U8VD4odGFyZ2V0LCBzb3VyY2UsIHttZXJnZXI6IF9tZXJnZXJJZn0pO1xufVxuXG4vKipcbiAqIE1lcmdlcyBzb3VyY2Vba2V5XSBpbiB0YXJnZXRba2V5XSBvbmx5IGlmIHRhcmdldFtrZXldIGlzIHVuZGVmaW5lZC5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfbWVyZ2VySWYoa2V5OiBzdHJpbmcsIHRhcmdldDogQW55T2JqZWN0LCBzb3VyY2U6IEFueU9iamVjdCkge1xuICBpZiAoIWlzVmFsaWRLZXkoa2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHR2YWwgPSB0YXJnZXRba2V5XTtcbiAgY29uc3Qgc3ZhbCA9IHNvdXJjZVtrZXldO1xuXG4gIGlmIChpc09iamVjdCh0dmFsKSAmJiBpc09iamVjdChzdmFsKSkge1xuICAgIG1lcmdlSWYodHZhbCwgc3ZhbCk7XG4gIH0gZWxzZSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IGNsb25lKHN2YWwpO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9kZXByZWNhdGVkKHNjb3BlOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duLCBwcmV2aW91czogc3RyaW5nLCBjdXJyZW50OiBzdHJpbmcpIHtcbiAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oc2NvcGUgKyAnOiBcIicgKyBwcmV2aW91cyArXG4gICAgICAnXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcIicgKyBjdXJyZW50ICsgJ1wiIGluc3RlYWQnKTtcbiAgfVxufVxuXG4vLyByZXNvbHZlT2JqZWN0S2V5IHJlc29sdmVyIGNhY2hlXG5jb25zdCBrZXlSZXNvbHZlcnMgPSB7XG4gIC8vIENoYXJ0LmhlbHBlcnMuY29yZSByZXNvbHZlT2JqZWN0S2V5IHNob3VsZCByZXNvbHZlIGVtcHR5IGtleSB0byByb290IG9iamVjdFxuICAnJzogdiA9PiB2LFxuICAvLyBkZWZhdWx0IHJlc29sdmVyc1xuICB4OiBvID0+IG8ueCxcbiAgeTogbyA9PiBvLnlcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zcGxpdEtleShrZXk6IHN0cmluZykge1xuICBjb25zdCBwYXJ0cyA9IGtleS5zcGxpdCgnLicpO1xuICBjb25zdCBrZXlzOiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgdG1wID0gJyc7XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIHRtcCArPSBwYXJ0O1xuICAgIGlmICh0bXAuZW5kc1dpdGgoJ1xcXFwnKSkge1xuICAgICAgdG1wID0gdG1wLnNsaWNlKDAsIC0xKSArICcuJztcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cy5wdXNoKHRtcCk7XG4gICAgICB0bXAgPSAnJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9nZXRLZXlSZXNvbHZlcihrZXk6IHN0cmluZykge1xuICBjb25zdCBrZXlzID0gX3NwbGl0S2V5KGtleSk7XG4gIHJldHVybiBvYmogPT4ge1xuICAgIGZvciAoY29uc3QgayBvZiBrZXlzKSB7XG4gICAgICBpZiAoayA9PT0gJycpIHtcbiAgICAgICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHk6XG4gICAgICAgIC8vIENoYXJ0LmhlbHBlcnMuY29yZSByZXNvbHZlT2JqZWN0S2V5IHNob3VsZCBicmVhayBhdCBlbXB0eSBrZXlcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBvYmogPSBvYmogJiYgb2JqW2tdO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZU9iamVjdEtleShvYmo6IEFueU9iamVjdCwga2V5OiBzdHJpbmcpOiBhbnkge1xuICBjb25zdCByZXNvbHZlciA9IGtleVJlc29sdmVyc1trZXldIHx8IChrZXlSZXNvbHZlcnNba2V5XSA9IF9nZXRLZXlSZXNvbHZlcihrZXkpKTtcbiAgcmV0dXJuIHJlc29sdmVyKG9iaik7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jYXBpdGFsaXplKHN0cjogc3RyaW5nKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59XG5cblxuZXhwb3J0IGNvbnN0IGRlZmluZWQgPSAodmFsdWU6IHVua25vd24pID0+IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCc7XG5cbmV4cG9ydCBjb25zdCBpc0Z1bmN0aW9uID0gKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkgPT4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuXG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzExMjg4NTUvY29tcGFyaW5nLWVjbWE2LXNldHMtZm9yLWVxdWFsaXR5IzMxMTI5Mzg0XG5leHBvcnQgY29uc3Qgc2V0c0VxdWFsID0gPFQ+KGE6IFNldDxUPiwgYjogU2V0PFQ+KSA9PiB7XG4gIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAoY29uc3QgaXRlbSBvZiBhKSB7XG4gICAgaWYgKCFiLmhhcyhpdGVtKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gZSAtIFRoZSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9pc0NsaWNrRXZlbnQoZTogQ2hhcnRFdmVudCkge1xuICByZXR1cm4gZS50eXBlID09PSAnbW91c2V1cCcgfHwgZS50eXBlID09PSAnY2xpY2snIHx8IGUudHlwZSA9PT0gJ2NvbnRleHRtZW51Jztcbn1cbiIsICJpbXBvcnQgdHlwZSB7UG9pbnR9IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5pbXBvcnQge2lzRmluaXRlIGFzIGlzRmluaXRlTnVtYmVyfSBmcm9tICcuL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogQGFsaWFzIENoYXJ0LmhlbHBlcnMubWF0aFxuICogQG5hbWVzcGFjZVxuICovXG5cbmV4cG9ydCBjb25zdCBQSSA9IE1hdGguUEk7XG5leHBvcnQgY29uc3QgVEFVID0gMiAqIFBJO1xuZXhwb3J0IGNvbnN0IFBJVEFVID0gVEFVICsgUEk7XG5leHBvcnQgY29uc3QgSU5GSU5JVFkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5leHBvcnQgY29uc3QgUkFEX1BFUl9ERUcgPSBQSSAvIDE4MDtcbmV4cG9ydCBjb25zdCBIQUxGX1BJID0gUEkgLyAyO1xuZXhwb3J0IGNvbnN0IFFVQVJURVJfUEkgPSBQSSAvIDQ7XG5leHBvcnQgY29uc3QgVFdPX1RISVJEU19QSSA9IFBJICogMiAvIDM7XG5cbmV4cG9ydCBjb25zdCBsb2cxMCA9IE1hdGgubG9nMTA7XG5leHBvcnQgY29uc3Qgc2lnbiA9IE1hdGguc2lnbjtcblxuZXhwb3J0IGZ1bmN0aW9uIGFsbW9zdEVxdWFscyh4OiBudW1iZXIsIHk6IG51bWJlciwgZXBzaWxvbjogbnVtYmVyKSB7XG4gIHJldHVybiBNYXRoLmFicyh4IC0geSkgPCBlcHNpbG9uO1xufVxuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBuaWNlIG51bWJlciBhbGdvcml0aG0gdXNlZCBpbiBkZXRlcm1pbmluZyB3aGVyZSBheGlzIGxhYmVscyB3aWxsIGdvXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuaWNlTnVtKHJhbmdlOiBudW1iZXIpIHtcbiAgY29uc3Qgcm91bmRlZFJhbmdlID0gTWF0aC5yb3VuZChyYW5nZSk7XG4gIHJhbmdlID0gYWxtb3N0RXF1YWxzKHJhbmdlLCByb3VuZGVkUmFuZ2UsIHJhbmdlIC8gMTAwMCkgPyByb3VuZGVkUmFuZ2UgOiByYW5nZTtcbiAgY29uc3QgbmljZVJhbmdlID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAocmFuZ2UpKSk7XG4gIGNvbnN0IGZyYWN0aW9uID0gcmFuZ2UgLyBuaWNlUmFuZ2U7XG4gIGNvbnN0IG5pY2VGcmFjdGlvbiA9IGZyYWN0aW9uIDw9IDEgPyAxIDogZnJhY3Rpb24gPD0gMiA/IDIgOiBmcmFjdGlvbiA8PSA1ID8gNSA6IDEwO1xuICByZXR1cm4gbmljZUZyYWN0aW9uICogbmljZVJhbmdlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgZmFjdG9ycyBzb3J0ZWQgZnJvbSAxIHRvIHNxcnQodmFsdWUpXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2ZhY3Rvcml6ZSh2YWx1ZTogbnVtYmVyKSB7XG4gIGNvbnN0IHJlc3VsdDogbnVtYmVyW10gPSBbXTtcbiAgY29uc3Qgc3FydCA9IE1hdGguc3FydCh2YWx1ZSk7XG4gIGxldCBpOiBudW1iZXI7XG5cbiAgZm9yIChpID0gMTsgaSA8IHNxcnQ7IGkrKykge1xuICAgIGlmICh2YWx1ZSAlIGkgPT09IDApIHtcbiAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUgLyBpKTtcbiAgICB9XG4gIH1cbiAgaWYgKHNxcnQgPT09IChzcXJ0IHwgMCkpIHsgLy8gaWYgdmFsdWUgaXMgYSBzcXVhcmUgbnVtYmVyXG4gICAgcmVzdWx0LnB1c2goc3FydCk7XG4gIH1cblxuICByZXN1bHQuc29ydCgoYSwgYikgPT4gYSAtIGIpLnBvcCgpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIobjogdW5rbm93bik6IG4gaXMgbnVtYmVyIHtcbiAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4gYXMgc3RyaW5nKSkgJiYgaXNGaW5pdGUobiBhcyBudW1iZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWxtb3N0V2hvbGUoeDogbnVtYmVyLCBlcHNpbG9uOiBudW1iZXIpIHtcbiAgY29uc3Qgcm91bmRlZCA9IE1hdGgucm91bmQoeCk7XG4gIHJldHVybiAoKHJvdW5kZWQgLSBlcHNpbG9uKSA8PSB4KSAmJiAoKHJvdW5kZWQgKyBlcHNpbG9uKSA+PSB4KTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3NldE1pbkFuZE1heEJ5S2V5KFxuICBhcnJheTogUmVjb3JkPHN0cmluZywgbnVtYmVyPltdLFxuICB0YXJnZXQ6IHsgbWluOiBudW1iZXIsIG1heDogbnVtYmVyIH0sXG4gIHByb3BlcnR5OiBzdHJpbmdcbikge1xuICBsZXQgaTogbnVtYmVyLCBpbGVuOiBudW1iZXIsIHZhbHVlOiBudW1iZXI7XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgIHZhbHVlID0gYXJyYXlbaV1bcHJvcGVydHldO1xuICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICB0YXJnZXQubWluID0gTWF0aC5taW4odGFyZ2V0Lm1pbiwgdmFsdWUpO1xuICAgICAgdGFyZ2V0Lm1heCA9IE1hdGgubWF4KHRhcmdldC5tYXgsIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvUmFkaWFucyhkZWdyZWVzOiBudW1iZXIpIHtcbiAgcmV0dXJuIGRlZ3JlZXMgKiAoUEkgLyAxODApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9EZWdyZWVzKHJhZGlhbnM6IG51bWJlcikge1xuICByZXR1cm4gcmFkaWFucyAqICgxODAgLyBQSSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXG4gKiBpLmUuIHRoZSBudW1iZXIgb2YgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBOdW1iZXIuXG4gKiBAcGFyYW0geCAtIEEgbnVtYmVyLlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcy5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZGVjaW1hbFBsYWNlcyh4OiBudW1iZXIpIHtcbiAgaWYgKCFpc0Zpbml0ZU51bWJlcih4KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgZSA9IDE7XG4gIGxldCBwID0gMDtcbiAgd2hpbGUgKE1hdGgucm91bmQoeCAqIGUpIC8gZSAhPT0geCkge1xuICAgIGUgKj0gMTA7XG4gICAgcCsrO1xuICB9XG4gIHJldHVybiBwO1xufVxuXG4vLyBHZXRzIHRoZSBhbmdsZSBmcm9tIHZlcnRpY2FsIHVwcmlnaHQgdG8gdGhlIHBvaW50IGFib3V0IGEgY2VudHJlLlxuZXhwb3J0IGZ1bmN0aW9uIGdldEFuZ2xlRnJvbVBvaW50KFxuICBjZW50cmVQb2ludDogUG9pbnQsXG4gIGFuZ2xlUG9pbnQ6IFBvaW50XG4pIHtcbiAgY29uc3QgZGlzdGFuY2VGcm9tWENlbnRlciA9IGFuZ2xlUG9pbnQueCAtIGNlbnRyZVBvaW50Lng7XG4gIGNvbnN0IGRpc3RhbmNlRnJvbVlDZW50ZXIgPSBhbmdsZVBvaW50LnkgLSBjZW50cmVQb2ludC55O1xuICBjb25zdCByYWRpYWxEaXN0YW5jZUZyb21DZW50ZXIgPSBNYXRoLnNxcnQoZGlzdGFuY2VGcm9tWENlbnRlciAqIGRpc3RhbmNlRnJvbVhDZW50ZXIgKyBkaXN0YW5jZUZyb21ZQ2VudGVyICogZGlzdGFuY2VGcm9tWUNlbnRlcik7XG5cbiAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMihkaXN0YW5jZUZyb21ZQ2VudGVyLCBkaXN0YW5jZUZyb21YQ2VudGVyKTtcblxuICBpZiAoYW5nbGUgPCAoLTAuNSAqIFBJKSkge1xuICAgIGFuZ2xlICs9IFRBVTsgLy8gbWFrZSBzdXJlIHRoZSByZXR1cm5lZCBhbmdsZSBpcyBpbiB0aGUgcmFuZ2Ugb2YgKC1QSS8yLCAzUEkvMl1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYW5nbGUsXG4gICAgZGlzdGFuY2U6IHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlclxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKHB0MTogUG9pbnQsIHB0MjogUG9pbnQpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwdDIueCAtIHB0MS54LCAyKSArIE1hdGgucG93KHB0Mi55IC0gcHQxLnksIDIpKTtcbn1cblxuLyoqXG4gKiBTaG9ydGVzdCBkaXN0YW5jZSBiZXR3ZWVuIGFuZ2xlcywgaW4gZWl0aGVyIGRpcmVjdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYW5nbGVEaWZmKGE6IG51bWJlciwgYjogbnVtYmVyKSB7XG4gIHJldHVybiAoYSAtIGIgKyBQSVRBVSkgJSBUQVUgLSBQSTtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYW5nbGUgdG8gYmUgYmV0d2VlbiAwIGFuZCAyKlBJXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX25vcm1hbGl6ZUFuZ2xlKGE6IG51bWJlcikge1xuICByZXR1cm4gKGEgJSBUQVUgKyBUQVUpICUgVEFVO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYW5nbGVCZXR3ZWVuKGFuZ2xlOiBudW1iZXIsIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyLCBzYW1lQW5nbGVJc0Z1bGxDaXJjbGU/OiBib29sZWFuKSB7XG4gIGNvbnN0IGEgPSBfbm9ybWFsaXplQW5nbGUoYW5nbGUpO1xuICBjb25zdCBzID0gX25vcm1hbGl6ZUFuZ2xlKHN0YXJ0KTtcbiAgY29uc3QgZSA9IF9ub3JtYWxpemVBbmdsZShlbmQpO1xuICBjb25zdCBhbmdsZVRvU3RhcnQgPSBfbm9ybWFsaXplQW5nbGUocyAtIGEpO1xuICBjb25zdCBhbmdsZVRvRW5kID0gX25vcm1hbGl6ZUFuZ2xlKGUgLSBhKTtcbiAgY29uc3Qgc3RhcnRUb0FuZ2xlID0gX25vcm1hbGl6ZUFuZ2xlKGEgLSBzKTtcbiAgY29uc3QgZW5kVG9BbmdsZSA9IF9ub3JtYWxpemVBbmdsZShhIC0gZSk7XG4gIHJldHVybiBhID09PSBzIHx8IGEgPT09IGUgfHwgKHNhbWVBbmdsZUlzRnVsbENpcmNsZSAmJiBzID09PSBlKVxuICAgIHx8IChhbmdsZVRvU3RhcnQgPiBhbmdsZVRvRW5kICYmIHN0YXJ0VG9BbmdsZSA8IGVuZFRvQW5nbGUpO1xufVxuXG4vKipcbiAqIExpbWl0IGB2YWx1ZWAgYmV0d2VlbiBgbWluYCBhbmQgYG1heGBcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIG1pblxuICogQHBhcmFtIG1heFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9saW1pdFZhbHVlKHZhbHVlOiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcikge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbHVlKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2ludDE2UmFuZ2UodmFsdWU6IG51bWJlcikge1xuICByZXR1cm4gX2xpbWl0VmFsdWUodmFsdWUsIC0zMjc2OCwgMzI3NjcpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIHN0YXJ0XG4gKiBAcGFyYW0gZW5kXG4gKiBAcGFyYW0gW2Vwc2lsb25dXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2lzQmV0d2Vlbih2YWx1ZTogbnVtYmVyLCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgZXBzaWxvbiA9IDFlLTYpIHtcbiAgcmV0dXJuIHZhbHVlID49IE1hdGgubWluKHN0YXJ0LCBlbmQpIC0gZXBzaWxvbiAmJiB2YWx1ZSA8PSBNYXRoLm1heChzdGFydCwgZW5kKSArIGVwc2lsb247XG59XG4iLCAiaW1wb3J0IHtfY2FwaXRhbGl6ZX0gZnJvbSAnLi9oZWxwZXJzLmNvcmUuanMnO1xuXG4vKipcbiAqIEJpbmFyeSBzZWFyY2hcbiAqIEBwYXJhbSB0YWJsZSAtIHRoZSB0YWJsZSBzZWFyY2guIG11c3QgYmUgc29ydGVkIVxuICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gZmluZFxuICogQHBhcmFtIGNtcFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9sb29rdXAoXG4gIHRhYmxlOiBudW1iZXJbXSxcbiAgdmFsdWU6IG51bWJlcixcbiAgY21wPzogKHZhbHVlOiBudW1iZXIpID0+IGJvb2xlYW5cbik6IHtsbzogbnVtYmVyLCBoaTogbnVtYmVyfTtcbmV4cG9ydCBmdW5jdGlvbiBfbG9va3VwPFQ+KFxuICB0YWJsZTogVFtdLFxuICB2YWx1ZTogbnVtYmVyLFxuICBjbXA6ICh2YWx1ZTogbnVtYmVyKSA9PiBib29sZWFuXG4pOiB7bG86IG51bWJlciwgaGk6IG51bWJlcn07XG5leHBvcnQgZnVuY3Rpb24gX2xvb2t1cChcbiAgdGFibGU6IHVua25vd25bXSxcbiAgdmFsdWU6IG51bWJlcixcbiAgY21wPzogKHZhbHVlOiBudW1iZXIpID0+IGJvb2xlYW5cbikge1xuICBjbXAgPSBjbXAgfHwgKChpbmRleCkgPT4gdGFibGVbaW5kZXhdIDwgdmFsdWUpO1xuICBsZXQgaGkgPSB0YWJsZS5sZW5ndGggLSAxO1xuICBsZXQgbG8gPSAwO1xuICBsZXQgbWlkOiBudW1iZXI7XG5cbiAgd2hpbGUgKGhpIC0gbG8gPiAxKSB7XG4gICAgbWlkID0gKGxvICsgaGkpID4+IDE7XG4gICAgaWYgKGNtcChtaWQpKSB7XG4gICAgICBsbyA9IG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGkgPSBtaWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtsbywgaGl9O1xufVxuXG4vKipcbiAqIEJpbmFyeSBzZWFyY2hcbiAqIEBwYXJhbSB0YWJsZSAtIHRoZSB0YWJsZSBzZWFyY2guIG11c3QgYmUgc29ydGVkIVxuICogQHBhcmFtIGtleSAtIHByb3BlcnR5IG5hbWUgZm9yIHRoZSB2YWx1ZSBpbiBlYWNoIGVudHJ5XG4gKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSB0byBmaW5kXG4gKiBAcGFyYW0gbGFzdCAtIGxvb2t1cCBsYXN0IGluZGV4XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgX2xvb2t1cEJ5S2V5ID0gKFxuICB0YWJsZTogUmVjb3JkPHN0cmluZywgbnVtYmVyPltdLFxuICBrZXk6IHN0cmluZyxcbiAgdmFsdWU6IG51bWJlcixcbiAgbGFzdD86IGJvb2xlYW5cbikgPT5cbiAgX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGxhc3RcbiAgICA/IGluZGV4ID0+IHtcbiAgICAgIGNvbnN0IHRpID0gdGFibGVbaW5kZXhdW2tleV07XG4gICAgICByZXR1cm4gdGkgPCB2YWx1ZSB8fCB0aSA9PT0gdmFsdWUgJiYgdGFibGVbaW5kZXggKyAxXVtrZXldID09PSB2YWx1ZTtcbiAgICB9XG4gICAgOiBpbmRleCA9PiB0YWJsZVtpbmRleF1ba2V5XSA8IHZhbHVlKTtcblxuLyoqXG4gKiBSZXZlcnNlIGJpbmFyeSBzZWFyY2hcbiAqIEBwYXJhbSB0YWJsZSAtIHRoZSB0YWJsZSBzZWFyY2guIG11c3QgYmUgc29ydGVkIVxuICogQHBhcmFtIGtleSAtIHByb3BlcnR5IG5hbWUgZm9yIHRoZSB2YWx1ZSBpbiBlYWNoIGVudHJ5XG4gKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSB0byBmaW5kXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgX3Jsb29rdXBCeUtleSA9IChcbiAgdGFibGU6IFJlY29yZDxzdHJpbmcsIG51bWJlcj5bXSxcbiAga2V5OiBzdHJpbmcsXG4gIHZhbHVlOiBudW1iZXJcbikgPT5cbiAgX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGluZGV4ID0+IHRhYmxlW2luZGV4XVtrZXldID49IHZhbHVlKTtcblxuLyoqXG4gKiBSZXR1cm4gc3Vic2V0IG9mIGB2YWx1ZXNgIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgIGluY2x1c2l2ZS5cbiAqIFZhbHVlcyBhcmUgYXNzdW1lZCB0byBiZSBpbiBzb3J0ZWQgb3JkZXIuXG4gKiBAcGFyYW0gdmFsdWVzIC0gc29ydGVkIGFycmF5IG9mIHZhbHVlc1xuICogQHBhcmFtIG1pbiAtIG1pbiB2YWx1ZVxuICogQHBhcmFtIG1heCAtIG1heCB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2ZpbHRlckJldHdlZW4odmFsdWVzOiBudW1iZXJbXSwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKSB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSB2YWx1ZXMubGVuZ3RoO1xuXG4gIHdoaWxlIChzdGFydCA8IGVuZCAmJiB2YWx1ZXNbc3RhcnRdIDwgbWluKSB7XG4gICAgc3RhcnQrKztcbiAgfVxuICB3aGlsZSAoZW5kID4gc3RhcnQgJiYgdmFsdWVzW2VuZCAtIDFdID4gbWF4KSB7XG4gICAgZW5kLS07XG4gIH1cblxuICByZXR1cm4gc3RhcnQgPiAwIHx8IGVuZCA8IHZhbHVlcy5sZW5ndGhcbiAgICA/IHZhbHVlcy5zbGljZShzdGFydCwgZW5kKVxuICAgIDogdmFsdWVzO1xufVxuXG5jb25zdCBhcnJheUV2ZW50cyA9IFsncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSBhcyBjb25zdDtcblxuZXhwb3J0IGludGVyZmFjZSBBcnJheUxpc3RlbmVyPFQ+IHtcbiAgX29uRGF0YVB1c2g/KC4uLml0ZW06IFRbXSk6IHZvaWQ7XG4gIF9vbkRhdGFQb3A/KCk6IHZvaWQ7XG4gIF9vbkRhdGFTaGlmdD8oKTogdm9pZDtcbiAgX29uRGF0YVNwbGljZT8oaW5kZXg6IG51bWJlciwgZGVsZXRlQ291bnQ6IG51bWJlciwgLi4uaXRlbXM6IFRbXSk6IHZvaWQ7XG4gIF9vbkRhdGFVbnNoaWZ0PyguLi5pdGVtOiBUW10pOiB2b2lkO1xufVxuXG4vKipcbiAqIEhvb2tzIHRoZSBhcnJheSBtZXRob2RzIHRoYXQgYWRkIG9yIHJlbW92ZSB2YWx1ZXMgKCdwdXNoJywgcG9wJywgJ3NoaWZ0JywgJ3NwbGljZScsXG4gKiAndW5zaGlmdCcpIGFuZCBub3RpZnkgdGhlIGxpc3RlbmVyIEFGVEVSIHRoZSBhcnJheSBoYXMgYmVlbiBhbHRlcmVkLiBMaXN0ZW5lcnMgYXJlXG4gKiBjYWxsZWQgb24gdGhlICdfb25EYXRhKicgY2FsbGJhY2tzIChlLmcuIF9vbkRhdGFQdXNoLCBldGMuKSB3aXRoIHNhbWUgYXJndW1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuQXJyYXlFdmVudHM8VD4oYXJyYXk6IFRbXSwgbGlzdGVuZXI6IEFycmF5TGlzdGVuZXI8VD4pOiB2b2lkO1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xuICBpZiAoYXJyYXkuX2NoYXJ0anMpIHtcbiAgICBhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCAnX2NoYXJ0anMnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiB7XG4gICAgICBsaXN0ZW5lcnM6IFtsaXN0ZW5lcl1cbiAgICB9XG4gIH0pO1xuXG4gIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGNvbnN0IG1ldGhvZCA9ICdfb25EYXRhJyArIF9jYXBpdGFsaXplKGtleSk7XG4gICAgY29uc3QgYmFzZSA9IGFycmF5W2tleV07XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZSguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJhc2UuYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICAgICAgYXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLmZvckVhY2goKG9iamVjdCkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0W21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9iamVjdFttZXRob2RdKC4uLmFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBnaXZlbiBhcnJheSBldmVudCBsaXN0ZW5lciBhbmQgY2xlYW51cCBleHRyYSBhdHRhY2hlZCBwcm9wZXJ0aWVzIChzdWNoIGFzXG4gKiB0aGUgX2NoYXJ0anMgc3R1YiBhbmQgb3ZlcnJpZGRlbiBtZXRob2RzKSBpZiBhcnJheSBkb2Vzbid0IGhhdmUgYW55IG1vcmUgbGlzdGVuZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5saXN0ZW5BcnJheUV2ZW50czxUPihhcnJheTogVFtdLCBsaXN0ZW5lcjogQXJyYXlMaXN0ZW5lcjxUPik6IHZvaWQ7XG5leHBvcnQgZnVuY3Rpb24gdW5saXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcbiAgY29uc3Qgc3R1YiA9IGFycmF5Ll9jaGFydGpzO1xuICBpZiAoIXN0dWIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBsaXN0ZW5lcnMgPSBzdHViLmxpc3RlbmVycztcbiAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxuXG4gIGlmIChsaXN0ZW5lcnMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGRlbGV0ZSBhcnJheVtrZXldO1xuICB9KTtcblxuICBkZWxldGUgYXJyYXkuX2NoYXJ0anM7XG59XG5cbi8qKlxuICogQHBhcmFtIGl0ZW1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYXJyYXlVbmlxdWU8VD4oaXRlbXM6IFRbXSkge1xuICBjb25zdCBzZXQgPSBuZXcgU2V0PFQ+KGl0ZW1zKTtcblxuICBpZiAoc2V0LnNpemUgPT09IGl0ZW1zLmxlbmd0aCkge1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIHJldHVybiBBcnJheS5mcm9tKHNldCk7XG59XG4iLCAiaW1wb3J0IHR5cGUge0NoYXJ0TWV0YSwgUG9pbnRFbGVtZW50fSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cbmltcG9ydCB7X2xpbWl0VmFsdWV9IGZyb20gJy4vaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7X2xvb2t1cEJ5S2V5fSBmcm9tICcuL2hlbHBlcnMuY29sbGVjdGlvbi5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBmb250U3RyaW5nKHBpeGVsU2l6ZTogbnVtYmVyLCBmb250U3R5bGU6IHN0cmluZywgZm9udEZhbWlseTogc3RyaW5nKSB7XG4gIHJldHVybiBmb250U3R5bGUgKyAnICcgKyBwaXhlbFNpemUgKyAncHggJyArIGZvbnRGYW1pbHk7XG59XG5cbi8qKlxuKiBSZXF1ZXN0IGFuaW1hdGlvbiBwb2x5ZmlsbFxuKi9cbmV4cG9ydCBjb25zdCByZXF1ZXN0QW5pbUZyYW1lID0gKGZ1bmN0aW9uKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG59KCkpO1xuXG4vKipcbiAqIFRocm90dGxlcyBjYWxsaW5nIGBmbmAgb25jZSBwZXIgYW5pbWF0aW9uIGZyYW1lXG4gKiBMYXRlc3QgYXJndW1lbnRzIGFyZSB1c2VkIG9uIHRoZSBhY3R1YWwgY2FsbFxuICovXG5leHBvcnQgZnVuY3Rpb24gdGhyb3R0bGVkPFRBcmdzIGV4dGVuZHMgQXJyYXk8YW55Pj4oXG4gIGZuOiAoLi4uYXJnczogVEFyZ3MpID0+IHZvaWQsXG4gIHRoaXNBcmc6IGFueSxcbikge1xuICBsZXQgYXJnc1RvVXNlID0gW10gYXMgVEFyZ3M7XG4gIGxldCB0aWNraW5nID0gZmFsc2U7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3M6IFRBcmdzKSB7XG4gICAgLy8gU2F2ZSB0aGUgYXJncyBmb3IgdXNlIGxhdGVyXG4gICAgYXJnc1RvVXNlID0gYXJncztcbiAgICBpZiAoIXRpY2tpbmcpIHtcbiAgICAgIHRpY2tpbmcgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgKCkgPT4ge1xuICAgICAgICB0aWNraW5nID0gZmFsc2U7XG4gICAgICAgIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3NUb1VzZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogRGVib3VuY2VzIGNhbGxpbmcgYGZuYCBmb3IgYGRlbGF5YCBtc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2U8VEFyZ3MgZXh0ZW5kcyBBcnJheTxhbnk+PihmbjogKC4uLmFyZ3M6IFRBcmdzKSA9PiB2b2lkLCBkZWxheTogbnVtYmVyKSB7XG4gIGxldCB0aW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJnczogVEFyZ3MpIHtcbiAgICBpZiAoZGVsYXkpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZuLCBkZWxheSwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gZGVsYXk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgJ3N0YXJ0JyB0byAnbGVmdCcsICdlbmQnIHRvICdyaWdodCcgYW5kIG90aGVycyB0byAnY2VudGVyJ1xuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IF90b0xlZnRSaWdodENlbnRlciA9IChhbGlnbjogJ3N0YXJ0JyB8ICdlbmQnIHwgJ2NlbnRlcicpID0+IGFsaWduID09PSAnc3RhcnQnID8gJ2xlZnQnIDogYWxpZ24gPT09ICdlbmQnID8gJ3JpZ2h0JyA6ICdjZW50ZXInO1xuXG4vKipcbiAqIFJldHVybnMgYHN0YXJ0YCwgYGVuZGAgb3IgYChzdGFydCArIGVuZCkgLyAyYCBkZXBlbmRpbmcgb24gYGFsaWduYC4gRGVmYXVsdHMgdG8gYGNlbnRlcmBcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBfYWxpZ25TdGFydEVuZCA9IChhbGlnbjogJ3N0YXJ0JyB8ICdlbmQnIHwgJ2NlbnRlcicsIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKSA9PiBhbGlnbiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogYWxpZ24gPT09ICdlbmQnID8gZW5kIDogKHN0YXJ0ICsgZW5kKSAvIDI7XG5cbi8qKlxuICogUmV0dXJucyBgbGVmdGAsIGByaWdodGAgb3IgYChsZWZ0ICsgcmlnaHQpIC8gMmAgZGVwZW5kaW5nIG9uIGBhbGlnbmAuIERlZmF1bHRzIHRvIGBsZWZ0YFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IF90ZXh0WCA9IChhbGlnbjogJ2xlZnQnIHwgJ3JpZ2h0JyB8ICdjZW50ZXInLCBsZWZ0OiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIHJ0bDogYm9vbGVhbikgPT4ge1xuICBjb25zdCBjaGVjayA9IHJ0bCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIHJldHVybiBhbGlnbiA9PT0gY2hlY2sgPyByaWdodCA6IGFsaWduID09PSAnY2VudGVyJyA/IChsZWZ0ICsgcmlnaHQpIC8gMiA6IGxlZnQ7XG59O1xuXG4vKipcbiAqIFJldHVybiBzdGFydCBhbmQgY291bnQgb2YgdmlzaWJsZSBwb2ludHMuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YTogQ2hhcnRNZXRhPCdsaW5lJyB8ICdzY2F0dGVyJz4sIHBvaW50czogUG9pbnRFbGVtZW50W10sIGFuaW1hdGlvbnNEaXNhYmxlZDogYm9vbGVhbikge1xuICBjb25zdCBwb2ludENvdW50ID0gcG9pbnRzLmxlbmd0aDtcblxuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgY291bnQgPSBwb2ludENvdW50O1xuXG4gIGlmIChtZXRhLl9zb3J0ZWQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCBfcGFyc2VkfSA9IG1ldGE7XG4gICAgY29uc3QgYXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBpU2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuXG4gICAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICAgIHN0YXJ0ID0gX2xpbWl0VmFsdWUoTWF0aC5taW4oXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTmVlZCB0byB0eXBlIF9wYXJzZWRcbiAgICAgICAgX2xvb2t1cEJ5S2V5KF9wYXJzZWQsIGF4aXMsIG1pbikubG8sXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTmVlZCB0byBmaXggdHlwZXMgb24gX2xvb2t1cEJ5S2V5XG4gICAgICAgIGFuaW1hdGlvbnNEaXNhYmxlZCA/IHBvaW50Q291bnQgOiBfbG9va3VwQnlLZXkocG9pbnRzLCBheGlzLCBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShtaW4pKS5sbyksXG4gICAgICAwLCBwb2ludENvdW50IC0gMSk7XG4gICAgfVxuICAgIGlmIChtYXhEZWZpbmVkKSB7XG4gICAgICBjb3VudCA9IF9saW1pdFZhbHVlKE1hdGgubWF4KFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5lZWQgdG8gdHlwZSBfcGFyc2VkXG4gICAgICAgIF9sb29rdXBCeUtleShfcGFyc2VkLCBpU2NhbGUuYXhpcywgbWF4LCB0cnVlKS5oaSArIDEsXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTmVlZCB0byBmaXggdHlwZXMgb24gX2xvb2t1cEJ5S2V5XG4gICAgICAgIGFuaW1hdGlvbnNEaXNhYmxlZCA/IDAgOiBfbG9va3VwQnlLZXkocG9pbnRzLCBheGlzLCBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShtYXgpLCB0cnVlKS5oaSArIDEpLFxuICAgICAgc3RhcnQsIHBvaW50Q291bnQpIC0gc3RhcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gcG9pbnRDb3VudCAtIHN0YXJ0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7c3RhcnQsIGNvdW50fTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHNjYWxlIHJhbmdlcyBoYXZlIGNoYW5nZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gbWV0YSAtIGRhdGFzZXQgbWV0YS5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zY2FsZVJhbmdlc0NoYW5nZWQobWV0YSkge1xuICBjb25zdCB7eFNjYWxlLCB5U2NhbGUsIF9zY2FsZVJhbmdlc30gPSBtZXRhO1xuICBjb25zdCBuZXdSYW5nZXMgPSB7XG4gICAgeG1pbjogeFNjYWxlLm1pbixcbiAgICB4bWF4OiB4U2NhbGUubWF4LFxuICAgIHltaW46IHlTY2FsZS5taW4sXG4gICAgeW1heDogeVNjYWxlLm1heFxuICB9O1xuICBpZiAoIV9zY2FsZVJhbmdlcykge1xuICAgIG1ldGEuX3NjYWxlUmFuZ2VzID0gbmV3UmFuZ2VzO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGNoYW5nZWQgPSBfc2NhbGVSYW5nZXMueG1pbiAhPT0geFNjYWxlLm1pblxuXHRcdHx8IF9zY2FsZVJhbmdlcy54bWF4ICE9PSB4U2NhbGUubWF4XG5cdFx0fHwgX3NjYWxlUmFuZ2VzLnltaW4gIT09IHlTY2FsZS5taW5cblx0XHR8fCBfc2NhbGVSYW5nZXMueW1heCAhPT0geVNjYWxlLm1heDtcblxuICBPYmplY3QuYXNzaWduKF9zY2FsZVJhbmdlcywgbmV3UmFuZ2VzKTtcbiAgcmV0dXJuIGNoYW5nZWQ7XG59XG4iLCAiaW1wb3J0IHtQSSwgVEFVLCBIQUxGX1BJfSBmcm9tICcuL2hlbHBlcnMubWF0aC5qcyc7XG5cbmNvbnN0IGF0RWRnZSA9ICh0OiBudW1iZXIpID0+IHQgPT09IDAgfHwgdCA9PT0gMTtcbmNvbnN0IGVsYXN0aWNJbiA9ICh0OiBudW1iZXIsIHM6IG51bWJlciwgcDogbnVtYmVyKSA9PiAtKE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqIFRBVSAvIHApKTtcbmNvbnN0IGVsYXN0aWNPdXQgPSAodDogbnVtYmVyLCBzOiBudW1iZXIsIHA6IG51bWJlcikgPT4gTWF0aC5wb3coMiwgLTEwICogdCkgKiBNYXRoLnNpbigodCAtIHMpICogVEFVIC8gcCkgKyAxO1xuXG4vKipcbiAqIEVhc2luZyBmdW5jdGlvbnMgYWRhcHRlZCBmcm9tIFJvYmVydCBQZW5uZXIncyBlYXNpbmcgZXF1YXRpb25zLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmVhc2luZy5lZmZlY3RzXG4gKiBAc2VlIGh0dHA6Ly93d3cucm9iZXJ0cGVubmVyLmNvbS9lYXNpbmcvXG4gKi9cbmNvbnN0IGVmZmVjdHMgPSB7XG4gIGxpbmVhcjogKHQ6IG51bWJlcikgPT4gdCxcblxuICBlYXNlSW5RdWFkOiAodDogbnVtYmVyKSA9PiB0ICogdCxcblxuICBlYXNlT3V0UXVhZDogKHQ6IG51bWJlcikgPT4gLXQgKiAodCAtIDIpLFxuXG4gIGVhc2VJbk91dFF1YWQ6ICh0OiBudW1iZXIpID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0XG4gICAgOiAtMC41ICogKCgtLXQpICogKHQgLSAyKSAtIDEpLFxuXG4gIGVhc2VJbkN1YmljOiAodDogbnVtYmVyKSA9PiB0ICogdCAqIHQsXG5cbiAgZWFzZU91dEN1YmljOiAodDogbnVtYmVyKSA9PiAodCAtPSAxKSAqIHQgKiB0ICsgMSxcblxuICBlYXNlSW5PdXRDdWJpYzogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0XG4gICAgOiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCArIDIpLFxuXG4gIGVhc2VJblF1YXJ0OiAodDogbnVtYmVyKSA9PiB0ICogdCAqIHQgKiB0LFxuXG4gIGVhc2VPdXRRdWFydDogKHQ6IG51bWJlcikgPT4gLSgodCAtPSAxKSAqIHQgKiB0ICogdCAtIDEpLFxuXG4gIGVhc2VJbk91dFF1YXJ0OiAodDogbnVtYmVyKSA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHQgKiB0XG4gICAgOiAtMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0IC0gMiksXG5cbiAgZWFzZUluUXVpbnQ6ICh0OiBudW1iZXIpID0+IHQgKiB0ICogdCAqIHQgKiB0LFxuXG4gIGVhc2VPdXRRdWludDogKHQ6IG51bWJlcikgPT4gKHQgLT0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMSxcblxuICBlYXNlSW5PdXRRdWludDogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0ICogdCAqIHRcbiAgICA6IDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKSxcblxuICBlYXNlSW5TaW5lOiAodDogbnVtYmVyKSA9PiAtTWF0aC5jb3ModCAqIEhBTEZfUEkpICsgMSxcblxuICBlYXNlT3V0U2luZTogKHQ6IG51bWJlcikgPT4gTWF0aC5zaW4odCAqIEhBTEZfUEkpLFxuXG4gIGVhc2VJbk91dFNpbmU6ICh0OiBudW1iZXIpID0+IC0wLjUgKiAoTWF0aC5jb3MoUEkgKiB0KSAtIDEpLFxuXG4gIGVhc2VJbkV4cG86ICh0OiBudW1iZXIpID0+ICh0ID09PSAwKSA/IDAgOiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpLFxuXG4gIGVhc2VPdXRFeHBvOiAodDogbnVtYmVyKSA9PiAodCA9PT0gMSkgPyAxIDogLU1hdGgucG93KDIsIC0xMCAqIHQpICsgMSxcblxuICBlYXNlSW5PdXRFeHBvOiAodDogbnVtYmVyKSA9PiBhdEVkZ2UodCkgPyB0IDogdCA8IDAuNVxuICAgID8gMC41ICogTWF0aC5wb3coMiwgMTAgKiAodCAqIDIgLSAxKSlcbiAgICA6IDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKHQgKiAyIC0gMSkpICsgMiksXG5cbiAgZWFzZUluQ2lyYzogKHQ6IG51bWJlcikgPT4gKHQgPj0gMSkgPyB0IDogLShNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpLFxuXG4gIGVhc2VPdXRDaXJjOiAodDogbnVtYmVyKSA9PiBNYXRoLnNxcnQoMSAtICh0IC09IDEpICogdCksXG5cbiAgZWFzZUluT3V0Q2lyYzogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpXG4gICAgOiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSksXG5cbiAgZWFzZUluRWxhc3RpYzogKHQ6IG51bWJlcikgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNJbih0LCAwLjA3NSwgMC4zKSxcblxuICBlYXNlT3V0RWxhc3RpYzogKHQ6IG51bWJlcikgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNPdXQodCwgMC4wNzUsIDAuMyksXG5cbiAgZWFzZUluT3V0RWxhc3RpYyh0OiBudW1iZXIpIHtcbiAgICBjb25zdCBzID0gMC4xMTI1O1xuICAgIGNvbnN0IHAgPSAwLjQ1O1xuICAgIHJldHVybiBhdEVkZ2UodCkgPyB0IDpcbiAgICAgIHQgPCAwLjVcbiAgICAgICAgPyAwLjUgKiBlbGFzdGljSW4odCAqIDIsIHMsIHApXG4gICAgICAgIDogMC41ICsgMC41ICogZWxhc3RpY091dCh0ICogMiAtIDEsIHMsIHApO1xuICB9LFxuXG4gIGVhc2VJbkJhY2sodDogbnVtYmVyKSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG4gIH0sXG5cbiAgZWFzZU91dEJhY2sodDogbnVtYmVyKSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuICh0IC09IDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMTtcbiAgfSxcblxuICBlYXNlSW5PdXRCYWNrKHQ6IG51bWJlcikge1xuICAgIGxldCBzID0gMS43MDE1ODtcbiAgICBpZiAoKHQgLz0gMC41KSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpO1xuICAgIH1cbiAgICByZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgKyBzKSArIDIpO1xuICB9LFxuXG4gIGVhc2VJbkJvdW5jZTogKHQ6IG51bWJlcikgPT4gMSAtIGVmZmVjdHMuZWFzZU91dEJvdW5jZSgxIC0gdCksXG5cbiAgZWFzZU91dEJvdW5jZSh0OiBudW1iZXIpIHtcbiAgICBjb25zdCBtID0gNy41NjI1O1xuICAgIGNvbnN0IGQgPSAyLjc1O1xuICAgIGlmICh0IDwgKDEgLyBkKSkge1xuICAgICAgcmV0dXJuIG0gKiB0ICogdDtcbiAgICB9XG4gICAgaWYgKHQgPCAoMiAvIGQpKSB7XG4gICAgICByZXR1cm4gbSAqICh0IC09ICgxLjUgLyBkKSkgKiB0ICsgMC43NTtcbiAgICB9XG4gICAgaWYgKHQgPCAoMi41IC8gZCkpIHtcbiAgICAgIHJldHVybiBtICogKHQgLT0gKDIuMjUgLyBkKSkgKiB0ICsgMC45Mzc1O1xuICAgIH1cbiAgICByZXR1cm4gbSAqICh0IC09ICgyLjYyNSAvIGQpKSAqIHQgKyAwLjk4NDM3NTtcbiAgfSxcblxuICBlYXNlSW5PdXRCb3VuY2U6ICh0OiBudW1iZXIpID0+ICh0IDwgMC41KVxuICAgID8gZWZmZWN0cy5lYXNlSW5Cb3VuY2UodCAqIDIpICogMC41XG4gICAgOiBlZmZlY3RzLmVhc2VPdXRCb3VuY2UodCAqIDIgLSAxKSAqIDAuNSArIDAuNSxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCB0eXBlIEVhc2luZ0Z1bmN0aW9uID0ga2V5b2YgdHlwZW9mIGVmZmVjdHNcblxuZXhwb3J0IGRlZmF1bHQgZWZmZWN0cztcbiIsICJpbXBvcnQge0NvbG9yfSBmcm9tICdAa3Vya2xlL2NvbG9yJztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBDYW52YXNQYXR0ZXJuIHwgQ2FudmFzR3JhZGllbnQge1xuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IHR5cGUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIHJldHVybiB0eXBlID09PSAnW29iamVjdCBDYW52YXNQYXR0ZXJuXScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgQ2FudmFzR3JhZGllbnRdJztcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yKHZhbHVlOiBDYW52YXNHcmFkaWVudCk6IENhbnZhc0dyYWRpZW50O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yKHZhbHVlOiBDYW52YXNQYXR0ZXJuKTogQ2FudmFzUGF0dGVybjtcbmV4cG9ydCBmdW5jdGlvbiBjb2xvcihcbiAgdmFsdWU6XG4gIHwgc3RyaW5nXG4gIHwgeyByOiBudW1iZXI7IGc6IG51bWJlcjsgYjogbnVtYmVyOyBhOiBudW1iZXIgfVxuICB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXVxuICB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdXG4pOiBDb2xvcjtcbmV4cG9ydCBmdW5jdGlvbiBjb2xvcih2YWx1ZSkge1xuICByZXR1cm4gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSkgPyB2YWx1ZSA6IG5ldyBDb2xvcih2YWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRIb3ZlckNvbG9yKHZhbHVlOiBDYW52YXNHcmFkaWVudCk6IENhbnZhc0dyYWRpZW50O1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhvdmVyQ29sb3IodmFsdWU6IENhbnZhc1BhdHRlcm4pOiBDYW52YXNQYXR0ZXJuO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhvdmVyQ29sb3IodmFsdWU6IHN0cmluZyk6IHN0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBnZXRIb3ZlckNvbG9yKHZhbHVlKSB7XG4gIHJldHVybiBpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKVxuICAgID8gdmFsdWVcbiAgICA6IG5ldyBDb2xvcih2YWx1ZSkuc2F0dXJhdGUoMC41KS5kYXJrZW4oMC4xKS5oZXhTdHJpbmcoKTtcbn1cbiIsICJjb25zdCBudW1iZXJzID0gWyd4JywgJ3knLCAnYm9yZGVyV2lkdGgnLCAncmFkaXVzJywgJ3RlbnNpb24nXTtcbmNvbnN0IGNvbG9ycyA9IFsnY29sb3InLCAnYm9yZGVyQ29sb3InLCAnYmFja2dyb3VuZENvbG9yJ107XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseUFuaW1hdGlvbnNEZWZhdWx0cyhkZWZhdWx0cykge1xuICBkZWZhdWx0cy5zZXQoJ2FuaW1hdGlvbicsIHtcbiAgICBkZWxheTogdW5kZWZpbmVkLFxuICAgIGR1cmF0aW9uOiAxMDAwLFxuICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFydCcsXG4gICAgZm46IHVuZGVmaW5lZCxcbiAgICBmcm9tOiB1bmRlZmluZWQsXG4gICAgbG9vcDogdW5kZWZpbmVkLFxuICAgIHRvOiB1bmRlZmluZWQsXG4gICAgdHlwZTogdW5kZWZpbmVkLFxuICB9KTtcblxuICBkZWZhdWx0cy5kZXNjcmliZSgnYW5pbWF0aW9uJywge1xuICAgIF9mYWxsYmFjazogZmFsc2UsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnb25Qcm9ncmVzcycgJiYgbmFtZSAhPT0gJ29uQ29tcGxldGUnICYmIG5hbWUgIT09ICdmbicsXG4gIH0pO1xuXG4gIGRlZmF1bHRzLnNldCgnYW5pbWF0aW9ucycsIHtcbiAgICBjb2xvcnM6IHtcbiAgICAgIHR5cGU6ICdjb2xvcicsXG4gICAgICBwcm9wZXJ0aWVzOiBjb2xvcnNcbiAgICB9LFxuICAgIG51bWJlcnM6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcHJvcGVydGllczogbnVtYmVyc1xuICAgIH0sXG4gIH0pO1xuXG4gIGRlZmF1bHRzLmRlc2NyaWJlKCdhbmltYXRpb25zJywge1xuICAgIF9mYWxsYmFjazogJ2FuaW1hdGlvbicsXG4gIH0pO1xuXG4gIGRlZmF1bHRzLnNldCgndHJhbnNpdGlvbnMnLCB7XG4gICAgYWN0aXZlOiB7XG4gICAgICBhbmltYXRpb246IHtcbiAgICAgICAgZHVyYXRpb246IDQwMFxuICAgICAgfVxuICAgIH0sXG4gICAgcmVzaXplOiB7XG4gICAgICBhbmltYXRpb246IHtcbiAgICAgICAgZHVyYXRpb246IDBcbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3c6IHtcbiAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgY29sb3JzOiB7XG4gICAgICAgICAgZnJvbTogJ3RyYW5zcGFyZW50J1xuICAgICAgICB9LFxuICAgICAgICB2aXNpYmxlOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIGR1cmF0aW9uOiAwIC8vIHNob3cgaW1tZWRpYXRlbHlcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICB9LFxuICAgIGhpZGU6IHtcbiAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgY29sb3JzOiB7XG4gICAgICAgICAgdG86ICd0cmFuc3BhcmVudCdcbiAgICAgICAgfSxcbiAgICAgICAgdmlzaWJsZToge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBlYXNpbmc6ICdsaW5lYXInLFxuICAgICAgICAgIGZuOiB2ID0+IHYgfCAwIC8vIGZvciBrZWVwaW5nIHRoZSBkYXRhc2V0IHZpc2libGUgYWxsIHRoZSB3YXkgdGhyb3VnaCB0aGUgYW5pbWF0aW9uXG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gYXBwbHlMYXlvdXRzRGVmYXVsdHMoZGVmYXVsdHMpIHtcbiAgZGVmYXVsdHMuc2V0KCdsYXlvdXQnLCB7XG4gICAgYXV0b1BhZGRpbmc6IHRydWUsXG4gICAgcGFkZGluZzoge1xuICAgICAgdG9wOiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwXG4gICAgfVxuICB9KTtcbn1cbiIsICJcbmNvbnN0IGludGxDYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBJbnRsLk51bWJlckZvcm1hdD4oKTtcblxuZnVuY3Rpb24gZ2V0TnVtYmVyRm9ybWF0KGxvY2FsZTogc3RyaW5nLCBvcHRpb25zPzogSW50bC5OdW1iZXJGb3JtYXRPcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBjYWNoZUtleSA9IGxvY2FsZSArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpO1xuICBsZXQgZm9ybWF0dGVyID0gaW50bENhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmICghZm9ybWF0dGVyKSB7XG4gICAgZm9ybWF0dGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucyk7XG4gICAgaW50bENhY2hlLnNldChjYWNoZUtleSwgZm9ybWF0dGVyKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0dGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TnVtYmVyKG51bTogbnVtYmVyLCBsb2NhbGU6IHN0cmluZywgb3B0aW9ucz86IEludGwuTnVtYmVyRm9ybWF0T3B0aW9ucykge1xuICByZXR1cm4gZ2V0TnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0KG51bSk7XG59XG4iLCAiaW1wb3J0IHtpc0FycmF5fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2Zvcm1hdE51bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmludGwuanMnO1xuaW1wb3J0IHtsb2cxMH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuXG4vKipcbiAqIE5hbWVzcGFjZSB0byBob2xkIGZvcm1hdHRlcnMgZm9yIGRpZmZlcmVudCB0eXBlcyBvZiB0aWNrc1xuICogQG5hbWVzcGFjZSBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzXG4gKi9cbmNvbnN0IGZvcm1hdHRlcnMgPSB7XG4gIC8qKlxuICAgKiBGb3JtYXR0ZXIgZm9yIHZhbHVlIGxhYmVsc1xuICAgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMudmFsdWVzXG4gICAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgdG8gZGlzcGxheVxuICAgKiBAcmV0dXJuIHtzdHJpbmd8c3RyaW5nW119IHRoZSBsYWJlbCB0byBkaXNwbGF5XG4gICAqL1xuICB2YWx1ZXModmFsdWUpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyAvKiogQHR5cGUge3N0cmluZ1tdfSAqLyAodmFsdWUpIDogJycgKyB2YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogRm9ybWF0dGVyIGZvciBudW1lcmljIHRpY2tzXG4gICAqIEBtZXRob2QgQ2hhcnQuVGlja3MuZm9ybWF0dGVycy5udW1lcmljXG4gICAqIEBwYXJhbSB0aWNrVmFsdWUge251bWJlcn0gdGhlIHZhbHVlIHRvIGJlIGZvcm1hdHRlZFxuICAgKiBAcGFyYW0gaW5kZXgge251bWJlcn0gdGhlIHBvc2l0aW9uIG9mIHRoZSB0aWNrVmFsdWUgcGFyYW1ldGVyIGluIHRoZSB0aWNrcyBhcnJheVxuICAgKiBAcGFyYW0gdGlja3Mge29iamVjdFtdfSB0aGUgbGlzdCBvZiB0aWNrcyBiZWluZyBjb252ZXJ0ZWRcbiAgICogQHJldHVybiB7c3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRpY2tWYWx1ZSBwYXJhbWV0ZXJcbiAgICovXG4gIG51bWVyaWModGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcbiAgICBpZiAodGlja1ZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gJzAnOyAvLyBuZXZlciBzaG93IGRlY2ltYWwgcGxhY2VzIGZvciAwXG4gICAgfVxuXG4gICAgY29uc3QgbG9jYWxlID0gdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZTtcbiAgICBsZXQgbm90YXRpb247XG4gICAgbGV0IGRlbHRhID0gdGlja1ZhbHVlOyAvLyBUaGlzIGlzIHVzZWQgd2hlbiB0aGVyZSBhcmUgbGVzcyB0aGFuIDIgdGlja3MgYXMgdGhlIHRpY2sgaW50ZXJ2YWwuXG5cbiAgICBpZiAodGlja3MubGVuZ3RoID4gMSkge1xuICAgICAgLy8gYWxsIHRpY2tzIGFyZSBzbWFsbCBvciB0aGVyZSBodWdlIG51bWJlcnM7IHVzZSBzY2llbnRpZmljIG5vdGF0aW9uXG4gICAgICBjb25zdCBtYXhUaWNrID0gTWF0aC5tYXgoTWF0aC5hYnModGlja3NbMF0udmFsdWUpLCBNYXRoLmFicyh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSkpO1xuICAgICAgaWYgKG1heFRpY2sgPCAxZS00IHx8IG1heFRpY2sgPiAxZSsxNSkge1xuICAgICAgICBub3RhdGlvbiA9ICdzY2llbnRpZmljJztcbiAgICAgIH1cblxuICAgICAgZGVsdGEgPSBjYWxjdWxhdGVEZWx0YSh0aWNrVmFsdWUsIHRpY2tzKTtcbiAgICB9XG5cbiAgICBjb25zdCBsb2dEZWx0YSA9IGxvZzEwKE1hdGguYWJzKGRlbHRhKSk7XG5cbiAgICAvLyBXaGVuIGRhdGFzZXRzIGhhdmUgdmFsdWVzIGFwcHJvYWNoaW5nIE51bWJlci5NQVhfVkFMVUUsIHRoZSB0aWNrIGNhbGN1bGF0aW9ucyBtaWdodCByZXN1bHQgaW5cbiAgICAvLyBpbmZpbml0eSBhbmQgZXZlbnR1YWxseSBOYU4uIFBhc3NpbmcgTmFOIGZvciBtaW5pbXVtRnJhY3Rpb25EaWdpdHMgb3IgbWF4aW11bUZyYWN0aW9uRGlnaXRzXG4gICAgLy8gd2lsbCBtYWtlIHRoZSBudW1iZXIgZm9ybWF0dGVyIHRocm93LiBTbyBpbnN0ZWFkIHdlIGNoZWNrIGZvciBpc05hTiBhbmQgdXNlIGEgZmFsbGJhY2sgdmFsdWUuXG4gICAgLy9cbiAgICAvLyB0b0ZpeGVkIGhhcyBhIG1heCBvZiAyMCBkZWNpbWFsIHBsYWNlc1xuICAgIGNvbnN0IG51bURlY2ltYWwgPSBpc05hTihsb2dEZWx0YSkgPyAxIDogTWF0aC5tYXgoTWF0aC5taW4oLTEgKiBNYXRoLmZsb29yKGxvZ0RlbHRhKSwgMjApLCAwKTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7bm90YXRpb24sIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogbnVtRGVjaW1hbCwgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiBudW1EZWNpbWFsfTtcbiAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuXG4gICAgcmV0dXJuIGZvcm1hdE51bWJlcih0aWNrVmFsdWUsIGxvY2FsZSwgb3B0aW9ucyk7XG4gIH0sXG5cblxuICAvKipcbiAgICogRm9ybWF0dGVyIGZvciBsb2dhcml0aG1pYyB0aWNrc1xuICAgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMubG9nYXJpdGhtaWNcbiAgICogQHBhcmFtIHRpY2tWYWx1ZSB7bnVtYmVyfSB0aGUgdmFsdWUgdG8gYmUgZm9ybWF0dGVkXG4gICAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfSB0aGUgcG9zaXRpb24gb2YgdGhlIHRpY2tWYWx1ZSBwYXJhbWV0ZXIgaW4gdGhlIHRpY2tzIGFycmF5XG4gICAqIEBwYXJhbSB0aWNrcyB7b2JqZWN0W119IHRoZSBsaXN0IG9mIHRpY2tzIGJlaW5nIGNvbnZlcnRlZFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlclxuICAgKi9cbiAgbG9nYXJpdGhtaWModGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcbiAgICBpZiAodGlja1ZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gJzAnO1xuICAgIH1cbiAgICBjb25zdCByZW1haW4gPSB0aWNrc1tpbmRleF0uc2lnbmlmaWNhbmQgfHwgKHRpY2tWYWx1ZSAvIChNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMCh0aWNrVmFsdWUpKSkpKTtcbiAgICBpZiAoWzEsIDIsIDMsIDUsIDEwLCAxNV0uaW5jbHVkZXMocmVtYWluKSB8fCBpbmRleCA+IDAuOCAqIHRpY2tzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcnMubnVtZXJpYy5jYWxsKHRoaXMsIHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbn07XG5cblxuZnVuY3Rpb24gY2FsY3VsYXRlRGVsdGEodGlja1ZhbHVlLCB0aWNrcykge1xuICAvLyBGaWd1cmUgb3V0IGhvdyBtYW55IGRpZ2l0cyB0byBzaG93XG4gIC8vIFRoZSBzcGFjZSBiZXR3ZWVuIHRoZSBmaXJzdCB0d28gdGlja3MgbWlnaHQgYmUgc21hbGxlciB0aGFuIG5vcm1hbCBzcGFjaW5nXG4gIGxldCBkZWx0YSA9IHRpY2tzLmxlbmd0aCA+IDMgPyB0aWNrc1syXS52YWx1ZSAtIHRpY2tzWzFdLnZhbHVlIDogdGlja3NbMV0udmFsdWUgLSB0aWNrc1swXS52YWx1ZTtcblxuICAvLyBJZiB3ZSBoYXZlIGEgbnVtYmVyIGxpa2UgMi41IGFzIHRoZSBkZWx0YSwgZmlndXJlIG91dCBob3cgbWFueSBkZWNpbWFsIHBsYWNlcyB3ZSBuZWVkXG4gIGlmIChNYXRoLmFicyhkZWx0YSkgPj0gMSAmJiB0aWNrVmFsdWUgIT09IE1hdGguZmxvb3IodGlja1ZhbHVlKSkge1xuICAgIC8vIG5vdCBhbiBpbnRlZ2VyXG4gICAgZGVsdGEgPSB0aWNrVmFsdWUgLSBNYXRoLmZsb29yKHRpY2tWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGRlbHRhO1xufVxuXG4vKipcbiAqIE5hbWVzcGFjZSB0byBob2xkIHN0YXRpYyB0aWNrIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gKiBAbmFtZXNwYWNlIENoYXJ0LlRpY2tzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtmb3JtYXR0ZXJzfTtcbiIsICJpbXBvcnQgVGlja3MgZnJvbSAnLi9jb3JlLnRpY2tzLmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5U2NhbGVEZWZhdWx0cyhkZWZhdWx0cykge1xuICBkZWZhdWx0cy5zZXQoJ3NjYWxlJywge1xuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgb2Zmc2V0OiBmYWxzZSxcbiAgICByZXZlcnNlOiBmYWxzZSxcbiAgICBiZWdpbkF0WmVybzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZSBib3VuZGFyeSBzdHJhdGVneSAoYnlwYXNzZWQgYnkgbWluL21heCB0aW1lIG9wdGlvbnMpXG4gICAgICogLSBgZGF0YWA6IG1ha2Ugc3VyZSBkYXRhIGFyZSBmdWxseSB2aXNpYmxlLCB0aWNrcyBvdXRzaWRlIGFyZSByZW1vdmVkXG4gICAgICogLSBgdGlja3NgOiBtYWtlIHN1cmUgdGlja3MgYXJlIGZ1bGx5IHZpc2libGUsIGRhdGEgb3V0c2lkZSBhcmUgdHJ1bmNhdGVkXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1NTZcbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKi9cbiAgICBib3VuZHM6ICd0aWNrcycsXG5cbiAgICBjbGlwOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQWRkaXRpb24gZ3JhY2UgYWRkZWQgdG8gbWF4IGFuZCByZWR1Y2VkIGZyb20gbWluIGRhdGEgdmFsdWUuXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICovXG4gICAgZ3JhY2U6IDAsXG5cbiAgICAvLyBncmlkIGxpbmUgc2V0dGluZ3NcbiAgICBncmlkOiB7XG4gICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgZHJhd09uQ2hhcnRBcmVhOiB0cnVlLFxuICAgICAgZHJhd1RpY2tzOiB0cnVlLFxuICAgICAgdGlja0xlbmd0aDogOCxcbiAgICAgIHRpY2tXaWR0aDogKF9jdHgsIG9wdGlvbnMpID0+IG9wdGlvbnMubGluZVdpZHRoLFxuICAgICAgdGlja0NvbG9yOiAoX2N0eCwgb3B0aW9ucykgPT4gb3B0aW9ucy5jb2xvcixcbiAgICAgIG9mZnNldDogZmFsc2UsXG4gICAgfSxcblxuICAgIGJvcmRlcjoge1xuICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgIGRhc2g6IFtdLFxuICAgICAgZGFzaE9mZnNldDogMC4wLFxuICAgICAgd2lkdGg6IDFcbiAgICB9LFxuXG4gICAgLy8gc2NhbGUgdGl0bGVcbiAgICB0aXRsZToge1xuICAgICAgLy8gZGlzcGxheSBwcm9wZXJ0eVxuICAgICAgZGlzcGxheTogZmFsc2UsXG5cbiAgICAgIC8vIGFjdHVhbCBsYWJlbFxuICAgICAgdGV4dDogJycsXG5cbiAgICAgIC8vIHRvcC9ib3R0b20gcGFkZGluZ1xuICAgICAgcGFkZGluZzoge1xuICAgICAgICB0b3A6IDQsXG4gICAgICAgIGJvdHRvbTogNFxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBsYWJlbCBzZXR0aW5nc1xuICAgIHRpY2tzOiB7XG4gICAgICBtaW5Sb3RhdGlvbjogMCxcbiAgICAgIG1heFJvdGF0aW9uOiA1MCxcbiAgICAgIG1pcnJvcjogZmFsc2UsXG4gICAgICB0ZXh0U3Ryb2tlV2lkdGg6IDAsXG4gICAgICB0ZXh0U3Ryb2tlQ29sb3I6ICcnLFxuICAgICAgcGFkZGluZzogMyxcbiAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICBhdXRvU2tpcDogdHJ1ZSxcbiAgICAgIGF1dG9Ta2lwUGFkZGluZzogMyxcbiAgICAgIGxhYmVsT2Zmc2V0OiAwLFxuICAgICAgLy8gV2UgcGFzcyB0aHJvdWdoIGFycmF5cyB0byBiZSByZW5kZXJlZCBhcyBtdWx0aWxpbmUgbGFiZWxzLCB3ZSBjb252ZXJ0IE90aGVycyB0byBzdHJpbmdzIGhlcmUuXG4gICAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy52YWx1ZXMsXG4gICAgICBtaW5vcjoge30sXG4gICAgICBtYWpvcjoge30sXG4gICAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgICBjcm9zc0FsaWduOiAnbmVhcicsXG5cbiAgICAgIHNob3dMYWJlbEJhY2tkcm9wOiBmYWxzZSxcbiAgICAgIGJhY2tkcm9wQ29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpJyxcbiAgICAgIGJhY2tkcm9wUGFkZGluZzogMixcbiAgICB9XG4gIH0pO1xuXG4gIGRlZmF1bHRzLnJvdXRlKCdzY2FsZS50aWNrcycsICdjb2xvcicsICcnLCAnY29sb3InKTtcbiAgZGVmYXVsdHMucm91dGUoJ3NjYWxlLmdyaWQnLCAnY29sb3InLCAnJywgJ2JvcmRlckNvbG9yJyk7XG4gIGRlZmF1bHRzLnJvdXRlKCdzY2FsZS5ib3JkZXInLCAnY29sb3InLCAnJywgJ2JvcmRlckNvbG9yJyk7XG4gIGRlZmF1bHRzLnJvdXRlKCdzY2FsZS50aXRsZScsICdjb2xvcicsICcnLCAnY29sb3InKTtcblxuICBkZWZhdWx0cy5kZXNjcmliZSgnc2NhbGUnLCB7XG4gICAgX2ZhbGxiYWNrOiBmYWxzZSxcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ2JlZm9yZScpICYmICFuYW1lLnN0YXJ0c1dpdGgoJ2FmdGVyJykgJiYgbmFtZSAhPT0gJ2NhbGxiYWNrJyAmJiBuYW1lICE9PSAncGFyc2VyJyxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnICYmIG5hbWUgIT09ICd0aWNrQm9yZGVyRGFzaCcgJiYgbmFtZSAhPT0gJ2Rhc2gnLFxuICB9KTtcblxuICBkZWZhdWx0cy5kZXNjcmliZSgnc2NhbGVzJywge1xuICAgIF9mYWxsYmFjazogJ3NjYWxlJyxcbiAgfSk7XG5cbiAgZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlLnRpY2tzJywge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JhY2tkcm9wUGFkZGluZycgJiYgbmFtZSAhPT0gJ2NhbGxiYWNrJyxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JhY2tkcm9wUGFkZGluZycsXG4gIH0pO1xufVxuIiwgImltcG9ydCB7Z2V0SG92ZXJDb2xvcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbG9yLmpzJztcbmltcG9ydCB7aXNPYmplY3QsIG1lcmdlLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHthcHBseUFuaW1hdGlvbnNEZWZhdWx0c30gZnJvbSAnLi9jb3JlLmFuaW1hdGlvbnMuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHthcHBseUxheW91dHNEZWZhdWx0c30gZnJvbSAnLi9jb3JlLmxheW91dHMuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHthcHBseVNjYWxlRGVmYXVsdHN9IGZyb20gJy4vY29yZS5zY2FsZS5kZWZhdWx0cy5qcyc7XG5cbmV4cG9ydCBjb25zdCBvdmVycmlkZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZXhwb3J0IGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTY29wZShub2RlLCBrZXkpIHtcbiAgaWYgKCFrZXkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBjb25zdCBrZXlzID0ga2V5LnNwbGl0KCcuJyk7XG4gIGZvciAobGV0IGkgPSAwLCBuID0ga2V5cy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBjb25zdCBrID0ga2V5c1tpXTtcbiAgICBub2RlID0gbm9kZVtrXSB8fCAobm9kZVtrXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBzZXQocm9vdCwgc2NvcGUsIHZhbHVlcykge1xuICBpZiAodHlwZW9mIHNjb3BlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBtZXJnZShnZXRTY29wZShyb290LCBzY29wZSksIHZhbHVlcyk7XG4gIH1cbiAgcmV0dXJuIG1lcmdlKGdldFNjb3BlKHJvb3QsICcnKSwgc2NvcGUpO1xufVxuXG4vKipcbiAqIFBsZWFzZSB1c2UgdGhlIG1vZHVsZSdzIGRlZmF1bHQgZXhwb3J0IHdoaWNoIHByb3ZpZGVzIGEgc2luZ2xldG9uIGluc3RhbmNlXG4gKiBOb3RlOiBjbGFzcyBpcyBleHBvcnRlZCBmb3IgdHlwZWRvY1xuICovXG5leHBvcnQgY2xhc3MgRGVmYXVsdHMge1xuICBjb25zdHJ1Y3RvcihfZGVzY3JpcHRvcnMsIF9hcHBsaWVycykge1xuICAgIHRoaXMuYW5pbWF0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMCwwLDAsMC4xKSc7XG4gICAgdGhpcy5ib3JkZXJDb2xvciA9ICdyZ2JhKDAsMCwwLDAuMSknO1xuICAgIHRoaXMuY29sb3IgPSAnIzY2Nic7XG4gICAgdGhpcy5kYXRhc2V0cyA9IHt9O1xuICAgIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbyA9IChjb250ZXh0KSA9PiBjb250ZXh0LmNoYXJ0LnBsYXRmb3JtLmdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICB0aGlzLmVsZW1lbnRzID0ge307XG4gICAgdGhpcy5ldmVudHMgPSBbXG4gICAgICAnbW91c2Vtb3ZlJyxcbiAgICAgICdtb3VzZW91dCcsXG4gICAgICAnY2xpY2snLFxuICAgICAgJ3RvdWNoc3RhcnQnLFxuICAgICAgJ3RvdWNobW92ZSdcbiAgICBdO1xuICAgIHRoaXMuZm9udCA9IHtcbiAgICAgIGZhbWlseTogXCInSGVsdmV0aWNhIE5ldWUnLCAnSGVsdmV0aWNhJywgJ0FyaWFsJywgc2Fucy1zZXJpZlwiLFxuICAgICAgc2l6ZTogMTIsXG4gICAgICBzdHlsZTogJ25vcm1hbCcsXG4gICAgICBsaW5lSGVpZ2h0OiAxLjIsXG4gICAgICB3ZWlnaHQ6IG51bGxcbiAgICB9O1xuICAgIHRoaXMuaG92ZXIgPSB7fTtcbiAgICB0aGlzLmhvdmVyQmFja2dyb3VuZENvbG9yID0gKGN0eCwgb3B0aW9ucykgPT4gZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcik7XG4gICAgdGhpcy5ob3ZlckJvcmRlckNvbG9yID0gKGN0eCwgb3B0aW9ucykgPT4gZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKTtcbiAgICB0aGlzLmhvdmVyQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuY29sb3IpO1xuICAgIHRoaXMuaW5kZXhBeGlzID0gJ3gnO1xuICAgIHRoaXMuaW50ZXJhY3Rpb24gPSB7XG4gICAgICBtb2RlOiAnbmVhcmVzdCcsXG4gICAgICBpbnRlcnNlY3Q6IHRydWUsXG4gICAgICBpbmNsdWRlSW52aXNpYmxlOiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy5tYWludGFpbkFzcGVjdFJhdGlvID0gdHJ1ZTtcbiAgICB0aGlzLm9uSG92ZXIgPSBudWxsO1xuICAgIHRoaXMub25DbGljayA9IG51bGw7XG4gICAgdGhpcy5wYXJzaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnBsdWdpbnMgPSB7fTtcbiAgICB0aGlzLnJlc3BvbnNpdmUgPSB0cnVlO1xuICAgIHRoaXMuc2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zY2FsZXMgPSB7fTtcbiAgICB0aGlzLnNob3dMaW5lID0gdHJ1ZTtcbiAgICB0aGlzLmRyYXdBY3RpdmVFbGVtZW50c09uVG9wID0gdHJ1ZTtcblxuICAgIHRoaXMuZGVzY3JpYmUoX2Rlc2NyaXB0b3JzKTtcbiAgICB0aGlzLmFwcGx5KF9hcHBsaWVycyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBzY29wZVxuXHQgKiBAcGFyYW0ge29iamVjdH0gW3ZhbHVlc11cblx0ICovXG4gIHNldChzY29wZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHNldCh0aGlzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2NvcGVcblx0ICovXG4gIGdldChzY29wZSkge1xuICAgIHJldHVybiBnZXRTY29wZSh0aGlzLCBzY29wZSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBzY29wZVxuXHQgKiBAcGFyYW0ge29iamVjdH0gW3ZhbHVlc11cblx0ICovXG4gIGRlc2NyaWJlKHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KGRlc2NyaXB0b3JzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuXG4gIG92ZXJyaWRlKHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KG92ZXJyaWRlcywgc2NvcGUsIHZhbHVlcyk7XG4gIH1cblxuICAvKipcblx0ICogUm91dGVzIHRoZSBuYW1lZCBkZWZhdWx0cyB0byBmYWxsYmFjayB0byBhbm90aGVyIHNjb3BlL25hbWUuXG5cdCAqIFRoaXMgcm91dGluZyBpcyB1c2VmdWwgd2hlbiB0aG9zZSB0YXJnZXQgdmFsdWVzLCBsaWtlIGRlZmF1bHRzLmNvbG9yLCBhcmUgY2hhbmdlZCBydW50aW1lLlxuXHQgKiBJZiB0aGUgdmFsdWVzIHdvdWxkIGJlIGNvcGllZCwgdGhlIHJ1bnRpbWUgY2hhbmdlIHdvdWxkIG5vdCB0YWtlIGVmZmVjdC4gQnkgcm91dGluZywgdGhlXG5cdCAqIGZhbGxiYWNrIGlzIGV2YWx1YXRlZCBhdCBlYWNoIGFjY2Vzcywgc28gaXRzIGFsd2F5cyB1cCB0byBkYXRlLlxuXHQgKlxuXHQgKiBFeGFtcGxlOlxuXHQgKlxuXHQgKiBcdGRlZmF1bHRzLnJvdXRlKCdlbGVtZW50cy5hcmMnLCAnYmFja2dyb3VuZENvbG9yJywgJycsICdjb2xvcicpXG5cdCAqICAgLSByZWFkcyB0aGUgYmFja2dyb3VuZENvbG9yIGZyb20gZGVmYXVsdHMuY29sb3Igd2hlbiB1bmRlZmluZWQgbG9jYWxseVxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2NvcGUgU2NvcGUgdGhpcyByb3V0ZSBhcHBsaWVzIHRvLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBQcm9wZXJ0eSBuYW1lIHRoYXQgc2hvdWxkIGJlIHJvdXRlZCB0byBkaWZmZXJlbnQgbmFtZXNwYWNlIHdoZW4gbm90IGRlZmluZWQgaGVyZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldFNjb3BlIFRoZSBuYW1lc3BhY2Ugd2hlcmUgdGhvc2UgcHJvcGVydGllcyBzaG91bGQgYmUgcm91dGVkIHRvLlxuXHQgKiBFbXB0eSBzdHJpbmcgKCcnKSBpcyB0aGUgcm9vdCBvZiBkZWZhdWx0cy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldE5hbWUgVGhlIHRhcmdldCBuYW1lIGluIHRoZSB0YXJnZXQgc2NvcGUgdGhlIHByb3BlcnR5IHNob3VsZCBiZSByb3V0ZWQgdG8uXG5cdCAqL1xuICByb3V0ZShzY29wZSwgbmFtZSwgdGFyZ2V0U2NvcGUsIHRhcmdldE5hbWUpIHtcbiAgICBjb25zdCBzY29wZU9iamVjdCA9IGdldFNjb3BlKHRoaXMsIHNjb3BlKTtcbiAgICBjb25zdCB0YXJnZXRTY29wZU9iamVjdCA9IGdldFNjb3BlKHRoaXMsIHRhcmdldFNjb3BlKTtcbiAgICBjb25zdCBwcml2YXRlTmFtZSA9ICdfJyArIG5hbWU7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzY29wZU9iamVjdCwge1xuICAgICAgLy8gQSBwcml2YXRlIHByb3BlcnR5IGlzIGRlZmluZWQgdG8gaG9sZCB0aGUgYWN0dWFsIHZhbHVlLCB3aGVuIHRoaXMgcHJvcGVydHkgaXMgc2V0IGluIGl0cyBzY29wZSAoc2V0IGluIHRoZSBzZXR0ZXIpXG4gICAgICBbcHJpdmF0ZU5hbWVdOiB7XG4gICAgICAgIHZhbHVlOiBzY29wZU9iamVjdFtuYW1lXSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0sXG4gICAgICAvLyBUaGUgYWN0dWFsIHByb3BlcnR5IGlzIGRlZmluZWQgYXMgZ2V0dGVyL3NldHRlciBzbyB3ZSBjYW4gZG8gdGhlIHJvdXRpbmcgd2hlbiB2YWx1ZSBpcyBub3QgbG9jYWxseSBzZXQuXG4gICAgICBbbmFtZV06IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGNvbnN0IGxvY2FsID0gdGhpc1twcml2YXRlTmFtZV07XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0U2NvcGVPYmplY3RbdGFyZ2V0TmFtZV07XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KGxvY2FsKSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRhcmdldCwgbG9jYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWVPckRlZmF1bHQobG9jYWwsIHRhcmdldCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIHRoaXNbcHJpdmF0ZU5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFwcGx5KGFwcGxpZXJzKSB7XG4gICAgYXBwbGllcnMuZm9yRWFjaCgoYXBwbHkpID0+IGFwcGx5KHRoaXMpKTtcbiAgfVxufVxuXG4vLyBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBkZWZhdWx0IC8qICNfX1BVUkVfXyAqLyBuZXcgRGVmYXVsdHMoe1xuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ29uJyksXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnZXZlbnRzJyxcbiAgaG92ZXI6IHtcbiAgICBfZmFsbGJhY2s6ICdpbnRlcmFjdGlvbidcbiAgfSxcbiAgaW50ZXJhY3Rpb246IHtcbiAgICBfc2NyaXB0YWJsZTogZmFsc2UsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH1cbn0sIFthcHBseUFuaW1hdGlvbnNEZWZhdWx0cywgYXBwbHlMYXlvdXRzRGVmYXVsdHMsIGFwcGx5U2NhbGVEZWZhdWx0c10pO1xuIiwgImltcG9ydCB0eXBlIHtcbiAgQ2hhcnQsXG4gIFBvaW50LFxuICBGb250U3BlYyxcbiAgQ2FudmFzRm9udFNwZWMsXG4gIFBvaW50U3R5bGUsXG4gIFJlbmRlclRleHRPcHRzLFxuICBCYWNrZHJvcE9wdGlvbnNcbn0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuaW1wb3J0IHR5cGUge1xuICBUUkJMLFxuICBTcGxpbmVQb2ludCxcbiAgUm91bmRlZFJlY3QsXG4gIFRSQkxDb3JuZXJzXG59IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5pbXBvcnQge2lzQXJyYXksIGlzTnVsbE9yVW5kZWZ9IGZyb20gJy4vaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7UEksIFRBVSwgSEFMRl9QSSwgUVVBUlRFUl9QSSwgVFdPX1RISVJEU19QSSwgUkFEX1BFUl9ERUd9IGZyb20gJy4vaGVscGVycy5tYXRoLmpzJztcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gZm9udCBvYmplY3QgaW50byBhIENTUyBmb250IHN0cmluZy5cbiAqIEBwYXJhbSBmb250IC0gQSBmb250IG9iamVjdC5cbiAqIEByZXR1cm4gVGhlIENTUyBmb250IHN0cmluZy4gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9mb250XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Gb250U3RyaW5nKGZvbnQ6IEZvbnRTcGVjKSB7XG4gIGlmICghZm9udCB8fCBpc051bGxPclVuZGVmKGZvbnQuc2l6ZSkgfHwgaXNOdWxsT3JVbmRlZihmb250LmZhbWlseSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiAoZm9udC5zdHlsZSA/IGZvbnQuc3R5bGUgKyAnICcgOiAnJylcblx0XHQrIChmb250LndlaWdodCA/IGZvbnQud2VpZ2h0ICsgJyAnIDogJycpXG5cdFx0KyBmb250LnNpemUgKyAncHggJ1xuXHRcdCsgZm9udC5mYW1pbHk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9tZWFzdXJlVGV4dChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4sXG4gIGdjOiBzdHJpbmdbXSxcbiAgbG9uZ2VzdDogbnVtYmVyLFxuICBzdHJpbmc6IHN0cmluZ1xuKSB7XG4gIGxldCB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ107XG4gIGlmICghdGV4dFdpZHRoKSB7XG4gICAgdGV4dFdpZHRoID0gZGF0YVtzdHJpbmddID0gY3R4Lm1lYXN1cmVUZXh0KHN0cmluZykud2lkdGg7XG4gICAgZ2MucHVzaChzdHJpbmcpO1xuICB9XG4gIGlmICh0ZXh0V2lkdGggPiBsb25nZXN0KSB7XG4gICAgbG9uZ2VzdCA9IHRleHRXaWR0aDtcbiAgfVxuICByZXR1cm4gbG9uZ2VzdDtcbn1cblxudHlwZSBUaGluZyA9IHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGxcbnR5cGUgVGhpbmdzID0gKFRoaW5nIHwgVGhpbmdbXSlbXVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5leHBvcnQgZnVuY3Rpb24gX2xvbmdlc3RUZXh0KFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgZm9udDogc3RyaW5nLFxuICBhcnJheU9mVGhpbmdzOiBUaGluZ3MsXG4gIGNhY2hlPzoge2RhdGE/OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LCBnYXJiYWdlQ29sbGVjdD86IHN0cmluZ1tdLCBmb250Pzogc3RyaW5nfVxuKSB7XG4gIGNhY2hlID0gY2FjaGUgfHwge307XG4gIGxldCBkYXRhID0gY2FjaGUuZGF0YSA9IGNhY2hlLmRhdGEgfHwge307XG4gIGxldCBnYyA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0ID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgfHwgW107XG5cbiAgaWYgKGNhY2hlLmZvbnQgIT09IGZvbnQpIHtcbiAgICBkYXRhID0gY2FjaGUuZGF0YSA9IHt9O1xuICAgIGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBbXTtcbiAgICBjYWNoZS5mb250ID0gZm9udDtcbiAgfVxuXG4gIGN0eC5zYXZlKCk7XG5cbiAgY3R4LmZvbnQgPSBmb250O1xuICBsZXQgbG9uZ2VzdCA9IDA7XG4gIGNvbnN0IGlsZW4gPSBhcnJheU9mVGhpbmdzLmxlbmd0aDtcbiAgbGV0IGk6IG51bWJlciwgajogbnVtYmVyLCBqbGVuOiBudW1iZXIsIHRoaW5nOiBUaGluZyB8IFRoaW5nW10sIG5lc3RlZFRoaW5nOiBUaGluZyB8IFRoaW5nW107XG4gIGZvciAoaSA9IDA7IGkgPCBpbGVuOyBpKyspIHtcbiAgICB0aGluZyA9IGFycmF5T2ZUaGluZ3NbaV07XG5cbiAgICAvLyBVbmRlZmluZWQgc3RyaW5ncyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcbiAgICBpZiAodGhpbmcgIT09IHVuZGVmaW5lZCAmJiB0aGluZyAhPT0gbnVsbCAmJiAhaXNBcnJheSh0aGluZykpIHtcbiAgICAgIGxvbmdlc3QgPSBfbWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgdGhpbmcpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0aGluZykpIHtcbiAgICAgIC8vIGlmIGl0IGlzIGFuIGFycmF5IGxldHMgbWVhc3VyZSBlYWNoIGVsZW1lbnRcbiAgICAgIC8vIHRvIGRvIG1heWJlIHNpbXBsaWZ5IHRoaXMgZnVuY3Rpb24gYSBiaXQgc28gd2UgY2FuIGRvIHRoaXMgbW9yZSByZWN1cnNpdmVseT9cbiAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSB0aGluZy5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgbmVzdGVkVGhpbmcgPSB0aGluZ1tqXTtcbiAgICAgICAgLy8gVW5kZWZpbmVkIHN0cmluZ3MgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXG4gICAgICAgIGlmIChuZXN0ZWRUaGluZyAhPT0gdW5kZWZpbmVkICYmIG5lc3RlZFRoaW5nICE9PSBudWxsICYmICFpc0FycmF5KG5lc3RlZFRoaW5nKSkge1xuICAgICAgICAgIGxvbmdlc3QgPSBfbWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgbmVzdGVkVGhpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY3R4LnJlc3RvcmUoKTtcblxuICBjb25zdCBnY0xlbiA9IGdjLmxlbmd0aCAvIDI7XG4gIGlmIChnY0xlbiA+IGFycmF5T2ZUaGluZ3MubGVuZ3RoKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGdjTGVuOyBpKyspIHtcbiAgICAgIGRlbGV0ZSBkYXRhW2djW2ldXTtcbiAgICB9XG4gICAgZ2Muc3BsaWNlKDAsIGdjTGVuKTtcbiAgfVxuICByZXR1cm4gbG9uZ2VzdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhbGlnbmVkIHBpeGVsIHZhbHVlIHRvIGF2b2lkIGFudGktYWxpYXNpbmcgYmx1clxuICogQHBhcmFtIGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuICogQHBhcmFtIHBpeGVsIC0gQSBwaXhlbCB2YWx1ZS5cbiAqIEBwYXJhbSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgZWxlbWVudC5cbiAqIEByZXR1cm5zIFRoZSBhbGlnbmVkIHBpeGVsIHZhbHVlLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9hbGlnblBpeGVsKGNoYXJ0OiBDaGFydCwgcGl4ZWw6IG51bWJlciwgd2lkdGg6IG51bWJlcikge1xuICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW87XG4gIGNvbnN0IGhhbGZXaWR0aCA9IHdpZHRoICE9PSAwID8gTWF0aC5tYXgod2lkdGggLyAyLCAwLjUpIDogMDtcbiAgcmV0dXJuIE1hdGgucm91bmQoKHBpeGVsIC0gaGFsZldpZHRoKSAqIGRldmljZVBpeGVsUmF0aW8pIC8gZGV2aWNlUGl4ZWxSYXRpbyArIGhhbGZXaWR0aDtcbn1cblxuLyoqXG4gKiBDbGVhcnMgdGhlIGVudGlyZSBjYW52YXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckNhbnZhcyhjYW52YXM/OiBIVE1MQ2FudmFzRWxlbWVudCwgY3R4PzogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gIGlmICghY3R4ICYmICFjYW52YXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdHggPSBjdHggfHwgY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgY3R4LnNhdmUoKTtcbiAgLy8gY2FudmFzLndpZHRoIGFuZCBjYW52YXMuaGVpZ2h0IGRvIG5vdCBjb25zaWRlciB0aGUgY2FudmFzIHRyYW5zZm9ybSxcbiAgLy8gd2hpbGUgY2xlYXJSZWN0IGRvZXNcbiAgY3R4LnJlc2V0VHJhbnNmb3JtKCk7XG4gIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEcmF3UG9pbnRPcHRpb25zIHtcbiAgcG9pbnRTdHlsZTogUG9pbnRTdHlsZTtcbiAgcm90YXRpb24/OiBudW1iZXI7XG4gIHJhZGl1czogbnVtYmVyO1xuICBib3JkZXJXaWR0aDogbnVtYmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZHJhd1BvaW50KFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgb3B0aW9uczogRHJhd1BvaW50T3B0aW9ucyxcbiAgeDogbnVtYmVyLFxuICB5OiBudW1iZXJcbikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gIGRyYXdQb2ludExlZ2VuZChjdHgsIG9wdGlvbnMsIHgsIHksIG51bGwpO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZXhwb3J0IGZ1bmN0aW9uIGRyYXdQb2ludExlZ2VuZChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIG9wdGlvbnM6IERyYXdQb2ludE9wdGlvbnMsXG4gIHg6IG51bWJlcixcbiAgeTogbnVtYmVyLFxuICB3OiBudW1iZXJcbikge1xuICBsZXQgdHlwZTogc3RyaW5nLCB4T2Zmc2V0OiBudW1iZXIsIHlPZmZzZXQ6IG51bWJlciwgc2l6ZTogbnVtYmVyLCBjb3JuZXJSYWRpdXM6IG51bWJlciwgd2lkdGg6IG51bWJlciwgeE9mZnNldFc6IG51bWJlciwgeU9mZnNldFc6IG51bWJlcjtcbiAgY29uc3Qgc3R5bGUgPSBvcHRpb25zLnBvaW50U3R5bGU7XG4gIGNvbnN0IHJvdGF0aW9uID0gb3B0aW9ucy5yb3RhdGlvbjtcbiAgY29uc3QgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXM7XG4gIGxldCByYWQgPSAocm90YXRpb24gfHwgMCkgKiBSQURfUEVSX0RFRztcblxuICBpZiAoc3R5bGUgJiYgdHlwZW9mIHN0eWxlID09PSAnb2JqZWN0Jykge1xuICAgIHR5cGUgPSBzdHlsZS50b1N0cmluZygpO1xuICAgIGlmICh0eXBlID09PSAnW29iamVjdCBIVE1MSW1hZ2VFbGVtZW50XScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgSFRNTENhbnZhc0VsZW1lbnRdJykge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICBjdHgucm90YXRlKHJhZCk7XG4gICAgICBjdHguZHJhd0ltYWdlKHN0eWxlLCAtc3R5bGUud2lkdGggLyAyLCAtc3R5bGUuaGVpZ2h0IC8gMiwgc3R5bGUud2lkdGgsIHN0eWxlLmhlaWdodCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc05hTihyYWRpdXMpIHx8IHJhZGl1cyA8PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gIHN3aXRjaCAoc3R5bGUpIHtcbiAgLy8gRGVmYXVsdCBpbmNsdWRlcyBjaXJjbGVcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHcpIHtcbiAgICAgICAgY3R4LmVsbGlwc2UoeCwgeSwgdyAvIDIsIHJhZGl1cywgMCwgMCwgVEFVKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCBUQVUpO1xuICAgICAgfVxuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndHJpYW5nbGUnOlxuICAgICAgd2lkdGggPSB3ID8gdyAvIDIgOiByYWRpdXM7XG4gICAgICBjdHgubW92ZVRvKHggKyBNYXRoLnNpbihyYWQpICogd2lkdGgsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICAgIHJhZCArPSBUV09fVEhJUkRTX1BJO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHdpZHRoLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgICByYWQgKz0gVFdPX1RISVJEU19QSTtcbiAgICAgIGN0eC5saW5lVG8oeCArIE1hdGguc2luKHJhZCkgKiB3aWR0aCwgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmVjdFJvdW5kZWQnOlxuICAgIC8vIE5PVEU6IHRoZSByb3VuZGVkIHJlY3QgaW1wbGVtZW50YXRpb24gY2hhbmdlZCB0byB1c2UgYGFyY2AgaW5zdGVhZCBvZlxuICAgIC8vIGBxdWFkcmF0aWNDdXJ2ZVRvYCBzaW5jZSBpdCBnZW5lcmF0ZXMgYmV0dGVyIHJlc3VsdHMgd2hlbiByZWN0IGlzXG4gICAgLy8gYWxtb3N0IGEgY2lyY2xlLiAwLjUxNiAoaW5zdGVhZCBvZiAwLjUpIHByb2R1Y2VzIHJlc3VsdHMgd2l0aCB2aXN1YWxseVxuICAgIC8vIGNsb3NlciBwcm9wb3J0aW9uIHRvIHRoZSBwcmV2aW91cyBpbXBsIGFuZCBpdCBpcyBpbnNjcmliZWQgaW4gdGhlXG4gICAgLy8gY2lyY2xlIHdpdGggYHJhZGl1c2AuIEZvciBtb3JlIGRldGFpbHMsIHNlZSB0aGUgZm9sbG93aW5nIFBSczpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTU5N1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81ODU4XG4gICAgICBjb3JuZXJSYWRpdXMgPSByYWRpdXMgKiAwLjUxNjtcbiAgICAgIHNpemUgPSByYWRpdXMgLSBjb3JuZXJSYWRpdXM7XG4gICAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkICsgUVVBUlRFUl9QSSkgKiBzaXplO1xuICAgICAgeE9mZnNldFcgPSBNYXRoLmNvcyhyYWQgKyBRVUFSVEVSX1BJKSAqICh3ID8gdyAvIDIgLSBjb3JuZXJSYWRpdXMgOiBzaXplKTtcbiAgICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQgKyBRVUFSVEVSX1BJKSAqIHNpemU7XG4gICAgICB5T2Zmc2V0VyA9IE1hdGguc2luKHJhZCArIFFVQVJURVJfUEkpICogKHcgPyB3IC8gMiAtIGNvcm5lclJhZGl1cyA6IHNpemUpO1xuICAgICAgY3R4LmFyYyh4IC0geE9mZnNldFcsIHkgLSB5T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCAtIFBJLCByYWQgLSBIQUxGX1BJKTtcbiAgICAgIGN0eC5hcmMoeCArIHlPZmZzZXRXLCB5IC0geE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgLSBIQUxGX1BJLCByYWQpO1xuICAgICAgY3R4LmFyYyh4ICsgeE9mZnNldFcsIHkgKyB5T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCwgcmFkICsgSEFMRl9QSSk7XG4gICAgICBjdHguYXJjKHggLSB5T2Zmc2V0VywgeSArIHhPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkICsgSEFMRl9QSSwgcmFkICsgUEkpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmVjdCc6XG4gICAgICBpZiAoIXJvdGF0aW9uKSB7XG4gICAgICAgIHNpemUgPSBNYXRoLlNRUlQxXzIgKiByYWRpdXM7XG4gICAgICAgIHdpZHRoID0gdyA/IHcgLyAyIDogc2l6ZTtcbiAgICAgICAgY3R4LnJlY3QoeCAtIHdpZHRoLCB5IC0gc2l6ZSwgMiAqIHdpZHRoLCAyICogc2l6ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmFkICs9IFFVQVJURVJfUEk7XG4gICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgJ3JlY3RSb3QnOlxuICAgICAgeE9mZnNldFcgPSBNYXRoLmNvcyhyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldFcgPSBNYXRoLnNpbihyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0VywgeSAtIHlPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgeU9mZnNldFcsIHkgLSB4T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXRXLCB5ICsgeU9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0VywgeSArIHhPZmZzZXQpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY3Jvc3NSb3QnOlxuICAgICAgcmFkICs9IFFVQVJURVJfUEk7XG4gICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgJ2Nyb3NzJzpcbiAgICAgIHhPZmZzZXRXID0gTWF0aC5jb3MocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXRXID0gTWF0aC5zaW4ocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldFcsIHkgLSB5T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXRXLCB5ICsgeU9mZnNldCk7XG4gICAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0VywgeSAtIHhPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldFcsIHkgKyB4T2Zmc2V0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3N0YXInOlxuICAgICAgeE9mZnNldFcgPSBNYXRoLmNvcyhyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldFcgPSBNYXRoLnNpbihyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0VywgeSAtIHlPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldFcsIHkgKyB5T2Zmc2V0KTtcbiAgICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXRXLCB5IC0geE9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0VywgeSArIHhPZmZzZXQpO1xuICAgICAgcmFkICs9IFFVQVJURVJfUEk7XG4gICAgICB4T2Zmc2V0VyA9IE1hdGguY29zKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0VyA9IE1hdGguc2luKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXRXLCB5IC0geU9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0VywgeSArIHlPZmZzZXQpO1xuICAgICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldFcsIHkgLSB4T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXRXLCB5ICsgeE9mZnNldCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdsaW5lJzpcbiAgICAgIHhPZmZzZXQgPSB3ID8gdyAvIDIgOiBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkYXNoJzpcbiAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICBjdHgubGluZVRvKHggKyBNYXRoLmNvcyhyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyksIHkgKyBNYXRoLnNpbihyYWQpICogcmFkaXVzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmFsc2U6XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGN0eC5maWxsKCk7XG4gIGlmIChvcHRpb25zLmJvcmRlcldpZHRoID4gMCkge1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcG9pbnQgaXMgaW5zaWRlIHRoZSByZWN0YW5nbGVcbiAqIEBwYXJhbSBwb2ludCAtIFRoZSBwb2ludCB0byB0ZXN0XG4gKiBAcGFyYW0gYXJlYSAtIFRoZSByZWN0YW5nbGVcbiAqIEBwYXJhbSBtYXJnaW4gLSBhbGxvd2VkIG1hcmdpblxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9pc1BvaW50SW5BcmVhKFxuICBwb2ludDogUG9pbnQsXG4gIGFyZWE6IFRSQkwsXG4gIG1hcmdpbj86IG51bWJlclxuKSB7XG4gIG1hcmdpbiA9IG1hcmdpbiB8fCAwLjU7IC8vIG1hcmdpbiAtIGRlZmF1bHQgaXMgdG8gbWF0Y2ggcm91bmRlZCBkZWNpbWFsc1xuXG4gIHJldHVybiAhYXJlYSB8fCAocG9pbnQgJiYgcG9pbnQueCA+IGFyZWEubGVmdCAtIG1hcmdpbiAmJiBwb2ludC54IDwgYXJlYS5yaWdodCArIG1hcmdpbiAmJlxuXHRcdHBvaW50LnkgPiBhcmVhLnRvcCAtIG1hcmdpbiAmJiBwb2ludC55IDwgYXJlYS5ib3R0b20gKyBtYXJnaW4pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xpcEFyZWEoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGFyZWE6IFRSQkwpIHtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgucmVjdChhcmVhLmxlZnQsIGFyZWEudG9wLCBhcmVhLnJpZ2h0IC0gYXJlYS5sZWZ0LCBhcmVhLmJvdHRvbSAtIGFyZWEudG9wKTtcbiAgY3R4LmNsaXAoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuY2xpcEFyZWEoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3N0ZXBwZWRMaW5lVG8oXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBwcmV2aW91czogUG9pbnQsXG4gIHRhcmdldDogUG9pbnQsXG4gIGZsaXA/OiBib29sZWFuLFxuICBtb2RlPzogc3RyaW5nXG4pIHtcbiAgaWYgKCFwcmV2aW91cykge1xuICAgIHJldHVybiBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG4gIH1cbiAgaWYgKG1vZGUgPT09ICdtaWRkbGUnKSB7XG4gICAgY29uc3QgbWlkcG9pbnQgPSAocHJldmlvdXMueCArIHRhcmdldC54KSAvIDIuMDtcbiAgICBjdHgubGluZVRvKG1pZHBvaW50LCBwcmV2aW91cy55KTtcbiAgICBjdHgubGluZVRvKG1pZHBvaW50LCB0YXJnZXQueSk7XG4gIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2FmdGVyJyAhPT0gISFmbGlwKSB7XG4gICAgY3R4LmxpbmVUbyhwcmV2aW91cy54LCB0YXJnZXQueSk7XG4gIH0gZWxzZSB7XG4gICAgY3R4LmxpbmVUbyh0YXJnZXQueCwgcHJldmlvdXMueSk7XG4gIH1cbiAgY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYmV6aWVyQ3VydmVUbyhcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIHByZXZpb3VzOiBTcGxpbmVQb2ludCxcbiAgdGFyZ2V0OiBTcGxpbmVQb2ludCxcbiAgZmxpcD86IGJvb2xlYW5cbikge1xuICBpZiAoIXByZXZpb3VzKSB7XG4gICAgcmV0dXJuIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbiAgfVxuICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICBmbGlwID8gcHJldmlvdXMuY3AxeCA6IHByZXZpb3VzLmNwMngsXG4gICAgZmxpcCA/IHByZXZpb3VzLmNwMXkgOiBwcmV2aW91cy5jcDJ5LFxuICAgIGZsaXAgPyB0YXJnZXQuY3AyeCA6IHRhcmdldC5jcDF4LFxuICAgIGZsaXAgPyB0YXJnZXQuY3AyeSA6IHRhcmdldC5jcDF5LFxuICAgIHRhcmdldC54LFxuICAgIHRhcmdldC55KTtcbn1cblxuZnVuY3Rpb24gc2V0UmVuZGVyT3B0cyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgb3B0czogUmVuZGVyVGV4dE9wdHMpIHtcbiAgaWYgKG9wdHMudHJhbnNsYXRpb24pIHtcbiAgICBjdHgudHJhbnNsYXRlKG9wdHMudHJhbnNsYXRpb25bMF0sIG9wdHMudHJhbnNsYXRpb25bMV0pO1xuICB9XG5cbiAgaWYgKCFpc051bGxPclVuZGVmKG9wdHMucm90YXRpb24pKSB7XG4gICAgY3R4LnJvdGF0ZShvcHRzLnJvdGF0aW9uKTtcbiAgfVxuXG4gIGlmIChvcHRzLmNvbG9yKSB7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdHMuY29sb3I7XG4gIH1cblxuICBpZiAob3B0cy50ZXh0QWxpZ24pIHtcbiAgICBjdHgudGV4dEFsaWduID0gb3B0cy50ZXh0QWxpZ247XG4gIH1cblxuICBpZiAob3B0cy50ZXh0QmFzZWxpbmUpIHtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gb3B0cy50ZXh0QmFzZWxpbmU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVjb3JhdGVUZXh0KFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgeDogbnVtYmVyLFxuICB5OiBudW1iZXIsXG4gIGxpbmU6IHN0cmluZyxcbiAgb3B0czogUmVuZGVyVGV4dE9wdHNcbikge1xuICBpZiAob3B0cy5zdHJpa2V0aHJvdWdoIHx8IG9wdHMudW5kZXJsaW5lKSB7XG4gICAgLyoqXG4gICAgICogTm93IHRoYXQgSUUxMSBzdXBwb3J0IGhhcyBiZWVuIGRyb3BwZWQsIHdlIGNhbiB1c2UgbW9yZVxuICAgICAqIG9mIHRoZSBUZXh0TWV0cmljcyBvYmplY3QuIFRoZSBhY3R1YWwgYm91bmRpbmcgYm94ZXNcbiAgICAgKiBhcmUgdW5mbGFnZ2VkIGluIENocm9tZSwgRmlyZWZveCwgRWRnZSwgYW5kIFNhZmFyaSBzbyB0aGV5XG4gICAgICogY2FuIGJlIHNhZmVseSB1c2VkLlxuICAgICAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVGV4dE1ldHJpY3MjQnJvd3Nlcl9jb21wYXRpYmlsaXR5XG4gICAgICovXG4gICAgY29uc3QgbWV0cmljcyA9IGN0eC5tZWFzdXJlVGV4dChsaW5lKTtcbiAgICBjb25zdCBsZWZ0ID0geCAtIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hMZWZ0O1xuICAgIGNvbnN0IHJpZ2h0ID0geCArIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hSaWdodDtcbiAgICBjb25zdCB0b3AgPSB5IC0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudDtcbiAgICBjb25zdCBib3R0b20gPSB5ICsgbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQ7XG4gICAgY29uc3QgeURlY29yYXRpb24gPSBvcHRzLnN0cmlrZXRocm91Z2ggPyAodG9wICsgYm90dG9tKSAvIDIgOiBib3R0b207XG5cbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubGluZVdpZHRoID0gb3B0cy5kZWNvcmF0aW9uV2lkdGggfHwgMjtcbiAgICBjdHgubW92ZVRvKGxlZnQsIHlEZWNvcmF0aW9uKTtcbiAgICBjdHgubGluZVRvKHJpZ2h0LCB5RGVjb3JhdGlvbik7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdCYWNrZHJvcChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgb3B0czogQmFja2Ryb3BPcHRpb25zKSB7XG4gIGNvbnN0IG9sZENvbG9yID0gY3R4LmZpbGxTdHlsZTtcblxuICBjdHguZmlsbFN0eWxlID0gb3B0cy5jb2xvciBhcyBzdHJpbmc7XG4gIGN0eC5maWxsUmVjdChvcHRzLmxlZnQsIG9wdHMudG9wLCBvcHRzLndpZHRoLCBvcHRzLmhlaWdodCk7XG4gIGN0eC5maWxsU3R5bGUgPSBvbGRDb2xvcjtcbn1cblxuLyoqXG4gKiBSZW5kZXIgdGV4dCBvbnRvIHRoZSBjYW52YXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlclRleHQoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICB0ZXh0OiBzdHJpbmcgfCBzdHJpbmdbXSxcbiAgeDogbnVtYmVyLFxuICB5OiBudW1iZXIsXG4gIGZvbnQ6IENhbnZhc0ZvbnRTcGVjLFxuICBvcHRzOiBSZW5kZXJUZXh0T3B0cyA9IHt9XG4pIHtcbiAgY29uc3QgbGluZXMgPSBpc0FycmF5KHRleHQpID8gdGV4dCA6IFt0ZXh0XTtcbiAgY29uc3Qgc3Ryb2tlID0gb3B0cy5zdHJva2VXaWR0aCA+IDAgJiYgb3B0cy5zdHJva2VDb2xvciAhPT0gJyc7XG4gIGxldCBpOiBudW1iZXIsIGxpbmU6IHN0cmluZztcblxuICBjdHguc2F2ZSgpO1xuICBjdHguZm9udCA9IGZvbnQuc3RyaW5nO1xuICBzZXRSZW5kZXJPcHRzKGN0eCwgb3B0cyk7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgbGluZSA9IGxpbmVzW2ldO1xuXG4gICAgaWYgKG9wdHMuYmFja2Ryb3ApIHtcbiAgICAgIGRyYXdCYWNrZHJvcChjdHgsIG9wdHMuYmFja2Ryb3ApO1xuICAgIH1cblxuICAgIGlmIChzdHJva2UpIHtcbiAgICAgIGlmIChvcHRzLnN0cm9rZUNvbG9yKSB7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdHMuc3Ryb2tlQ29sb3I7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZihvcHRzLnN0cm9rZVdpZHRoKSkge1xuICAgICAgICBjdHgubGluZVdpZHRoID0gb3B0cy5zdHJva2VXaWR0aDtcbiAgICAgIH1cblxuICAgICAgY3R4LnN0cm9rZVRleHQobGluZSwgeCwgeSwgb3B0cy5tYXhXaWR0aCk7XG4gICAgfVxuXG4gICAgY3R4LmZpbGxUZXh0KGxpbmUsIHgsIHksIG9wdHMubWF4V2lkdGgpO1xuICAgIGRlY29yYXRlVGV4dChjdHgsIHgsIHksIGxpbmUsIG9wdHMpO1xuXG4gICAgeSArPSBOdW1iZXIoZm9udC5saW5lSGVpZ2h0KTtcbiAgfVxuXG4gIGN0eC5yZXN0b3JlKCk7XG59XG5cbi8qKlxuICogQWRkIGEgcGF0aCBvZiBhIHJlY3RhbmdsZSB3aXRoIHJvdW5kZWQgY29ybmVycyB0byB0aGUgY3VycmVudCBzdWItcGF0aFxuICogQHBhcmFtIGN0eCAtIENvbnRleHRcbiAqIEBwYXJhbSByZWN0IC0gQm91bmRpbmcgcmVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkUm91bmRlZFJlY3RQYXRoKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgcmVjdDogUm91bmRlZFJlY3QgJiB7IHJhZGl1czogVFJCTENvcm5lcnMgfVxuKSB7XG4gIGNvbnN0IHt4LCB5LCB3LCBoLCByYWRpdXN9ID0gcmVjdDtcblxuICAvLyB0b3AgbGVmdCBhcmNcbiAgY3R4LmFyYyh4ICsgcmFkaXVzLnRvcExlZnQsIHkgKyByYWRpdXMudG9wTGVmdCwgcmFkaXVzLnRvcExlZnQsIDEuNSAqIFBJLCBQSSwgdHJ1ZSk7XG5cbiAgLy8gbGluZSBmcm9tIHRvcCBsZWZ0IHRvIGJvdHRvbSBsZWZ0XG4gIGN0eC5saW5lVG8oeCwgeSArIGggLSByYWRpdXMuYm90dG9tTGVmdCk7XG5cbiAgLy8gYm90dG9tIGxlZnQgYXJjXG4gIGN0eC5hcmMoeCArIHJhZGl1cy5ib3R0b21MZWZ0LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21MZWZ0LCByYWRpdXMuYm90dG9tTGVmdCwgUEksIEhBTEZfUEksIHRydWUpO1xuXG4gIC8vIGxpbmUgZnJvbSBib3R0b20gbGVmdCB0byBib3R0b20gcmlnaHRcbiAgY3R4LmxpbmVUbyh4ICsgdyAtIHJhZGl1cy5ib3R0b21SaWdodCwgeSArIGgpO1xuXG4gIC8vIGJvdHRvbSByaWdodCBhcmNcbiAgY3R4LmFyYyh4ICsgdyAtIHJhZGl1cy5ib3R0b21SaWdodCwgeSArIGggLSByYWRpdXMuYm90dG9tUmlnaHQsIHJhZGl1cy5ib3R0b21SaWdodCwgSEFMRl9QSSwgMCwgdHJ1ZSk7XG5cbiAgLy8gbGluZSBmcm9tIGJvdHRvbSByaWdodCB0byB0b3AgcmlnaHRcbiAgY3R4LmxpbmVUbyh4ICsgdywgeSArIHJhZGl1cy50b3BSaWdodCk7XG5cbiAgLy8gdG9wIHJpZ2h0IGFyY1xuICBjdHguYXJjKHggKyB3IC0gcmFkaXVzLnRvcFJpZ2h0LCB5ICsgcmFkaXVzLnRvcFJpZ2h0LCByYWRpdXMudG9wUmlnaHQsIDAsIC1IQUxGX1BJLCB0cnVlKTtcblxuICAvLyBsaW5lIGZyb20gdG9wIHJpZ2h0IHRvIHRvcCBsZWZ0XG4gIGN0eC5saW5lVG8oeCArIHJhZGl1cy50b3BMZWZ0LCB5KTtcbn1cbiIsICJpbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vY29yZS9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCB7aXNBcnJheSwgaXNPYmplY3QsIHRvRGltZW5zaW9uLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b0ZvbnRTdHJpbmd9IGZyb20gJy4vaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHR5cGUge0NoYXJ0QXJlYSwgRm9udFNwZWMsIFBvaW50fSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSB7VFJCTCwgVFJCTENvcm5lcnN9IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5cbmNvbnN0IExJTkVfSEVJR0hUID0gL14obm9ybWFsfChcXGQrKD86XFwuXFxkKyk/KShweHxlbXwlKT8pJC87XG5jb25zdCBGT05UX1NUWUxFID0gL14obm9ybWFsfGl0YWxpY3xpbml0aWFsfGluaGVyaXR8dW5zZXR8KG9ibGlxdWUoIC0/WzAtOV0/WzAtOV1kZWcpPykpJC87XG5cbi8qKlxuICogQGFsaWFzIENoYXJ0LmhlbHBlcnMub3B0aW9uc1xuICogQG5hbWVzcGFjZVxuICovXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBsaW5lIGhlaWdodCBgdmFsdWVgIGluIHBpeGVscyBmb3IgYSBzcGVjaWZpYyBmb250IGBzaXplYC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBsaW5lSGVpZ2h0IHRvIHBhcnNlIChlZy4gMS42LCAnMTRweCcsICc3NSUnLCAnMS42ZW0nKS5cbiAqIEBwYXJhbSBzaXplIC0gVGhlIGZvbnQgc2l6ZSAoaW4gcGl4ZWxzKSB1c2VkIHRvIHJlc29sdmUgcmVsYXRpdmUgYHZhbHVlYC5cbiAqIEByZXR1cm5zIFRoZSBlZmZlY3RpdmUgbGluZSBoZWlnaHQgaW4gcGl4ZWxzIChzaXplICogMS4yIGlmIHZhbHVlIGlzIGludmFsaWQpLlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvbGluZS1oZWlnaHRcbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9MaW5lSGVpZ2h0KHZhbHVlOiBudW1iZXIgfCBzdHJpbmcsIHNpemU6IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IG1hdGNoZXMgPSAoJycgKyB2YWx1ZSkubWF0Y2goTElORV9IRUlHSFQpO1xuICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlc1sxXSA9PT0gJ25vcm1hbCcpIHtcbiAgICByZXR1cm4gc2l6ZSAqIDEuMjtcbiAgfVxuXG4gIHZhbHVlID0gK21hdGNoZXNbMl07XG5cbiAgc3dpdGNoIChtYXRjaGVzWzNdKSB7XG4gICAgY2FzZSAncHgnOlxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNhc2UgJyUnOlxuICAgICAgdmFsdWUgLz0gMTAwO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHNpemUgKiB2YWx1ZTtcbn1cblxuY29uc3QgbnVtYmVyT3JaZXJvID0gKHY6IHVua25vd24pID0+ICt2IHx8IDA7XG5cbi8qKlxuICogQHBhcmFtIHZhbHVlXG4gKiBAcGFyYW0gcHJvcHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9yZWFkVmFsdWVUb1Byb3BzPEsgZXh0ZW5kcyBzdHJpbmc+KHZhbHVlOiBudW1iZXIgfCBSZWNvcmQ8SywgbnVtYmVyPiwgcHJvcHM6IEtbXSk6IFJlY29yZDxLLCBudW1iZXI+O1xuZXhwb3J0IGZ1bmN0aW9uIF9yZWFkVmFsdWVUb1Byb3BzPEsgZXh0ZW5kcyBzdHJpbmcsIFQgZXh0ZW5kcyBzdHJpbmc+KHZhbHVlOiBudW1iZXIgfCBSZWNvcmQ8SyAmIFQsIG51bWJlcj4sIHByb3BzOiBSZWNvcmQ8VCwgSz4pOiBSZWNvcmQ8VCwgbnVtYmVyPjtcbmV4cG9ydCBmdW5jdGlvbiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZTogbnVtYmVyIHwgUmVjb3JkPHN0cmluZywgbnVtYmVyPiwgcHJvcHM6IHN0cmluZ1tdIHwgUmVjb3JkPHN0cmluZywgc3RyaW5nPikge1xuICBjb25zdCByZXQgPSB7fTtcbiAgY29uc3Qgb2JqUHJvcHMgPSBpc09iamVjdChwcm9wcyk7XG4gIGNvbnN0IGtleXMgPSBvYmpQcm9wcyA/IE9iamVjdC5rZXlzKHByb3BzKSA6IHByb3BzO1xuICBjb25zdCByZWFkID0gaXNPYmplY3QodmFsdWUpXG4gICAgPyBvYmpQcm9wc1xuICAgICAgPyBwcm9wID0+IHZhbHVlT3JEZWZhdWx0KHZhbHVlW3Byb3BdLCB2YWx1ZVtwcm9wc1twcm9wXV0pXG4gICAgICA6IHByb3AgPT4gdmFsdWVbcHJvcF1cbiAgICA6ICgpID0+IHZhbHVlO1xuXG4gIGZvciAoY29uc3QgcHJvcCBvZiBrZXlzKSB7XG4gICAgcmV0W3Byb3BdID0gbnVtYmVyT3JaZXJvKHJlYWQocHJvcCkpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYSBUUkJMIG9iamVjdC5cbiAqIEBwYXJhbSB2YWx1ZSAtIElmIGEgbnVtYmVyLCBzZXQgdGhlIHZhbHVlIHRvIGFsbCBUUkJMIGNvbXBvbmVudCxcbiAqICBlbHNlLCBpZiBhbiBvYmplY3QsIHVzZSBkZWZpbmVkIHByb3BlcnRpZXMgYW5kIHNldHMgdW5kZWZpbmVkIG9uZXMgdG8gMC5cbiAqICB4IC8geSBhcmUgc2hvcnRoYW5kcyBmb3Igc2FtZSB2YWx1ZSBmb3IgbGVmdC9yaWdodCBhbmQgdG9wL2JvdHRvbS5cbiAqIEByZXR1cm5zIFRoZSBwYWRkaW5nIHZhbHVlcyAodG9wLCByaWdodCwgYm90dG9tLCBsZWZ0KVxuICogQHNpbmNlIDMuMC4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1RSQkwodmFsdWU6IG51bWJlciB8IFRSQkwgfCBQb2ludCkge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIHt0b3A6ICd5JywgcmlnaHQ6ICd4JywgYm90dG9tOiAneScsIGxlZnQ6ICd4J30pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiB2YWx1ZSBpbnRvIGEgVFJCTCBjb3JuZXJzIG9iamVjdCAoc2ltaWxhciB3aXRoIGNzcyBib3JkZXItcmFkaXVzKS5cbiAqIEBwYXJhbSB2YWx1ZSAtIElmIGEgbnVtYmVyLCBzZXQgdGhlIHZhbHVlIHRvIGFsbCBUUkJMIGNvcm5lciBjb21wb25lbnRzLFxuICogIGVsc2UsIGlmIGFuIG9iamVjdCwgdXNlIGRlZmluZWQgcHJvcGVydGllcyBhbmQgc2V0cyB1bmRlZmluZWQgb25lcyB0byAwLlxuICogQHJldHVybnMgVGhlIFRSQkwgY29ybmVyIHZhbHVlcyAodG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0KVxuICogQHNpbmNlIDMuMC4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1RSQkxDb3JuZXJzKHZhbHVlOiBudW1iZXIgfCBUUkJMQ29ybmVycykge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIFsndG9wTGVmdCcsICd0b3BSaWdodCcsICdib3R0b21MZWZ0JywgJ2JvdHRvbVJpZ2h0J10pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiB2YWx1ZSBpbnRvIGEgcGFkZGluZyBvYmplY3Qgd2l0aCBwcmUtY29tcHV0ZWQgd2lkdGgvaGVpZ2h0LlxuICogQHBhcmFtIHZhbHVlIC0gSWYgYSBudW1iZXIsIHNldCB0aGUgdmFsdWUgdG8gYWxsIFRSQkwgY29tcG9uZW50LFxuICogIGVsc2UsIGlmIGFuIG9iamVjdCwgdXNlIGRlZmluZWQgcHJvcGVydGllcyBhbmQgc2V0cyB1bmRlZmluZWQgb25lcyB0byAwLlxuICogIHggLyB5IGFyZSBzaG9ydGhhbmRzIGZvciBzYW1lIHZhbHVlIGZvciBsZWZ0L3JpZ2h0IGFuZCB0b3AvYm90dG9tLlxuICogQHJldHVybnMgVGhlIHBhZGRpbmcgdmFsdWVzICh0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHdpZHRoLCBoZWlnaHQpXG4gKiBAc2luY2UgMi43LjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUGFkZGluZyh2YWx1ZT86IG51bWJlciB8IFRSQkwpOiBDaGFydEFyZWEge1xuICBjb25zdCBvYmogPSB0b1RSQkwodmFsdWUpIGFzIENoYXJ0QXJlYTtcblxuICBvYmoud2lkdGggPSBvYmoubGVmdCArIG9iai5yaWdodDtcbiAgb2JqLmhlaWdodCA9IG9iai50b3AgKyBvYmouYm90dG9tO1xuXG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogUGFyc2VzIGZvbnQgb3B0aW9ucyBhbmQgcmV0dXJucyB0aGUgZm9udCBvYmplY3QuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEEgb2JqZWN0IHRoYXQgY29udGFpbnMgZm9udCBvcHRpb25zIHRvIGJlIHBhcnNlZC5cbiAqIEBwYXJhbSBmYWxsYmFjayAtIEEgb2JqZWN0IHRoYXQgY29udGFpbnMgZmFsbGJhY2sgZm9udCBvcHRpb25zLlxuICogQHJldHVybiBUaGUgZm9udCBvYmplY3QuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0b0ZvbnQob3B0aW9uczogUGFydGlhbDxGb250U3BlYz4sIGZhbGxiYWNrPzogUGFydGlhbDxGb250U3BlYz4pIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGZhbGxiYWNrID0gZmFsbGJhY2sgfHwgZGVmYXVsdHMuZm9udCBhcyBGb250U3BlYztcblxuICBsZXQgc2l6ZSA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuc2l6ZSwgZmFsbGJhY2suc2l6ZSk7XG5cbiAgaWYgKHR5cGVvZiBzaXplID09PSAnc3RyaW5nJykge1xuICAgIHNpemUgPSBwYXJzZUludChzaXplLCAxMCk7XG4gIH1cbiAgbGV0IHN0eWxlID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5zdHlsZSwgZmFsbGJhY2suc3R5bGUpO1xuICBpZiAoc3R5bGUgJiYgISgnJyArIHN0eWxlKS5tYXRjaChGT05UX1NUWUxFKSkge1xuICAgIGNvbnNvbGUud2FybignSW52YWxpZCBmb250IHN0eWxlIHNwZWNpZmllZDogXCInICsgc3R5bGUgKyAnXCInKTtcbiAgICBzdHlsZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IGZvbnQgPSB7XG4gICAgZmFtaWx5OiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmZhbWlseSwgZmFsbGJhY2suZmFtaWx5KSxcbiAgICBsaW5lSGVpZ2h0OiB0b0xpbmVIZWlnaHQodmFsdWVPckRlZmF1bHQob3B0aW9ucy5saW5lSGVpZ2h0LCBmYWxsYmFjay5saW5lSGVpZ2h0KSwgc2l6ZSksXG4gICAgc2l6ZSxcbiAgICBzdHlsZSxcbiAgICB3ZWlnaHQ6IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMud2VpZ2h0LCBmYWxsYmFjay53ZWlnaHQpLFxuICAgIHN0cmluZzogJydcbiAgfTtcblxuICBmb250LnN0cmluZyA9IHRvRm9udFN0cmluZyhmb250KTtcbiAgcmV0dXJuIGZvbnQ7XG59XG5cbi8qKlxuICogRXZhbHVhdGVzIHRoZSBnaXZlbiBgaW5wdXRzYCBzZXF1ZW50aWFsbHkgYW5kIHJldHVybnMgdGhlIGZpcnN0IGRlZmluZWQgdmFsdWUuXG4gKiBAcGFyYW0gaW5wdXRzIC0gQW4gYXJyYXkgb2YgdmFsdWVzLCBmYWxsaW5nIGJhY2sgdG8gdGhlIGxhc3QgdmFsdWUuXG4gKiBAcGFyYW0gY29udGV4dCAtIElmIGRlZmluZWQgYW5kIHRoZSBjdXJyZW50IHZhbHVlIGlzIGEgZnVuY3Rpb24sIHRoZSB2YWx1ZVxuICogaXMgY2FsbGVkIHdpdGggYGNvbnRleHRgIGFzIGZpcnN0IGFyZ3VtZW50IGFuZCB0aGUgcmVzdWx0IGJlY29tZXMgdGhlIG5ldyBpbnB1dC5cbiAqIEBwYXJhbSBpbmRleCAtIElmIGRlZmluZWQgYW5kIHRoZSBjdXJyZW50IHZhbHVlIGlzIGFuIGFycmF5LCB0aGUgdmFsdWVcbiAqIGF0IGBpbmRleGAgYmVjb21lIHRoZSBuZXcgaW5wdXQuXG4gKiBAcGFyYW0gaW5mbyAtIG9iamVjdCB0byByZXR1cm4gaW5mb3JtYXRpb24gYWJvdXQgcmVzb2x1dGlvbiBpblxuICogQHBhcmFtIGluZm8uY2FjaGVhYmxlIC0gV2lsbCBiZSBzZXQgdG8gYGZhbHNlYCBpZiBvcHRpb24gaXMgbm90IGNhY2hlYWJsZS5cbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZShpbnB1dHM6IEFycmF5PHVua25vd24+LCBjb250ZXh0Pzogb2JqZWN0LCBpbmRleD86IG51bWJlciwgaW5mbz86IHsgY2FjaGVhYmxlOiBib29sZWFuIH0pIHtcbiAgbGV0IGNhY2hlYWJsZSA9IHRydWU7XG4gIGxldCBpOiBudW1iZXIsIGlsZW46IG51bWJlciwgdmFsdWU6IHVua25vd247XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGlucHV0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICB2YWx1ZSA9IGlucHV0c1tpXTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlKGNvbnRleHQpO1xuICAgICAgY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlW2luZGV4ICUgdmFsdWUubGVuZ3RoXTtcbiAgICAgIGNhY2hlYWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGluZm8gJiYgIWNhY2hlYWJsZSkge1xuICAgICAgICBpbmZvLmNhY2hlYWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSBtaW5tYXhcbiAqIEBwYXJhbSBncmFjZVxuICogQHBhcmFtIGJlZ2luQXRaZXJvXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2FkZEdyYWNlKG1pbm1heDogeyBtaW46IG51bWJlcjsgbWF4OiBudW1iZXI7IH0sIGdyYWNlOiBudW1iZXIgfCBzdHJpbmcsIGJlZ2luQXRaZXJvOiBib29sZWFuKSB7XG4gIGNvbnN0IHttaW4sIG1heH0gPSBtaW5tYXg7XG4gIGNvbnN0IGNoYW5nZSA9IHRvRGltZW5zaW9uKGdyYWNlLCAobWF4IC0gbWluKSAvIDIpO1xuICBjb25zdCBrZWVwWmVybyA9ICh2YWx1ZTogbnVtYmVyLCBhZGQ6IG51bWJlcikgPT4gYmVnaW5BdFplcm8gJiYgdmFsdWUgPT09IDAgPyAwIDogdmFsdWUgKyBhZGQ7XG4gIHJldHVybiB7XG4gICAgbWluOiBrZWVwWmVybyhtaW4sIC1NYXRoLmFicyhjaGFuZ2UpKSxcbiAgICBtYXg6IGtlZXBaZXJvKG1heCwgY2hhbmdlKVxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNvbnRleHQgaW5oZXJpdGluZyBwYXJlbnRDb250ZXh0XG4gKiBAcGFyYW0gcGFyZW50Q29udGV4dFxuICogQHBhcmFtIGNvbnRleHRcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0PFQgZXh0ZW5kcyBvYmplY3Q+KHBhcmVudENvbnRleHQ6IG51bGwsIGNvbnRleHQ6IFQpOiBUO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQ8VCBleHRlbmRzIG9iamVjdCwgUCBleHRlbmRzIFQ+KHBhcmVudENvbnRleHQ6IFAsIGNvbnRleHQ6IFQpOiBQICYgVDtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0KHBhcmVudENvbnRleHQ6IG9iamVjdCwgY29udGV4dDogb2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUocGFyZW50Q29udGV4dCksIGNvbnRleHQpO1xufVxuIiwgIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZSAqL1xuaW1wb3J0IHR5cGUge0FueU9iamVjdH0gZnJvbSAnLi4vdHlwZXMvYmFzaWMuanMnO1xuaW1wb3J0IHR5cGUge0NoYXJ0TWV0YX0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuaW1wb3J0IHR5cGUge1xuICBSZXNvbHZlck9iamVjdEtleSxcbiAgUmVzb2x2ZXJDYWNoZSxcbiAgUmVzb2x2ZXJQcm94eSxcbiAgRGVzY3JpcHRvckRlZmF1bHRzLFxuICBEZXNjcmlwdG9yLFxuICBDb250ZXh0Q2FjaGUsXG4gIENvbnRleHRQcm94eVxufSBmcm9tICcuL2hlbHBlcnMuY29uZmlnLnR5cGVzLmpzJztcbmltcG9ydCB7aXNBcnJheSwgaXNGdW5jdGlvbiwgaXNPYmplY3QsIHJlc29sdmVPYmplY3RLZXksIF9jYXBpdGFsaXplfSBmcm9tICcuL2hlbHBlcnMuY29yZS5qcyc7XG5cbmV4cG9ydCAqIGZyb20gJy4vaGVscGVycy5jb25maWcudHlwZXMuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBQcm94eSBmb3IgcmVzb2x2aW5nIHJhdyB2YWx1ZXMgZm9yIG9wdGlvbnMuXG4gKiBAcGFyYW0gc2NvcGVzIC0gVGhlIG9wdGlvbiBzY29wZXMgdG8gbG9vayBmb3IgdmFsdWVzLCBpbiByZXNvbHV0aW9uIG9yZGVyXG4gKiBAcGFyYW0gcHJlZml4ZXMgLSBUaGUgcHJlZml4ZXMgZm9yIHZhbHVlcywgaW4gcmVzb2x1dGlvbiBvcmRlci5cbiAqIEBwYXJhbSByb290U2NvcGVzIC0gVGhlIHJvb3Qgb3B0aW9uIHNjb3Blc1xuICogQHBhcmFtIGZhbGxiYWNrIC0gUGFyZW50IHNjb3BlcyBmYWxsYmFja1xuICogQHBhcmFtIGdldFRhcmdldCAtIGNhbGxiYWNrIGZvciBnZXR0aW5nIHRoZSB0YXJnZXQgZm9yIGNoYW5nZWQgdmFsdWVzXG4gKiBAcmV0dXJucyBQcm94eVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jcmVhdGVSZXNvbHZlcjxcbiAgVCBleHRlbmRzIEFueU9iamVjdFtdID0gQW55T2JqZWN0W10sXG4gIFIgZXh0ZW5kcyBBbnlPYmplY3RbXSA9IFRcbj4oXG4gIHNjb3BlczogVCxcbiAgcHJlZml4ZXMgPSBbJyddLFxuICByb290U2NvcGVzPzogUixcbiAgZmFsbGJhY2s/OiBSZXNvbHZlck9iamVjdEtleSxcbiAgZ2V0VGFyZ2V0ID0gKCkgPT4gc2NvcGVzWzBdXG4pIHtcbiAgY29uc3QgZmluYWxSb290U2NvcGVzID0gcm9vdFNjb3BlcyB8fCBzY29wZXM7XG4gIGlmICh0eXBlb2YgZmFsbGJhY2sgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZmFsbGJhY2sgPSBfcmVzb2x2ZSgnX2ZhbGxiYWNrJywgc2NvcGVzKTtcbiAgfVxuICBjb25zdCBjYWNoZTogUmVzb2x2ZXJDYWNoZTxULCBSPiA9IHtcbiAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ09iamVjdCcsXG4gICAgX2NhY2hlYWJsZTogdHJ1ZSxcbiAgICBfc2NvcGVzOiBzY29wZXMsXG4gICAgX3Jvb3RTY29wZXM6IGZpbmFsUm9vdFNjb3BlcyxcbiAgICBfZmFsbGJhY2s6IGZhbGxiYWNrLFxuICAgIF9nZXRUYXJnZXQ6IGdldFRhcmdldCxcbiAgICBvdmVycmlkZTogKHNjb3BlOiBBbnlPYmplY3QpID0+IF9jcmVhdGVSZXNvbHZlcihbc2NvcGUsIC4uLnNjb3Blc10sIHByZWZpeGVzLCBmaW5hbFJvb3RTY29wZXMsIGZhbGxiYWNrKSxcbiAgfTtcbiAgcmV0dXJuIG5ldyBQcm94eShjYWNoZSwge1xuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgdGhlIGRlbGV0ZSBvcGVyYXRvci5cbiAgICAgKi9cbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3A6IHN0cmluZykge1xuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTsgLy8gcmVtb3ZlIGZyb20gY2FjaGVcbiAgICAgIGRlbGV0ZSB0YXJnZXQuX2tleXM7IC8vIHJlbW92ZSBjYWNoZWQga2V5c1xuICAgICAgZGVsZXRlIHNjb3Blc1swXVtwcm9wXTsgLy8gcmVtb3ZlIGZyb20gdG9wIGxldmVsIHNjb3BlXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBnZXR0aW5nIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBnZXQodGFyZ2V0LCBwcm9wOiBzdHJpbmcpIHtcbiAgICAgIHJldHVybiBfY2FjaGVkKHRhcmdldCwgcHJvcCxcbiAgICAgICAgKCkgPT4gX3Jlc29sdmVXaXRoUHJlZml4ZXMocHJvcCwgcHJlZml4ZXMsIHNjb3BlcywgdGFyZ2V0KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvci5cbiAgICAgKiBBbHNvIHVzZWQgYnkgT2JqZWN0Lmhhc093blByb3BlcnR5LlxuICAgICAqL1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQuX3Njb3Blc1swXSwgcHJvcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mLlxuICAgICAqL1xuICAgIGdldFByb3RvdHlwZU9mKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yoc2NvcGVzWzBdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciB0aGUgaW4gb3BlcmF0b3IuXG4gICAgICovXG4gICAgaGFzKHRhcmdldCwgcHJvcDogc3RyaW5nKSB7XG4gICAgICByZXR1cm4gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0KS5pbmNsdWRlcyhwcm9wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyBhbmQgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scy5cbiAgICAgKi9cbiAgICBvd25LZXlzKHRhcmdldCkge1xuICAgICAgcmV0dXJuIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3Igc2V0dGluZyBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICovXG4gICAgc2V0KHRhcmdldCwgcHJvcDogc3RyaW5nLCB2YWx1ZSkge1xuICAgICAgY29uc3Qgc3RvcmFnZSA9IHRhcmdldC5fc3RvcmFnZSB8fCAodGFyZ2V0Ll9zdG9yYWdlID0gZ2V0VGFyZ2V0KCkpO1xuICAgICAgdGFyZ2V0W3Byb3BdID0gc3RvcmFnZVtwcm9wXSA9IHZhbHVlOyAvLyBzZXQgdG8gdG9wIGxldmVsIHNjb3BlICsgY2FjaGVcbiAgICAgIGRlbGV0ZSB0YXJnZXQuX2tleXM7IC8vIHJlbW92ZSBjYWNoZWQga2V5c1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KSBhcyBSZXNvbHZlclByb3h5PFQsIFI+O1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gUHJveHkgZm9yIHJlc29sdmluZyBvcHRpb24gdmFsdWVzIHdpdGggY29udGV4dC5cbiAqIEBwYXJhbSBwcm94eSAtIFRoZSBQcm94eSByZXR1cm5lZCBieSBgX2NyZWF0ZVJlc29sdmVyYFxuICogQHBhcmFtIGNvbnRleHQgLSBDb250ZXh0IG9iamVjdCBmb3Igc2NyaXB0YWJsZS9pbmRleGFibGUgb3B0aW9uc1xuICogQHBhcmFtIHN1YlByb3h5IC0gVGhlIHByb3h5IHByb3ZpZGVkIGZvciBzY3JpcHRhYmxlIG9wdGlvbnNcbiAqIEBwYXJhbSBkZXNjcmlwdG9yRGVmYXVsdHMgLSBEZWZhdWx0cyBmb3IgZGVzY3JpcHRvcnNcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYXR0YWNoQ29udGV4dDxcbiAgVCBleHRlbmRzIEFueU9iamVjdFtdID0gQW55T2JqZWN0W10sXG4gIFIgZXh0ZW5kcyBBbnlPYmplY3RbXSA9IFRcbj4oXG4gIHByb3h5OiBSZXNvbHZlclByb3h5PFQsIFI+LFxuICBjb250ZXh0OiBBbnlPYmplY3QsXG4gIHN1YlByb3h5PzogUmVzb2x2ZXJQcm94eTxULCBSPixcbiAgZGVzY3JpcHRvckRlZmF1bHRzPzogRGVzY3JpcHRvckRlZmF1bHRzXG4pIHtcbiAgY29uc3QgY2FjaGU6IENvbnRleHRDYWNoZTxULCBSPiA9IHtcbiAgICBfY2FjaGVhYmxlOiBmYWxzZSxcbiAgICBfcHJveHk6IHByb3h5LFxuICAgIF9jb250ZXh0OiBjb250ZXh0LFxuICAgIF9zdWJQcm94eTogc3ViUHJveHksXG4gICAgX3N0YWNrOiBuZXcgU2V0KCksXG4gICAgX2Rlc2NyaXB0b3JzOiBfZGVzY3JpcHRvcnMocHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cyksXG4gICAgc2V0Q29udGV4dDogKGN0eDogQW55T2JqZWN0KSA9PiBfYXR0YWNoQ29udGV4dChwcm94eSwgY3R4LCBzdWJQcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKSxcbiAgICBvdmVycmlkZTogKHNjb3BlOiBBbnlPYmplY3QpID0+IF9hdHRhY2hDb250ZXh0KHByb3h5Lm92ZXJyaWRlKHNjb3BlKSwgY29udGV4dCwgc3ViUHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cylcbiAgfTtcbiAgcmV0dXJuIG5ldyBQcm94eShjYWNoZSwge1xuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgdGhlIGRlbGV0ZSBvcGVyYXRvci5cbiAgICAgKi9cbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07IC8vIHJlbW92ZSBmcm9tIGNhY2hlXG4gICAgICBkZWxldGUgcHJveHlbcHJvcF07IC8vIHJlbW92ZSBmcm9tIHByb3h5XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBnZXR0aW5nIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBnZXQodGFyZ2V0LCBwcm9wOiBzdHJpbmcsIHJlY2VpdmVyKSB7XG4gICAgICByZXR1cm4gX2NhY2hlZCh0YXJnZXQsIHByb3AsXG4gICAgICAgICgpID0+IF9yZXNvbHZlV2l0aENvbnRleHQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuXG4gICAgICogQWxzbyB1c2VkIGJ5IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0Ll9kZXNjcmlwdG9ycy5hbGxLZXlzXG4gICAgICAgID8gUmVmbGVjdC5oYXMocHJveHksIHByb3ApID8ge2VudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0gOiB1bmRlZmluZWRcbiAgICAgICAgOiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm94eSwgcHJvcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mLlxuICAgICAqL1xuICAgIGdldFByb3RvdHlwZU9mKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YocHJveHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHRoZSBpbiBvcGVyYXRvci5cbiAgICAgKi9cbiAgICBoYXModGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5oYXMocHJveHksIHByb3ApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIGFuZCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLlxuICAgICAqL1xuICAgIG93bktleXMoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHByb3h5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBzZXR0aW5nIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgcHJveHlbcHJvcF0gPSB2YWx1ZTsgLy8gc2V0IHRvIHByb3h5XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdOyAvLyByZW1vdmUgZnJvbSBjYWNoZVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KSBhcyBDb250ZXh0UHJveHk8VCwgUj47XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9kZXNjcmlwdG9ycyhcbiAgcHJveHk6IFJlc29sdmVyQ2FjaGUsXG4gIGRlZmF1bHRzOiBEZXNjcmlwdG9yRGVmYXVsdHMgPSB7c2NyaXB0YWJsZTogdHJ1ZSwgaW5kZXhhYmxlOiB0cnVlfVxuKTogRGVzY3JpcHRvciB7XG4gIGNvbnN0IHtfc2NyaXB0YWJsZSA9IGRlZmF1bHRzLnNjcmlwdGFibGUsIF9pbmRleGFibGUgPSBkZWZhdWx0cy5pbmRleGFibGUsIF9hbGxLZXlzID0gZGVmYXVsdHMuYWxsS2V5c30gPSBwcm94eTtcbiAgcmV0dXJuIHtcbiAgICBhbGxLZXlzOiBfYWxsS2V5cyxcbiAgICBzY3JpcHRhYmxlOiBfc2NyaXB0YWJsZSxcbiAgICBpbmRleGFibGU6IF9pbmRleGFibGUsXG4gICAgaXNTY3JpcHRhYmxlOiBpc0Z1bmN0aW9uKF9zY3JpcHRhYmxlKSA/IF9zY3JpcHRhYmxlIDogKCkgPT4gX3NjcmlwdGFibGUsXG4gICAgaXNJbmRleGFibGU6IGlzRnVuY3Rpb24oX2luZGV4YWJsZSkgPyBfaW5kZXhhYmxlIDogKCkgPT4gX2luZGV4YWJsZVxuICB9O1xufVxuXG5jb25zdCByZWFkS2V5ID0gKHByZWZpeDogc3RyaW5nLCBuYW1lOiBzdHJpbmcpID0+IHByZWZpeCA/IHByZWZpeCArIF9jYXBpdGFsaXplKG5hbWUpIDogbmFtZTtcbmNvbnN0IG5lZWRzU3ViUmVzb2x2ZXIgPSAocHJvcDogc3RyaW5nLCB2YWx1ZTogdW5rbm93bikgPT4gaXNPYmplY3QodmFsdWUpICYmIHByb3AgIT09ICdhZGFwdGVycycgJiZcbiAgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IG51bGwgfHwgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCk7XG5cbmZ1bmN0aW9uIF9jYWNoZWQoXG4gIHRhcmdldDogQW55T2JqZWN0LFxuICBwcm9wOiBzdHJpbmcsXG4gIHJlc29sdmU6ICgpID0+IHVua25vd25cbikge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwgcHJvcCkgfHwgcHJvcCA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gIH1cblxuICBjb25zdCB2YWx1ZSA9IHJlc29sdmUoKTtcbiAgLy8gY2FjaGUgdGhlIHJlc29sdmVkIHZhbHVlXG4gIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIF9yZXNvbHZlV2l0aENvbnRleHQoXG4gIHRhcmdldDogQ29udGV4dENhY2hlLFxuICBwcm9wOiBzdHJpbmcsXG4gIHJlY2VpdmVyOiBBbnlPYmplY3Rcbikge1xuICBjb25zdCB7X3Byb3h5LCBfY29udGV4dCwgX3N1YlByb3h5LCBfZGVzY3JpcHRvcnM6IGRlc2NyaXB0b3JzfSA9IHRhcmdldDtcbiAgbGV0IHZhbHVlID0gX3Byb3h5W3Byb3BdOyAvLyByZXNvbHZlIGZyb20gcHJveHlcblxuICAvLyByZXNvbHZlIHdpdGggY29udGV4dFxuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkgJiYgZGVzY3JpcHRvcnMuaXNTY3JpcHRhYmxlKHByb3ApKSB7XG4gICAgdmFsdWUgPSBfcmVzb2x2ZVNjcmlwdGFibGUocHJvcCwgdmFsdWUsIHRhcmdldCwgcmVjZWl2ZXIpO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICB2YWx1ZSA9IF9yZXNvbHZlQXJyYXkocHJvcCwgdmFsdWUsIHRhcmdldCwgZGVzY3JpcHRvcnMuaXNJbmRleGFibGUpO1xuICB9XG4gIGlmIChuZWVkc1N1YlJlc29sdmVyKHByb3AsIHZhbHVlKSkge1xuICAgIC8vIGlmIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBhbiBvYmplY3QsIGNyZWF0ZSBhIHN1YiByZXNvbHZlciBmb3IgaXRcbiAgICB2YWx1ZSA9IF9hdHRhY2hDb250ZXh0KHZhbHVlLCBfY29udGV4dCwgX3N1YlByb3h5ICYmIF9zdWJQcm94eVtwcm9wXSwgZGVzY3JpcHRvcnMpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVTY3JpcHRhYmxlKFxuICBwcm9wOiBzdHJpbmcsXG4gIGdldFZhbHVlOiAoY3R4OiBBbnlPYmplY3QsIHN1YjogQW55T2JqZWN0KSA9PiB1bmtub3duLFxuICB0YXJnZXQ6IENvbnRleHRDYWNoZSxcbiAgcmVjZWl2ZXI6IEFueU9iamVjdFxuKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9zdGFja30gPSB0YXJnZXQ7XG4gIGlmIChfc3RhY2suaGFzKHByb3ApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZWN1cnNpb24gZGV0ZWN0ZWQ6ICcgKyBBcnJheS5mcm9tKF9zdGFjaykuam9pbignLT4nKSArICctPicgKyBwcm9wKTtcbiAgfVxuICBfc3RhY2suYWRkKHByb3ApO1xuICBsZXQgdmFsdWUgPSBnZXRWYWx1ZShfY29udGV4dCwgX3N1YlByb3h5IHx8IHJlY2VpdmVyKTtcbiAgX3N0YWNrLmRlbGV0ZShwcm9wKTtcbiAgaWYgKG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpKSB7XG4gICAgLy8gV2hlbiBzY3JpcHRhYmxlIG9wdGlvbiByZXR1cm5zIGFuIG9iamVjdCwgY3JlYXRlIGEgcmVzb2x2ZXIgb24gdGhhdC5cbiAgICB2YWx1ZSA9IGNyZWF0ZVN1YlJlc29sdmVyKF9wcm94eS5fc2NvcGVzLCBfcHJveHksIHByb3AsIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIF9yZXNvbHZlQXJyYXkoXG4gIHByb3A6IHN0cmluZyxcbiAgdmFsdWU6IHVua25vd25bXSxcbiAgdGFyZ2V0OiBDb250ZXh0Q2FjaGUsXG4gIGlzSW5kZXhhYmxlOiAoa2V5OiBzdHJpbmcpID0+IGJvb2xlYW5cbikge1xuICBjb25zdCB7X3Byb3h5LCBfY29udGV4dCwgX3N1YlByb3h5LCBfZGVzY3JpcHRvcnM6IGRlc2NyaXB0b3JzfSA9IHRhcmdldDtcblxuICBpZiAodHlwZW9mIF9jb250ZXh0LmluZGV4ICE9PSAndW5kZWZpbmVkJyAmJiBpc0luZGV4YWJsZShwcm9wKSkge1xuICAgIHJldHVybiB2YWx1ZVtfY29udGV4dC5pbmRleCAlIHZhbHVlLmxlbmd0aF07XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWVbMF0pKSB7XG4gICAgLy8gQXJyYXkgb2Ygb2JqZWN0cywgcmV0dXJuIGFycmF5IG9yIHJlc29sdmVyc1xuICAgIGNvbnN0IGFyciA9IHZhbHVlO1xuICAgIGNvbnN0IHNjb3BlcyA9IF9wcm94eS5fc2NvcGVzLmZpbHRlcihzID0+IHMgIT09IGFycik7XG4gICAgdmFsdWUgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSB7XG4gICAgICBjb25zdCByZXNvbHZlciA9IGNyZWF0ZVN1YlJlc29sdmVyKHNjb3BlcywgX3Byb3h5LCBwcm9wLCBpdGVtKTtcbiAgICAgIHZhbHVlLnB1c2goX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIF9jb250ZXh0LCBfc3ViUHJveHkgJiYgX3N1YlByb3h5W3Byb3BdLCBkZXNjcmlwdG9ycykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVGYWxsYmFjayhcbiAgZmFsbGJhY2s6IFJlc29sdmVyT2JqZWN0S2V5IHwgKChwcm9wOiBSZXNvbHZlck9iamVjdEtleSwgdmFsdWU6IHVua25vd24pID0+IFJlc29sdmVyT2JqZWN0S2V5KSxcbiAgcHJvcDogUmVzb2x2ZXJPYmplY3RLZXksXG4gIHZhbHVlOiB1bmtub3duXG4pIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oZmFsbGJhY2spID8gZmFsbGJhY2socHJvcCwgdmFsdWUpIDogZmFsbGJhY2s7XG59XG5cbmNvbnN0IGdldFNjb3BlID0gKGtleTogUmVzb2x2ZXJPYmplY3RLZXksIHBhcmVudDogQW55T2JqZWN0KSA9PiBrZXkgPT09IHRydWUgPyBwYXJlbnRcbiAgOiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/IHJlc29sdmVPYmplY3RLZXkocGFyZW50LCBrZXkpIDogdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBhZGRTY29wZXMoXG4gIHNldDogU2V0PEFueU9iamVjdD4sXG4gIHBhcmVudFNjb3BlczogQW55T2JqZWN0W10sXG4gIGtleTogUmVzb2x2ZXJPYmplY3RLZXksXG4gIHBhcmVudEZhbGxiYWNrOiBSZXNvbHZlck9iamVjdEtleSxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICBmb3IgKGNvbnN0IHBhcmVudCBvZiBwYXJlbnRTY29wZXMpIHtcbiAgICBjb25zdCBzY29wZSA9IGdldFNjb3BlKGtleSwgcGFyZW50KTtcbiAgICBpZiAoc2NvcGUpIHtcbiAgICAgIHNldC5hZGQoc2NvcGUpO1xuICAgICAgY29uc3QgZmFsbGJhY2sgPSByZXNvbHZlRmFsbGJhY2soc2NvcGUuX2ZhbGxiYWNrLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICh0eXBlb2YgZmFsbGJhY2sgIT09ICd1bmRlZmluZWQnICYmIGZhbGxiYWNrICE9PSBrZXkgJiYgZmFsbGJhY2sgIT09IHBhcmVudEZhbGxiYWNrKSB7XG4gICAgICAgIC8vIFdoZW4gd2UgcmVhY2ggdGhlIGRlc2NyaXB0b3IgdGhhdCBkZWZpbmVzIGEgbmV3IF9mYWxsYmFjaywgcmV0dXJuIHRoYXQuXG4gICAgICAgIC8vIFRoZSBmYWxsYmFjayB3aWxsIHJlc3VtZSB0byB0aGF0IG5ldyBzY29wZS5cbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2NvcGUgPT09IGZhbHNlICYmIHR5cGVvZiBwYXJlbnRGYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcgJiYga2V5ICE9PSBwYXJlbnRGYWxsYmFjaykge1xuICAgICAgLy8gRmFsbGJhY2sgdG8gYGZhbHNlYCByZXN1bHRzIHRvIGBmYWxzZWAsIHdoZW4gZmFsbGluZyBiYWNrIHRvIGRpZmZlcmVudCBrZXkuXG4gICAgICAvLyBGb3IgZXhhbXBsZSBgaW50ZXJhY3Rpb25gIGZyb20gYGhvdmVyYCBvciBgcGx1Z2lucy50b29sdGlwYCBhbmQgYGFuaW1hdGlvbmAgZnJvbSBgYW5pbWF0aW9uc2BcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN1YlJlc29sdmVyKFxuICBwYXJlbnRTY29wZXM6IEFueU9iamVjdFtdLFxuICByZXNvbHZlcjogUmVzb2x2ZXJDYWNoZSxcbiAgcHJvcDogUmVzb2x2ZXJPYmplY3RLZXksXG4gIHZhbHVlOiB1bmtub3duXG4pIHtcbiAgY29uc3Qgcm9vdFNjb3BlcyA9IHJlc29sdmVyLl9yb290U2NvcGVzO1xuICBjb25zdCBmYWxsYmFjayA9IHJlc29sdmVGYWxsYmFjayhyZXNvbHZlci5fZmFsbGJhY2ssIHByb3AsIHZhbHVlKTtcbiAgY29uc3QgYWxsU2NvcGVzID0gWy4uLnBhcmVudFNjb3BlcywgLi4ucm9vdFNjb3Blc107XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQ8QW55T2JqZWN0PigpO1xuICBzZXQuYWRkKHZhbHVlKTtcbiAgbGV0IGtleSA9IGFkZFNjb3Blc0Zyb21LZXkoc2V0LCBhbGxTY29wZXMsIHByb3AsIGZhbGxiYWNrIHx8IHByb3AsIHZhbHVlKTtcbiAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIGZhbGxiYWNrICE9PSAndW5kZWZpbmVkJyAmJiBmYWxsYmFjayAhPT0gcHJvcCkge1xuICAgIGtleSA9IGFkZFNjb3Blc0Zyb21LZXkoc2V0LCBhbGxTY29wZXMsIGZhbGxiYWNrLCBrZXksIHZhbHVlKTtcbiAgICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfY3JlYXRlUmVzb2x2ZXIoQXJyYXkuZnJvbShzZXQpLCBbJyddLCByb290U2NvcGVzLCBmYWxsYmFjayxcbiAgICAoKSA9PiBzdWJHZXRUYXJnZXQocmVzb2x2ZXIsIHByb3AgYXMgc3RyaW5nLCB2YWx1ZSkpO1xufVxuXG5mdW5jdGlvbiBhZGRTY29wZXNGcm9tS2V5KFxuICBzZXQ6IFNldDxBbnlPYmplY3Q+LFxuICBhbGxTY29wZXM6IEFueU9iamVjdFtdLFxuICBrZXk6IFJlc29sdmVyT2JqZWN0S2V5LFxuICBmYWxsYmFjazogUmVzb2x2ZXJPYmplY3RLZXksXG4gIGl0ZW06IHVua25vd25cbikge1xuICB3aGlsZSAoa2V5KSB7XG4gICAga2V5ID0gYWRkU2NvcGVzKHNldCwgYWxsU2NvcGVzLCBrZXksIGZhbGxiYWNrLCBpdGVtKTtcbiAgfVxuICByZXR1cm4ga2V5O1xufVxuXG5mdW5jdGlvbiBzdWJHZXRUYXJnZXQoXG4gIHJlc29sdmVyOiBSZXNvbHZlckNhY2hlLFxuICBwcm9wOiBzdHJpbmcsXG4gIHZhbHVlOiB1bmtub3duXG4pIHtcbiAgY29uc3QgcGFyZW50ID0gcmVzb2x2ZXIuX2dldFRhcmdldCgpO1xuICBpZiAoIShwcm9wIGluIHBhcmVudCkpIHtcbiAgICBwYXJlbnRbcHJvcF0gPSB7fTtcbiAgfVxuICBjb25zdCB0YXJnZXQgPSBwYXJlbnRbcHJvcF07XG4gIGlmIChpc0FycmF5KHRhcmdldCkgJiYgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgLy8gRm9yIGFycmF5IG9mIG9iamVjdHMsIHRoZSBvYmplY3QgaXMgdXNlZCB0byBzdG9yZSB1cGRhdGVkIHZhbHVlc1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0IHx8IHt9O1xufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZVdpdGhQcmVmaXhlcyhcbiAgcHJvcDogc3RyaW5nLFxuICBwcmVmaXhlczogc3RyaW5nW10sXG4gIHNjb3BlczogQW55T2JqZWN0W10sXG4gIHByb3h5OiBSZXNvbHZlclByb3h5XG4pIHtcbiAgbGV0IHZhbHVlOiB1bmtub3duO1xuICBmb3IgKGNvbnN0IHByZWZpeCBvZiBwcmVmaXhlcykge1xuICAgIHZhbHVlID0gX3Jlc29sdmUocmVhZEtleShwcmVmaXgsIHByb3ApLCBzY29wZXMpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSlcbiAgICAgICAgPyBjcmVhdGVTdWJSZXNvbHZlcihzY29wZXMsIHByb3h5LCBwcm9wLCB2YWx1ZSlcbiAgICAgICAgOiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX3Jlc29sdmUoa2V5OiBzdHJpbmcsIHNjb3BlczogQW55T2JqZWN0W10pIHtcbiAgZm9yIChjb25zdCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICBpZiAoIXNjb3BlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBzY29wZVtrZXldO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldDogUmVzb2x2ZXJDYWNoZSkge1xuICBsZXQga2V5cyA9IHRhcmdldC5fa2V5cztcbiAgaWYgKCFrZXlzKSB7XG4gICAga2V5cyA9IHRhcmdldC5fa2V5cyA9IHJlc29sdmVLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQuX3Njb3Blcyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVLZXlzRnJvbUFsbFNjb3BlcyhzY29wZXM6IEFueU9iamVjdFtdKSB7XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBmb3IgKGNvbnN0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjb3BlKS5maWx0ZXIoayA9PiAhay5zdGFydHNXaXRoKCdfJykpKSB7XG4gICAgICBzZXQuYWRkKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKHNldCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUoXG4gIG1ldGE6IENoYXJ0TWV0YTwnbGluZScgfCAnc2NhdHRlcic+LFxuICBkYXRhOiBBbnlPYmplY3RbXSxcbiAgc3RhcnQ6IG51bWJlcixcbiAgY291bnQ6IG51bWJlclxuKSB7XG4gIGNvbnN0IHtpU2NhbGV9ID0gbWV0YTtcbiAgY29uc3Qge2tleSA9ICdyJ30gPSB0aGlzLl9wYXJzaW5nO1xuICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXk8e3I6IHVua25vd259Pihjb3VudCk7XG4gIGxldCBpOiBudW1iZXIsIGlsZW46IG51bWJlciwgaW5kZXg6IG51bWJlciwgaXRlbTogQW55T2JqZWN0O1xuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgIGl0ZW0gPSBkYXRhW2luZGV4XTtcbiAgICBwYXJzZWRbaV0gPSB7XG4gICAgICByOiBpU2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShpdGVtLCBrZXkpLCBpbmRleClcbiAgICB9O1xuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59XG4iLCAiaW1wb3J0IHthbG1vc3RFcXVhbHMsIGRpc3RhbmNlQmV0d2VlblBvaW50cywgc2lnbn0gZnJvbSAnLi9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfaXNQb2ludEluQXJlYX0gZnJvbSAnLi9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnRBcmVhfSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSB7U3BsaW5lUG9pbnR9IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5cbmNvbnN0IEVQU0lMT04gPSBOdW1iZXIuRVBTSUxPTiB8fCAxZS0xNDtcblxudHlwZSBPcHRpb25hbFNwbGluZVBvaW50ID0gU3BsaW5lUG9pbnQgfCBmYWxzZVxuY29uc3QgZ2V0UG9pbnQgPSAocG9pbnRzOiBTcGxpbmVQb2ludFtdLCBpOiBudW1iZXIpOiBPcHRpb25hbFNwbGluZVBvaW50ID0+IGkgPCBwb2ludHMubGVuZ3RoICYmICFwb2ludHNbaV0uc2tpcCAmJiBwb2ludHNbaV07XG5jb25zdCBnZXRWYWx1ZUF4aXMgPSAoaW5kZXhBeGlzOiAneCcgfCAneScpID0+IGluZGV4QXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuXG5leHBvcnQgZnVuY3Rpb24gc3BsaW5lQ3VydmUoXG4gIGZpcnN0UG9pbnQ6IFNwbGluZVBvaW50LFxuICBtaWRkbGVQb2ludDogU3BsaW5lUG9pbnQsXG4gIGFmdGVyUG9pbnQ6IFNwbGluZVBvaW50LFxuICB0OiBudW1iZXJcbik6IHtcbiAgICBwcmV2aW91czogU3BsaW5lUG9pbnRcbiAgICBuZXh0OiBTcGxpbmVQb2ludFxuICB9IHtcbiAgLy8gUHJvcHMgdG8gUm9iIFNwZW5jZXIgYXQgc2NhbGVkIGlubm92YXRpb24gZm9yIGhpcyBwb3N0IG9uIHNwbGluaW5nIGJldHdlZW4gcG9pbnRzXG4gIC8vIGh0dHA6Ly9zY2FsZWRpbm5vdmF0aW9uLmNvbS9hbmFseXRpY3Mvc3BsaW5lcy9hYm91dFNwbGluZXMuaHRtbFxuXG4gIC8vIFRoaXMgZnVuY3Rpb24gbXVzdCBhbHNvIHJlc3BlY3QgXCJza2lwcGVkXCIgcG9pbnRzXG5cbiAgY29uc3QgcHJldmlvdXMgPSBmaXJzdFBvaW50LnNraXAgPyBtaWRkbGVQb2ludCA6IGZpcnN0UG9pbnQ7XG4gIGNvbnN0IGN1cnJlbnQgPSBtaWRkbGVQb2ludDtcbiAgY29uc3QgbmV4dCA9IGFmdGVyUG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogYWZ0ZXJQb2ludDtcbiAgY29uc3QgZDAxID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKGN1cnJlbnQsIHByZXZpb3VzKTtcbiAgY29uc3QgZDEyID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKG5leHQsIGN1cnJlbnQpO1xuXG4gIGxldCBzMDEgPSBkMDEgLyAoZDAxICsgZDEyKTtcbiAgbGV0IHMxMiA9IGQxMiAvIChkMDEgKyBkMTIpO1xuXG4gIC8vIElmIGFsbCBwb2ludHMgYXJlIHRoZSBzYW1lLCBzMDEgJiBzMDIgd2lsbCBiZSBpbmZcbiAgczAxID0gaXNOYU4oczAxKSA/IDAgOiBzMDE7XG4gIHMxMiA9IGlzTmFOKHMxMikgPyAwIDogczEyO1xuXG4gIGNvbnN0IGZhID0gdCAqIHMwMTsgLy8gc2NhbGluZyBmYWN0b3IgZm9yIHRyaWFuZ2xlIFRhXG4gIGNvbnN0IGZiID0gdCAqIHMxMjtcblxuICByZXR1cm4ge1xuICAgIHByZXZpb3VzOiB7XG4gICAgICB4OiBjdXJyZW50LnggLSBmYSAqIChuZXh0LnggLSBwcmV2aW91cy54KSxcbiAgICAgIHk6IGN1cnJlbnQueSAtIGZhICogKG5leHQueSAtIHByZXZpb3VzLnkpXG4gICAgfSxcbiAgICBuZXh0OiB7XG4gICAgICB4OiBjdXJyZW50LnggKyBmYiAqIChuZXh0LnggLSBwcmV2aW91cy54KSxcbiAgICAgIHk6IGN1cnJlbnQueSArIGZiICogKG5leHQueSAtIHByZXZpb3VzLnkpXG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEFkanVzdCB0YW5nZW50cyB0byBlbnN1cmUgbW9ub3RvbmljIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gbW9ub3RvbmVBZGp1c3QocG9pbnRzOiBTcGxpbmVQb2ludFtdLCBkZWx0YUs6IG51bWJlcltdLCBtSzogbnVtYmVyW10pIHtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcblxuICBsZXQgYWxwaGFLOiBudW1iZXIsIGJldGFLOiBudW1iZXIsIHRhdUs6IG51bWJlciwgc3F1YXJlZE1hZ25pdHVkZTogbnVtYmVyLCBwb2ludEN1cnJlbnQ6IE9wdGlvbmFsU3BsaW5lUG9pbnQ7XG4gIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHNMZW4gLSAxOyArK2kpIHtcbiAgICBwb2ludEN1cnJlbnQgPSBwb2ludEFmdGVyO1xuICAgIHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIGkgKyAxKTtcbiAgICBpZiAoIXBvaW50Q3VycmVudCB8fCAhcG9pbnRBZnRlcikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGFsbW9zdEVxdWFscyhkZWx0YUtbaV0sIDAsIEVQU0lMT04pKSB7XG4gICAgICBtS1tpXSA9IG1LW2kgKyAxXSA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBhbHBoYUsgPSBtS1tpXSAvIGRlbHRhS1tpXTtcbiAgICBiZXRhSyA9IG1LW2kgKyAxXSAvIGRlbHRhS1tpXTtcbiAgICBzcXVhcmVkTWFnbml0dWRlID0gTWF0aC5wb3coYWxwaGFLLCAyKSArIE1hdGgucG93KGJldGFLLCAyKTtcbiAgICBpZiAoc3F1YXJlZE1hZ25pdHVkZSA8PSA5KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0YXVLID0gMyAvIE1hdGguc3FydChzcXVhcmVkTWFnbml0dWRlKTtcbiAgICBtS1tpXSA9IGFscGhhSyAqIHRhdUsgKiBkZWx0YUtbaV07XG4gICAgbUtbaSArIDFdID0gYmV0YUsgKiB0YXVLICogZGVsdGFLW2ldO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vbm90b25lQ29tcHV0ZShwb2ludHM6IFNwbGluZVBvaW50W10sIG1LOiBudW1iZXJbXSwgaW5kZXhBeGlzOiAneCcgfCAneScgPSAneCcpIHtcbiAgY29uc3QgdmFsdWVBeGlzID0gZ2V0VmFsdWVBeGlzKGluZGV4QXhpcyk7XG4gIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGg7XG4gIGxldCBkZWx0YTogbnVtYmVyLCBwb2ludEJlZm9yZTogT3B0aW9uYWxTcGxpbmVQb2ludCwgcG9pbnRDdXJyZW50OiBPcHRpb25hbFNwbGluZVBvaW50O1xuICBsZXQgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgMCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xuICAgIHBvaW50QmVmb3JlID0gcG9pbnRDdXJyZW50O1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBpUGl4ZWwgPSBwb2ludEN1cnJlbnRbaW5kZXhBeGlzXTtcbiAgICBjb25zdCB2UGl4ZWwgPSBwb2ludEN1cnJlbnRbdmFsdWVBeGlzXTtcbiAgICBpZiAocG9pbnRCZWZvcmUpIHtcbiAgICAgIGRlbHRhID0gKGlQaXhlbCAtIHBvaW50QmVmb3JlW2luZGV4QXhpc10pIC8gMztcbiAgICAgIHBvaW50Q3VycmVudFtgY3AxJHtpbmRleEF4aXN9YF0gPSBpUGl4ZWwgLSBkZWx0YTtcbiAgICAgIHBvaW50Q3VycmVudFtgY3AxJHt2YWx1ZUF4aXN9YF0gPSB2UGl4ZWwgLSBkZWx0YSAqIG1LW2ldO1xuICAgIH1cbiAgICBpZiAocG9pbnRBZnRlcikge1xuICAgICAgZGVsdGEgPSAocG9pbnRBZnRlcltpbmRleEF4aXNdIC0gaVBpeGVsKSAvIDM7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMiR7aW5kZXhBeGlzfWBdID0gaVBpeGVsICsgZGVsdGE7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMiR7dmFsdWVBeGlzfWBdID0gdlBpeGVsICsgZGVsdGEgKiBtS1tpXTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgQsOpemllciBjb250cm9sIHBvaW50cyBpbiBhIHNpbWlsYXIgd2F5IHRoYW4gfHNwbGluZUN1cnZlfCxcbiAqIGJ1dCBwcmVzZXJ2ZXMgbW9ub3RvbmljaXR5IG9mIHRoZSBwcm92aWRlZCBkYXRhIGFuZCBlbnN1cmVzIG5vIGxvY2FsIGV4dHJlbXVtcyBhcmUgYWRkZWRcbiAqIGJldHdlZW4gdGhlIGRhdGFzZXQgZGlzY3JldGUgcG9pbnRzIGR1ZSB0byB0aGUgaW50ZXJwb2xhdGlvbi5cbiAqIFNlZSA6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vbm90b25lX2N1YmljX2ludGVycG9sYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwbGluZUN1cnZlTW9ub3RvbmUocG9pbnRzOiBTcGxpbmVQb2ludFtdLCBpbmRleEF4aXM6ICd4JyB8ICd5JyA9ICd4Jykge1xuICBjb25zdCB2YWx1ZUF4aXMgPSBnZXRWYWx1ZUF4aXMoaW5kZXhBeGlzKTtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgZGVsdGFLOiBudW1iZXJbXSA9IEFycmF5KHBvaW50c0xlbikuZmlsbCgwKTtcbiAgY29uc3QgbUs6IG51bWJlcltdID0gQXJyYXkocG9pbnRzTGVuKTtcblxuICAvLyBDYWxjdWxhdGUgc2xvcGVzIChkZWx0YUspIGFuZCBpbml0aWFsaXplIHRhbmdlbnRzIChtSylcbiAgbGV0IGksIHBvaW50QmVmb3JlOiBPcHRpb25hbFNwbGluZVBvaW50LCBwb2ludEN1cnJlbnQ6IE9wdGlvbmFsU3BsaW5lUG9pbnQ7XG4gIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpIHtcbiAgICBwb2ludEJlZm9yZSA9IHBvaW50Q3VycmVudDtcbiAgICBwb2ludEN1cnJlbnQgPSBwb2ludEFmdGVyO1xuICAgIHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIGkgKyAxKTtcbiAgICBpZiAoIXBvaW50Q3VycmVudCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHBvaW50QWZ0ZXIpIHtcbiAgICAgIGNvbnN0IHNsb3BlRGVsdGEgPSBwb2ludEFmdGVyW2luZGV4QXhpc10gLSBwb2ludEN1cnJlbnRbaW5kZXhBeGlzXTtcblxuICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgdHdvIHBvaW50cyB0aGF0IGFwcGVhciBhdCB0aGUgc2FtZSB4IHBpeGVsLCBzbG9wZURlbHRhWCBpcyAwXG4gICAgICBkZWx0YUtbaV0gPSBzbG9wZURlbHRhICE9PSAwID8gKHBvaW50QWZ0ZXJbdmFsdWVBeGlzXSAtIHBvaW50Q3VycmVudFt2YWx1ZUF4aXNdKSAvIHNsb3BlRGVsdGEgOiAwO1xuICAgIH1cbiAgICBtS1tpXSA9ICFwb2ludEJlZm9yZSA/IGRlbHRhS1tpXVxuICAgICAgOiAhcG9pbnRBZnRlciA/IGRlbHRhS1tpIC0gMV1cbiAgICAgICAgOiAoc2lnbihkZWx0YUtbaSAtIDFdKSAhPT0gc2lnbihkZWx0YUtbaV0pKSA/IDBcbiAgICAgICAgICA6IChkZWx0YUtbaSAtIDFdICsgZGVsdGFLW2ldKSAvIDI7XG4gIH1cblxuICBtb25vdG9uZUFkanVzdChwb2ludHMsIGRlbHRhSywgbUspO1xuXG4gIG1vbm90b25lQ29tcHV0ZShwb2ludHMsIG1LLCBpbmRleEF4aXMpO1xufVxuXG5mdW5jdGlvbiBjYXBDb250cm9sUG9pbnQocHQ6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKSB7XG4gIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihwdCwgbWF4KSwgbWluKTtcbn1cblxuZnVuY3Rpb24gY2FwQmV6aWVyUG9pbnRzKHBvaW50czogU3BsaW5lUG9pbnRbXSwgYXJlYTogQ2hhcnRBcmVhKSB7XG4gIGxldCBpLCBpbGVuLCBwb2ludCwgaW5BcmVhLCBpbkFyZWFQcmV2O1xuICBsZXQgaW5BcmVhTmV4dCA9IF9pc1BvaW50SW5BcmVhKHBvaW50c1swXSwgYXJlYSk7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgaW5BcmVhUHJldiA9IGluQXJlYTtcbiAgICBpbkFyZWEgPSBpbkFyZWFOZXh0O1xuICAgIGluQXJlYU5leHQgPSBpIDwgaWxlbiAtIDEgJiYgX2lzUG9pbnRJbkFyZWEocG9pbnRzW2kgKyAxXSwgYXJlYSk7XG4gICAgaWYgKCFpbkFyZWEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICBpZiAoaW5BcmVhUHJldikge1xuICAgICAgcG9pbnQuY3AxeCA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDF4LCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuICAgICAgcG9pbnQuY3AxeSA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDF5LCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xuICAgIH1cbiAgICBpZiAoaW5BcmVhTmV4dCkge1xuICAgICAgcG9pbnQuY3AyeCA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDJ4LCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuICAgICAgcG9pbnQuY3AyeSA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDJ5LCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyhcbiAgcG9pbnRzOiBTcGxpbmVQb2ludFtdLFxuICBvcHRpb25zLFxuICBhcmVhOiBDaGFydEFyZWEsXG4gIGxvb3A6IGJvb2xlYW4sXG4gIGluZGV4QXhpczogJ3gnIHwgJ3knXG4pIHtcbiAgbGV0IGk6IG51bWJlciwgaWxlbjogbnVtYmVyLCBwb2ludDogU3BsaW5lUG9pbnQsIGNvbnRyb2xQb2ludHM6IFJldHVyblR5cGU8dHlwZW9mIHNwbGluZUN1cnZlPjtcblxuICAvLyBPbmx5IGNvbnNpZGVyIHBvaW50cyB0aGF0IGFyZSBkcmF3biBpbiBjYXNlIHRoZSBzcGFuR2FwcyBvcHRpb24gaXMgdXNlZFxuICBpZiAob3B0aW9ucy5zcGFuR2Fwcykge1xuICAgIHBvaW50cyA9IHBvaW50cy5maWx0ZXIoKHB0KSA9PiAhcHQuc2tpcCk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSB7XG4gICAgc3BsaW5lQ3VydmVNb25vdG9uZShwb2ludHMsIGluZGV4QXhpcyk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHByZXYgPSBsb29wID8gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSA6IHBvaW50c1swXTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb250cm9sUG9pbnRzID0gc3BsaW5lQ3VydmUoXG4gICAgICAgIHByZXYsXG4gICAgICAgIHBvaW50LFxuICAgICAgICBwb2ludHNbTWF0aC5taW4oaSArIDEsIGlsZW4gLSAobG9vcCA/IDAgOiAxKSkgJSBpbGVuXSxcbiAgICAgICAgb3B0aW9ucy50ZW5zaW9uXG4gICAgICApO1xuICAgICAgcG9pbnQuY3AxeCA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueDtcbiAgICAgIHBvaW50LmNwMXkgPSBjb250cm9sUG9pbnRzLnByZXZpb3VzLnk7XG4gICAgICBwb2ludC5jcDJ4ID0gY29udHJvbFBvaW50cy5uZXh0Lng7XG4gICAgICBwb2ludC5jcDJ5ID0gY29udHJvbFBvaW50cy5uZXh0Lnk7XG4gICAgICBwcmV2ID0gcG9pbnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuY2FwQmV6aWVyUG9pbnRzKSB7XG4gICAgY2FwQmV6aWVyUG9pbnRzKHBvaW50cywgYXJlYSk7XG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7Q2hhcnRBcmVhLCBTY2FsZX0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuaW1wb3J0IHR5cGUgQ2hhcnQgZnJvbSAnLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHR5cGUge0NoYXJ0RXZlbnR9IGZyb20gJy4uL3R5cGVzLmpzJztcbmltcG9ydCB7SU5GSU5JVFl9IGZyb20gJy4vaGVscGVycy5tYXRoLmpzJztcblxuLyoqXG4gKiBOb3RlOiB0eXBlZGVmcyBhcmUgYXV0by1leHBvcnRlZCwgc28gdXNlIGEgbWFkZS11cCBgZG9tYCBuYW1lc3BhY2Ugd2hlcmVcbiAqIG5lY2Vzc2FyeSB0byBhdm9pZCBkdXBsaWNhdGVzIHdpdGggYGV4cG9ydCAqIGZyb20gJy4vaGVscGVyc2A7IHNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy80NjAxMVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IGRvbS5DaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL3R5cGVzJykuQ2hhcnRFdmVudCB9IENoYXJ0RXZlbnRcbiAqL1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfaXNEb21TdXBwb3J0ZWQoKTogYm9vbGVhbiB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0UGFyZW50Tm9kZShkb21Ob2RlOiBIVE1MQ2FudmFzRWxlbWVudCk6IEhUTUxDYW52YXNFbGVtZW50IHtcbiAgbGV0IHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCAmJiBwYXJlbnQudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgU2hhZG93Um9vdF0nKSB7XG4gICAgcGFyZW50ID0gKHBhcmVudCBhcyBTaGFkb3dSb290KS5ob3N0O1xuICB9XG4gIHJldHVybiBwYXJlbnQgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XG59XG5cbi8qKlxuICogY29udmVydCBtYXgtd2lkdGgvbWF4LWhlaWdodCB2YWx1ZXMgdGhhdCBtYXkgYmUgcGVyY2VudGFnZXMgaW50byBhIG51bWJlclxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZU1heFN0eWxlKHN0eWxlVmFsdWU6IHN0cmluZyB8IG51bWJlciwgbm9kZTogSFRNTEVsZW1lbnQsIHBhcmVudFByb3BlcnR5OiBzdHJpbmcpIHtcbiAgbGV0IHZhbHVlSW5QaXhlbHM6IG51bWJlcjtcbiAgaWYgKHR5cGVvZiBzdHlsZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlSW5QaXhlbHMgPSBwYXJzZUludChzdHlsZVZhbHVlLCAxMCk7XG5cbiAgICBpZiAoc3R5bGVWYWx1ZS5pbmRleE9mKCclJykgIT09IC0xKSB7XG4gICAgICAvLyBwZXJjZW50YWdlICogc2l6ZSBpbiBkaW1lbnNpb25cbiAgICAgIHZhbHVlSW5QaXhlbHMgPSAodmFsdWVJblBpeGVscyAvIDEwMCkgKiBub2RlLnBhcmVudE5vZGVbcGFyZW50UHJvcGVydHldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZUluUGl4ZWxzID0gc3R5bGVWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZUluUGl4ZWxzO1xufVxuXG5jb25zdCBnZXRDb21wdXRlZFN0eWxlID0gKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogQ1NTU3R5bGVEZWNsYXJhdGlvbiA9PlxuICBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0eWxlKGVsOiBIVE1MRWxlbWVudCwgcHJvcGVydHk6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcbn1cblxuY29uc3QgcG9zaXRpb25zID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcbmZ1bmN0aW9uIGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZXM6IENTU1N0eWxlRGVjbGFyYXRpb24sIHN0eWxlOiBzdHJpbmcsIHN1ZmZpeD86IHN0cmluZyk6IENoYXJ0QXJlYSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9IGFzIENoYXJ0QXJlYTtcbiAgc3VmZml4ID0gc3VmZml4ID8gJy0nICsgc3VmZml4IDogJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgY29uc3QgcG9zID0gcG9zaXRpb25zW2ldO1xuICAgIHJlc3VsdFtwb3NdID0gcGFyc2VGbG9hdChzdHlsZXNbc3R5bGUgKyAnLScgKyBwb3MgKyBzdWZmaXhdKSB8fCAwO1xuICB9XG4gIHJlc3VsdC53aWR0aCA9IHJlc3VsdC5sZWZ0ICsgcmVzdWx0LnJpZ2h0O1xuICByZXN1bHQuaGVpZ2h0ID0gcmVzdWx0LnRvcCArIHJlc3VsdC5ib3R0b207XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IHVzZU9mZnNldFBvcyA9ICh4OiBudW1iZXIsIHk6IG51bWJlciwgdGFyZ2V0OiBIVE1MRWxlbWVudCB8IEV2ZW50VGFyZ2V0KSA9PlxuICAoeCA+IDAgfHwgeSA+IDApICYmICghdGFyZ2V0IHx8ICEodGFyZ2V0IGFzIEhUTUxFbGVtZW50KS5zaGFkb3dSb290KTtcblxuLyoqXG4gKiBAcGFyYW0gZVxuICogQHBhcmFtIGNhbnZhc1xuICogQHJldHVybnMgQ2FudmFzIHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldENhbnZhc1Bvc2l0aW9uKFxuICBlOiBFdmVudCB8IFRvdWNoRXZlbnQgfCBNb3VzZUV2ZW50LFxuICBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50XG4pOiB7XG4gICAgeDogbnVtYmVyO1xuICAgIHk6IG51bWJlcjtcbiAgICBib3g6IGJvb2xlYW47XG4gIH0ge1xuICBjb25zdCB0b3VjaGVzID0gKGUgYXMgVG91Y2hFdmVudCkudG91Y2hlcztcbiAgY29uc3Qgc291cmNlID0gKHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGggPyB0b3VjaGVzWzBdIDogZSkgYXMgTW91c2VFdmVudDtcbiAgY29uc3Qge29mZnNldFgsIG9mZnNldFl9ID0gc291cmNlIGFzIE1vdXNlRXZlbnQ7XG4gIGxldCBib3ggPSBmYWxzZTtcbiAgbGV0IHgsIHk7XG4gIGlmICh1c2VPZmZzZXRQb3Mob2Zmc2V0WCwgb2Zmc2V0WSwgZS50YXJnZXQpKSB7XG4gICAgeCA9IG9mZnNldFg7XG4gICAgeSA9IG9mZnNldFk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB4ID0gc291cmNlLmNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgeSA9IHNvdXJjZS5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgYm94ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4ge3gsIHksIGJveH07XG59XG5cbi8qKlxuICogR2V0cyBhbiBldmVudCdzIHgsIHkgY29vcmRpbmF0ZXMsIHJlbGF0aXZlIHRvIHRoZSBjaGFydCBhcmVhXG4gKiBAcGFyYW0gZXZlbnRcbiAqIEBwYXJhbSBjaGFydFxuICogQHJldHVybnMgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgZXZlbnRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVsYXRpdmVQb3NpdGlvbihcbiAgZXZlbnQ6IEV2ZW50IHwgQ2hhcnRFdmVudCB8IFRvdWNoRXZlbnQgfCBNb3VzZUV2ZW50LFxuICBjaGFydDogQ2hhcnRcbik6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB7XG4gIGlmICgnbmF0aXZlJyBpbiBldmVudCkge1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuXG4gIGNvbnN0IHtjYW52YXMsIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvfSA9IGNoYXJ0O1xuICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY2FudmFzKTtcbiAgY29uc3QgYm9yZGVyQm94ID0gc3R5bGUuYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCc7XG4gIGNvbnN0IHBhZGRpbmdzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAncGFkZGluZycpO1xuICBjb25zdCBib3JkZXJzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG4gIGNvbnN0IHt4LCB5LCBib3h9ID0gZ2V0Q2FudmFzUG9zaXRpb24oZXZlbnQsIGNhbnZhcyk7XG4gIGNvbnN0IHhPZmZzZXQgPSBwYWRkaW5ncy5sZWZ0ICsgKGJveCAmJiBib3JkZXJzLmxlZnQpO1xuICBjb25zdCB5T2Zmc2V0ID0gcGFkZGluZ3MudG9wICsgKGJveCAmJiBib3JkZXJzLnRvcCk7XG5cbiAgbGV0IHt3aWR0aCwgaGVpZ2h0fSA9IGNoYXJ0O1xuICBpZiAoYm9yZGVyQm94KSB7XG4gICAgd2lkdGggLT0gcGFkZGluZ3Mud2lkdGggKyBib3JkZXJzLndpZHRoO1xuICAgIGhlaWdodCAtPSBwYWRkaW5ncy5oZWlnaHQgKyBib3JkZXJzLmhlaWdodDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IE1hdGgucm91bmQoKHggLSB4T2Zmc2V0KSAvIHdpZHRoICogY2FudmFzLndpZHRoIC8gY3VycmVudERldmljZVBpeGVsUmF0aW8pLFxuICAgIHk6IE1hdGgucm91bmQoKHkgLSB5T2Zmc2V0KSAvIGhlaWdodCAqIGNhbnZhcy5oZWlnaHQgLyBjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbylcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGFpbmVyU2l6ZShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IFBhcnRpYWw8U2NhbGU+IHtcbiAgbGV0IG1heFdpZHRoOiBudW1iZXIsIG1heEhlaWdodDogbnVtYmVyO1xuXG4gIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkIHx8IGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gY2FudmFzICYmIF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgIHdpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoO1xuICAgICAgaGVpZ2h0ID0gY2FudmFzLmNsaWVudEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gdGhpcyBpcyB0aGUgYm9yZGVyIGJveCBvZiB0aGUgY29udGFpbmVyXG4gICAgICBjb25zdCBjb250YWluZXJTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lckJvcmRlciA9IGdldFBvc2l0aW9uZWRTdHlsZShjb250YWluZXJTdHlsZSwgJ2JvcmRlcicsICd3aWR0aCcpO1xuICAgICAgY29uc3QgY29udGFpbmVyUGFkZGluZyA9IGdldFBvc2l0aW9uZWRTdHlsZShjb250YWluZXJTdHlsZSwgJ3BhZGRpbmcnKTtcbiAgICAgIHdpZHRoID0gcmVjdC53aWR0aCAtIGNvbnRhaW5lclBhZGRpbmcud2lkdGggLSBjb250YWluZXJCb3JkZXIud2lkdGg7XG4gICAgICBoZWlnaHQgPSByZWN0LmhlaWdodCAtIGNvbnRhaW5lclBhZGRpbmcuaGVpZ2h0IC0gY29udGFpbmVyQm9yZGVyLmhlaWdodDtcbiAgICAgIG1heFdpZHRoID0gcGFyc2VNYXhTdHlsZShjb250YWluZXJTdHlsZS5tYXhXaWR0aCwgY29udGFpbmVyLCAnY2xpZW50V2lkdGgnKTtcbiAgICAgIG1heEhlaWdodCA9IHBhcnNlTWF4U3R5bGUoY29udGFpbmVyU3R5bGUubWF4SGVpZ2h0LCBjb250YWluZXIsICdjbGllbnRIZWlnaHQnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbWF4V2lkdGg6IG1heFdpZHRoIHx8IElORklOSVRZLFxuICAgIG1heEhlaWdodDogbWF4SGVpZ2h0IHx8IElORklOSVRZXG4gIH07XG59XG5cbmNvbnN0IHJvdW5kMSA9ICh2OiBudW1iZXIpID0+IE1hdGgucm91bmQodiAqIDEwKSAvIDEwO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZXhwb3J0IGZ1bmN0aW9uIGdldE1heGltdW1TaXplKFxuICBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LFxuICBiYldpZHRoPzogbnVtYmVyLFxuICBiYkhlaWdodD86IG51bWJlcixcbiAgYXNwZWN0UmF0aW8/OiBudW1iZXJcbik6IHsgd2lkdGg6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXIgfSB7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMpO1xuICBjb25zdCBtYXJnaW5zID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnbWFyZ2luJyk7XG4gIGNvbnN0IG1heFdpZHRoID0gcGFyc2VNYXhTdHlsZShzdHlsZS5tYXhXaWR0aCwgY2FudmFzLCAnY2xpZW50V2lkdGgnKSB8fCBJTkZJTklUWTtcbiAgY29uc3QgbWF4SGVpZ2h0ID0gcGFyc2VNYXhTdHlsZShzdHlsZS5tYXhIZWlnaHQsIGNhbnZhcywgJ2NsaWVudEhlaWdodCcpIHx8IElORklOSVRZO1xuICBjb25zdCBjb250YWluZXJTaXplID0gZ2V0Q29udGFpbmVyU2l6ZShjYW52YXMsIGJiV2lkdGgsIGJiSGVpZ2h0KTtcbiAgbGV0IHt3aWR0aCwgaGVpZ2h0fSA9IGNvbnRhaW5lclNpemU7XG5cbiAgaWYgKHN0eWxlLmJveFNpemluZyA9PT0gJ2NvbnRlbnQtYm94Jykge1xuICAgIGNvbnN0IGJvcmRlcnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgICBjb25zdCBwYWRkaW5ncyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ3BhZGRpbmcnKTtcbiAgICB3aWR0aCAtPSBwYWRkaW5ncy53aWR0aCArIGJvcmRlcnMud2lkdGg7XG4gICAgaGVpZ2h0IC09IHBhZGRpbmdzLmhlaWdodCArIGJvcmRlcnMuaGVpZ2h0O1xuICB9XG4gIHdpZHRoID0gTWF0aC5tYXgoMCwgd2lkdGggLSBtYXJnaW5zLndpZHRoKTtcbiAgaGVpZ2h0ID0gTWF0aC5tYXgoMCwgYXNwZWN0UmF0aW8gPyB3aWR0aCAvIGFzcGVjdFJhdGlvIDogaGVpZ2h0IC0gbWFyZ2lucy5oZWlnaHQpO1xuICB3aWR0aCA9IHJvdW5kMShNYXRoLm1pbih3aWR0aCwgbWF4V2lkdGgsIGNvbnRhaW5lclNpemUubWF4V2lkdGgpKTtcbiAgaGVpZ2h0ID0gcm91bmQxKE1hdGgubWluKGhlaWdodCwgbWF4SGVpZ2h0LCBjb250YWluZXJTaXplLm1heEhlaWdodCkpO1xuICBpZiAod2lkdGggJiYgIWhlaWdodCkge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80NjU5XG4gICAgLy8gSWYgdGhlIGNhbnZhcyBoYXMgd2lkdGgsIGJ1dCBubyBoZWlnaHQsIGRlZmF1bHQgdG8gYXNwZWN0UmF0aW8gb2YgMiAoY2FudmFzIGRlZmF1bHQpXG4gICAgaGVpZ2h0ID0gcm91bmQxKHdpZHRoIC8gMik7XG4gIH1cblxuICBjb25zdCBtYWludGFpbkhlaWdodCA9IGJiV2lkdGggIT09IHVuZGVmaW5lZCB8fCBiYkhlaWdodCAhPT0gdW5kZWZpbmVkO1xuXG4gIGlmIChtYWludGFpbkhlaWdodCAmJiBhc3BlY3RSYXRpbyAmJiBjb250YWluZXJTaXplLmhlaWdodCAmJiBoZWlnaHQgPiBjb250YWluZXJTaXplLmhlaWdodCkge1xuICAgIGhlaWdodCA9IGNvbnRhaW5lclNpemUuaGVpZ2h0O1xuICAgIHdpZHRoID0gcm91bmQxKE1hdGguZmxvb3IoaGVpZ2h0ICogYXNwZWN0UmF0aW8pKTtcbiAgfVxuXG4gIHJldHVybiB7d2lkdGgsIGhlaWdodH07XG59XG5cbi8qKlxuICogQHBhcmFtIGNoYXJ0XG4gKiBAcGFyYW0gZm9yY2VSYXRpb1xuICogQHBhcmFtIGZvcmNlU3R5bGVcbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGNhbnZhcyBjb250ZXh0IHNpemUgb3IgdHJhbnNmb3JtYXRpb24gaGFzIGNoYW5nZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXRpbmFTY2FsZShcbiAgY2hhcnQ6IENoYXJ0LFxuICBmb3JjZVJhdGlvOiBudW1iZXIsXG4gIGZvcmNlU3R5bGU/OiBib29sZWFuXG4pOiBib29sZWFuIHwgdm9pZCB7XG4gIGNvbnN0IHBpeGVsUmF0aW8gPSBmb3JjZVJhdGlvIHx8IDE7XG4gIGNvbnN0IGRldmljZUhlaWdodCA9IE1hdGguZmxvb3IoY2hhcnQuaGVpZ2h0ICogcGl4ZWxSYXRpbyk7XG4gIGNvbnN0IGRldmljZVdpZHRoID0gTWF0aC5mbG9vcihjaGFydC53aWR0aCAqIHBpeGVsUmF0aW8pO1xuXG4gIGNoYXJ0LmhlaWdodCA9IE1hdGguZmxvb3IoY2hhcnQuaGVpZ2h0KTtcbiAgY2hhcnQud2lkdGggPSBNYXRoLmZsb29yKGNoYXJ0LndpZHRoKTtcblxuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG5cbiAgLy8gSWYgbm8gc3R5bGUgaGFzIGJlZW4gc2V0IG9uIHRoZSBjYW52YXMsIHRoZSByZW5kZXIgc2l6ZSBpcyB1c2VkIGFzIGRpc3BsYXkgc2l6ZSxcbiAgLy8gbWFraW5nIHRoZSBjaGFydCB2aXN1YWxseSBiaWdnZXIsIHNvIGxldCdzIGVuZm9yY2UgaXQgdG8gdGhlIFwiY29ycmVjdFwiIHZhbHVlcy5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8zNTc1XG4gIGlmIChjYW52YXMuc3R5bGUgJiYgKGZvcmNlU3R5bGUgfHwgKCFjYW52YXMuc3R5bGUuaGVpZ2h0ICYmICFjYW52YXMuc3R5bGUud2lkdGgpKSkge1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBgJHtjaGFydC5oZWlnaHR9cHhgO1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGAke2NoYXJ0LndpZHRofXB4YDtcbiAgfVxuXG4gIGlmIChjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyAhPT0gcGl4ZWxSYXRpb1xuICAgICAgfHwgY2FudmFzLmhlaWdodCAhPT0gZGV2aWNlSGVpZ2h0XG4gICAgICB8fCBjYW52YXMud2lkdGggIT09IGRldmljZVdpZHRoKSB7XG4gICAgY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBkZXZpY2VIZWlnaHQ7XG4gICAgY2FudmFzLndpZHRoID0gZGV2aWNlV2lkdGg7XG4gICAgY2hhcnQuY3R4LnNldFRyYW5zZm9ybShwaXhlbFJhdGlvLCAwLCAwLCBwaXhlbFJhdGlvLCAwLCAwKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogRGV0ZWN0cyBzdXBwb3J0IGZvciBvcHRpb25zIG9iamVjdCBhcmd1bWVudCBpbiBhZGRFdmVudExpc3RlbmVyLlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXIjU2FmZWx5X2RldGVjdGluZ19vcHRpb25fc3VwcG9ydFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPSAoZnVuY3Rpb24oKSB7XG4gIGxldCBwYXNzaXZlU3VwcG9ydGVkID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGdldCBwYXNzaXZlKCkgeyAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGJyb3dzZXIgYXR0ZW1wdHMgdG8gYWNjZXNzIHRoZSBwYXNzaXZlIHByb3BlcnR5LlxuICAgICAgICBwYXNzaXZlU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gYXMgRXZlbnRMaXN0ZW5lck9wdGlvbnM7XG5cbiAgICBpZiAoX2lzRG9tU3VwcG9ydGVkKCkpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0aW9ucyk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGNvbnRpbnVlIHJlZ2FyZGxlc3Mgb2YgZXJyb3JcbiAgfVxuICByZXR1cm4gcGFzc2l2ZVN1cHBvcnRlZDtcbn0oKSk7XG5cbi8qKlxuICogVGhlIFwidXNlZFwiIHNpemUgaXMgdGhlIGZpbmFsIHZhbHVlIG9mIGEgZGltZW5zaW9uIHByb3BlcnR5IGFmdGVyIGFsbCBjYWxjdWxhdGlvbnMgaGF2ZVxuICogYmVlbiBwZXJmb3JtZWQuIFRoaXMgbWV0aG9kIHVzZXMgdGhlIGNvbXB1dGVkIHN0eWxlIG9mIGBlbGVtZW50YCBidXQgcmV0dXJucyB1bmRlZmluZWRcbiAqIGlmIHRoZSBjb21wdXRlZCBzdHlsZSBpcyBub3QgZXhwcmVzc2VkIGluIHBpeGVscy4gVGhhdCBjYW4gaGFwcGVuIGluIHNvbWUgY2FzZXMgd2hlcmVcbiAqIGBlbGVtZW50YCBoYXMgYSBzaXplIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQgYW5kIHRoaXMgbGFzdCBvbmUgaXMgbm90IHlldCBkaXNwbGF5ZWQsXG4gKiBmb3IgZXhhbXBsZSBiZWNhdXNlIG9mIGBkaXNwbGF5OiBub25lYCBvbiBhIHBhcmVudCBub2RlLlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvdXNlZF92YWx1ZVxuICogQHJldHVybnMgU2l6ZSBpbiBwaXhlbHMgb3IgdW5kZWZpbmVkIGlmIHVua25vd24uXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRVc2VkU2l6ZShcbiAgZWxlbWVudDogSFRNTEVsZW1lbnQsXG4gIHByb3BlcnR5OiAnd2lkdGgnIHwgJ2hlaWdodCdcbik6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IHZhbHVlID0gZ2V0U3R5bGUoZWxlbWVudCwgcHJvcGVydHkpO1xuICBjb25zdCBtYXRjaGVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goL14oXFxkKykoXFwuXFxkKyk/cHgkLyk7XG4gIHJldHVybiBtYXRjaGVzID8gK21hdGNoZXNbMV0gOiB1bmRlZmluZWQ7XG59XG4iLCAiaW1wb3J0IHR5cGUge1BvaW50LCBTcGxpbmVQb2ludH0gZnJvbSAnLi4vdHlwZXMvZ2VvbWV0cmljLmpzJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3BvaW50SW5MaW5lKHAxOiBQb2ludCwgcDI6IFBvaW50LCB0OiBudW1iZXIsIG1vZGU/KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIHJldHVybiB7XG4gICAgeDogcDEueCArIHQgKiAocDIueCAtIHAxLngpLFxuICAgIHk6IHAxLnkgKyB0ICogKHAyLnkgLSBwMS55KVxuICB9O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfc3RlcHBlZEludGVycG9sYXRpb24oXG4gIHAxOiBQb2ludCxcbiAgcDI6IFBvaW50LFxuICB0OiBudW1iZXIsIG1vZGU6ICdtaWRkbGUnIHwgJ2FmdGVyJyB8IHVua25vd25cbikge1xuICByZXR1cm4ge1xuICAgIHg6IHAxLnggKyB0ICogKHAyLnggLSBwMS54KSxcbiAgICB5OiBtb2RlID09PSAnbWlkZGxlJyA/IHQgPCAwLjUgPyBwMS55IDogcDIueVxuICAgICAgOiBtb2RlID09PSAnYWZ0ZXInID8gdCA8IDEgPyBwMS55IDogcDIueVxuICAgICAgICA6IHQgPiAwID8gcDIueSA6IHAxLnlcbiAgfTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2JlemllckludGVycG9sYXRpb24ocDE6IFNwbGluZVBvaW50LCBwMjogU3BsaW5lUG9pbnQsIHQ6IG51bWJlciwgbW9kZT8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgY29uc3QgY3AxID0ge3g6IHAxLmNwMngsIHk6IHAxLmNwMnl9O1xuICBjb25zdCBjcDIgPSB7eDogcDIuY3AxeCwgeTogcDIuY3AxeX07XG4gIGNvbnN0IGEgPSBfcG9pbnRJbkxpbmUocDEsIGNwMSwgdCk7XG4gIGNvbnN0IGIgPSBfcG9pbnRJbkxpbmUoY3AxLCBjcDIsIHQpO1xuICBjb25zdCBjID0gX3BvaW50SW5MaW5lKGNwMiwgcDIsIHQpO1xuICBjb25zdCBkID0gX3BvaW50SW5MaW5lKGEsIGIsIHQpO1xuICBjb25zdCBlID0gX3BvaW50SW5MaW5lKGIsIGMsIHQpO1xuICByZXR1cm4gX3BvaW50SW5MaW5lKGQsIGUsIHQpO1xufVxuIiwgImV4cG9ydCBpbnRlcmZhY2UgUlRMQWRhcHRlciB7XG4gIHgoeDogbnVtYmVyKTogbnVtYmVyO1xuICBzZXRXaWR0aCh3OiBudW1iZXIpOiB2b2lkO1xuICB0ZXh0QWxpZ24oYWxpZ246ICdjZW50ZXInIHwgJ2xlZnQnIHwgJ3JpZ2h0Jyk6ICdjZW50ZXInIHwgJ2xlZnQnIHwgJ3JpZ2h0JztcbiAgeFBsdXMoeDogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKTogbnVtYmVyO1xuICBsZWZ0Rm9yTHRyKHg6IG51bWJlciwgaXRlbVdpZHRoOiBudW1iZXIpOiBudW1iZXI7XG59XG5cbmNvbnN0IGdldFJpZ2h0VG9MZWZ0QWRhcHRlciA9IGZ1bmN0aW9uKHJlY3RYOiBudW1iZXIsIHdpZHRoOiBudW1iZXIpOiBSVExBZGFwdGVyIHtcbiAgcmV0dXJuIHtcbiAgICB4KHgpIHtcbiAgICAgIHJldHVybiByZWN0WCArIHJlY3RYICsgd2lkdGggLSB4O1xuICAgIH0sXG4gICAgc2V0V2lkdGgodykge1xuICAgICAgd2lkdGggPSB3O1xuICAgIH0sXG4gICAgdGV4dEFsaWduKGFsaWduKSB7XG4gICAgICBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHJldHVybiBhbGlnbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGlnbiA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfSxcbiAgICB4UGx1cyh4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHggLSB2YWx1ZTtcbiAgICB9LFxuICAgIGxlZnRGb3JMdHIoeCwgaXRlbVdpZHRoKSB7XG4gICAgICByZXR1cm4geCAtIGl0ZW1XaWR0aDtcbiAgICB9LFxuICB9O1xufTtcblxuY29uc3QgZ2V0TGVmdFRvUmlnaHRBZGFwdGVyID0gZnVuY3Rpb24oKTogUlRMQWRhcHRlciB7XG4gIHJldHVybiB7XG4gICAgeCh4KSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9LFxuICAgIHNldFdpZHRoKHcpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIH0sXG4gICAgdGV4dEFsaWduKGFsaWduKSB7XG4gICAgICByZXR1cm4gYWxpZ247XG4gICAgfSxcbiAgICB4UGx1cyh4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHggKyB2YWx1ZTtcbiAgICB9LFxuICAgIGxlZnRGb3JMdHIoeCwgX2l0ZW1XaWR0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIHg7XG4gICAgfSxcbiAgfTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSdGxBZGFwdGVyKHJ0bDogYm9vbGVhbiwgcmVjdFg6IG51bWJlciwgd2lkdGg6IG51bWJlcikge1xuICByZXR1cm4gcnRsID8gZ2V0UmlnaHRUb0xlZnRBZGFwdGVyKHJlY3RYLCB3aWR0aCkgOiBnZXRMZWZ0VG9SaWdodEFkYXB0ZXIoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG92ZXJyaWRlVGV4dERpcmVjdGlvbihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgZGlyZWN0aW9uOiAnbHRyJyB8ICdydGwnKSB7XG4gIGxldCBzdHlsZTogQ1NTU3R5bGVEZWNsYXJhdGlvbiwgb3JpZ2luYWw6IFtzdHJpbmcsIHN0cmluZ107XG4gIGlmIChkaXJlY3Rpb24gPT09ICdsdHInIHx8IGRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICBzdHlsZSA9IGN0eC5jYW52YXMuc3R5bGU7XG4gICAgb3JpZ2luYWwgPSBbXG4gICAgICBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXJlY3Rpb24nKSxcbiAgICAgIHN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkoJ2RpcmVjdGlvbicpLFxuICAgIF07XG5cbiAgICBzdHlsZS5zZXRQcm9wZXJ0eSgnZGlyZWN0aW9uJywgZGlyZWN0aW9uLCAnaW1wb3J0YW50Jyk7XG4gICAgKGN0eCBhcyB7IHByZXZUZXh0RGlyZWN0aW9uPzogW3N0cmluZywgc3RyaW5nXSB9KS5wcmV2VGV4dERpcmVjdGlvbiA9IG9yaWdpbmFsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXN0b3JlVGV4dERpcmVjdGlvbihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgb3JpZ2luYWw/OiBbc3RyaW5nLCBzdHJpbmddKSB7XG4gIGlmIChvcmlnaW5hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVsZXRlIChjdHggYXMgeyBwcmV2VGV4dERpcmVjdGlvbj86IFtzdHJpbmcsIHN0cmluZ10gfSkucHJldlRleHREaXJlY3Rpb247XG4gICAgY3R4LmNhbnZhcy5zdHlsZS5zZXRQcm9wZXJ0eSgnZGlyZWN0aW9uJywgb3JpZ2luYWxbMF0sIG9yaWdpbmFsWzFdKTtcbiAgfVxufVxuIiwgImltcG9ydCB7X2FuZ2xlQmV0d2VlbiwgX2FuZ2xlRGlmZiwgX2lzQmV0d2VlbiwgX25vcm1hbGl6ZUFuZ2xlfSBmcm9tICcuL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge2NyZWF0ZUNvbnRleHR9IGZyb20gJy4vaGVscGVycy5vcHRpb25zLmpzJztcbmltcG9ydCB7aXNQYXR0ZXJuT3JHcmFkaWVudH0gZnJvbSAnLi9oZWxwZXJzLmNvbG9yLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vZWxlbWVudHMvZWxlbWVudC5saW5lLmpzJykuZGVmYXVsdCB9IExpbmVFbGVtZW50XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vZWxlbWVudHMvZWxlbWVudC5wb2ludC5qcycpLmRlZmF1bHQgfSBQb2ludEVsZW1lbnRcbiAqIEB0eXBlZGVmIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIsIGxvb3A6IGJvb2xlYW4sIHN0eWxlPzogYW55fX0gU2VnbWVudFxuICovXG5cbmZ1bmN0aW9uIHByb3BlcnR5Rm4ocHJvcGVydHkpIHtcbiAgaWYgKHByb3BlcnR5ID09PSAnYW5nbGUnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJldHdlZW46IF9hbmdsZUJldHdlZW4sXG4gICAgICBjb21wYXJlOiBfYW5nbGVEaWZmLFxuICAgICAgbm9ybWFsaXplOiBfbm9ybWFsaXplQW5nbGUsXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGJldHdlZW46IF9pc0JldHdlZW4sXG4gICAgY29tcGFyZTogKGEsIGIpID0+IGEgLSBiLFxuICAgIG5vcm1hbGl6ZTogeCA9PiB4XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlZ21lbnQoe3N0YXJ0LCBlbmQsIGNvdW50LCBsb29wLCBzdHlsZX0pIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQgJSBjb3VudCxcbiAgICBlbmQ6IGVuZCAlIGNvdW50LFxuICAgIGxvb3A6IGxvb3AgJiYgKGVuZCAtIHN0YXJ0ICsgMSkgJSBjb3VudCA9PT0gMCxcbiAgICBzdHlsZVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgYm91bmRzKSB7XG4gIGNvbnN0IHtwcm9wZXJ0eSwgc3RhcnQ6IHN0YXJ0Qm91bmQsIGVuZDogZW5kQm91bmR9ID0gYm91bmRzO1xuICBjb25zdCB7YmV0d2Vlbiwgbm9ybWFsaXplfSA9IHByb3BlcnR5Rm4ocHJvcGVydHkpO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgbGV0IHtzdGFydCwgZW5kLCBsb29wfSA9IHNlZ21lbnQ7XG4gIGxldCBpLCBpbGVuO1xuXG4gIGlmIChsb29wKSB7XG4gICAgc3RhcnQgKz0gY291bnQ7XG4gICAgZW5kICs9IGNvdW50O1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaWYgKCFiZXR3ZWVuKG5vcm1hbGl6ZShwb2ludHNbc3RhcnQgJSBjb3VudF1bcHJvcGVydHldKSwgc3RhcnRCb3VuZCwgZW5kQm91bmQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhcnQtLTtcbiAgICAgIGVuZC0tO1xuICAgIH1cbiAgICBzdGFydCAlPSBjb3VudDtcbiAgICBlbmQgJT0gY291bnQ7XG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICBlbmQgKz0gY291bnQ7XG4gIH1cbiAgcmV0dXJuIHtzdGFydCwgZW5kLCBsb29wLCBzdHlsZTogc2VnbWVudC5zdHlsZX07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3ViLXNlZ21lbnQocykgb2YgYSBsaW5lIHNlZ21lbnQgdGhhdCBmYWxsIGluIHRoZSBnaXZlbiBib3VuZHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBzZWdtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5zdGFydCAtIHN0YXJ0IGluZGV4IG9mIHRoZSBzZWdtZW50LCByZWZlcnJpbmcgdGhlIHBvaW50cyBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQuZW5kIC0gZW5kIGluZGV4IG9mIHRoZSBzZWdtZW50LCByZWZlcnJpbmcgdGhlIHBvaW50cyBhcnJheVxuICogQHBhcmFtIHtib29sZWFufSBzZWdtZW50Lmxvb3AgLSBpbmRpY2F0ZXMgdGhhdCB0aGUgc2VnbWVudCBpcyBhIGxvb3BcbiAqIEBwYXJhbSB7b2JqZWN0fSBbc2VnbWVudC5zdHlsZV0gLSBzZWdtZW50IHN0eWxlXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudFtdfSBwb2ludHMgLSB0aGUgcG9pbnRzIHRoYXQgdGhpcyBzZWdtZW50IHJlZmVycyB0b1xuICogQHBhcmFtIHtvYmplY3R9IFtib3VuZHNdXG4gKiBAcGFyYW0ge3N0cmluZ30gYm91bmRzLnByb3BlcnR5IC0gdGhlIHByb3BlcnR5IG9mIGEgYFBvaW50RWxlbWVudGAgd2UgYXJlIGJvdW5kaW5nLiBgeGAsIGB5YCBvciBgYW5nbGVgLlxuICogQHBhcmFtIHtudW1iZXJ9IGJvdW5kcy5zdGFydCAtIHN0YXJ0IHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuICogQHBhcmFtIHtudW1iZXJ9IGJvdW5kcy5lbmQgLSBlbmQgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4gKiBAcHJpdmF0ZVxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIF9ib3VuZFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpIHtcbiAgaWYgKCFib3VuZHMpIHtcbiAgICByZXR1cm4gW3NlZ21lbnRdO1xuICB9XG5cbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydDogc3RhcnRCb3VuZCwgZW5kOiBlbmRCb3VuZH0gPSBib3VuZHM7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3Qge2NvbXBhcmUsIGJldHdlZW4sIG5vcm1hbGl6ZX0gPSBwcm9wZXJ0eUZuKHByb3BlcnR5KTtcbiAgY29uc3Qge3N0YXJ0LCBlbmQsIGxvb3AsIHN0eWxlfSA9IGdldFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpO1xuXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgaW5zaWRlID0gZmFsc2U7XG4gIGxldCBzdWJTdGFydCA9IG51bGw7XG4gIGxldCB2YWx1ZSwgcG9pbnQsIHByZXZWYWx1ZTtcblxuICBjb25zdCBzdGFydElzQmVmb3JlID0gKCkgPT4gYmV0d2VlbihzdGFydEJvdW5kLCBwcmV2VmFsdWUsIHZhbHVlKSAmJiBjb21wYXJlKHN0YXJ0Qm91bmQsIHByZXZWYWx1ZSkgIT09IDA7XG4gIGNvbnN0IGVuZElzQmVmb3JlID0gKCkgPT4gY29tcGFyZShlbmRCb3VuZCwgdmFsdWUpID09PSAwIHx8IGJldHdlZW4oZW5kQm91bmQsIHByZXZWYWx1ZSwgdmFsdWUpO1xuICBjb25zdCBzaG91bGRTdGFydCA9ICgpID0+IGluc2lkZSB8fCBzdGFydElzQmVmb3JlKCk7XG4gIGNvbnN0IHNob3VsZFN0b3AgPSAoKSA9PiAhaW5zaWRlIHx8IGVuZElzQmVmb3JlKCk7XG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0LCBwcmV2ID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICBwb2ludCA9IHBvaW50c1tpICUgY291bnRdO1xuXG4gICAgaWYgKHBvaW50LnNraXApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhbHVlID0gbm9ybWFsaXplKHBvaW50W3Byb3BlcnR5XSk7XG5cbiAgICBpZiAodmFsdWUgPT09IHByZXZWYWx1ZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaW5zaWRlID0gYmV0d2Vlbih2YWx1ZSwgc3RhcnRCb3VuZCwgZW5kQm91bmQpO1xuXG4gICAgaWYgKHN1YlN0YXJ0ID09PSBudWxsICYmIHNob3VsZFN0YXJ0KCkpIHtcbiAgICAgIHN1YlN0YXJ0ID0gY29tcGFyZSh2YWx1ZSwgc3RhcnRCb3VuZCkgPT09IDAgPyBpIDogcHJldjtcbiAgICB9XG5cbiAgICBpZiAoc3ViU3RhcnQgIT09IG51bGwgJiYgc2hvdWxkU3RvcCgpKSB7XG4gICAgICByZXN1bHQucHVzaChub3JtYWxpemVTZWdtZW50KHtzdGFydDogc3ViU3RhcnQsIGVuZDogaSwgbG9vcCwgY291bnQsIHN0eWxlfSkpO1xuICAgICAgc3ViU3RhcnQgPSBudWxsO1xuICAgIH1cbiAgICBwcmV2ID0gaTtcbiAgICBwcmV2VmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIGlmIChzdWJTdGFydCAhPT0gbnVsbCkge1xuICAgIHJlc3VsdC5wdXNoKG5vcm1hbGl6ZVNlZ21lbnQoe3N0YXJ0OiBzdWJTdGFydCwgZW5kLCBsb29wLCBjb3VudCwgc3R5bGV9KSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2VnbWVudHMgb2YgdGhlIGxpbmUgdGhhdCBhcmUgaW5zaWRlIGdpdmVuIGJvdW5kc1xuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtvYmplY3R9IFtib3VuZHNdXG4gKiBAcGFyYW0ge3N0cmluZ30gYm91bmRzLnByb3BlcnR5IC0gdGhlIHByb3BlcnR5IHdlIGFyZSBib3VuZGluZyB3aXRoLiBgeGAsIGB5YCBvciBgYW5nbGVgLlxuICogQHBhcmFtIHtudW1iZXJ9IGJvdW5kcy5zdGFydCAtIHN0YXJ0IHZhbHVlIG9mIHRoZSBgcHJvcGVydHlgXG4gKiBAcGFyYW0ge251bWJlcn0gYm91bmRzLmVuZCAtIGVuZCB2YWx1ZSBvZiB0aGUgYHByb3BlcnR5YFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9ib3VuZFNlZ21lbnRzKGxpbmUsIGJvdW5kcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzdWIgPSBfYm91bmRTZWdtZW50KHNlZ21lbnRzW2ldLCBsaW5lLnBvaW50cywgYm91bmRzKTtcbiAgICBpZiAoc3ViLmxlbmd0aCkge1xuICAgICAgcmVzdWx0LnB1c2goLi4uc3ViKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBGaW5kIHN0YXJ0IGFuZCBlbmQgaW5kZXggb2YgYSBsaW5lLlxuICovXG5mdW5jdGlvbiBmaW5kU3RhcnRBbmRFbmQocG9pbnRzLCBjb3VudCwgbG9vcCwgc3BhbkdhcHMpIHtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGVuZCA9IGNvdW50IC0gMTtcblxuICBpZiAobG9vcCAmJiAhc3BhbkdhcHMpIHtcbiAgICAvLyBsb29wIGFuZCBub3Qgc3Bhbm5pbmcgZ2FwcywgZmlyc3QgZmluZCBhIGdhcCB0byBzdGFydCBmcm9tXG4gICAgd2hpbGUgKHN0YXJ0IDwgY291bnQgJiYgIXBvaW50c1tzdGFydF0uc2tpcCkge1xuICAgICAgc3RhcnQrKztcbiAgICB9XG4gIH1cblxuICAvLyBmaW5kIGZpcnN0IG5vbiBza2lwcGVkIHBvaW50IChhZnRlciB0aGUgZmlyc3QgZ2FwIHBvc3NpYmx5KVxuICB3aGlsZSAoc3RhcnQgPCBjb3VudCAmJiBwb2ludHNbc3RhcnRdLnNraXApIHtcbiAgICBzdGFydCsrO1xuICB9XG5cbiAgLy8gaWYgd2UgbG9vcGVkIHRvIGNvdW50LCBzdGFydCBuZWVkcyB0byBiZSAwXG4gIHN0YXJ0ICU9IGNvdW50O1xuXG4gIGlmIChsb29wKSB7XG4gICAgLy8gbG9vcCB3aWxsIGdvIHBhc3QgY291bnQsIGlmIHN0YXJ0ID4gMFxuICAgIGVuZCArPSBzdGFydDtcbiAgfVxuXG4gIHdoaWxlIChlbmQgPiBzdGFydCAmJiBwb2ludHNbZW5kICUgY291bnRdLnNraXApIHtcbiAgICBlbmQtLTtcbiAgfVxuXG4gIC8vIGVuZCBjb3VsZCBiZSBtb3JlIHRoYW4gY291bnQsIG5vcm1hbGl6ZVxuICBlbmQgJT0gY291bnQ7XG5cbiAgcmV0dXJuIHtzdGFydCwgZW5kfTtcbn1cblxuLyoqXG4gKiBDb21wdXRlIHNvbGlkIHNlZ21lbnRzIGZyb20gUG9pbnRzLCB3aGVuIHNwYW5HYXBzID09PSBmYWxzZVxuICogQHBhcmFtIHtQb2ludEVsZW1lbnRbXX0gcG9pbnRzIC0gdGhlIHBvaW50c1xuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gc3RhcnQgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSBtYXggaW5kZXggKGNhbiBnbyBwYXN0IGNvdW50IG9uIGEgbG9vcClcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcCAtIGJvb2xlYW4gaW5kaWNhdGluZyB0aGF0IHRoaXMgd291bGQgYmUgYSBsb29wIGlmIG5vIGdhcHMgYXJlIGZvdW5kXG4gKi9cbmZ1bmN0aW9uIHNvbGlkU2VnbWVudHMocG9pbnRzLCBzdGFydCwgbWF4LCBsb29wKSB7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBsYXN0ID0gc3RhcnQ7XG4gIGxldCBwcmV2ID0gcG9pbnRzW3N0YXJ0XTtcbiAgbGV0IGVuZDtcblxuICBmb3IgKGVuZCA9IHN0YXJ0ICsgMTsgZW5kIDw9IG1heDsgKytlbmQpIHtcbiAgICBjb25zdCBjdXIgPSBwb2ludHNbZW5kICUgY291bnRdO1xuICAgIGlmIChjdXIuc2tpcCB8fCBjdXIuc3RvcCkge1xuICAgICAgaWYgKCFwcmV2LnNraXApIHtcbiAgICAgICAgbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXN1bHQucHVzaCh7c3RhcnQ6IHN0YXJ0ICUgY291bnQsIGVuZDogKGVuZCAtIDEpICUgY291bnQsIGxvb3B9KTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBzdGFydCA9IGxhc3QgPSBjdXIuc3RvcCA/IGVuZCA6IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3QgPSBlbmQ7XG4gICAgICBpZiAocHJldi5za2lwKSB7XG4gICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgfVxuICAgIH1cbiAgICBwcmV2ID0gY3VyO1xuICB9XG5cbiAgaWYgKGxhc3QgIT09IG51bGwpIHtcbiAgICByZXN1bHQucHVzaCh7c3RhcnQ6IHN0YXJ0ICUgY291bnQsIGVuZDogbGFzdCAlIGNvdW50LCBsb29wfSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbXB1dGUgdGhlIGNvbnRpbnVvdXMgc2VnbWVudHMgdGhhdCBkZWZpbmUgdGhlIHdob2xlIGxpbmVcbiAqIFRoZXJlIGNhbiBiZSBza2lwcGVkIHBvaW50cyB3aXRoaW4gYSBzZWdtZW50LCBpZiBzcGFuR2FwcyBpcyB0cnVlLlxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtvYmplY3R9IFtzZWdtZW50T3B0aW9uc11cbiAqIEByZXR1cm4ge1NlZ21lbnRbXX1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY29tcHV0ZVNlZ21lbnRzKGxpbmUsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCBzcGFuR2FwcyA9IGxpbmUub3B0aW9ucy5zcGFuR2FwcztcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuXG4gIGlmICghY291bnQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBsb29wID0gISFsaW5lLl9sb29wO1xuICBjb25zdCB7c3RhcnQsIGVuZH0gPSBmaW5kU3RhcnRBbmRFbmQocG9pbnRzLCBjb3VudCwgbG9vcCwgc3BhbkdhcHMpO1xuXG4gIGlmIChzcGFuR2FwcyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBzcGxpdEJ5U3R5bGVzKGxpbmUsIFt7c3RhcnQsIGVuZCwgbG9vcH1dLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbiAgfVxuXG4gIGNvbnN0IG1heCA9IGVuZCA8IHN0YXJ0ID8gZW5kICsgY291bnQgOiBlbmQ7XG4gIGNvbnN0IGNvbXBsZXRlTG9vcCA9ICEhbGluZS5fZnVsbExvb3AgJiYgc3RhcnQgPT09IDAgJiYgZW5kID09PSBjb3VudCAtIDE7XG4gIHJldHVybiBzcGxpdEJ5U3R5bGVzKGxpbmUsIHNvbGlkU2VnbWVudHMocG9pbnRzLCBzdGFydCwgbWF4LCBjb21wbGV0ZUxvb3ApLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NlZ21lbnRbXX0gc2VnbWVudHNcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50W119IHBvaW50c1xuICogQHBhcmFtIHtvYmplY3R9IFtzZWdtZW50T3B0aW9uc11cbiAqIEByZXR1cm4ge1NlZ21lbnRbXX1cbiAqL1xuZnVuY3Rpb24gc3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucykge1xuICBpZiAoIXNlZ21lbnRPcHRpb25zIHx8ICFzZWdtZW50T3B0aW9ucy5zZXRDb250ZXh0IHx8ICFwb2ludHMpIHtcbiAgICByZXR1cm4gc2VnbWVudHM7XG4gIH1cbiAgcmV0dXJuIGRvU3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtTZWdtZW50W119IHNlZ21lbnRzXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudFtdfSBwb2ludHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBbc2VnbWVudE9wdGlvbnNdXG4gKiBAcmV0dXJuIHtTZWdtZW50W119XG4gKi9cbmZ1bmN0aW9uIGRvU3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucykge1xuICBjb25zdCBjaGFydENvbnRleHQgPSBsaW5lLl9jaGFydC5nZXRDb250ZXh0KCk7XG4gIGNvbnN0IGJhc2VTdHlsZSA9IHJlYWRTdHlsZShsaW5lLm9wdGlvbnMpO1xuICBjb25zdCB7X2RhdGFzZXRJbmRleDogZGF0YXNldEluZGV4LCBvcHRpb25zOiB7c3BhbkdhcHN9fSA9IGxpbmU7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBwcmV2U3R5bGUgPSBiYXNlU3R5bGU7XG4gIGxldCBzdGFydCA9IHNlZ21lbnRzWzBdLnN0YXJ0O1xuICBsZXQgaSA9IHN0YXJ0O1xuXG4gIGZ1bmN0aW9uIGFkZFN0eWxlKHMsIGUsIGwsIHN0KSB7XG4gICAgY29uc3QgZGlyID0gc3BhbkdhcHMgPyAtMSA6IDE7XG4gICAgaWYgKHMgPT09IGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gU3R5bGUgY2FuIG5vdCBzdGFydC9lbmQgb24gYSBza2lwcGVkIHBvaW50LCBhZGp1c3QgaW5kaWNlcyBhY2NvcmRpbmdseVxuICAgIHMgKz0gY291bnQ7XG4gICAgd2hpbGUgKHBvaW50c1tzICUgY291bnRdLnNraXApIHtcbiAgICAgIHMgLT0gZGlyO1xuICAgIH1cbiAgICB3aGlsZSAocG9pbnRzW2UgJSBjb3VudF0uc2tpcCkge1xuICAgICAgZSArPSBkaXI7XG4gICAgfVxuICAgIGlmIChzICUgY291bnQgIT09IGUgJSBjb3VudCkge1xuICAgICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzICUgY291bnQsIGVuZDogZSAlIGNvdW50LCBsb29wOiBsLCBzdHlsZTogc3R9KTtcbiAgICAgIHByZXZTdHlsZSA9IHN0O1xuICAgICAgc3RhcnQgPSBlICUgY291bnQ7XG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgc3RhcnQgPSBzcGFuR2FwcyA/IHN0YXJ0IDogc2VnbWVudC5zdGFydDtcbiAgICBsZXQgcHJldiA9IHBvaW50c1tzdGFydCAlIGNvdW50XTtcbiAgICBsZXQgc3R5bGU7XG4gICAgZm9yIChpID0gc3RhcnQgKyAxOyBpIDw9IHNlZ21lbnQuZW5kOyBpKyspIHtcbiAgICAgIGNvbnN0IHB0ID0gcG9pbnRzW2kgJSBjb3VudF07XG4gICAgICBzdHlsZSA9IHJlYWRTdHlsZShzZWdtZW50T3B0aW9ucy5zZXRDb250ZXh0KGNyZWF0ZUNvbnRleHQoY2hhcnRDb250ZXh0LCB7XG4gICAgICAgIHR5cGU6ICdzZWdtZW50JyxcbiAgICAgICAgcDA6IHByZXYsXG4gICAgICAgIHAxOiBwdCxcbiAgICAgICAgcDBEYXRhSW5kZXg6IChpIC0gMSkgJSBjb3VudCxcbiAgICAgICAgcDFEYXRhSW5kZXg6IGkgJSBjb3VudCxcbiAgICAgICAgZGF0YXNldEluZGV4XG4gICAgICB9KSkpO1xuICAgICAgaWYgKHN0eWxlQ2hhbmdlZChzdHlsZSwgcHJldlN0eWxlKSkge1xuICAgICAgICBhZGRTdHlsZShzdGFydCwgaSAtIDEsIHNlZ21lbnQubG9vcCwgcHJldlN0eWxlKTtcbiAgICAgIH1cbiAgICAgIHByZXYgPSBwdDtcbiAgICAgIHByZXZTdHlsZSA9IHN0eWxlO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgPCBpIC0gMSkge1xuICAgICAgYWRkU3R5bGUoc3RhcnQsIGkgLSAxLCBzZWdtZW50Lmxvb3AsIHByZXZTdHlsZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcmVhZFN0eWxlKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuICAgIGJvcmRlckNhcFN0eWxlOiBvcHRpb25zLmJvcmRlckNhcFN0eWxlLFxuICAgIGJvcmRlckRhc2g6IG9wdGlvbnMuYm9yZGVyRGFzaCxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgYm9yZGVySm9pblN0eWxlOiBvcHRpb25zLmJvcmRlckpvaW5TdHlsZSxcbiAgICBib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcbiAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvclxuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUNoYW5nZWQoc3R5bGUsIHByZXZTdHlsZSkge1xuICBpZiAoIXByZXZTdHlsZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBjYWNoZSA9IFtdO1xuICBjb25zdCByZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzUGF0dGVybk9yR3JhZGllbnQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICghY2FjaGUuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICBjYWNoZS5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlLmluZGV4T2YodmFsdWUpO1xuICB9O1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3R5bGUsIHJlcGxhY2VyKSAhPT0gSlNPTi5zdHJpbmdpZnkocHJldlN0eWxlLCByZXBsYWNlcik7XG59XG4iLCAiaW1wb3J0IHtyZXF1ZXN0QW5pbUZyYW1lfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmFuaW1hdGlvbi5qcycpLmRlZmF1bHQgfSBBbmltYXRpb25cbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICovXG5cbi8qKlxuICogUGxlYXNlIHVzZSB0aGUgbW9kdWxlJ3MgZGVmYXVsdCBleHBvcnQgd2hpY2ggcHJvdmlkZXMgYSBzaW5nbGV0b24gaW5zdGFuY2VcbiAqIE5vdGU6IGNsYXNzIGlzIGV4cG9ydCBmb3IgdHlwZWRvY1xuICovXG5leHBvcnQgY2xhc3MgQW5pbWF0b3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICB0aGlzLl9jaGFydHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2xhc3REYXRlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgdHlwZSkge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IGFuaW1zLmxpc3RlbmVyc1t0eXBlXTtcbiAgICBjb25zdCBudW1TdGVwcyA9IGFuaW1zLmR1cmF0aW9uO1xuXG4gICAgY2FsbGJhY2tzLmZvckVhY2goZm4gPT4gZm4oe1xuICAgICAgY2hhcnQsXG4gICAgICBpbml0aWFsOiBhbmltcy5pbml0aWFsLFxuICAgICAgbnVtU3RlcHMsXG4gICAgICBjdXJyZW50U3RlcDogTWF0aC5taW4oZGF0ZSAtIGFuaW1zLnN0YXJ0LCBudW1TdGVwcylcbiAgICB9KSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZWZyZXNoKCkge1xuICAgIGlmICh0aGlzLl9yZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuXG4gICAgdGhpcy5fcmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csICgpID0+IHtcbiAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLl9ydW5uaW5nKSB7XG4gICAgICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZShkYXRlID0gRGF0ZS5ub3coKSkge1xuICAgIGxldCByZW1haW5pbmcgPSAwO1xuXG4gICAgdGhpcy5fY2hhcnRzLmZvckVhY2goKGFuaW1zLCBjaGFydCkgPT4ge1xuICAgICAgaWYgKCFhbmltcy5ydW5uaW5nIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaXRlbXMgPSBhbmltcy5pdGVtcztcbiAgICAgIGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICAgIGxldCBkcmF3ID0gZmFsc2U7XG4gICAgICBsZXQgaXRlbTtcblxuICAgICAgZm9yICg7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcblxuICAgICAgICBpZiAoaXRlbS5fYWN0aXZlKSB7XG4gICAgICAgICAgaWYgKGl0ZW0uX3RvdGFsID4gYW5pbXMuZHVyYXRpb24pIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBhbmltYXRpb24gaGFzIGJlZW4gdXBkYXRlZCBhbmQgaXRzIGR1cmF0aW9uIHByb2xvbmdlZCxcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0byB0b3RhbCBkdXJhdGlvbiBvZiBjdXJyZW50IGFuaW1hdGlvbnMgcnVuIChmb3IgcHJvZ3Jlc3MgZXZlbnQpXG4gICAgICAgICAgICBhbmltcy5kdXJhdGlvbiA9IGl0ZW0uX3RvdGFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVtLnRpY2soZGF0ZSk7XG4gICAgICAgICAgZHJhdyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIHRoZSBpdGVtIGJ5IHJlcGxhY2luZyBpdCB3aXRoIGxhc3QgaXRlbSBhbmQgcmVtb3ZpbmcgdGhlIGxhc3RcbiAgICAgICAgICAvLyBBIGxvdCBmYXN0ZXIgdGhhbiBzcGxpY2UuXG4gICAgICAgICAgaXRlbXNbaV0gPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpdGVtcy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZHJhdykge1xuICAgICAgICBjaGFydC5kcmF3KCk7XG4gICAgICAgIHRoaXMuX25vdGlmeShjaGFydCwgYW5pbXMsIGRhdGUsICdwcm9ncmVzcycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICBhbmltcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX25vdGlmeShjaGFydCwgYW5pbXMsIGRhdGUsICdjb21wbGV0ZScpO1xuICAgICAgICBhbmltcy5pbml0aWFsID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJlbWFpbmluZyArPSBpdGVtcy5sZW5ndGg7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9sYXN0RGF0ZSA9IGRhdGU7XG5cbiAgICBpZiAocmVtYWluaW5nID09PSAwKSB7XG4gICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0QW5pbXMoY2hhcnQpIHtcbiAgICBjb25zdCBjaGFydHMgPSB0aGlzLl9jaGFydHM7XG4gICAgbGV0IGFuaW1zID0gY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcykge1xuICAgICAgYW5pbXMgPSB7XG4gICAgICAgIHJ1bm5pbmc6IGZhbHNlLFxuICAgICAgICBpbml0aWFsOiB0cnVlLFxuICAgICAgICBpdGVtczogW10sXG4gICAgICAgIGxpc3RlbmVyczoge1xuICAgICAgICAgIGNvbXBsZXRlOiBbXSxcbiAgICAgICAgICBwcm9ncmVzczogW11cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNoYXJ0cy5zZXQoY2hhcnQsIGFuaW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1zO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCAtIGV2ZW50IG5hbWVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBjYWxsYmFja1xuXHQgKi9cbiAgbGlzdGVuKGNoYXJ0LCBldmVudCwgY2IpIHtcbiAgICB0aGlzLl9nZXRBbmltcyhjaGFydCkubGlzdGVuZXJzW2V2ZW50XS5wdXNoKGNiKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGQgYW5pbWF0aW9uc1xuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcGFyYW0ge0FuaW1hdGlvbltdfSBpdGVtcyAtIGFuaW1hdGlvbnNcblx0ICovXG4gIGFkZChjaGFydCwgaXRlbXMpIHtcbiAgICBpZiAoIWl0ZW1zIHx8ICFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLml0ZW1zLnB1c2goLi4uaXRlbXMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENvdW50cyBudW1iZXIgb2YgYWN0aXZlIGFuaW1hdGlvbnMgZm9yIHRoZSBjaGFydFxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKi9cbiAgaGFzKGNoYXJ0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5pdGVtcy5sZW5ndGggPiAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIFN0YXJ0IGFuaW1hdGluZyAoYWxsIGNoYXJ0cylcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICovXG4gIHN0YXJ0KGNoYXJ0KSB7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFuaW1zLnJ1bm5pbmcgPSB0cnVlO1xuICAgIGFuaW1zLnN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBhbmltcy5kdXJhdGlvbiA9IGFuaW1zLml0ZW1zLnJlZHVjZSgoYWNjLCBjdXIpID0+IE1hdGgubWF4KGFjYywgY3VyLl9kdXJhdGlvbiksIDApO1xuICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgfVxuXG4gIHJ1bm5pbmcoY2hhcnQpIHtcbiAgICBpZiAoIXRoaXMuX3J1bm5pbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zIHx8ICFhbmltcy5ydW5uaW5nIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcblx0ICogU3RvcCBhbGwgYW5pbWF0aW9ucyBmb3IgdGhlIGNoYXJ0XG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqL1xuICBzdG9wKGNoYXJ0KSB7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXRlbXMgPSBhbmltcy5pdGVtcztcbiAgICBsZXQgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7XG5cbiAgICBmb3IgKDsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGl0ZW1zW2ldLmNhbmNlbCgpO1xuICAgIH1cbiAgICBhbmltcy5pdGVtcyA9IFtdO1xuICAgIHRoaXMuX25vdGlmeShjaGFydCwgYW5pbXMsIERhdGUubm93KCksICdjb21wbGV0ZScpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJlbW92ZSBjaGFydCBmcm9tIEFuaW1hdG9yXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqL1xuICByZW1vdmUoY2hhcnQpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hhcnRzLmRlbGV0ZShjaGFydCk7XG4gIH1cbn1cblxuLy8gc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgZGVmYXVsdCAvKiAjX19QVVJFX18gKi8gbmV3IEFuaW1hdG9yKCk7XG4iLCAiaW1wb3J0IGVmZmVjdHMgZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmVhc2luZy5qcyc7XG5pbXBvcnQge3Jlc29sdmV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcbmltcG9ydCB7Y29sb3IgYXMgaGVscGVyc0NvbG9yfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29sb3IuanMnO1xuXG5jb25zdCB0cmFuc3BhcmVudCA9ICd0cmFuc3BhcmVudCc7XG5jb25zdCBpbnRlcnBvbGF0b3JzID0ge1xuICBib29sZWFuKGZyb20sIHRvLCBmYWN0b3IpIHtcbiAgICByZXR1cm4gZmFjdG9yID4gMC41ID8gdG8gOiBmcm9tO1xuICB9LFxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZyb21cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmYWN0b3JcbiAgICovXG4gIGNvbG9yKGZyb20sIHRvLCBmYWN0b3IpIHtcbiAgICBjb25zdCBjMCA9IGhlbHBlcnNDb2xvcihmcm9tIHx8IHRyYW5zcGFyZW50KTtcbiAgICBjb25zdCBjMSA9IGMwLnZhbGlkICYmIGhlbHBlcnNDb2xvcih0byB8fCB0cmFuc3BhcmVudCk7XG4gICAgcmV0dXJuIGMxICYmIGMxLnZhbGlkXG4gICAgICA/IGMxLm1peChjMCwgZmFjdG9yKS5oZXhTdHJpbmcoKVxuICAgICAgOiB0bztcbiAgfSxcbiAgbnVtYmVyKGZyb20sIHRvLCBmYWN0b3IpIHtcbiAgICByZXR1cm4gZnJvbSArICh0byAtIGZyb20pICogZmFjdG9yO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRpb24ge1xuICBjb25zdHJ1Y3RvcihjZmcsIHRhcmdldCwgcHJvcCwgdG8pIHtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0YXJnZXRbcHJvcF07XG5cbiAgICB0byA9IHJlc29sdmUoW2NmZy50bywgdG8sIGN1cnJlbnRWYWx1ZSwgY2ZnLmZyb21dKTtcbiAgICBjb25zdCBmcm9tID0gcmVzb2x2ZShbY2ZnLmZyb20sIGN1cnJlbnRWYWx1ZSwgdG9dKTtcblxuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5fZm4gPSBjZmcuZm4gfHwgaW50ZXJwb2xhdG9yc1tjZmcudHlwZSB8fCB0eXBlb2YgZnJvbV07XG4gICAgdGhpcy5fZWFzaW5nID0gZWZmZWN0c1tjZmcuZWFzaW5nXSB8fCBlZmZlY3RzLmxpbmVhcjtcbiAgICB0aGlzLl9zdGFydCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSArIChjZmcuZGVsYXkgfHwgMCkpO1xuICAgIHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fdG90YWwgPSBNYXRoLmZsb29yKGNmZy5kdXJhdGlvbik7XG4gICAgdGhpcy5fbG9vcCA9ICEhY2ZnLmxvb3A7XG4gICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMuX3Byb3AgPSBwcm9wO1xuICAgIHRoaXMuX2Zyb20gPSBmcm9tO1xuICAgIHRoaXMuX3RvID0gdG87XG4gICAgdGhpcy5fcHJvbWlzZXMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgfVxuXG4gIHVwZGF0ZShjZmcsIHRvLCBkYXRlKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fbm90aWZ5KGZhbHNlKTtcblxuICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy5fdGFyZ2V0W3RoaXMuX3Byb3BdO1xuICAgICAgY29uc3QgZWxhcHNlZCA9IGRhdGUgLSB0aGlzLl9zdGFydDtcbiAgICAgIGNvbnN0IHJlbWFpbiA9IHRoaXMuX2R1cmF0aW9uIC0gZWxhcHNlZDtcbiAgICAgIHRoaXMuX3N0YXJ0ID0gZGF0ZTtcbiAgICAgIHRoaXMuX2R1cmF0aW9uID0gTWF0aC5mbG9vcihNYXRoLm1heChyZW1haW4sIGNmZy5kdXJhdGlvbikpO1xuICAgICAgdGhpcy5fdG90YWwgKz0gZWxhcHNlZDtcbiAgICAgIHRoaXMuX2xvb3AgPSAhIWNmZy5sb29wO1xuICAgICAgdGhpcy5fdG8gPSByZXNvbHZlKFtjZmcudG8sIHRvLCBjdXJyZW50VmFsdWUsIGNmZy5mcm9tXSk7XG4gICAgICB0aGlzLl9mcm9tID0gcmVzb2x2ZShbY2ZnLmZyb20sIGN1cnJlbnRWYWx1ZSwgdG9dKTtcbiAgICB9XG4gIH1cblxuICBjYW5jZWwoKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgLy8gdXBkYXRlIGN1cnJlbnQgZXZhbHVhdGVkIHZhbHVlLCBmb3Igc21vb3RoZXIgYW5pbWF0aW9uc1xuICAgICAgdGhpcy50aWNrKERhdGUubm93KCkpO1xuICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLl9ub3RpZnkoZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIHRpY2soZGF0ZSkge1xuICAgIGNvbnN0IGVsYXBzZWQgPSBkYXRlIC0gdGhpcy5fc3RhcnQ7XG4gICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbjtcbiAgICBjb25zdCBwcm9wID0gdGhpcy5fcHJvcDtcbiAgICBjb25zdCBmcm9tID0gdGhpcy5fZnJvbTtcbiAgICBjb25zdCBsb29wID0gdGhpcy5fbG9vcDtcbiAgICBjb25zdCB0byA9IHRoaXMuX3RvO1xuICAgIGxldCBmYWN0b3I7XG5cbiAgICB0aGlzLl9hY3RpdmUgPSBmcm9tICE9PSB0byAmJiAobG9vcCB8fCAoZWxhcHNlZCA8IGR1cmF0aW9uKSk7XG5cbiAgICBpZiAoIXRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gdG87XG4gICAgICB0aGlzLl9ub3RpZnkodHJ1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsYXBzZWQgPCAwKSB7XG4gICAgICB0aGlzLl90YXJnZXRbcHJvcF0gPSBmcm9tO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZhY3RvciA9IChlbGFwc2VkIC8gZHVyYXRpb24pICUgMjtcbiAgICBmYWN0b3IgPSBsb29wICYmIGZhY3RvciA+IDEgPyAyIC0gZmFjdG9yIDogZmFjdG9yO1xuICAgIGZhY3RvciA9IHRoaXMuX2Vhc2luZyhNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBmYWN0b3IpKSk7XG5cbiAgICB0aGlzLl90YXJnZXRbcHJvcF0gPSB0aGlzLl9mbihmcm9tLCB0bywgZmFjdG9yKTtcbiAgfVxuXG4gIHdhaXQoKSB7XG4gICAgY29uc3QgcHJvbWlzZXMgPSB0aGlzLl9wcm9taXNlcyB8fCAodGhpcy5fcHJvbWlzZXMgPSBbXSk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgcHJvbWlzZXMucHVzaCh7cmVzLCByZWp9KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9ub3RpZnkocmVzb2x2ZWQpIHtcbiAgICBjb25zdCBtZXRob2QgPSByZXNvbHZlZCA/ICdyZXMnIDogJ3Jlaic7XG4gICAgY29uc3QgcHJvbWlzZXMgPSB0aGlzLl9wcm9taXNlcyB8fCBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb21pc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwcm9taXNlc1tpXVttZXRob2RdKCk7XG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IGFuaW1hdG9yIGZyb20gJy4vY29yZS5hbmltYXRvci5qcyc7XG5pbXBvcnQgQW5pbWF0aW9uIGZyb20gJy4vY29yZS5hbmltYXRpb24uanMnO1xuaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4vY29yZS5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge2lzQXJyYXksIGlzT2JqZWN0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGlvbnMge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgY29uZmlnKSB7XG4gICAgdGhpcy5fY2hhcnQgPSBjaGFydDtcbiAgICB0aGlzLl9wcm9wZXJ0aWVzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuY29uZmlndXJlKGNvbmZpZyk7XG4gIH1cblxuICBjb25maWd1cmUoY29uZmlnKSB7XG4gICAgaWYgKCFpc09iamVjdChjb25maWcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzLmFuaW1hdGlvbik7XG4gICAgY29uc3QgYW5pbWF0ZWRQcm9wcyA9IHRoaXMuX3Byb3BlcnRpZXM7XG5cbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjb25maWcpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IGNmZyA9IGNvbmZpZ1trZXldO1xuICAgICAgaWYgKCFpc09iamVjdChjZmcpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc29sdmVkID0ge307XG4gICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBhbmltYXRpb25PcHRpb25zKSB7XG4gICAgICAgIHJlc29sdmVkW29wdGlvbl0gPSBjZmdbb3B0aW9uXTtcbiAgICAgIH1cblxuICAgICAgKGlzQXJyYXkoY2ZnLnByb3BlcnRpZXMpICYmIGNmZy5wcm9wZXJ0aWVzIHx8IFtrZXldKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgIGlmIChwcm9wID09PSBrZXkgfHwgIWFuaW1hdGVkUHJvcHMuaGFzKHByb3ApKSB7XG4gICAgICAgICAgYW5pbWF0ZWRQcm9wcy5zZXQocHJvcCwgcmVzb2x2ZWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IHRvIGhhbmRsZSBhbmltYXRpb24gb2YgYG9wdGlvbnNgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2FuaW1hdGVPcHRpb25zKHRhcmdldCwgdmFsdWVzKSB7XG4gICAgY29uc3QgbmV3T3B0aW9ucyA9IHZhbHVlcy5vcHRpb25zO1xuICAgIGNvbnN0IG9wdGlvbnMgPSByZXNvbHZlVGFyZ2V0T3B0aW9ucyh0YXJnZXQsIG5ld09wdGlvbnMpO1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLl9jcmVhdGVBbmltYXRpb25zKG9wdGlvbnMsIG5ld09wdGlvbnMpO1xuICAgIGlmIChuZXdPcHRpb25zLiRzaGFyZWQpIHtcbiAgICAgIC8vIEdvaW5nIHRvIHNoYXJlZCBvcHRpb25zOlxuICAgICAgLy8gQWZ0ZXIgYWxsIGFuaW1hdGlvbnMgYXJlIGRvbmUsIGFzc2lnbiB0aGUgc2hhcmVkIG9wdGlvbnMgb2JqZWN0IHRvIHRoZSBlbGVtZW50XG4gICAgICAvLyBTbyBhbnkgbmV3IHVwZGF0ZXMgdG8gdGhlIHNoYXJlZCBvcHRpb25zIGFyZSBvYnNlcnZlZFxuICAgICAgYXdhaXRBbGwodGFyZ2V0Lm9wdGlvbnMuJGFuaW1hdGlvbnMsIG5ld09wdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0YXJnZXQub3B0aW9ucyA9IG5ld09wdGlvbnM7XG4gICAgICB9LCAoKSA9PiB7XG4gICAgICAgIC8vIHJlamVjdGVkLCBub29wXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NyZWF0ZUFuaW1hdGlvbnModGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBjb25zdCBhbmltYXRlZFByb3BzID0gdGhpcy5fcHJvcGVydGllcztcbiAgICBjb25zdCBhbmltYXRpb25zID0gW107XG4gICAgY29uc3QgcnVubmluZyA9IHRhcmdldC4kYW5pbWF0aW9ucyB8fCAodGFyZ2V0LiRhbmltYXRpb25zID0ge30pO1xuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXModmFsdWVzKTtcbiAgICBjb25zdCBkYXRlID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgaTtcblxuICAgIGZvciAoaSA9IHByb3BzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBwcm9wID0gcHJvcHNbaV07XG4gICAgICBpZiAocHJvcC5jaGFyQXQoMCkgPT09ICckJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3AgPT09ICdvcHRpb25zJykge1xuICAgICAgICBhbmltYXRpb25zLnB1c2goLi4udGhpcy5fYW5pbWF0ZU9wdGlvbnModGFyZ2V0LCB2YWx1ZXMpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1twcm9wXTtcbiAgICAgIGxldCBhbmltYXRpb24gPSBydW5uaW5nW3Byb3BdO1xuICAgICAgY29uc3QgY2ZnID0gYW5pbWF0ZWRQcm9wcy5nZXQocHJvcCk7XG5cbiAgICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgICAgaWYgKGNmZyAmJiBhbmltYXRpb24uYWN0aXZlKCkpIHtcbiAgICAgICAgICAvLyBUaGVyZSBpcyBhbiBleGlzdGluZyBhY3RpdmUgYW5pbWF0aW9uLCBsZXQncyB1cGRhdGUgdGhhdFxuICAgICAgICAgIGFuaW1hdGlvbi51cGRhdGUoY2ZnLCB2YWx1ZSwgZGF0ZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWNmZyB8fCAhY2ZnLmR1cmF0aW9uKSB7XG4gICAgICAgIC8vIG5vdCBhbmltYXRlZCwgc2V0IGRpcmVjdGx5IHRvIG5ldyB2YWx1ZVxuICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJ1bm5pbmdbcHJvcF0gPSBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKGNmZywgdGFyZ2V0LCBwcm9wLCB2YWx1ZSk7XG4gICAgICBhbmltYXRpb25zLnB1c2goYW5pbWF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cblxuXG4gIC8qKlxuXHQgKiBVcGRhdGUgYHRhcmdldGAgcHJvcGVydGllcyB0byBuZXcgdmFsdWVzLCB1c2luZyBjb25maWd1cmVkIGFuaW1hdGlvbnNcblx0ICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCAtIG9iamVjdCB0byB1cGRhdGVcblx0ICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyAtIG5ldyB0YXJnZXQgcHJvcGVydGllc1xuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbnx1bmRlZmluZWR9IC0gYHRydWVgIGlmIGFuaW1hdGlvbnMgd2VyZSBzdGFydGVkXG5cdCAqKi9cbiAgdXBkYXRlKHRhcmdldCwgdmFsdWVzKSB7XG4gICAgaWYgKHRoaXMuX3Byb3BlcnRpZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgLy8gTm90aGluZyBpcyBhbmltYXRlZCwganVzdCBhcHBseSB0aGUgbmV3IHZhbHVlcy5cbiAgICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB2YWx1ZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLl9jcmVhdGVBbmltYXRpb25zKHRhcmdldCwgdmFsdWVzKTtcblxuICAgIGlmIChhbmltYXRpb25zLmxlbmd0aCkge1xuICAgICAgYW5pbWF0b3IuYWRkKHRoaXMuX2NoYXJ0LCBhbmltYXRpb25zKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhd2FpdEFsbChhbmltYXRpb25zLCBwcm9wZXJ0aWVzKSB7XG4gIGNvbnN0IHJ1bm5pbmcgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhbmltID0gYW5pbWF0aW9uc1trZXlzW2ldXTtcbiAgICBpZiAoYW5pbSAmJiBhbmltLmFjdGl2ZSgpKSB7XG4gICAgICBydW5uaW5nLnB1c2goYW5pbS53YWl0KCkpO1xuICAgIH1cbiAgfVxuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiBQcm9taXNlLmFsbChydW5uaW5nKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldE9wdGlvbnModGFyZ2V0LCBuZXdPcHRpb25zKSB7XG4gIGlmICghbmV3T3B0aW9ucykge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgb3B0aW9ucyA9IHRhcmdldC5vcHRpb25zO1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICB0YXJnZXQub3B0aW9ucyA9IG5ld09wdGlvbnM7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChvcHRpb25zLiRzaGFyZWQpIHtcbiAgICAvLyBHb2luZyBmcm9tIHNoYXJlZCBvcHRpb25zIHRvIGRpc3RpbmN0IG9uZTpcbiAgICAvLyBDcmVhdGUgbmV3IG9wdGlvbnMgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9sZCBzaGFyZWQgdmFsdWVzIGFuZCBzdGFydCB1cGRhdGluZyB0aGF0LlxuICAgIHRhcmdldC5vcHRpb25zID0gb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHskc2hhcmVkOiBmYWxzZSwgJGFuaW1hdGlvbnM6IHt9fSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG4iLCAiaW1wb3J0IEFuaW1hdGlvbnMgZnJvbSAnLi9jb3JlLmFuaW1hdGlvbnMuanMnO1xuaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4vY29yZS5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge2lzQXJyYXksIGlzRmluaXRlLCBpc09iamVjdCwgdmFsdWVPckRlZmF1bHQsIHJlc29sdmVPYmplY3RLZXksIGRlZmluZWR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7bGlzdGVuQXJyYXlFdmVudHMsIHVubGlzdGVuQXJyYXlFdmVudHN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb2xsZWN0aW9uLmpzJztcbmltcG9ydCB7Y3JlYXRlQ29udGV4dCwgc2lnbn0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLnNjYWxlLmpzJykuZGVmYXVsdCB9IFNjYWxlXG4gKi9cblxuZnVuY3Rpb24gc2NhbGVDbGlwKHNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpIHtcbiAgY29uc3Qgb3B0cyA9IHNjYWxlICYmIHNjYWxlLm9wdGlvbnMgfHwge307XG4gIGNvbnN0IHJldmVyc2UgPSBvcHRzLnJldmVyc2U7XG4gIGNvbnN0IG1pbiA9IG9wdHMubWluID09PSB1bmRlZmluZWQgPyBhbGxvd2VkT3ZlcmZsb3cgOiAwO1xuICBjb25zdCBtYXggPSBvcHRzLm1heCA9PT0gdW5kZWZpbmVkID8gYWxsb3dlZE92ZXJmbG93IDogMDtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogcmV2ZXJzZSA/IG1heCA6IG1pbixcbiAgICBlbmQ6IHJldmVyc2UgPyBtaW4gOiBtYXhcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENsaXAoeFNjYWxlLCB5U2NhbGUsIGFsbG93ZWRPdmVyZmxvdykge1xuICBpZiAoYWxsb3dlZE92ZXJmbG93ID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB4ID0gc2NhbGVDbGlwKHhTY2FsZSwgYWxsb3dlZE92ZXJmbG93KTtcbiAgY29uc3QgeSA9IHNjYWxlQ2xpcCh5U2NhbGUsIGFsbG93ZWRPdmVyZmxvdyk7XG5cbiAgcmV0dXJuIHtcbiAgICB0b3A6IHkuZW5kLFxuICAgIHJpZ2h0OiB4LmVuZCxcbiAgICBib3R0b206IHkuc3RhcnQsXG4gICAgbGVmdDogeC5zdGFydFxuICB9O1xufVxuXG5mdW5jdGlvbiB0b0NsaXAodmFsdWUpIHtcbiAgbGV0IHQsIHIsIGIsIGw7XG5cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHQgPSB2YWx1ZS50b3A7XG4gICAgciA9IHZhbHVlLnJpZ2h0O1xuICAgIGIgPSB2YWx1ZS5ib3R0b207XG4gICAgbCA9IHZhbHVlLmxlZnQ7XG4gIH0gZWxzZSB7XG4gICAgdCA9IHIgPSBiID0gbCA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b3A6IHQsXG4gICAgcmlnaHQ6IHIsXG4gICAgYm90dG9tOiBiLFxuICAgIGxlZnQ6IGwsXG4gICAgZGlzYWJsZWQ6IHZhbHVlID09PSBmYWxzZVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyhjaGFydCwgZmlsdGVyVmlzaWJsZSkge1xuICBjb25zdCBrZXlzID0gW107XG4gIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuX2dldFNvcnRlZERhdGFzZXRNZXRhcyhmaWx0ZXJWaXNpYmxlKTtcbiAgbGV0IGksIGlsZW47XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGtleXMucHVzaChtZXRhc2V0c1tpXS5pbmRleCk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIGFwcGx5U3RhY2soc3RhY2ssIHZhbHVlLCBkc0luZGV4LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qga2V5cyA9IHN0YWNrLmtleXM7XG4gIGNvbnN0IHNpbmdsZU1vZGUgPSBvcHRpb25zLm1vZGUgPT09ICdzaW5nbGUnO1xuICBsZXQgaSwgaWxlbiwgZGF0YXNldEluZGV4LCBvdGhlclZhbHVlO1xuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBmb3VuZCA9IGZhbHNlO1xuICBmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBkYXRhc2V0SW5kZXggPSAra2V5c1tpXTtcbiAgICBpZiAoZGF0YXNldEluZGV4ID09PSBkc0luZGV4KSB7XG4gICAgICBmb3VuZCA9IHRydWU7XG4gICAgICBpZiAob3B0aW9ucy5hbGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb3RoZXJWYWx1ZSA9IHN0YWNrLnZhbHVlc1tkYXRhc2V0SW5kZXhdO1xuICAgIGlmIChpc0Zpbml0ZShvdGhlclZhbHVlKSAmJiAoc2luZ2xlTW9kZSB8fCAodmFsdWUgPT09IDAgfHwgc2lnbih2YWx1ZSkgPT09IHNpZ24ob3RoZXJWYWx1ZSkpKSkge1xuICAgICAgdmFsdWUgKz0gb3RoZXJWYWx1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWZvdW5kICYmICFvcHRpb25zLmFsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkoZGF0YSwgbWV0YSkge1xuICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgY29uc3QgaUF4aXNLZXkgPSBpU2NhbGUuYXhpcyA9PT0gJ3gnID8gJ3gnIDogJ3knO1xuICBjb25zdCB2QXhpc0tleSA9IHZTY2FsZS5heGlzID09PSAneCcgPyAneCcgOiAneSc7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgY29uc3QgYWRhdGEgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICBsZXQgaSwgaWxlbiwga2V5O1xuICBmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIGFkYXRhW2ldID0ge1xuICAgICAgW2lBeGlzS2V5XToga2V5LFxuICAgICAgW3ZBeGlzS2V5XTogZGF0YVtrZXldXG4gICAgfTtcbiAgfVxuICByZXR1cm4gYWRhdGE7XG59XG5cbmZ1bmN0aW9uIGlzU3RhY2tlZChzY2FsZSwgbWV0YSkge1xuICBjb25zdCBzdGFja2VkID0gc2NhbGUgJiYgc2NhbGUub3B0aW9ucy5zdGFja2VkO1xuICByZXR1cm4gc3RhY2tlZCB8fCAoc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIG1ldGEuc3RhY2sgIT09IHVuZGVmaW5lZCk7XG59XG5cbmZ1bmN0aW9uIGdldFN0YWNrS2V5KGluZGV4U2NhbGUsIHZhbHVlU2NhbGUsIG1ldGEpIHtcbiAgcmV0dXJuIGAke2luZGV4U2NhbGUuaWR9LiR7dmFsdWVTY2FsZS5pZH0uJHttZXRhLnN0YWNrIHx8IG1ldGEudHlwZX1gO1xufVxuXG5mdW5jdGlvbiBnZXRVc2VyQm91bmRzKHNjYWxlKSB7XG4gIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBzY2FsZS5nZXRVc2VyQm91bmRzKCk7XG4gIHJldHVybiB7XG4gICAgbWluOiBtaW5EZWZpbmVkID8gbWluIDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxuICAgIG1heDogbWF4RGVmaW5lZCA/IG1heCA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRPckNyZWF0ZVN0YWNrKHN0YWNrcywgc3RhY2tLZXksIGluZGV4VmFsdWUpIHtcbiAgY29uc3Qgc3ViU3RhY2sgPSBzdGFja3Nbc3RhY2tLZXldIHx8IChzdGFja3Nbc3RhY2tLZXldID0ge30pO1xuICByZXR1cm4gc3ViU3RhY2tbaW5kZXhWYWx1ZV0gfHwgKHN1YlN0YWNrW2luZGV4VmFsdWVdID0ge30pO1xufVxuXG5mdW5jdGlvbiBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIHBvc2l0aXZlLCB0eXBlKSB7XG4gIGZvciAoY29uc3QgbWV0YSBvZiB2U2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSkucmV2ZXJzZSgpKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzdGFja1ttZXRhLmluZGV4XTtcbiAgICBpZiAoKHBvc2l0aXZlICYmIHZhbHVlID4gMCkgfHwgKCFwb3NpdGl2ZSAmJiB2YWx1ZSA8IDApKSB7XG4gICAgICByZXR1cm4gbWV0YS5pbmRleDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3RhY2tzKGNvbnRyb2xsZXIsIHBhcnNlZCkge1xuICBjb25zdCB7Y2hhcnQsIF9jYWNoZWRNZXRhOiBtZXRhfSA9IGNvbnRyb2xsZXI7XG4gIGNvbnN0IHN0YWNrcyA9IGNoYXJ0Ll9zdGFja3MgfHwgKGNoYXJ0Ll9zdGFja3MgPSB7fSk7IC8vIG1hcCBzdHJ1Y3R1cmUgaXMge3N0YWNrS2V5OiB7ZGF0YXNldEluZGV4OiB2YWx1ZX19XG4gIGNvbnN0IHtpU2NhbGUsIHZTY2FsZSwgaW5kZXg6IGRhdGFzZXRJbmRleH0gPSBtZXRhO1xuICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICBjb25zdCBrZXkgPSBnZXRTdGFja0tleShpU2NhbGUsIHZTY2FsZSwgbWV0YSk7XG4gIGNvbnN0IGlsZW4gPSBwYXJzZWQubGVuZ3RoO1xuICBsZXQgc3RhY2s7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjb25zdCBpdGVtID0gcGFyc2VkW2ldO1xuICAgIGNvbnN0IHtbaUF4aXNdOiBpbmRleCwgW3ZBeGlzXTogdmFsdWV9ID0gaXRlbTtcbiAgICBjb25zdCBpdGVtU3RhY2tzID0gaXRlbS5fc3RhY2tzIHx8IChpdGVtLl9zdGFja3MgPSB7fSk7XG4gICAgc3RhY2sgPSBpdGVtU3RhY2tzW3ZBeGlzXSA9IGdldE9yQ3JlYXRlU3RhY2soc3RhY2tzLCBrZXksIGluZGV4KTtcbiAgICBzdGFja1tkYXRhc2V0SW5kZXhdID0gdmFsdWU7XG5cbiAgICBzdGFjay5fdG9wID0gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCB0cnVlLCBtZXRhLnR5cGUpO1xuICAgIHN0YWNrLl9ib3R0b20gPSBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIGZhbHNlLCBtZXRhLnR5cGUpO1xuXG4gICAgY29uc3QgdmlzdWFsVmFsdWVzID0gc3RhY2suX3Zpc3VhbFZhbHVlcyB8fCAoc3RhY2suX3Zpc3VhbFZhbHVlcyA9IHt9KTtcbiAgICB2aXN1YWxWYWx1ZXNbZGF0YXNldEluZGV4XSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEZpcnN0U2NhbGVJZChjaGFydCwgYXhpcykge1xuICBjb25zdCBzY2FsZXMgPSBjaGFydC5zY2FsZXM7XG4gIHJldHVybiBPYmplY3Qua2V5cyhzY2FsZXMpLmZpbHRlcihrZXkgPT4gc2NhbGVzW2tleV0uYXhpcyA9PT0gYXhpcykuc2hpZnQoKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGF0YXNldENvbnRleHQocGFyZW50LCBpbmRleCkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsXG4gICAge1xuICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgIGRhdGFzZXQ6IHVuZGVmaW5lZCxcbiAgICAgIGRhdGFzZXRJbmRleDogaW5kZXgsXG4gICAgICBpbmRleCxcbiAgICAgIG1vZGU6ICdkZWZhdWx0JyxcbiAgICAgIHR5cGU6ICdkYXRhc2V0J1xuICAgIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGF0YUNvbnRleHQocGFyZW50LCBpbmRleCwgZWxlbWVudCkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICBhY3RpdmU6IGZhbHNlLFxuICAgIGRhdGFJbmRleDogaW5kZXgsXG4gICAgcGFyc2VkOiB1bmRlZmluZWQsXG4gICAgcmF3OiB1bmRlZmluZWQsXG4gICAgZWxlbWVudCxcbiAgICBpbmRleCxcbiAgICBtb2RlOiAnZGVmYXVsdCcsXG4gICAgdHlwZTogJ2RhdGEnXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjbGVhclN0YWNrcyhtZXRhLCBpdGVtcykge1xuICAvLyBOb3QgdXNpbmcgbWV0YS5pbmRleCBoZXJlLCBiZWNhdXNlIGl0IG1pZ2h0IGJlIGFscmVhZHkgdXBkYXRlZCBpZiB0aGUgZGF0YXNldCBjaGFuZ2VkIGxvY2F0aW9uXG4gIGNvbnN0IGRhdGFzZXRJbmRleCA9IG1ldGEuY29udHJvbGxlci5pbmRleDtcbiAgY29uc3QgYXhpcyA9IG1ldGEudlNjYWxlICYmIG1ldGEudlNjYWxlLmF4aXM7XG4gIGlmICghYXhpcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGl0ZW1zID0gaXRlbXMgfHwgbWV0YS5fcGFyc2VkO1xuICBmb3IgKGNvbnN0IHBhcnNlZCBvZiBpdGVtcykge1xuICAgIGNvbnN0IHN0YWNrcyA9IHBhcnNlZC5fc3RhY2tzO1xuICAgIGlmICghc3RhY2tzIHx8IHN0YWNrc1theGlzXSA9PT0gdW5kZWZpbmVkIHx8IHN0YWNrc1theGlzXVtkYXRhc2V0SW5kZXhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVsZXRlIHN0YWNrc1theGlzXVtkYXRhc2V0SW5kZXhdO1xuICAgIGlmIChzdGFja3NbYXhpc10uX3Zpc3VhbFZhbHVlcyAhPT0gdW5kZWZpbmVkICYmIHN0YWNrc1theGlzXS5fdmlzdWFsVmFsdWVzW2RhdGFzZXRJbmRleF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVsZXRlIHN0YWNrc1theGlzXS5fdmlzdWFsVmFsdWVzW2RhdGFzZXRJbmRleF07XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGlzRGlyZWN0VXBkYXRlTW9kZSA9IChtb2RlKSA9PiBtb2RlID09PSAncmVzZXQnIHx8IG1vZGUgPT09ICdub25lJztcbmNvbnN0IGNsb25lSWZOb3RTaGFyZWQgPSAoY2FjaGVkLCBzaGFyZWQpID0+IHNoYXJlZCA/IGNhY2hlZCA6IE9iamVjdC5hc3NpZ24oe30sIGNhY2hlZCk7XG5jb25zdCBjcmVhdGVTdGFjayA9IChjYW5TdGFjaywgbWV0YSwgY2hhcnQpID0+IGNhblN0YWNrICYmICFtZXRhLmhpZGRlbiAmJiBtZXRhLl9zdGFja2VkXG4gICYmIHtrZXlzOiBnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyhjaGFydCwgdHJ1ZSksIHZhbHVlczogbnVsbH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHt9O1xuXG4gIC8qKlxuICAgKiBFbGVtZW50IHR5cGUgdXNlZCB0byBnZW5lcmF0ZSBhIG1ldGEgZGF0YXNldCAoZS5nLiBDaGFydC5lbGVtZW50LkxpbmVFbGVtZW50KS5cbiAgICovXG4gIHN0YXRpYyBkYXRhc2V0RWxlbWVudFR5cGUgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBFbGVtZW50IHR5cGUgdXNlZCB0byBnZW5lcmF0ZSBhIG1ldGEgZGF0YSAoZS5nLiBDaGFydC5lbGVtZW50LlBvaW50RWxlbWVudCkuXG4gICAqL1xuICBzdGF0aWMgZGF0YUVsZW1lbnRUeXBlID0gbnVsbDtcblxuICAvKipcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IGRhdGFzZXRJbmRleFxuXHQgKi9cbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuICAgIHRoaXMuY2hhcnQgPSBjaGFydDtcbiAgICB0aGlzLl9jdHggPSBjaGFydC5jdHg7XG4gICAgdGhpcy5pbmRleCA9IGRhdGFzZXRJbmRleDtcbiAgICB0aGlzLl9jYWNoZWREYXRhT3B0cyA9IHt9O1xuICAgIHRoaXMuX2NhY2hlZE1ldGEgPSB0aGlzLmdldE1ldGEoKTtcbiAgICB0aGlzLl90eXBlID0gdGhpcy5fY2FjaGVkTWV0YS50eXBlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge2Jvb2xlYW4gfCBvYmplY3R9ICovXG4gICAgdGhpcy5fcGFyc2luZyA9IGZhbHNlO1xuICAgIHRoaXMuX2RhdGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fb2JqZWN0RGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zaGFyZWRPcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RyYXdTdGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kcmF3Q291bnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gZmFsc2U7XG4gICAgdGhpcy5zdXBwb3J0c0RlY2ltYXRpb24gPSBmYWxzZTtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgPSBuZXcudGFyZ2V0LmRhdGFzZXRFbGVtZW50VHlwZTtcbiAgICB0aGlzLmRhdGFFbGVtZW50VHlwZSA9IG5ldy50YXJnZXQuZGF0YUVsZW1lbnRUeXBlO1xuXG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gIH1cblxuICBpbml0aWFsaXplKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMuY29uZmlndXJlKCk7XG4gICAgdGhpcy5saW5rU2NhbGVzKCk7XG4gICAgbWV0YS5fc3RhY2tlZCA9IGlzU3RhY2tlZChtZXRhLnZTY2FsZSwgbWV0YSk7XG4gICAgdGhpcy5hZGRFbGVtZW50cygpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5maWxsICYmICF0aGlzLmNoYXJ0LmlzUGx1Z2luRW5hYmxlZCgnZmlsbGVyJykpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRyaWVkIHRvIHVzZSB0aGUgJ2ZpbGwnIG9wdGlvbiB3aXRob3V0IHRoZSAnRmlsbGVyJyBwbHVnaW4gZW5hYmxlZC4gUGxlYXNlIGltcG9ydCBhbmQgcmVnaXN0ZXIgdGhlICdGaWxsZXInIHBsdWdpbiBhbmQgbWFrZSBzdXJlIGl0IGlzIG5vdCBkaXNhYmxlZCBpbiB0aGUgb3B0aW9uc1wiKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVJbmRleChkYXRhc2V0SW5kZXgpIHtcbiAgICBpZiAodGhpcy5pbmRleCAhPT0gZGF0YXNldEluZGV4KSB7XG4gICAgICBjbGVhclN0YWNrcyh0aGlzLl9jYWNoZWRNZXRhKTtcbiAgICB9XG4gICAgdGhpcy5pbmRleCA9IGRhdGFzZXRJbmRleDtcbiAgfVxuXG4gIGxpbmtTY2FsZXMoKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcblxuICAgIGNvbnN0IGNob29zZUlkID0gKGF4aXMsIHgsIHksIHIpID0+IGF4aXMgPT09ICd4JyA/IHggOiBheGlzID09PSAncicgPyByIDogeTtcblxuICAgIGNvbnN0IHhpZCA9IG1ldGEueEF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQueEF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAneCcpKTtcbiAgICBjb25zdCB5aWQgPSBtZXRhLnlBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnlBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3knKSk7XG4gICAgY29uc3QgcmlkID0gbWV0YS5yQXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC5yQXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICdyJykpO1xuICAgIGNvbnN0IGluZGV4QXhpcyA9IG1ldGEuaW5kZXhBeGlzO1xuICAgIGNvbnN0IGlpZCA9IG1ldGEuaUF4aXNJRCA9IGNob29zZUlkKGluZGV4QXhpcywgeGlkLCB5aWQsIHJpZCk7XG4gICAgY29uc3QgdmlkID0gbWV0YS52QXhpc0lEID0gY2hvb3NlSWQoaW5kZXhBeGlzLCB5aWQsIHhpZCwgcmlkKTtcbiAgICBtZXRhLnhTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh4aWQpO1xuICAgIG1ldGEueVNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHlpZCk7XG4gICAgbWV0YS5yU2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQocmlkKTtcbiAgICBtZXRhLmlTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChpaWQpO1xuICAgIG1ldGEudlNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHZpZCk7XG4gIH1cblxuICBnZXREYXRhc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbdGhpcy5pbmRleF07XG4gIH1cblxuICBnZXRNZXRhKCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRoaXMuaW5kZXgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzY2FsZUlEXG5cdCAqIEByZXR1cm4ge1NjYWxlfVxuXHQgKi9cbiAgZ2V0U2NhbGVGb3JJZChzY2FsZUlEKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuc2NhbGVzW3NjYWxlSURdO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0T3RoZXJTY2FsZShzY2FsZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHJldHVybiBzY2FsZSA9PT0gbWV0YS5pU2NhbGVcbiAgICAgID8gbWV0YS52U2NhbGVcbiAgICAgIDogbWV0YS5pU2NhbGU7XG4gIH1cblxuICByZXNldCgpIHtcbiAgICB0aGlzLl91cGRhdGUoJ3Jlc2V0Jyk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kZXN0cm95KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICB1bmxpc3RlbkFycmF5RXZlbnRzKHRoaXMuX2RhdGEsIHRoaXMpO1xuICAgIH1cbiAgICBpZiAobWV0YS5fc3RhY2tlZCkge1xuICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZGF0YUNoZWNrKCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBjb25zdCBkYXRhID0gZGF0YXNldC5kYXRhIHx8IChkYXRhc2V0LmRhdGEgPSBbXSk7XG4gICAgY29uc3QgX2RhdGEgPSB0aGlzLl9kYXRhO1xuXG4gICAgLy8gSW4gb3JkZXIgdG8gY29ycmVjdGx5IGhhbmRsZSBkYXRhIGFkZGl0aW9uL2RlbGV0aW9uIGFuaW1hdGlvbiAoYW5kIHRodXMgc2ltdWxhdGVcbiAgICAvLyByZWFsLXRpbWUgY2hhcnRzKSwgd2UgbmVlZCB0byBtb25pdG9yIHRoZXNlIGRhdGEgbW9kaWZpY2F0aW9ucyBhbmQgc3luY2hyb25pemVcbiAgICAvLyB0aGUgaW50ZXJuYWwgbWV0YWRhdGEgYWNjb3JkaW5nbHkuXG5cbiAgICBpZiAoaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgdGhpcy5fZGF0YSA9IGNvbnZlcnRPYmplY3REYXRhVG9BcnJheShkYXRhLCBtZXRhKTtcbiAgICB9IGVsc2UgaWYgKF9kYXRhICE9PSBkYXRhKSB7XG4gICAgICBpZiAoX2RhdGEpIHtcbiAgICAgICAgLy8gVGhpcyBjYXNlIGhhcHBlbnMgd2hlbiB0aGUgdXNlciByZXBsYWNlZCB0aGUgZGF0YSBhcnJheSBpbnN0YW5jZS5cbiAgICAgICAgdW5saXN0ZW5BcnJheUV2ZW50cyhfZGF0YSwgdGhpcyk7XG4gICAgICAgIC8vIERpc2NhcmQgb2xkIHBhcnNlZCBkYXRhIGFuZCBzdGFja3NcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNsZWFyU3RhY2tzKG1ldGEpO1xuICAgICAgICBtZXRhLl9wYXJzZWQgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhICYmIE9iamVjdC5pc0V4dGVuc2libGUoZGF0YSkpIHtcbiAgICAgICAgbGlzdGVuQXJyYXlFdmVudHMoZGF0YSwgdGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zeW5jTGlzdCA9IFtdO1xuICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgfVxuICB9XG5cbiAgYWRkRWxlbWVudHMoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG5cbiAgICB0aGlzLl9kYXRhQ2hlY2soKTtcblxuICAgIGlmICh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSkge1xuICAgICAgbWV0YS5kYXRhc2V0ID0gbmV3IHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKCk7XG4gICAgfVxuICB9XG5cbiAgYnVpbGRPclVwZGF0ZUVsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgbGV0IHN0YWNrQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5fZGF0YUNoZWNrKCk7XG5cbiAgICAvLyBtYWtlIHN1cmUgY2FjaGVkIF9zdGFja2VkIHN0YXR1cyBpcyBjdXJyZW50XG4gICAgY29uc3Qgb2xkU3RhY2tlZCA9IG1ldGEuX3N0YWNrZWQ7XG4gICAgbWV0YS5fc3RhY2tlZCA9IGlzU3RhY2tlZChtZXRhLnZTY2FsZSwgbWV0YSk7XG5cbiAgICAvLyBkZXRlY3QgY2hhbmdlIGluIHN0YWNrIG9wdGlvblxuICAgIGlmIChtZXRhLnN0YWNrICE9PSBkYXRhc2V0LnN0YWNrKSB7XG4gICAgICBzdGFja0NoYW5nZWQgPSB0cnVlO1xuICAgICAgLy8gcmVtb3ZlIHZhbHVlcyBmcm9tIG9sZCBzdGFja1xuICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgICBtZXRhLnN0YWNrID0gZGF0YXNldC5zdGFjaztcbiAgICB9XG5cbiAgICAvLyBSZS1zeW5jIG1ldGEgZGF0YSBpbiBjYXNlIHRoZSB1c2VyIHJlcGxhY2VkIHRoZSBkYXRhIGFycmF5IG9yIGlmIHdlIG1pc3NlZFxuICAgIC8vIGFueSB1cGRhdGVzIGFuZCBzbyBtYWtlIHN1cmUgdGhhdCB3ZSBoYW5kbGUgbnVtYmVyIG9mIGRhdGFwb2ludHMgY2hhbmdpbmcuXG4gICAgdGhpcy5fcmVzeW5jRWxlbWVudHMocmVzZXROZXdFbGVtZW50cyk7XG5cbiAgICAvLyBpZiBzdGFjayBjaGFuZ2VkLCB1cGRhdGUgc3RhY2sgdmFsdWVzIGZvciB0aGUgd2hvbGUgZGF0YXNldFxuICAgIGlmIChzdGFja0NoYW5nZWQgfHwgb2xkU3RhY2tlZCAhPT0gbWV0YS5fc3RhY2tlZCkge1xuICAgICAgdXBkYXRlU3RhY2tzKHRoaXMsIG1ldGEuX3BhcnNlZCk7XG4gICAgICBtZXRhLl9zdGFja2VkID0gaXNTdGFja2VkKG1ldGEudlNjYWxlLCBtZXRhKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogTWVyZ2VzIHVzZXItc3VwcGxpZWQgYW5kIGRlZmF1bHQgZGF0YXNldC1sZXZlbCBvcHRpb25zXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRTY29wZUtleXModGhpcy5fdHlwZSk7XG4gICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzLCB0cnVlKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgdGhpcy5fcGFyc2luZyA9IHRoaXMub3B0aW9ucy5wYXJzaW5nO1xuICAgIHRoaXMuX2NhY2hlZERhdGFPcHRzID0ge307XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuXHQgKi9cbiAgcGFyc2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge19jYWNoZWRNZXRhOiBtZXRhLCBfZGF0YTogZGF0YX0gPSB0aGlzO1xuICAgIGNvbnN0IHtpU2NhbGUsIF9zdGFja2VkfSA9IG1ldGE7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcblxuICAgIGxldCBzb3J0ZWQgPSBzdGFydCA9PT0gMCAmJiBjb3VudCA9PT0gZGF0YS5sZW5ndGggPyB0cnVlIDogbWV0YS5fc29ydGVkO1xuICAgIGxldCBwcmV2ID0gc3RhcnQgPiAwICYmIG1ldGEuX3BhcnNlZFtzdGFydCAtIDFdO1xuICAgIGxldCBpLCBjdXIsIHBhcnNlZDtcblxuICAgIGlmICh0aGlzLl9wYXJzaW5nID09PSBmYWxzZSkge1xuICAgICAgbWV0YS5fcGFyc2VkID0gZGF0YTtcbiAgICAgIG1ldGEuX3NvcnRlZCA9IHRydWU7XG4gICAgICBwYXJzZWQgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNBcnJheShkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZCA9IHRoaXMucGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2ID0gKCkgPT4gY3VyW2lBeGlzXSA9PT0gbnVsbCB8fCAocHJldiAmJiBjdXJbaUF4aXNdIDwgcHJldltpQXhpc10pO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgbWV0YS5fcGFyc2VkW2kgKyBzdGFydF0gPSBjdXIgPSBwYXJzZWRbaV07XG4gICAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgICBpZiAoaXNOb3RJbk9yZGVyQ29tcGFyZWRUb1ByZXYoKSkge1xuICAgICAgICAgICAgc29ydGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZXYgPSBjdXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1ldGEuX3NvcnRlZCA9IHNvcnRlZDtcbiAgICB9XG5cbiAgICBpZiAoX3N0YWNrZWQpIHtcbiAgICAgIHVwZGF0ZVN0YWNrcyh0aGlzLCBwYXJzZWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhcnJheSBvZiBwcmltaXRpdmUgdmFsdWVzXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhIC0gZGF0YXNldCBtZXRhXG5cdCAqIEBwYXJhbSB7YXJyYXl9IGRhdGEgLSBkYXRhIGFycmF5LiBFeGFtcGxlIFsxLDMsNF1cblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gc3RhcnQgaW5kZXhcblx0ICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IC0gbnVtYmVyIG9mIGl0ZW1zIHRvIHBhcnNlXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHBhcnNlZCBpdGVtIC0gaXRlbSBjb250YWluaW5nIGluZGV4IGFuZCBhIHBhcnNlZCB2YWx1ZVxuXHQgKiBmb3IgZWFjaCBzY2FsZSBpZC5cblx0ICogRXhhbXBsZToge3hTY2FsZTA6IDAsIHlTY2FsZTA6IDF9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3QgbGFiZWxzID0gaVNjYWxlLmdldExhYmVscygpO1xuICAgIGNvbnN0IHNpbmdsZVNjYWxlID0gaVNjYWxlID09PSB2U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXg7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICBbaUF4aXNdOiBzaW5nbGVTY2FsZSB8fCBpU2NhbGUucGFyc2UobGFiZWxzW2luZGV4XSwgaW5kZXgpLFxuICAgICAgICBbdkF4aXNdOiB2U2NhbGUucGFyc2UoZGF0YVtpbmRleF0sIGluZGV4KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhcnJheSBvZiBhcnJheXNcblx0ICogQHBhcmFtIHtvYmplY3R9IG1ldGEgLSBkYXRhc2V0IG1ldGFcblx0ICogQHBhcmFtIHthcnJheX0gZGF0YSAtIGRhdGEgYXJyYXkuIEV4YW1wbGUgW1sxLDJdLFszLDRdXVxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBzdGFydCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBudW1iZXIgb2YgaXRlbXMgdG8gcGFyc2Vcblx0ICogQHJldHVybnMge29iamVjdH0gcGFyc2VkIGl0ZW0gLSBpdGVtIGNvbnRhaW5pbmcgaW5kZXggYW5kIGEgcGFyc2VkIHZhbHVlXG5cdCAqIGZvciBlYWNoIHNjYWxlIGlkLlxuXHQgKiBFeGFtcGxlOiB7eDogMCwgeTogMX1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICB4OiB4U2NhbGUucGFyc2UoaXRlbVswXSwgaW5kZXgpLFxuICAgICAgICB5OiB5U2NhbGUucGFyc2UoaXRlbVsxXSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIG9iamVjdHNcblx0ICogQHBhcmFtIHtvYmplY3R9IG1ldGEgLSBkYXRhc2V0IG1ldGFcblx0ICogQHBhcmFtIHthcnJheX0gZGF0YSAtIGRhdGEgYXJyYXkuIEV4YW1wbGUgW3t4OjEsIHk6NX0sIHt4OjIsIHk6MTB9XVxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBzdGFydCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBudW1iZXIgb2YgaXRlbXMgdG8gcGFyc2Vcblx0ICogQHJldHVybnMge29iamVjdH0gcGFyc2VkIGl0ZW0gLSBpdGVtIGNvbnRhaW5pbmcgaW5kZXggYW5kIGEgcGFyc2VkIHZhbHVlXG5cdCAqIGZvciBlYWNoIHNjYWxlIGlkLiBfY3VzdG9tIGlzIG9wdGlvbmFsXG5cdCAqIEV4YW1wbGU6IHt4U2NhbGUwOiAwLCB5U2NhbGUwOiAxLCBfY3VzdG9tOiB7cjogMTAsIGZvbzogJ2Jhcid9fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3Qge3hBeGlzS2V5ID0gJ3gnLCB5QXhpc0tleSA9ICd5J30gPSB0aGlzLl9wYXJzaW5nO1xuICAgIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgbGV0IGksIGlsZW4sIGluZGV4LCBpdGVtO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgIGl0ZW0gPSBkYXRhW2luZGV4XTtcbiAgICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgICAgeDogeFNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwgeEF4aXNLZXkpLCBpbmRleCksXG4gICAgICAgIHk6IHlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIHlBeGlzS2V5KSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldFBhcnNlZChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRNZXRhLl9wYXJzZWRbaW5kZXhdO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldERhdGFFbGVtZW50KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE1ldGEuZGF0YVtpbmRleF07XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgYXBwbHlTdGFjayhzY2FsZSwgcGFyc2VkLCBtb2RlKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHZhbHVlID0gcGFyc2VkW3NjYWxlLmF4aXNdO1xuICAgIGNvbnN0IHN0YWNrID0ge1xuICAgICAga2V5czogZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIHRydWUpLFxuICAgICAgdmFsdWVzOiBwYXJzZWQuX3N0YWNrc1tzY2FsZS5heGlzXS5fdmlzdWFsVmFsdWVzXG4gICAgfTtcbiAgICByZXR1cm4gYXBwbHlTdGFjayhzdGFjaywgdmFsdWUsIG1ldGEuaW5kZXgsIHttb2RlfSk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgdXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjaykge1xuICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VkW3NjYWxlLmF4aXNdO1xuICAgIGxldCB2YWx1ZSA9IHBhcnNlZFZhbHVlID09PSBudWxsID8gTmFOIDogcGFyc2VkVmFsdWU7XG4gICAgY29uc3QgdmFsdWVzID0gc3RhY2sgJiYgcGFyc2VkLl9zdGFja3Nbc2NhbGUuYXhpc107XG4gICAgaWYgKHN0YWNrICYmIHZhbHVlcykge1xuICAgICAgc3RhY2sudmFsdWVzID0gdmFsdWVzO1xuICAgICAgdmFsdWUgPSBhcHBseVN0YWNrKHN0YWNrLCBwYXJzZWRWYWx1ZSwgdGhpcy5fY2FjaGVkTWV0YS5pbmRleCk7XG4gICAgfVxuICAgIHJhbmdlLm1pbiA9IE1hdGgubWluKHJhbmdlLm1pbiwgdmFsdWUpO1xuICAgIHJhbmdlLm1heCA9IE1hdGgubWF4KHJhbmdlLm1heCwgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldE1pbk1heChzY2FsZSwgY2FuU3RhY2spIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBfcGFyc2VkID0gbWV0YS5fcGFyc2VkO1xuICAgIGNvbnN0IHNvcnRlZCA9IG1ldGEuX3NvcnRlZCAmJiBzY2FsZSA9PT0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgaWxlbiA9IF9wYXJzZWQubGVuZ3RoO1xuICAgIGNvbnN0IG90aGVyU2NhbGUgPSB0aGlzLl9nZXRPdGhlclNjYWxlKHNjYWxlKTtcbiAgICBjb25zdCBzdGFjayA9IGNyZWF0ZVN0YWNrKGNhblN0YWNrLCBtZXRhLCB0aGlzLmNoYXJ0KTtcbiAgICBjb25zdCByYW5nZSA9IHttaW46IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWF4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFl9O1xuICAgIGNvbnN0IHttaW46IG90aGVyTWluLCBtYXg6IG90aGVyTWF4fSA9IGdldFVzZXJCb3VuZHMob3RoZXJTY2FsZSk7XG4gICAgbGV0IGksIHBhcnNlZDtcblxuICAgIGZ1bmN0aW9uIF9za2lwKCkge1xuICAgICAgcGFyc2VkID0gX3BhcnNlZFtpXTtcbiAgICAgIGNvbnN0IG90aGVyVmFsdWUgPSBwYXJzZWRbb3RoZXJTY2FsZS5heGlzXTtcbiAgICAgIHJldHVybiAhaXNGaW5pdGUocGFyc2VkW3NjYWxlLmF4aXNdKSB8fCBvdGhlck1pbiA+IG90aGVyVmFsdWUgfHwgb3RoZXJNYXggPCBvdGhlclZhbHVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmIChfc2tpcCgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgLy8gaWYgdGhlIGRhdGEgaXMgc29ydGVkLCB3ZSBkb24ndCBuZWVkIHRvIGNoZWNrIGZ1cnRoZXIgZnJvbSB0aGlzIGVuZCBvZiBhcnJheVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNvcnRlZCkge1xuICAgICAgLy8gaW4gdGhlIHNvcnRlZCBjYXNlLCBmaW5kIGZpcnN0IG5vbi1za2lwcGVkIHZhbHVlIGZyb20gb3RoZXIgZW5kIG9mIGFycmF5XG4gICAgICBmb3IgKGkgPSBpbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaWYgKF9za2lwKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG5cbiAgZ2V0QWxsUGFyc2VkVmFsdWVzKHNjYWxlKSB7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5fY2FjaGVkTWV0YS5fcGFyc2VkO1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCB2YWx1ZTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBwYXJzZWQubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlZFtpXVtzY2FsZS5heGlzXTtcbiAgICAgIGlmIChpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge251bWJlcnxib29sZWFufVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICAgIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGlTY2FsZSA/ICcnICsgaVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW2lTY2FsZS5heGlzXSkgOiAnJyxcbiAgICAgIHZhbHVlOiB2U2NhbGUgPyAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pIDogJydcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLnVwZGF0ZShtb2RlIHx8ICdkZWZhdWx0Jyk7XG4gICAgbWV0YS5fY2xpcCA9IHRvQ2xpcCh2YWx1ZU9yRGVmYXVsdCh0aGlzLm9wdGlvbnMuY2xpcCwgZGVmYXVsdENsaXAobWV0YS54U2NhbGUsIG1ldGEueVNjYWxlLCB0aGlzLmdldE1heE92ZXJmbG93KCkpKSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1vZGVcblx0ICovXG4gIHVwZGF0ZShtb2RlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgZHJhdygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLl9jdHg7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGNvbnN0IGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3QgYWN0aXZlID0gW107XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9kcmF3U3RhcnQgfHwgMDtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuX2RyYXdDb3VudCB8fCAoZWxlbWVudHMubGVuZ3RoIC0gc3RhcnQpO1xuICAgIGNvbnN0IGRyYXdBY3RpdmVFbGVtZW50c09uVG9wID0gdGhpcy5vcHRpb25zLmRyYXdBY3RpdmVFbGVtZW50c09uVG9wO1xuICAgIGxldCBpO1xuXG4gICAgaWYgKG1ldGEuZGF0YXNldCkge1xuICAgICAgbWV0YS5kYXRhc2V0LmRyYXcoY3R4LCBhcmVhLCBzdGFydCwgY291bnQpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICBpZiAoZWxlbWVudC5oaWRkZW4pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudC5hY3RpdmUgJiYgZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3ApIHtcbiAgICAgICAgYWN0aXZlLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LmRyYXcoY3R4LCBhcmVhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYWN0aXZlLmxlbmd0aDsgKytpKSB7XG4gICAgICBhY3RpdmVbaV0uZHJhdyhjdHgsIGFyZWEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGEgc2V0IG9mIHByZWRlZmluZWQgc3R5bGUgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlcHJlc2VudCB0aGUgZGF0YXNldFxuXHQgKiBvciB0aGUgZGF0YSBpZiB0aGUgaW5kZXggaXMgc3BlY2lmaWVkXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGRhdGEgaW5kZXhcblx0ICogQHBhcmFtIHtib29sZWFufSBbYWN0aXZlXSAtIHRydWUgaWYgaG92ZXJcblx0ICogQHJldHVybiB7b2JqZWN0fSBzdHlsZSBvYmplY3Rcblx0ICovXG4gIGdldFN0eWxlKGluZGV4LCBhY3RpdmUpIHtcbiAgICBjb25zdCBtb2RlID0gYWN0aXZlID8gJ2FjdGl2ZScgOiAnZGVmYXVsdCc7XG4gICAgcmV0dXJuIGluZGV4ID09PSB1bmRlZmluZWQgJiYgdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0XG4gICAgICA/IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKVxuICAgICAgOiB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXggfHwgMCwgbW9kZSk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCBtb2RlKSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGxldCBjb250ZXh0O1xuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fY2FjaGVkTWV0YS5kYXRhLmxlbmd0aCkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YVtpbmRleF07XG4gICAgICBjb250ZXh0ID0gZWxlbWVudC4kY29udGV4dCB8fFxuICAgICAgICAoZWxlbWVudC4kY29udGV4dCA9IGNyZWF0ZURhdGFDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgZWxlbWVudCkpO1xuICAgICAgY29udGV4dC5wYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgICBjb250ZXh0LnJhdyA9IGRhdGFzZXQuZGF0YVtpbmRleF07XG4gICAgICBjb250ZXh0LmluZGV4ID0gY29udGV4dC5kYXRhSW5kZXggPSBpbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dCA9IHRoaXMuJGNvbnRleHQgfHxcbiAgICAgICAgKHRoaXMuJGNvbnRleHQgPSBjcmVhdGVEYXRhc2V0Q29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcy5pbmRleCkpO1xuICAgICAgY29udGV4dC5kYXRhc2V0ID0gZGF0YXNldDtcbiAgICAgIGNvbnRleHQuaW5kZXggPSBjb250ZXh0LmRhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgfVxuXG4gICAgY29udGV4dC5hY3RpdmUgPSAhIWFjdGl2ZTtcbiAgICBjb250ZXh0Lm1vZGUgPSBtb2RlO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbW9kZV1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZS5pZCwgbW9kZSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbW9kZV1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlRWxlbWVudE9wdGlvbnModGhpcy5kYXRhRWxlbWVudFR5cGUuaWQsIG1vZGUsIGluZGV4KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc29sdmVFbGVtZW50T3B0aW9ucyhlbGVtZW50VHlwZSwgbW9kZSA9ICdkZWZhdWx0JywgaW5kZXgpIHtcbiAgICBjb25zdCBhY3RpdmUgPSBtb2RlID09PSAnYWN0aXZlJztcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZERhdGFPcHRzO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gZWxlbWVudFR5cGUgKyAnLScgKyBtb2RlO1xuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICBjb25zdCBzaGFyaW5nID0gdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nICYmIGRlZmluZWQoaW5kZXgpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjbG9uZUlmTm90U2hhcmVkKGNhY2hlZCwgc2hhcmluZyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IHNjb3BlS2V5cyA9IGNvbmZpZy5kYXRhc2V0RWxlbWVudFNjb3BlS2V5cyh0aGlzLl90eXBlLCBlbGVtZW50VHlwZSk7XG4gICAgY29uc3QgcHJlZml4ZXMgPSBhY3RpdmUgPyBbYCR7ZWxlbWVudFR5cGV9SG92ZXJgLCAnaG92ZXInLCBlbGVtZW50VHlwZSwgJyddIDogW2VsZW1lbnRUeXBlLCAnJ107XG4gICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzKTtcbiAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzLmVsZW1lbnRzW2VsZW1lbnRUeXBlXSk7XG4gICAgLy8gY29udGV4dCBpcyBwcm92aWRlZCBhcyBhIGZ1bmN0aW9uLCBhbmQgaXMgY2FsbGVkIG9ubHkgaWYgbmVlZGVkLFxuICAgIC8vIHNvIHdlIGRvbid0IGNyZWF0ZSBhIGNvbnRleHQgZm9yIGVhY2ggZWxlbWVudCBpZiBub3QgbmVlZGVkLlxuICAgIGNvbnN0IGNvbnRleHQgPSAoKSA9PiB0aGlzLmdldENvbnRleHQoaW5kZXgsIGFjdGl2ZSwgbW9kZSk7XG4gICAgY29uc3QgdmFsdWVzID0gY29uZmlnLnJlc29sdmVOYW1lZE9wdGlvbnMoc2NvcGVzLCBuYW1lcywgY29udGV4dCwgcHJlZml4ZXMpO1xuXG4gICAgaWYgKHZhbHVlcy4kc2hhcmVkKSB7XG4gICAgICAvLyBgJHNoYXJlZGAgaW5kaWNhdGVzIHRoaXMgc2V0IG9mIG9wdGlvbnMgY2FuIGJlIHNoYXJlZCBiZXR3ZWVuIG11bHRpcGxlIGVsZW1lbnRzLlxuICAgICAgLy8gU2hhcmluZyBpcyB1c2VkIHRvIHJlZHVjZSBudW1iZXIgb2YgcHJvcGVydGllcyB0byBjaGFuZ2UgZHVyaW5nIGFuaW1hdGlvbi5cbiAgICAgIHZhbHVlcy4kc2hhcmVkID0gc2hhcmluZztcblxuICAgICAgLy8gV2UgY2FjaGUgb3B0aW9ucyBieSBgbW9kZWAsIHdoaWNoIGNhbiBiZSAnYWN0aXZlJyBmb3IgZXhhbXBsZS4gVGhpcyBlbmFibGVzIHVzXG4gICAgICAvLyB0byBoYXZlIHRoZSAnYWN0aXZlJyBlbGVtZW50IG9wdGlvbnMgYW5kICdkZWZhdWx0JyBvcHRpb25zIHRvIHN3aXRjaCBiZXR3ZWVuXG4gICAgICAvLyB3aGVuIGludGVyYWN0aW5nLlxuICAgICAgY2FjaGVbY2FjaGVLZXldID0gT2JqZWN0LmZyZWV6ZShjbG9uZUlmTm90U2hhcmVkKHZhbHVlcywgc2hhcmluZykpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCB0cmFuc2l0aW9uLCBhY3RpdmUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWREYXRhT3B0cztcbiAgICBjb25zdCBjYWNoZUtleSA9IGBhbmltYXRpb24tJHt0cmFuc2l0aW9ufWA7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGVbY2FjaGVLZXldO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGxldCBvcHRpb25zO1xuICAgIGlmIChjaGFydC5vcHRpb25zLmFuaW1hdGlvbiAhPT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRBbmltYXRpb25TY29wZUtleXModGhpcy5fdHlwZSwgdHJhbnNpdGlvbik7XG4gICAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMpO1xuICAgICAgb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIHRoaXMuZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCB0cmFuc2l0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9ucyhjaGFydCwgb3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGlvbnMpO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2NhY2hlYWJsZSkge1xuICAgICAgY2FjaGVbY2FjaGVLZXldID0gT2JqZWN0LmZyZWV6ZShhbmltYXRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cblxuICAvKipcblx0ICogVXRpbGl0eSBmb3IgZ2V0dGluZyB0aGUgb3B0aW9ucyBvYmplY3Qgc2hhcmVkIGJldHdlZW4gZWxlbWVudHNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0U2hhcmVkT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLiRzaGFyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NoYXJlZE9wdGlvbnMgfHwgKHRoaXMuX3NoYXJlZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSk7XG4gIH1cblxuICAvKipcblx0ICogVXRpbGl0eSBmb3IgZGV0ZXJtaW5pbmcgaWYgYG9wdGlvbnNgIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgdXBkYXRlZCBwcm9wZXJ0aWVzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpIHtcbiAgICByZXR1cm4gIXNoYXJlZE9wdGlvbnMgfHwgaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpIHx8IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdG9kbyB2NCwgcmVuYW1lIHRvIGdldFNoYXJlZE9wdGlvbnMgYW5kIHJlbW92ZSBleGNlc3MgZnVuY3Rpb25zXG4gICAqL1xuICBfZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSkge1xuICAgIGNvbnN0IGZpcnN0T3B0cyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3QgcHJldmlvdXNseVNoYXJlZE9wdGlvbnMgPSB0aGlzLl9zaGFyZWRPcHRpb25zO1xuICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcbiAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucykgfHwgKHNoYXJlZE9wdGlvbnMgIT09IHByZXZpb3VzbHlTaGFyZWRPcHRpb25zKTtcbiAgICB0aGlzLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgICByZXR1cm4ge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IGZvciB1cGRhdGluZyBhbiBlbGVtZW50IHdpdGggbmV3IHByb3BlcnRpZXMsIHVzaW5nIGFuaW1hdGlvbnMgd2hlbiBhcHByb3ByaWF0ZS5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgdXBkYXRlRWxlbWVudChlbGVtZW50LCBpbmRleCwgcHJvcGVydGllcywgbW9kZSkge1xuICAgIGlmIChpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCBtb2RlKS51cGRhdGUoZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFV0aWxpdHkgdG8gYW5pbWF0ZSB0aGUgc2hhcmVkIG9wdGlvbnMsIHRoYXQgYXJlIHBvdGVudGlhbGx5IGFmZmVjdGluZyBtdWx0aXBsZSBlbGVtZW50cy5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgdXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBuZXdPcHRpb25zKSB7XG4gICAgaWYgKHNoYXJlZE9wdGlvbnMgJiYgIWlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSkge1xuICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnModW5kZWZpbmVkLCBtb2RlKS51cGRhdGUoc2hhcmVkT3B0aW9ucywgbmV3T3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsIG1vZGUsIGFjdGl2ZSkge1xuICAgIGVsZW1lbnQuYWN0aXZlID0gYWN0aXZlO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmdldFN0eWxlKGluZGV4LCBhY3RpdmUpO1xuICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCBtb2RlLCBhY3RpdmUpLnVwZGF0ZShlbGVtZW50LCB7XG4gICAgICAvLyBXaGVuIGdvaW5nIGZyb20gYWN0aXZlIHRvIGluYWN0aXZlLCB3ZSBuZWVkIHRvIHVwZGF0ZSB0byB0aGUgc2hhcmVkIG9wdGlvbnMuXG4gICAgICAvLyBUaGlzIHdheSB0aGUgb25jZSBob3ZlcmVkIGVsZW1lbnQgd2lsbCBlbmQgdXAgd2l0aCB0aGUgc2FtZSBvcmlnaW5hbCBzaGFyZWQgb3B0aW9ucyBpbnN0YW5jZSwgYWZ0ZXIgYW5pbWF0aW9uLlxuICAgICAgb3B0aW9uczogKCFhY3RpdmUgJiYgdGhpcy5nZXRTaGFyZWRPcHRpb25zKG9wdGlvbnMpKSB8fCBvcHRpb25zXG4gICAgfSk7XG4gIH1cblxuICByZW1vdmVIb3ZlclN0eWxlKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCBpbmRleCwgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgfVxuXG4gIHNldEhvdmVyU3R5bGUoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCAnYWN0aXZlJywgdHJ1ZSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZW1vdmVEYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0O1xuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIHVuZGVmaW5lZCwgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9zZXREYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0O1xuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIHVuZGVmaW5lZCwgJ2FjdGl2ZScsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc3luY0VsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcblxuICAgIC8vIEFwcGx5IGNoYW5nZXMgZGV0ZWN0ZWQgdGhyb3VnaCBhcnJheSBsaXN0ZW5lcnNcbiAgICBmb3IgKGNvbnN0IFttZXRob2QsIGFyZzEsIGFyZzJdIG9mIHRoaXMuX3N5bmNMaXN0KSB7XG4gICAgICB0aGlzW21ldGhvZF0oYXJnMSwgYXJnMik7XG4gICAgfVxuICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG5cbiAgICBjb25zdCBudW1NZXRhID0gZWxlbWVudHMubGVuZ3RoO1xuICAgIGNvbnN0IG51bURhdGEgPSBkYXRhLmxlbmd0aDtcbiAgICBjb25zdCBjb3VudCA9IE1hdGgubWluKG51bURhdGEsIG51bU1ldGEpO1xuXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICAvLyBUT0RPOiBJdCBpcyBub3Qgb3B0aW1hbCB0byBhbHdheXMgcGFyc2UgdGhlIG9sZCBkYXRhXG4gICAgICAvLyBUaGlzIGlzIGRvbmUgYmVjYXVzZSB3ZSBhcmUgbm90IGRldGVjdGluZyBkaXJlY3QgYXNzaWdubWVudHM6XG4gICAgICAvLyBjaGFydC5kYXRhLmRhdGFzZXRzWzBdLmRhdGFbNV0gPSAxMDtcbiAgICAgIC8vIGNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YVs1XS55ID0gMTA7XG4gICAgICB0aGlzLnBhcnNlKDAsIGNvdW50KTtcbiAgICB9XG5cbiAgICBpZiAobnVtRGF0YSA+IG51bU1ldGEpIHtcbiAgICAgIHRoaXMuX2luc2VydEVsZW1lbnRzKG51bU1ldGEsIG51bURhdGEgLSBudW1NZXRhLCByZXNldE5ld0VsZW1lbnRzKTtcbiAgICB9IGVsc2UgaWYgKG51bURhdGEgPCBudW1NZXRhKSB7XG4gICAgICB0aGlzLl9yZW1vdmVFbGVtZW50cyhudW1EYXRhLCBudW1NZXRhIC0gbnVtRGF0YSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfaW5zZXJ0RWxlbWVudHMoc3RhcnQsIGNvdW50LCByZXNldE5ld0VsZW1lbnRzID0gdHJ1ZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGEgPSBtZXRhLmRhdGE7XG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBjb3VudDtcbiAgICBsZXQgaTtcblxuICAgIGNvbnN0IG1vdmUgPSAoYXJyKSA9PiB7XG4gICAgICBhcnIubGVuZ3RoICs9IGNvdW50O1xuICAgICAgZm9yIChpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gZW5kOyBpLS0pIHtcbiAgICAgICAgYXJyW2ldID0gYXJyW2kgLSBjb3VudF07XG4gICAgICB9XG4gICAgfTtcbiAgICBtb3ZlKGRhdGEpO1xuXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgZGF0YVtpXSA9IG5ldyB0aGlzLmRhdGFFbGVtZW50VHlwZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XG4gICAgICBtb3ZlKG1ldGEuX3BhcnNlZCk7XG4gICAgfVxuICAgIHRoaXMucGFyc2Uoc3RhcnQsIGNvdW50KTtcblxuICAgIGlmIChyZXNldE5ld0VsZW1lbnRzKSB7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGRhdGEsIHN0YXJ0LCBjb3VudCwgJ3Jlc2V0Jyk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMoZWxlbWVudCwgc3RhcnQsIGNvdW50LCBtb2RlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVtb3ZlRWxlbWVudHMoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIGNvbnN0IHJlbW92ZWQgPSBtZXRhLl9wYXJzZWQuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG4gICAgICBpZiAobWV0YS5fc3RhY2tlZCkge1xuICAgICAgICBjbGVhclN0YWNrcyhtZXRhLCByZW1vdmVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWV0YS5kYXRhLnNwbGljZShzdGFydCwgY291bnQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG4gICAqL1xuICBfc3luYyhhcmdzKSB7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIHRoaXMuX3N5bmNMaXN0LnB1c2goYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFttZXRob2QsIGFyZzEsIGFyZzJdID0gYXJncztcbiAgICAgIHRoaXNbbWV0aG9kXShhcmcxLCBhcmcyKTtcbiAgICB9XG4gICAgdGhpcy5jaGFydC5fZGF0YUNoYW5nZXMucHVzaChbdGhpcy5pbmRleCwgLi4uYXJnc10pO1xuICB9XG5cbiAgX29uRGF0YVB1c2goKSB7XG4gICAgY29uc3QgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCB0aGlzLmdldERhdGFzZXQoKS5kYXRhLmxlbmd0aCAtIGNvdW50LCBjb3VudF0pO1xuICB9XG5cbiAgX29uRGF0YVBvcCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgdGhpcy5fY2FjaGVkTWV0YS5kYXRhLmxlbmd0aCAtIDEsIDFdKTtcbiAgfVxuXG4gIF9vbkRhdGFTaGlmdCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgMCwgMV0pO1xuICB9XG5cbiAgX29uRGF0YVNwbGljZShzdGFydCwgY291bnQpIHtcbiAgICBpZiAoY291bnQpIHtcbiAgICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCBzdGFydCwgY291bnRdKTtcbiAgICB9XG4gICAgY29uc3QgbmV3Q291bnQgPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICBpZiAobmV3Q291bnQpIHtcbiAgICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCBzdGFydCwgbmV3Q291bnRdKTtcbiAgICB9XG4gIH1cblxuICBfb25EYXRhVW5zaGlmdCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX2luc2VydEVsZW1lbnRzJywgMCwgYXJndW1lbnRzLmxlbmd0aF0pO1xuICB9XG59XG4iLCAiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge1xuICBfYXJyYXlVbmlxdWUsIGlzQXJyYXksIGlzTnVsbE9yVW5kZWYsXG4gIHZhbHVlT3JEZWZhdWx0LCByZXNvbHZlT2JqZWN0S2V5LCBzaWduLCBkZWZpbmVkXG59IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5mdW5jdGlvbiBnZXRBbGxTY2FsZVZhbHVlcyhzY2FsZSwgdHlwZSkge1xuICBpZiAoIXNjYWxlLl9jYWNoZS4kYmFyKSB7XG4gICAgY29uc3QgdmlzaWJsZU1ldGFzID0gc2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSk7XG4gICAgbGV0IHZhbHVlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB2aXNpYmxlTWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHZpc2libGVNZXRhc1tpXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyhzY2FsZSkpO1xuICAgIH1cbiAgICBzY2FsZS5fY2FjaGUuJGJhciA9IF9hcnJheVVuaXF1ZSh2YWx1ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpKTtcbiAgfVxuICByZXR1cm4gc2NhbGUuX2NhY2hlLiRiYXI7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFwib3B0aW1hbFwiIHNhbXBsZSBzaXplIHRvIG1haW50YWluIGJhcnMgZXF1YWxseSBzaXplZCB3aGlsZSBwcmV2ZW50aW5nIG92ZXJsYXAuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlTWluU2FtcGxlU2l6ZShtZXRhKSB7XG4gIGNvbnN0IHNjYWxlID0gbWV0YS5pU2NhbGU7XG4gIGNvbnN0IHZhbHVlcyA9IGdldEFsbFNjYWxlVmFsdWVzKHNjYWxlLCBtZXRhLnR5cGUpO1xuICBsZXQgbWluID0gc2NhbGUuX2xlbmd0aDtcbiAgbGV0IGksIGlsZW4sIGN1cnIsIHByZXY7XG4gIGNvbnN0IHVwZGF0ZU1pbkFuZFByZXYgPSAoKSA9PiB7XG4gICAgaWYgKGN1cnIgPT09IDMyNzY3IHx8IGN1cnIgPT09IC0zMjc2OCkge1xuICAgICAgLy8gSWdub3JlIHRydW5jYXRlZCBwaXhlbHNcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRlZmluZWQocHJldikpIHtcbiAgICAgIC8vIGN1cnIgLSBwcmV2ID09PSAwIGlzIGlnbm9yZWRcbiAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgTWF0aC5hYnMoY3VyciAtIHByZXYpIHx8IG1pbik7XG4gICAgfVxuICAgIHByZXYgPSBjdXJyO1xuICB9O1xuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY3VyciA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUodmFsdWVzW2ldKTtcbiAgICB1cGRhdGVNaW5BbmRQcmV2KCk7XG4gIH1cblxuICBwcmV2ID0gdW5kZWZpbmVkO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gc2NhbGUudGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY3VyciA9IHNjYWxlLmdldFBpeGVsRm9yVGljayhpKTtcbiAgICB1cGRhdGVNaW5BbmRQcmV2KCk7XG4gIH1cblxuICByZXR1cm4gbWluO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGFuIFwiaWRlYWxcIiBjYXRlZ29yeSBiYXNlZCBvbiB0aGUgYWJzb2x1dGUgYmFyIHRoaWNrbmVzcyBvciwgaWYgdW5kZWZpbmVkIG9yIG51bGwsXG4gKiB1c2VzIHRoZSBzbWFsbGVzdCBpbnRlcnZhbCAoc2VlIGNvbXB1dGVNaW5TYW1wbGVTaXplKSB0aGF0IHByZXZlbnRzIGJhciBvdmVybGFwcGluZy4gVGhpc1xuICogbW9kZSBjdXJyZW50bHkgYWx3YXlzIGdlbmVyYXRlcyBiYXJzIGVxdWFsbHkgc2l6ZWQgKHVudGlsIHdlIGludHJvZHVjZSBzY3JpcHRhYmxlIG9wdGlvbnM/KS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpIHtcbiAgY29uc3QgdGhpY2tuZXNzID0gb3B0aW9ucy5iYXJUaGlja25lc3M7XG4gIGxldCBzaXplLCByYXRpbztcblxuICBpZiAoaXNOdWxsT3JVbmRlZih0aGlja25lc3MpKSB7XG4gICAgc2l6ZSA9IHJ1bGVyLm1pbiAqIG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuICAgIHJhdGlvID0gb3B0aW9ucy5iYXJQZXJjZW50YWdlO1xuICB9IGVsc2Uge1xuICAgIC8vIFdoZW4gYmFyIHRoaWNrbmVzcyBpcyBlbmZvcmNlZCwgY2F0ZWdvcnkgYW5kIGJhciBwZXJjZW50YWdlcyBhcmUgaWdub3JlZC5cbiAgICAvLyBOb3RlKFNCKTogd2UgY291bGQgYWRkIHN1cHBvcnQgZm9yIHJlbGF0aXZlIGJhciB0aGlja25lc3MgKGUuZy4gYmFyVGhpY2tuZXNzOiAnNTAlJylcbiAgICAvLyBhbmQgZGVwcmVjYXRlIGJhclBlcmNlbnRhZ2Ugc2luY2UgdGhpcyB2YWx1ZSBpcyBpZ25vcmVkIHdoZW4gdGhpY2tuZXNzIGlzIGFic29sdXRlLlxuICAgIHNpemUgPSB0aGlja25lc3MgKiBzdGFja0NvdW50O1xuICAgIHJhdGlvID0gMTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2h1bms6IHNpemUgLyBzdGFja0NvdW50LFxuICAgIHJhdGlvLFxuICAgIHN0YXJ0OiBydWxlci5waXhlbHNbaW5kZXhdIC0gKHNpemUgLyAyKVxuICB9O1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGFuIFwib3B0aW1hbFwiIGNhdGVnb3J5IHRoYXQgZ2xvYmFsbHkgYXJyYW5nZXMgYmFycyBzaWRlIGJ5IHNpZGUgKG5vIGdhcCB3aGVuXG4gKiBwZXJjZW50YWdlIG9wdGlvbnMgYXJlIDEpLCBiYXNlZCBvbiB0aGUgcHJldmlvdXMgYW5kIGZvbGxvd2luZyBjYXRlZ29yaWVzLiBUaGlzIG1vZGVcbiAqIGdlbmVyYXRlcyBiYXJzIHdpdGggZGlmZmVyZW50IHdpZHRocyB3aGVuIGRhdGEgYXJlIG5vdCBldmVubHkgc3BhY2VkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpIHtcbiAgY29uc3QgcGl4ZWxzID0gcnVsZXIucGl4ZWxzO1xuICBjb25zdCBjdXJyID0gcGl4ZWxzW2luZGV4XTtcbiAgbGV0IHByZXYgPSBpbmRleCA+IDAgPyBwaXhlbHNbaW5kZXggLSAxXSA6IG51bGw7XG4gIGxldCBuZXh0ID0gaW5kZXggPCBwaXhlbHMubGVuZ3RoIC0gMSA/IHBpeGVsc1tpbmRleCArIDFdIDogbnVsbDtcbiAgY29uc3QgcGVyY2VudCA9IG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuXG4gIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgLy8gZmlyc3QgZGF0YTogaXRzIHNpemUgaXMgZG91YmxlIGJhc2VkIG9uIHRoZSBuZXh0IHBvaW50IG9yLFxuICAgIC8vIGlmIGl0J3MgYWxzbyB0aGUgbGFzdCBkYXRhLCB3ZSB1c2UgdGhlIHNjYWxlIHNpemUuXG4gICAgcHJldiA9IGN1cnIgLSAobmV4dCA9PT0gbnVsbCA/IHJ1bGVyLmVuZCAtIHJ1bGVyLnN0YXJ0IDogbmV4dCAtIGN1cnIpO1xuICB9XG5cbiAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAvLyBsYXN0IGRhdGE6IGl0cyBzaXplIGlzIGFsc28gZG91YmxlIGJhc2VkIG9uIHRoZSBwcmV2aW91cyBwb2ludC5cbiAgICBuZXh0ID0gY3VyciArIGN1cnIgLSBwcmV2O1xuICB9XG5cbiAgY29uc3Qgc3RhcnQgPSBjdXJyIC0gKGN1cnIgLSBNYXRoLm1pbihwcmV2LCBuZXh0KSkgLyAyICogcGVyY2VudDtcbiAgY29uc3Qgc2l6ZSA9IE1hdGguYWJzKG5leHQgLSBwcmV2KSAvIDIgKiBwZXJjZW50O1xuXG4gIHJldHVybiB7XG4gICAgY2h1bms6IHNpemUgLyBzdGFja0NvdW50LFxuICAgIHJhdGlvOiBvcHRpb25zLmJhclBlcmNlbnRhZ2UsXG4gICAgc3RhcnRcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VGbG9hdEJhcihlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSB7XG4gIGNvbnN0IHN0YXJ0VmFsdWUgPSB2U2NhbGUucGFyc2UoZW50cnlbMF0sIGkpO1xuICBjb25zdCBlbmRWYWx1ZSA9IHZTY2FsZS5wYXJzZShlbnRyeVsxXSwgaSk7XG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgoc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xuICBsZXQgYmFyU3RhcnQgPSBtaW47XG4gIGxldCBiYXJFbmQgPSBtYXg7XG5cbiAgaWYgKE1hdGguYWJzKG1pbikgPiBNYXRoLmFicyhtYXgpKSB7XG4gICAgYmFyU3RhcnQgPSBtYXg7XG4gICAgYmFyRW5kID0gbWluO1xuICB9XG5cbiAgLy8gU3RvcmUgYGJhckVuZGAgKGZ1cnRoZXN0IGF3YXkgZnJvbSBvcmlnaW4pIGFzIHBhcnNlZCB2YWx1ZSxcbiAgLy8gdG8gbWFrZSBzdGFja2luZyBzdHJhaWdodCBmb3J3YXJkXG4gIGl0ZW1bdlNjYWxlLmF4aXNdID0gYmFyRW5kO1xuXG4gIGl0ZW0uX2N1c3RvbSA9IHtcbiAgICBiYXJTdGFydCxcbiAgICBiYXJFbmQsXG4gICAgc3RhcnQ6IHN0YXJ0VmFsdWUsXG4gICAgZW5kOiBlbmRWYWx1ZSxcbiAgICBtaW4sXG4gICAgbWF4XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlVmFsdWUoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkge1xuICBpZiAoaXNBcnJheShlbnRyeSkpIHtcbiAgICBwYXJzZUZsb2F0QmFyKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpO1xuICB9IGVsc2Uge1xuICAgIGl0ZW1bdlNjYWxlLmF4aXNdID0gdlNjYWxlLnBhcnNlKGVudHJ5LCBpKTtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cblxuZnVuY3Rpb24gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICBjb25zdCBpU2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgY29uc3QgdlNjYWxlID0gbWV0YS52U2NhbGU7XG4gIGNvbnN0IGxhYmVscyA9IGlTY2FsZS5nZXRMYWJlbHMoKTtcbiAgY29uc3Qgc2luZ2xlU2NhbGUgPSBpU2NhbGUgPT09IHZTY2FsZTtcbiAgY29uc3QgcGFyc2VkID0gW107XG4gIGxldCBpLCBpbGVuLCBpdGVtLCBlbnRyeTtcblxuICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBlbnRyeSA9IGRhdGFbaV07XG4gICAgaXRlbSA9IHt9O1xuICAgIGl0ZW1baVNjYWxlLmF4aXNdID0gc2luZ2xlU2NhbGUgfHwgaVNjYWxlLnBhcnNlKGxhYmVsc1tpXSwgaSk7XG4gICAgcGFyc2VkLnB1c2gocGFyc2VWYWx1ZShlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cblxuZnVuY3Rpb24gaXNGbG9hdEJhcihjdXN0b20pIHtcbiAgcmV0dXJuIGN1c3RvbSAmJiBjdXN0b20uYmFyU3RhcnQgIT09IHVuZGVmaW5lZCAmJiBjdXN0b20uYmFyRW5kICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGJhclNpZ24oc2l6ZSwgdlNjYWxlLCBhY3R1YWxCYXNlKSB7XG4gIGlmIChzaXplICE9PSAwKSB7XG4gICAgcmV0dXJuIHNpZ24oc2l6ZSk7XG4gIH1cbiAgcmV0dXJuICh2U2NhbGUuaXNIb3Jpem9udGFsKCkgPyAxIDogLTEpICogKHZTY2FsZS5taW4gPj0gYWN0dWFsQmFzZSA/IDEgOiAtMSk7XG59XG5cbmZ1bmN0aW9uIGJvcmRlclByb3BzKHByb3BlcnRpZXMpIHtcbiAgbGV0IHJldmVyc2UsIHN0YXJ0LCBlbmQsIHRvcCwgYm90dG9tO1xuICBpZiAocHJvcGVydGllcy5ob3Jpem9udGFsKSB7XG4gICAgcmV2ZXJzZSA9IHByb3BlcnRpZXMuYmFzZSA+IHByb3BlcnRpZXMueDtcbiAgICBzdGFydCA9ICdsZWZ0JztcbiAgICBlbmQgPSAncmlnaHQnO1xuICB9IGVsc2Uge1xuICAgIHJldmVyc2UgPSBwcm9wZXJ0aWVzLmJhc2UgPCBwcm9wZXJ0aWVzLnk7XG4gICAgc3RhcnQgPSAnYm90dG9tJztcbiAgICBlbmQgPSAndG9wJztcbiAgfVxuICBpZiAocmV2ZXJzZSkge1xuICAgIHRvcCA9ICdlbmQnO1xuICAgIGJvdHRvbSA9ICdzdGFydCc7XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gJ3N0YXJ0JztcbiAgICBib3R0b20gPSAnZW5kJztcbiAgfVxuICByZXR1cm4ge3N0YXJ0LCBlbmQsIHJldmVyc2UsIHRvcCwgYm90dG9tfTtcbn1cblxuZnVuY3Rpb24gc2V0Qm9yZGVyU2tpcHBlZChwcm9wZXJ0aWVzLCBvcHRpb25zLCBzdGFjaywgaW5kZXgpIHtcbiAgbGV0IGVkZ2UgPSBvcHRpb25zLmJvcmRlclNraXBwZWQ7XG4gIGNvbnN0IHJlcyA9IHt9O1xuXG4gIGlmICghZWRnZSkge1xuICAgIHByb3BlcnRpZXMuYm9yZGVyU2tpcHBlZCA9IHJlcztcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZWRnZSA9PT0gdHJ1ZSkge1xuICAgIHByb3BlcnRpZXMuYm9yZGVyU2tpcHBlZCA9IHt0b3A6IHRydWUsIHJpZ2h0OiB0cnVlLCBib3R0b206IHRydWUsIGxlZnQ6IHRydWV9O1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHtzdGFydCwgZW5kLCByZXZlcnNlLCB0b3AsIGJvdHRvbX0gPSBib3JkZXJQcm9wcyhwcm9wZXJ0aWVzKTtcblxuICBpZiAoZWRnZSA9PT0gJ21pZGRsZScgJiYgc3RhY2spIHtcbiAgICBwcm9wZXJ0aWVzLmVuYWJsZUJvcmRlclJhZGl1cyA9IHRydWU7XG4gICAgaWYgKChzdGFjay5fdG9wIHx8IDApID09PSBpbmRleCkge1xuICAgICAgZWRnZSA9IHRvcDtcbiAgICB9IGVsc2UgaWYgKChzdGFjay5fYm90dG9tIHx8IDApID09PSBpbmRleCkge1xuICAgICAgZWRnZSA9IGJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW3BhcnNlRWRnZShib3R0b20sIHN0YXJ0LCBlbmQsIHJldmVyc2UpXSA9IHRydWU7XG4gICAgICBlZGdlID0gdG9wO1xuICAgIH1cbiAgfVxuXG4gIHJlc1twYXJzZUVkZ2UoZWRnZSwgc3RhcnQsIGVuZCwgcmV2ZXJzZSldID0gdHJ1ZTtcbiAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0gcmVzO1xufVxuXG5mdW5jdGlvbiBwYXJzZUVkZ2UoZWRnZSwgYSwgYiwgcmV2ZXJzZSkge1xuICBpZiAocmV2ZXJzZSkge1xuICAgIGVkZ2UgPSBzd2FwKGVkZ2UsIGEsIGIpO1xuICAgIGVkZ2UgPSBzdGFydEVuZChlZGdlLCBiLCBhKTtcbiAgfSBlbHNlIHtcbiAgICBlZGdlID0gc3RhcnRFbmQoZWRnZSwgYSwgYik7XG4gIH1cbiAgcmV0dXJuIGVkZ2U7XG59XG5cbmZ1bmN0aW9uIHN3YXAob3JpZywgdjEsIHYyKSB7XG4gIHJldHVybiBvcmlnID09PSB2MSA/IHYyIDogb3JpZyA9PT0gdjIgPyB2MSA6IG9yaWc7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0RW5kKHYsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHYgPT09ICdzdGFydCcgPyBzdGFydCA6IHYgPT09ICdlbmQnID8gZW5kIDogdjtcbn1cblxuZnVuY3Rpb24gc2V0SW5mbGF0ZUFtb3VudChwcm9wZXJ0aWVzLCB7aW5mbGF0ZUFtb3VudH0sIHJhdGlvKSB7XG4gIHByb3BlcnRpZXMuaW5mbGF0ZUFtb3VudCA9IGluZmxhdGVBbW91bnQgPT09ICdhdXRvJ1xuICAgID8gcmF0aW8gPT09IDEgPyAwLjMzIDogMFxuICAgIDogaW5mbGF0ZUFtb3VudDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAnYmFyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ2JhcicsXG5cbiAgICBjYXRlZ29yeVBlcmNlbnRhZ2U6IDAuOCxcbiAgICBiYXJQZXJjZW50YWdlOiAwLjksXG4gICAgZ3JvdXBlZDogdHJ1ZSxcblxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ2Jhc2UnLCAnd2lkdGgnLCAnaGVpZ2h0J11cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIHNjYWxlczoge1xuICAgICAgX2luZGV4Xzoge1xuICAgICAgICB0eXBlOiAnY2F0ZWdvcnknLFxuICAgICAgICBvZmZzZXQ6IHRydWUsXG4gICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICBvZmZzZXQ6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF92YWx1ZV86IHtcbiAgICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuXHQgKiBPdmVycmlkaW5nIHByaW1pdGl2ZSBkYXRhIHBhcnNpbmcgc2luY2Ugd2Ugc3VwcG9ydCBtaXhlZCBwcmltaXRpdmUvYXJyYXlcblx0ICogZGF0YSBmb3IgZmxvYXQgYmFyc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIE92ZXJyaWRpbmcgYXJyYXkgZGF0YSBwYXJzaW5nIHNpbmNlIHdlIHN1cHBvcnQgbWl4ZWQgcHJpbWl0aXZlL2FycmF5XG5cdCAqIGRhdGEgZm9yIGZsb2F0IGJhcnNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIE92ZXJyaWRpbmcgb2JqZWN0IGRhdGEgcGFyc2luZyBzaW5jZSB3ZSBzdXBwb3J0IG1peGVkIHByaW1pdGl2ZS9hcnJheVxuXHQgKiB2YWx1ZS1zY2FsZSBkYXRhIGZvciBmbG9hdCBiYXJzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCB7eEF4aXNLZXkgPSAneCcsIHlBeGlzS2V5ID0gJ3knfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgY29uc3QgaUF4aXNLZXkgPSBpU2NhbGUuYXhpcyA9PT0gJ3gnID8geEF4aXNLZXkgOiB5QXhpc0tleTtcbiAgICBjb25zdCB2QXhpc0tleSA9IHZTY2FsZS5heGlzID09PSAneCcgPyB4QXhpc0tleSA6IHlBeGlzS2V5O1xuICAgIGNvbnN0IHBhcnNlZCA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCBpdGVtLCBvYmo7XG4gICAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBvYmogPSBkYXRhW2ldO1xuICAgICAgaXRlbSA9IHt9O1xuICAgICAgaXRlbVtpU2NhbGUuYXhpc10gPSBpU2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShvYmosIGlBeGlzS2V5KSwgaSk7XG4gICAgICBwYXJzZWQucHVzaChwYXJzZVZhbHVlKHJlc29sdmVPYmplY3RLZXkob2JqLCB2QXhpc0tleSksIGl0ZW0sIHZTY2FsZSwgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spIHtcbiAgICBzdXBlci51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICBpZiAoY3VzdG9tICYmIHNjYWxlID09PSB0aGlzLl9jYWNoZWRNZXRhLnZTY2FsZSkge1xuICAgICAgLy8gZmxvYXQgYmFyOiBvbmx5IG9uZSBlbmQgb2YgdGhlIGJhciBpcyBjb25zaWRlcmVkIGJ5IGBzdXBlcmBcbiAgICAgIHJhbmdlLm1pbiA9IE1hdGgubWluKHJhbmdlLm1pbiwgY3VzdG9tLm1pbik7XG4gICAgICByYW5nZS5tYXggPSBNYXRoLm1heChyYW5nZS5tYXgsIGN1c3RvbS5tYXgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ8Ym9vbGVhbn1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICBjb25zdCB2YWx1ZSA9IGlzRmxvYXRCYXIoY3VzdG9tKVxuICAgICAgPyAnWycgKyBjdXN0b20uc3RhcnQgKyAnLCAnICsgY3VzdG9tLmVuZCArICddJ1xuICAgICAgOiAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiAnJyArIGlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFtpU2NhbGUuYXhpc10pLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG5cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuXG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuXG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgbWV0YS5zdGFjayA9IHRoaXMuZ2V0RGF0YXNldCgpLnN0YWNrO1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKG1ldGEuZGF0YSwgMCwgbWV0YS5kYXRhLmxlbmd0aCwgbW9kZSk7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhiYXJzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2luZGV4LCBfY2FjaGVkTWV0YToge3ZTY2FsZX19ID0gdGhpcztcbiAgICBjb25zdCBiYXNlID0gdlNjYWxlLmdldEJhc2VQaXhlbCgpO1xuICAgIGNvbnN0IGhvcml6b250YWwgPSB2U2NhbGUuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgcnVsZXIgPSB0aGlzLl9nZXRSdWxlcigpO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcblxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCB2cGl4ZWxzID0gcmVzZXQgfHwgaXNOdWxsT3JVbmRlZihwYXJzZWRbdlNjYWxlLmF4aXNdKSA/IHtiYXNlLCBoZWFkOiBiYXNlfSA6IHRoaXMuX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGkpO1xuICAgICAgY29uc3QgaXBpeGVscyA9IHRoaXMuX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzKGksIHJ1bGVyKTtcbiAgICAgIGNvbnN0IHN0YWNrID0gKHBhcnNlZC5fc3RhY2tzIHx8IHt9KVt2U2NhbGUuYXhpc107XG5cbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIGhvcml6b250YWwsXG4gICAgICAgIGJhc2U6IHZwaXhlbHMuYmFzZSxcbiAgICAgICAgZW5hYmxlQm9yZGVyUmFkaXVzOiAhc3RhY2sgfHwgaXNGbG9hdEJhcihwYXJzZWQuX2N1c3RvbSkgfHwgKGluZGV4ID09PSBzdGFjay5fdG9wIHx8IGluZGV4ID09PSBzdGFjay5fYm90dG9tKSxcbiAgICAgICAgeDogaG9yaXpvbnRhbCA/IHZwaXhlbHMuaGVhZCA6IGlwaXhlbHMuY2VudGVyLFxuICAgICAgICB5OiBob3Jpem9udGFsID8gaXBpeGVscy5jZW50ZXIgOiB2cGl4ZWxzLmhlYWQsXG4gICAgICAgIGhlaWdodDogaG9yaXpvbnRhbCA/IGlwaXhlbHMuc2l6ZSA6IE1hdGguYWJzKHZwaXhlbHMuc2l6ZSksXG4gICAgICAgIHdpZHRoOiBob3Jpem9udGFsID8gTWF0aC5hYnModnBpeGVscy5zaXplKSA6IGlwaXhlbHMuc2l6ZVxuICAgICAgfTtcblxuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGJhcnNbaV0uYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBwcm9wZXJ0aWVzLm9wdGlvbnMgfHwgYmFyc1tpXS5vcHRpb25zO1xuICAgICAgc2V0Qm9yZGVyU2tpcHBlZChwcm9wZXJ0aWVzLCBvcHRpb25zLCBzdGFjaywgaW5kZXgpO1xuICAgICAgc2V0SW5mbGF0ZUFtb3VudChwcm9wZXJ0aWVzLCBvcHRpb25zLCBydWxlci5yYXRpbyk7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoYmFyc1tpXSwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHN0YWNrcyBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2xhc3RdIC0gVGhlIGRhdGFzZXQgaW5kZXhcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtkYXRhSW5kZXhdIC0gVGhlIGRhdGEgaW5kZXggb2YgdGhlIHJ1bGVyXG5cdCAqIEByZXR1cm5zIHtzdHJpbmdbXX0gVGhlIGxpc3Qgb2Ygc3RhY2sgSURzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0U3RhY2tzKGxhc3QsIGRhdGFJbmRleCkge1xuICAgIGNvbnN0IHtpU2NhbGV9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBtZXRhc2V0cyA9IGlTY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0aGlzLl90eXBlKVxuICAgICAgLmZpbHRlcihtZXRhID0+IG1ldGEuY29udHJvbGxlci5vcHRpb25zLmdyb3VwZWQpO1xuICAgIGNvbnN0IHN0YWNrZWQgPSBpU2NhbGUub3B0aW9ucy5zdGFja2VkO1xuICAgIGNvbnN0IHN0YWNrcyA9IFtdO1xuICAgIGNvbnN0IGN1cnJlbnRQYXJzZWQgPSB0aGlzLl9jYWNoZWRNZXRhLmNvbnRyb2xsZXIuZ2V0UGFyc2VkKGRhdGFJbmRleCk7XG4gICAgY29uc3QgaVNjYWxlVmFsdWUgPSBjdXJyZW50UGFyc2VkICYmIGN1cnJlbnRQYXJzZWRbaVNjYWxlLmF4aXNdO1xuXG4gICAgY29uc3Qgc2tpcE51bGwgPSAobWV0YSkgPT4ge1xuICAgICAgY29uc3QgcGFyc2VkID0gbWV0YS5fcGFyc2VkLmZpbmQoaXRlbSA9PiBpdGVtW2lTY2FsZS5heGlzXSA9PT0gaVNjYWxlVmFsdWUpO1xuICAgICAgY29uc3QgdmFsID0gcGFyc2VkICYmIHBhcnNlZFttZXRhLnZTY2FsZS5heGlzXTtcblxuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsKSB8fCBpc05hTih2YWwpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKGNvbnN0IG1ldGEgb2YgbWV0YXNldHMpIHtcbiAgICAgIGlmIChkYXRhSW5kZXggIT09IHVuZGVmaW5lZCAmJiBza2lwTnVsbChtZXRhKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gc3RhY2tlZCAgIHwgbWV0YS5zdGFja1xuICAgICAgLy8gICAgICAgICAgIHwgZm91bmQgfCBub3QgZm91bmQgfCB1bmRlZmluZWRcbiAgICAgIC8vIGZhbHNlICAgICB8ICAgeCAgIHwgICAgIHggICAgIHwgICAgIHhcbiAgICAgIC8vIHRydWUgICAgICB8ICAgICAgIHwgICAgIHggICAgIHxcbiAgICAgIC8vIHVuZGVmaW5lZCB8ICAgICAgIHwgICAgIHggICAgIHwgICAgIHhcbiAgICAgIGlmIChzdGFja2VkID09PSBmYWxzZSB8fCBzdGFja3MuaW5kZXhPZihtZXRhLnN0YWNrKSA9PT0gLTEgfHxcblx0XHRcdFx0KHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHN0YWNrcy5wdXNoKG1ldGEuc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKG1ldGEuaW5kZXggPT09IGxhc3QpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm8gc3RhY2tzPyB0aGF0IG1lYW5zIHRoZXJlIGlzIG5vIHZpc2libGUgZGF0YS4gTGV0J3Mgc3RpbGwgaW5pdGlhbGl6ZSBhbiBgdW5kZWZpbmVkYFxuICAgIC8vIHN0YWNrIHdoZXJlIHBvc3NpYmxlIGludmlzaWJsZSBiYXJzIHdpbGwgYmUgbG9jYXRlZC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNjM2OFxuICAgIGlmICghc3RhY2tzLmxlbmd0aCkge1xuICAgICAgc3RhY2tzLnB1c2godW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhY2tzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIGVmZmVjdGl2ZSBudW1iZXIgb2Ygc3RhY2tzIGJhc2VkIG9uIGdyb3VwcyBhbmQgYmFyIHZpc2liaWxpdHkuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0U3RhY2tDb3VudChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTdGFja3ModW5kZWZpbmVkLCBpbmRleCkubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHN0YWNrIGluZGV4IGZvciB0aGUgZ2l2ZW4gZGF0YXNldCBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFzZXRJbmRleF0gLSBUaGUgZGF0YXNldCBpbmRleFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdIC0gVGhlIHN0YWNrIG5hbWUgdG8gZmluZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFJbmRleF1cblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIHN0YWNrIGluZGV4XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0U3RhY2tJbmRleChkYXRhc2V0SW5kZXgsIG5hbWUsIGRhdGFJbmRleCkge1xuICAgIGNvbnN0IHN0YWNrcyA9IHRoaXMuX2dldFN0YWNrcyhkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCk7XG4gICAgY29uc3QgaW5kZXggPSAobmFtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgPyBzdGFja3MuaW5kZXhPZihuYW1lKVxuICAgICAgOiAtMTsgLy8gaW5kZXhPZiByZXR1cm5zIC0xIGlmIGVsZW1lbnQgaXMgbm90IHByZXNlbnRcblxuICAgIHJldHVybiAoaW5kZXggPT09IC0xKVxuICAgICAgPyBzdGFja3MubGVuZ3RoIC0gMVxuICAgICAgOiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFJ1bGVyKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgcGl4ZWxzID0gW107XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YS5kYXRhLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcGl4ZWxzLnB1c2goaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaSlbaVNjYWxlLmF4aXNdLCBpKSk7XG4gICAgfVxuXG4gICAgY29uc3QgYmFyVGhpY2tuZXNzID0gb3B0cy5iYXJUaGlja25lc3M7XG4gICAgY29uc3QgbWluID0gYmFyVGhpY2tuZXNzIHx8IGNvbXB1dGVNaW5TYW1wbGVTaXplKG1ldGEpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbixcbiAgICAgIHBpeGVscyxcbiAgICAgIHN0YXJ0OiBpU2NhbGUuX3N0YXJ0UGl4ZWwsXG4gICAgICBlbmQ6IGlTY2FsZS5fZW5kUGl4ZWwsXG4gICAgICBzdGFja0NvdW50OiB0aGlzLl9nZXRTdGFja0NvdW50KCksXG4gICAgICBzY2FsZTogaVNjYWxlLFxuICAgICAgZ3JvdXBlZDogb3B0cy5ncm91cGVkLFxuICAgICAgLy8gYmFyIHRoaWNrbmVzcyByYXRpbyB1c2VkIGZvciBub24tZ3JvdXBlZCBiYXJzXG4gICAgICByYXRpbzogYmFyVGhpY2tuZXNzID8gMSA6IG9wdHMuY2F0ZWdvcnlQZXJjZW50YWdlICogb3B0cy5iYXJQZXJjZW50YWdlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBOb3RlOiBwaXhlbCB2YWx1ZXMgYXJlIG5vdCBjbGFtcGVkIHRvIHRoZSBzY2FsZSBhcmVhLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGluZGV4KSB7XG4gICAgY29uc3Qge19jYWNoZWRNZXRhOiB7dlNjYWxlLCBfc3RhY2tlZCwgaW5kZXg6IGRhdGFzZXRJbmRleH0sIG9wdGlvbnM6IHtiYXNlOiBiYXNlVmFsdWUsIG1pbkJhckxlbmd0aH19ID0gdGhpcztcbiAgICBjb25zdCBhY3R1YWxCYXNlID0gYmFzZVZhbHVlIHx8IDA7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGNvbnN0IGZsb2F0aW5nID0gaXNGbG9hdEJhcihjdXN0b20pO1xuICAgIGxldCB2YWx1ZSA9IHBhcnNlZFt2U2NhbGUuYXhpc107XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgbGVuZ3RoID0gX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHZhbHVlO1xuICAgIGxldCBoZWFkLCBzaXplO1xuXG4gICAgaWYgKGxlbmd0aCAhPT0gdmFsdWUpIHtcbiAgICAgIHN0YXJ0ID0gbGVuZ3RoIC0gdmFsdWU7XG4gICAgICBsZW5ndGggPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoZmxvYXRpbmcpIHtcbiAgICAgIHZhbHVlID0gY3VzdG9tLmJhclN0YXJ0O1xuICAgICAgbGVuZ3RoID0gY3VzdG9tLmJhckVuZCAtIGN1c3RvbS5iYXJTdGFydDtcbiAgICAgIC8vIGJhcnMgY3Jvc3Npbmcgb3JpZ2luIGFyZSBub3Qgc3RhY2tlZFxuICAgICAgaWYgKHZhbHVlICE9PSAwICYmIHNpZ24odmFsdWUpICE9PSBzaWduKGN1c3RvbS5iYXJFbmQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ICs9IHZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0VmFsdWUgPSAhaXNOdWxsT3JVbmRlZihiYXNlVmFsdWUpICYmICFmbG9hdGluZyA/IGJhc2VWYWx1ZSA6IHN0YXJ0O1xuICAgIGxldCBiYXNlID0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3RhcnRWYWx1ZSk7XG5cbiAgICBpZiAodGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgIGhlYWQgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydCArIGxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdoZW4gbm90IHZpc2libGUsIG5vIGhlaWdodFxuICAgICAgaGVhZCA9IGJhc2U7XG4gICAgfVxuXG4gICAgc2l6ZSA9IGhlYWQgLSBiYXNlO1xuXG4gICAgaWYgKE1hdGguYWJzKHNpemUpIDwgbWluQmFyTGVuZ3RoKSB7XG4gICAgICBzaXplID0gYmFyU2lnbihzaXplLCB2U2NhbGUsIGFjdHVhbEJhc2UpICogbWluQmFyTGVuZ3RoO1xuICAgICAgaWYgKHZhbHVlID09PSBhY3R1YWxCYXNlKSB7XG4gICAgICAgIGJhc2UgLT0gc2l6ZSAvIDI7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFydFBpeGVsID0gdlNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgwKTtcbiAgICAgIGNvbnN0IGVuZFBpeGVsID0gdlNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgxKTtcbiAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKHN0YXJ0UGl4ZWwsIGVuZFBpeGVsKTtcbiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHN0YXJ0UGl4ZWwsIGVuZFBpeGVsKTtcbiAgICAgIGJhc2UgPSBNYXRoLm1heChNYXRoLm1pbihiYXNlLCBtYXgpLCBtaW4pO1xuICAgICAgaGVhZCA9IGJhc2UgKyBzaXplO1xuXG4gICAgICBpZiAoX3N0YWNrZWQgJiYgIWZsb2F0aW5nKSB7XG4gICAgICAgIC8vIHZpc3VhbCBkYXRhIGNvb3JkaW5hdGVzIGFmdGVyIGFwcGx5aW5nIG1pbkJhckxlbmd0aFxuICAgICAgICBwYXJzZWQuX3N0YWNrc1t2U2NhbGUuYXhpc10uX3Zpc3VhbFZhbHVlc1tkYXRhc2V0SW5kZXhdID0gdlNjYWxlLmdldFZhbHVlRm9yUGl4ZWwoaGVhZCkgLSB2U2NhbGUuZ2V0VmFsdWVGb3JQaXhlbChiYXNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoYWN0dWFsQmFzZSkpIHtcbiAgICAgIGNvbnN0IGhhbGZHcmlkID0gc2lnbihzaXplKSAqIHZTY2FsZS5nZXRMaW5lV2lkdGhGb3JWYWx1ZShhY3R1YWxCYXNlKSAvIDI7XG4gICAgICBiYXNlICs9IGhhbGZHcmlkO1xuICAgICAgc2l6ZSAtPSBoYWxmR3JpZDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2l6ZSxcbiAgICAgIGJhc2UsXG4gICAgICBoZWFkLFxuICAgICAgY2VudGVyOiBoZWFkICsgc2l6ZSAvIDJcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMoaW5kZXgsIHJ1bGVyKSB7XG4gICAgY29uc3Qgc2NhbGUgPSBydWxlci5zY2FsZTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNraXBOdWxsID0gb3B0aW9ucy5za2lwTnVsbDtcbiAgICBjb25zdCBtYXhCYXJUaGlja25lc3MgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLm1heEJhclRoaWNrbmVzcywgSW5maW5pdHkpO1xuICAgIGxldCBjZW50ZXIsIHNpemU7XG4gICAgaWYgKHJ1bGVyLmdyb3VwZWQpIHtcbiAgICAgIGNvbnN0IHN0YWNrQ291bnQgPSBza2lwTnVsbCA/IHRoaXMuX2dldFN0YWNrQ291bnQoaW5kZXgpIDogcnVsZXIuc3RhY2tDb3VudDtcbiAgICAgIGNvbnN0IHJhbmdlID0gb3B0aW9ucy5iYXJUaGlja25lc3MgPT09ICdmbGV4J1xuICAgICAgICA/IGNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KVxuICAgICAgICA6IGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpO1xuXG4gICAgICBjb25zdCBzdGFja0luZGV4ID0gdGhpcy5fZ2V0U3RhY2tJbmRleCh0aGlzLmluZGV4LCB0aGlzLl9jYWNoZWRNZXRhLnN0YWNrLCBza2lwTnVsbCA/IGluZGV4IDogdW5kZWZpbmVkKTtcbiAgICAgIGNlbnRlciA9IHJhbmdlLnN0YXJ0ICsgKHJhbmdlLmNodW5rICogc3RhY2tJbmRleCkgKyAocmFuZ2UuY2h1bmsgLyAyKTtcbiAgICAgIHNpemUgPSBNYXRoLm1pbihtYXhCYXJUaGlja25lc3MsIHJhbmdlLmNodW5rICogcmFuZ2UucmF0aW8pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3Igbm9uLWdyb3VwZWQgYmFyIGNoYXJ0cywgZXhhY3QgcGl4ZWwgdmFsdWVzIGFyZSB1c2VkXG4gICAgICBjZW50ZXIgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKGluZGV4KVtzY2FsZS5heGlzXSwgaW5kZXgpO1xuICAgICAgc2l6ZSA9IE1hdGgubWluKG1heEJhclRoaWNrbmVzcywgcnVsZXIubWluICogcnVsZXIucmF0aW8pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBiYXNlOiBjZW50ZXIgLSBzaXplIC8gMixcbiAgICAgIGhlYWQ6IGNlbnRlciArIHNpemUgLyAyLFxuICAgICAgY2VudGVyLFxuICAgICAgc2l6ZVxuICAgIH07XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHJlY3RzID0gbWV0YS5kYXRhO1xuICAgIGNvbnN0IGlsZW4gPSByZWN0cy5sZW5ndGg7XG4gICAgbGV0IGkgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmdldFBhcnNlZChpKVt2U2NhbGUuYXhpc10gIT09IG51bGwgJiYgIXJlY3RzW2ldLmhpZGRlbikge1xuICAgICAgICByZWN0c1tpXS5kcmF3KHRoaXMuX2N0eCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cbiIsICJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7dmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnViYmxlQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAnYnViYmxlJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcblxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ2JvcmRlcldpZHRoJywgJ3JhZGl1cyddXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlcyA9IHtcbiAgICBzY2FsZXM6IHtcbiAgICAgIHg6IHtcbiAgICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICAgIH0sXG4gICAgICB5OiB7XG4gICAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gIH1cblxuICAvKipcblx0ICogUGFyc2UgYXJyYXkgb2YgcHJpbWl0aXZlIHZhbHVlc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgcGFyc2VkID0gc3VwZXIucGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhcnNlZFtpXS5fY3VzdG9tID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkgKyBzdGFydCkucmFkaXVzO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIGFycmF5c1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdXBlci5wYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gZGF0YVtzdGFydCArIGldO1xuICAgICAgcGFyc2VkW2ldLl9jdXN0b20gPSB2YWx1ZU9yRGVmYXVsdChpdGVtWzJdLCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSArIHN0YXJ0KS5yYWRpdXMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIG9iamVjdHNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gZGF0YVtzdGFydCArIGldO1xuICAgICAgcGFyc2VkW2ldLl9jdXN0b20gPSB2YWx1ZU9yRGVmYXVsdChpdGVtICYmIGl0ZW0uciAmJiAraXRlbS5yLCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSArIHN0YXJ0KS5yYWRpdXMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG5cbiAgICBsZXQgbWF4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBkYXRhW2ldLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpKSAvIDIpO1xuICAgIH1cbiAgICByZXR1cm4gbWF4ID4gMCAmJiBtYXg7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IHggPSB4U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWQueCk7XG4gICAgY29uc3QgeSA9IHlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC55KTtcbiAgICBjb25zdCByID0gcGFyc2VkLl9jdXN0b207XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICB2YWx1ZTogJygnICsgeCArICcsICcgKyB5ICsgKHIgPyAnLCAnICsgciA6ICcnKSArICcpJ1xuICAgIH07XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcblxuICAgIC8vIFVwZGF0ZSBQb2ludHNcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgMCwgcG9pbnRzLmxlbmd0aCwgbW9kZSk7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9ICFyZXNldCAmJiB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7fTtcbiAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gcmVzZXQgPyBpU2NhbGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDAuNSkgOiBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdKTtcbiAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbdkF4aXNdKTtcblxuICAgICAgcHJvcGVydGllcy5za2lwID0gaXNOYU4oaVBpeGVsKSB8fCBpc05hTih2UGl4ZWwpO1xuXG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcblxuICAgICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMucmFkaXVzID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcblx0ICogQHBhcmFtIHtzdHJpbmd9IFttb2RlXVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICByZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKSB7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGxldCB2YWx1ZXMgPSBzdXBlci5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKTtcblxuICAgIC8vIEluIGNhc2UgdmFsdWVzIHdlcmUgY2FjaGVkIChhbmQgdGh1cyBmcm96ZW4pLCB3ZSBuZWVkIHRvIGNsb25lIHRoZSB2YWx1ZXNcbiAgICBpZiAodmFsdWVzLiRzaGFyZWQpIHtcbiAgICAgIHZhbHVlcyA9IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlcywgeyRzaGFyZWQ6IGZhbHNlfSk7XG4gICAgfVxuXG4gICAgLy8gQ3VzdG9tIHJhZGl1cyByZXNvbHV0aW9uXG4gICAgY29uc3QgcmFkaXVzID0gdmFsdWVzLnJhZGl1cztcbiAgICBpZiAobW9kZSAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgIHZhbHVlcy5yYWRpdXMgPSAwO1xuICAgIH1cbiAgICB2YWx1ZXMucmFkaXVzICs9IHZhbHVlT3JEZWZhdWx0KHBhcnNlZCAmJiBwYXJzZWQuX2N1c3RvbSwgcmFkaXVzKTtcblxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cbn1cbiIsICJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7aXNPYmplY3QsIHJlc29sdmVPYmplY3RLZXksIHRvUGVyY2VudGFnZSwgdG9EaW1lbnNpb24sIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2Zvcm1hdE51bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmludGwuanMnO1xuaW1wb3J0IHt0b1JhZGlhbnMsIFBJLCBUQVUsIEhBTEZfUEksIF9hbmdsZUJldHdlZW59IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqL1xuXG5mdW5jdGlvbiBnZXRSYXRpb0FuZE9mZnNldChyb3RhdGlvbiwgY2lyY3VtZmVyZW5jZSwgY3V0b3V0KSB7XG4gIGxldCByYXRpb1ggPSAxO1xuICBsZXQgcmF0aW9ZID0gMTtcbiAgbGV0IG9mZnNldFggPSAwO1xuICBsZXQgb2Zmc2V0WSA9IDA7XG4gIC8vIElmIHRoZSBjaGFydCdzIGNpcmN1bWZlcmVuY2UgaXNuJ3QgYSBmdWxsIGNpcmNsZSwgY2FsY3VsYXRlIHNpemUgYXMgYSByYXRpbyBvZiB0aGUgd2lkdGgvaGVpZ2h0IG9mIHRoZSBhcmNcbiAgaWYgKGNpcmN1bWZlcmVuY2UgPCBUQVUpIHtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gcm90YXRpb247XG4gICAgY29uc3QgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgY2lyY3VtZmVyZW5jZTtcbiAgICBjb25zdCBzdGFydFggPSBNYXRoLmNvcyhzdGFydEFuZ2xlKTtcbiAgICBjb25zdCBzdGFydFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcbiAgICBjb25zdCBlbmRYID0gTWF0aC5jb3MoZW5kQW5nbGUpO1xuICAgIGNvbnN0IGVuZFkgPSBNYXRoLnNpbihlbmRBbmdsZSk7XG4gICAgY29uc3QgY2FsY01heCA9IChhbmdsZSwgYSwgYikgPT4gX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIHRydWUpID8gMSA6IE1hdGgubWF4KGEsIGEgKiBjdXRvdXQsIGIsIGIgKiBjdXRvdXQpO1xuICAgIGNvbnN0IGNhbGNNaW4gPSAoYW5nbGUsIGEsIGIpID0+IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCB0cnVlKSA/IC0xIDogTWF0aC5taW4oYSwgYSAqIGN1dG91dCwgYiwgYiAqIGN1dG91dCk7XG4gICAgY29uc3QgbWF4WCA9IGNhbGNNYXgoMCwgc3RhcnRYLCBlbmRYKTtcbiAgICBjb25zdCBtYXhZID0gY2FsY01heChIQUxGX1BJLCBzdGFydFksIGVuZFkpO1xuICAgIGNvbnN0IG1pblggPSBjYWxjTWluKFBJLCBzdGFydFgsIGVuZFgpO1xuICAgIGNvbnN0IG1pblkgPSBjYWxjTWluKFBJICsgSEFMRl9QSSwgc3RhcnRZLCBlbmRZKTtcbiAgICByYXRpb1ggPSAobWF4WCAtIG1pblgpIC8gMjtcbiAgICByYXRpb1kgPSAobWF4WSAtIG1pblkpIC8gMjtcbiAgICBvZmZzZXRYID0gLShtYXhYICsgbWluWCkgLyAyO1xuICAgIG9mZnNldFkgPSAtKG1heFkgKyBtaW5ZKSAvIDI7XG4gIH1cbiAgcmV0dXJuIHtyYXRpb1gsIHJhdGlvWSwgb2Zmc2V0WCwgb2Zmc2V0WX07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvdWdobnV0Q29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAnZG91Z2hudXQnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gICAgZGF0YUVsZW1lbnRUeXBlOiAnYXJjJyxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIC8vIEJvb2xlYW4gLSBXaGV0aGVyIHdlIGFuaW1hdGUgdGhlIHJvdGF0aW9uIG9mIHRoZSBEb3VnaG51dFxuICAgICAgYW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcbiAgICAgIC8vIEJvb2xlYW4gLSBXaGV0aGVyIHdlIGFuaW1hdGUgc2NhbGluZyB0aGUgRG91Z2hudXQgZnJvbSB0aGUgY2VudHJlXG4gICAgICBhbmltYXRlU2NhbGU6IGZhbHNlXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBudW1iZXJzOiB7XG4gICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICBwcm9wZXJ0aWVzOiBbJ2NpcmN1bWZlcmVuY2UnLCAnZW5kQW5nbGUnLCAnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnLCAnc3RhcnRBbmdsZScsICd4JywgJ3knLCAnb2Zmc2V0JywgJ2JvcmRlcldpZHRoJywgJ3NwYWNpbmcnXVxuICAgICAgfSxcbiAgICB9LFxuICAgIC8vIFRoZSBwZXJjZW50YWdlIG9mIHRoZSBjaGFydCB0aGF0IHdlIGN1dCBvdXQgb2YgdGhlIG1pZGRsZS5cbiAgICBjdXRvdXQ6ICc1MCUnLFxuXG4gICAgLy8gVGhlIHJvdGF0aW9uIG9mIHRoZSBjaGFydCwgd2hlcmUgdGhlIGZpcnN0IGRhdGEgYXJjIGJlZ2lucy5cbiAgICByb3RhdGlvbjogMCxcblxuICAgIC8vIFRoZSB0b3RhbCBjaXJjdW1mZXJlbmNlIG9mIHRoZSBjaGFydC5cbiAgICBjaXJjdW1mZXJlbmNlOiAzNjAsXG5cbiAgICAvLyBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBjaGFydFxuICAgIHJhZGl1czogJzEwMCUnLFxuXG4gICAgLy8gU3BhY2luZyBiZXR3ZWVuIGFyY3NcbiAgICBzcGFjaW5nOiAwLFxuXG4gICAgaW5kZXhBeGlzOiAncicsXG4gIH07XG5cbiAgc3RhdGljIGRlc2NyaXB0b3JzID0ge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ3NwYWNpbmcnLFxuICAgIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnc3BhY2luZycgJiYgIW5hbWUuc3RhcnRzV2l0aCgnYm9yZGVyRGFzaCcpICYmICFuYW1lLnN0YXJ0c1dpdGgoJ2hvdmVyQm9yZGVyRGFzaCcpLFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlcyA9IHtcbiAgICBhc3BlY3RSYXRpbzogMSxcblxuICAgIC8vIE5lZWQgdG8gb3ZlcnJpZGUgdGhlc2UgdG8gZ2l2ZSBhIG5pY2UgZGVmYXVsdFxuICAgIHBsdWdpbnM6IHtcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICBnZW5lcmF0ZUxhYmVscyhjaGFydCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmRhdGE7XG4gICAgICAgICAgICBpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtsYWJlbHM6IHtwb2ludFN0eWxlLCBjb2xvcn19ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGEubGFiZWxzLm1hcCgobGFiZWwsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUoaSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgdGV4dDogbGFiZWwsXG4gICAgICAgICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICAgIGZvbnRDb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IHN0eWxlLmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSxcbiAgICAgICAgICAgICAgICAgIGhpZGRlbjogIWNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpLFxuXG4gICAgICAgICAgICAgICAgICAvLyBFeHRyYSBkYXRhIHVzZWQgZm9yIHRvZ2dsaW5nIHRoZSBjb3JyZWN0IGl0ZW1cbiAgICAgICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2xpY2soZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XG4gICAgICAgICAgbGVnZW5kLmNoYXJ0LnRvZ2dsZURhdGFWaXNpYmlsaXR5KGxlZ2VuZEl0ZW0uaW5kZXgpO1xuICAgICAgICAgIGxlZ2VuZC5jaGFydC51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KSB7XG4gICAgc3VwZXIoY2hhcnQsIGRhdGFzZXRJbmRleCk7XG5cbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9mZnNldFggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vZmZzZXRZID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgbGlua1NjYWxlcygpIHt9XG5cbiAgLyoqXG5cdCAqIE92ZXJyaWRlIGRhdGEgcGFyc2luZywgc2luY2Ugd2UgYXJlIG5vdCB1c2luZyBzY2FsZXNcblx0ICovXG4gIHBhcnNlKHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldERhdGFzZXQoKS5kYXRhO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuXG4gICAgaWYgKHRoaXMuX3BhcnNpbmcgPT09IGZhbHNlKSB7XG4gICAgICBtZXRhLl9wYXJzZWQgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZ2V0dGVyID0gKGkpID0+ICtkYXRhW2ldO1xuXG4gICAgICBpZiAoaXNPYmplY3QoZGF0YVtzdGFydF0pKSB7XG4gICAgICAgIGNvbnN0IHtrZXkgPSAndmFsdWUnfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgICAgIGdldHRlciA9IChpKSA9PiArcmVzb2x2ZU9iamVjdEtleShkYXRhW2ldLCBrZXkpO1xuICAgICAgfVxuXG4gICAgICBsZXQgaSwgaWxlbjtcbiAgICAgIGZvciAoaSA9IHN0YXJ0LCBpbGVuID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgICBtZXRhLl9wYXJzZWRbaV0gPSBnZXR0ZXIoaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0Um90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRvUmFkaWFucyh0aGlzLm9wdGlvbnMucm90YXRpb24gLSA5MCk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRDaXJjdW1mZXJlbmNlKCkge1xuICAgIHJldHVybiB0b1JhZGlhbnModGhpcy5vcHRpb25zLmNpcmN1bWZlcmVuY2UpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldCB0aGUgbWF4aW1hbCByb3RhdGlvbiAmIGNpcmN1bWZlcmVuY2UgZXh0ZW50c1xuXHQgKiBhY3Jvc3MgYWxsIHZpc2libGUgZGF0YXNldHMuXG5cdCAqL1xuICBfZ2V0Um90YXRpb25FeHRlbnRzKCkge1xuICAgIGxldCBtaW4gPSBUQVU7XG4gICAgbGV0IG1heCA9IC1UQVU7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKGkpLnR5cGUgPT09IHRoaXMuX3R5cGUpIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSkuY29udHJvbGxlcjtcbiAgICAgICAgY29uc3Qgcm90YXRpb24gPSBjb250cm9sbGVyLl9nZXRSb3RhdGlvbigpO1xuICAgICAgICBjb25zdCBjaXJjdW1mZXJlbmNlID0gY29udHJvbGxlci5fZ2V0Q2lyY3VtZmVyZW5jZSgpO1xuXG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgcm90YXRpb24pO1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHJvdGF0aW9uICsgY2lyY3VtZmVyZW5jZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdGF0aW9uOiBtaW4sXG4gICAgICBjaXJjdW1mZXJlbmNlOiBtYXggLSBtaW4sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbW9kZVxuXHQgKi9cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qge2NoYXJ0QXJlYX0gPSBjaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBhcmNzID0gbWV0YS5kYXRhO1xuICAgIGNvbnN0IHNwYWNpbmcgPSB0aGlzLmdldE1heEJvcmRlcldpZHRoKCkgKyB0aGlzLmdldE1heE9mZnNldChhcmNzKSArIHRoaXMub3B0aW9ucy5zcGFjaW5nO1xuICAgIGNvbnN0IG1heFNpemUgPSBNYXRoLm1heCgoTWF0aC5taW4oY2hhcnRBcmVhLndpZHRoLCBjaGFydEFyZWEuaGVpZ2h0KSAtIHNwYWNpbmcpIC8gMiwgMCk7XG4gICAgY29uc3QgY3V0b3V0ID0gTWF0aC5taW4odG9QZXJjZW50YWdlKHRoaXMub3B0aW9ucy5jdXRvdXQsIG1heFNpemUpLCAxKTtcbiAgICBjb25zdCBjaGFydFdlaWdodCA9IHRoaXMuX2dldFJpbmdXZWlnaHQodGhpcy5pbmRleCk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBtYXhpbWFsIHJvdGF0aW9uICYgY2lyY3VtZmVyZW5jZSBsaW1pdHMuXG4gICAgLy8gSWYgd2Ugb25seSBjb25zaWRlciBvdXIgZGF0YXNldCwgdGhpcyBjYW4gY2F1c2UgcHJvYmxlbXMgd2hlbiB0d28gZGF0YXNldHNcbiAgICAvLyBhcmUgYm90aCBsZXNzIHRoYW4gYSBjaXJjbGUgd2l0aCBkaWZmZXJlbnQgcm90YXRpb25zIChzdGFydGluZyBhbmdsZXMpXG4gICAgY29uc3Qge2NpcmN1bWZlcmVuY2UsIHJvdGF0aW9ufSA9IHRoaXMuX2dldFJvdGF0aW9uRXh0ZW50cygpO1xuICAgIGNvbnN0IHtyYXRpb1gsIHJhdGlvWSwgb2Zmc2V0WCwgb2Zmc2V0WX0gPSBnZXRSYXRpb0FuZE9mZnNldChyb3RhdGlvbiwgY2lyY3VtZmVyZW5jZSwgY3V0b3V0KTtcbiAgICBjb25zdCBtYXhXaWR0aCA9IChjaGFydEFyZWEud2lkdGggLSBzcGFjaW5nKSAvIHJhdGlvWDtcbiAgICBjb25zdCBtYXhIZWlnaHQgPSAoY2hhcnRBcmVhLmhlaWdodCAtIHNwYWNpbmcpIC8gcmF0aW9ZO1xuICAgIGNvbnN0IG1heFJhZGl1cyA9IE1hdGgubWF4KE1hdGgubWluKG1heFdpZHRoLCBtYXhIZWlnaHQpIC8gMiwgMCk7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSB0b0RpbWVuc2lvbih0aGlzLm9wdGlvbnMucmFkaXVzLCBtYXhSYWRpdXMpO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gTWF0aC5tYXgob3V0ZXJSYWRpdXMgKiBjdXRvdXQsIDApO1xuICAgIGNvbnN0IHJhZGl1c0xlbmd0aCA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIHRoaXMuX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwoKTtcbiAgICB0aGlzLm9mZnNldFggPSBvZmZzZXRYICogb3V0ZXJSYWRpdXM7XG4gICAgdGhpcy5vZmZzZXRZID0gb2Zmc2V0WSAqIG91dGVyUmFkaXVzO1xuXG4gICAgbWV0YS50b3RhbCA9IHRoaXMuY2FsY3VsYXRlVG90YWwoKTtcblxuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aCAqIHRoaXMuX2dldFJpbmdXZWlnaHRPZmZzZXQodGhpcy5pbmRleCk7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IE1hdGgubWF4KHRoaXMub3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGggKiBjaGFydFdlaWdodCwgMCk7XG5cbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGFyY3MsIDAsIGFyY3MubGVuZ3RoLCBtb2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSB0aGlzLl9nZXRDaXJjdW1mZXJlbmNlKCk7XG4gICAgaWYgKChyZXNldCAmJiBvcHRzLmFuaW1hdGlvbi5hbmltYXRlUm90YXRlKSB8fCAhdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSB8fCBtZXRhLl9wYXJzZWRbaV0gPT09IG51bGwgfHwgbWV0YS5kYXRhW2ldLmhpZGRlbikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UobWV0YS5fcGFyc2VkW2ldICogY2lyY3VtZmVyZW5jZSAvIFRBVSk7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhhcmNzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcbiAgICBjb25zdCBhbmltYXRpb25PcHRzID0gb3B0cy5hbmltYXRpb247XG4gICAgY29uc3QgY2VudGVyWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSAoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMjtcbiAgICBjb25zdCBhbmltYXRlU2NhbGUgPSByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZTtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IGFuaW1hdGVTY2FsZSA/IDAgOiB0aGlzLmlubmVyUmFkaXVzO1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gYW5pbWF0ZVNjYWxlID8gMCA6IHRoaXMub3V0ZXJSYWRpdXM7XG4gICAgY29uc3Qge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGxldCBzdGFydEFuZ2xlID0gdGhpcy5fZ2V0Um90YXRpb24oKTtcbiAgICBsZXQgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFydDsgKytpKSB7XG4gICAgICBzdGFydEFuZ2xlICs9IHRoaXMuX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBjaXJjdW1mZXJlbmNlID0gdGhpcy5fY2lyY3VtZmVyZW5jZShpLCByZXNldCk7XG4gICAgICBjb25zdCBhcmMgPSBhcmNzW2ldO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgeDogY2VudGVyWCArIHRoaXMub2Zmc2V0WCxcbiAgICAgICAgeTogY2VudGVyWSArIHRoaXMub2Zmc2V0WSxcbiAgICAgICAgc3RhcnRBbmdsZSxcbiAgICAgICAgZW5kQW5nbGU6IHN0YXJ0QW5nbGUgKyBjaXJjdW1mZXJlbmNlLFxuICAgICAgICBjaXJjdW1mZXJlbmNlLFxuICAgICAgICBvdXRlclJhZGl1cyxcbiAgICAgICAgaW5uZXJSYWRpdXNcbiAgICAgIH07XG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYXJjLmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG4gICAgICBzdGFydEFuZ2xlICs9IGNpcmN1bWZlcmVuY2U7XG5cbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChhcmMsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZVRvdGFsKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IG1ldGFEYXRhID0gbWV0YS5kYXRhO1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgbGV0IGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbWV0YURhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gbWV0YS5fcGFyc2VkW2ldO1xuICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmICFpc05hTih2YWx1ZSkgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSAmJiAhbWV0YURhdGFbaV0uaGlkZGVuKSB7XG4gICAgICAgIHRvdGFsICs9IE1hdGguYWJzKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdG90YWw7XG4gIH1cblxuICBjYWxjdWxhdGVDaXJjdW1mZXJlbmNlKHZhbHVlKSB7XG4gICAgY29uc3QgdG90YWwgPSB0aGlzLl9jYWNoZWRNZXRhLnRvdGFsO1xuICAgIGlmICh0b3RhbCA+IDAgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIFRBVSAqIChNYXRoLmFicyh2YWx1ZSkgLyB0b3RhbCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBsYWJlbHMgPSBjaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcbiAgICBjb25zdCB2YWx1ZSA9IGZvcm1hdE51bWJlcihtZXRhLl9wYXJzZWRbaW5kZXhdLCBjaGFydC5vcHRpb25zLmxvY2FsZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICB2YWx1ZSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0TWF4Qm9yZGVyV2lkdGgoYXJjcykge1xuICAgIGxldCBtYXggPSAwO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBsZXQgaSwgaWxlbiwgbWV0YSwgY29udHJvbGxlciwgb3B0aW9ucztcblxuICAgIGlmICghYXJjcykge1xuICAgICAgLy8gRmluZCB0aGUgb3V0bW9zdCB2aXNpYmxlIGRhdGFzZXRcbiAgICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgICBpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuICAgICAgICAgIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgICAgICBhcmNzID0gbWV0YS5kYXRhO1xuICAgICAgICAgIGNvbnRyb2xsZXIgPSBtZXRhLmNvbnRyb2xsZXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWFyY3MpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgb3B0aW9ucyA9IGNvbnRyb2xsZXIucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKTtcbiAgICAgIGlmIChvcHRpb25zLmJvcmRlckFsaWduICE9PSAnaW5uZXInKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgb3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwLCBvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGggfHwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXg7XG4gIH1cblxuICBnZXRNYXhPZmZzZXQoYXJjcykge1xuICAgIGxldCBtYXggPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgb3B0aW9ucy5vZmZzZXQgfHwgMCwgb3B0aW9ucy5ob3Zlck9mZnNldCB8fCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXQgcmFkaXVzIGxlbmd0aCBvZmZzZXQgb2YgdGhlIGRhdGFzZXQgaW4gcmVsYXRpb24gdG8gdGhlIHZpc2libGUgZGF0YXNldHMgd2VpZ2h0cy4gVGhpcyBhbGxvd3MgZGV0ZXJtaW5pbmcgdGhlIGlubmVyIGFuZCBvdXRlciByYWRpdXMgY29ycmVjdGx5XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0UmluZ1dlaWdodE9mZnNldChkYXRhc2V0SW5kZXgpIHtcbiAgICBsZXQgcmluZ1dlaWdodE9mZnNldCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzZXRJbmRleDsgKytpKSB7XG4gICAgICBpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG4gICAgICAgIHJpbmdXZWlnaHRPZmZzZXQgKz0gdGhpcy5fZ2V0UmluZ1dlaWdodChpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmluZ1dlaWdodE9mZnNldDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFJpbmdXZWlnaHQoZGF0YXNldEluZGV4KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHZhbHVlT3JEZWZhdWx0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLndlaWdodCwgMSksIDApO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHN1bSBvZiBhbGwgdmlzaWJsZSBkYXRhIHNldCB3ZWlnaHRzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFJpbmdXZWlnaHRPZmZzZXQodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aCkgfHwgMTtcbiAgfVxufVxuIiwgImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHtpc051bGxPclVuZGVmfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7aXNOdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7X2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMsIF9zY2FsZVJhbmdlc0NoYW5nZWR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAnbGluZSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGF0YXNldEVsZW1lbnRUeXBlOiAnbGluZScsXG4gICAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuXG4gICAgc2hvd0xpbmU6IHRydWUsXG4gICAgc3BhbkdhcHM6IGZhbHNlLFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlcyA9IHtcbiAgICBzY2FsZXM6IHtcbiAgICAgIF9pbmRleF86IHtcbiAgICAgICAgdHlwZTogJ2NhdGVnb3J5JyxcbiAgICAgIH0sXG4gICAgICBfdmFsdWVfOiB7XG4gICAgICAgIHR5cGU6ICdsaW5lYXInLFxuICAgICAgfSxcbiAgICB9XG4gIH07XG5cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHRoaXMuc3VwcG9ydHNEZWNpbWF0aW9uID0gdHJ1ZTtcbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtkYXRhc2V0OiBsaW5lLCBkYXRhOiBwb2ludHMgPSBbXSwgX2RhdGFzZXR9ID0gbWV0YTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgYW5pbWF0aW9uc0Rpc2FibGVkID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICAgIGxldCB7c3RhcnQsIGNvdW50fSA9IF9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGEsIHBvaW50cywgYW5pbWF0aW9uc0Rpc2FibGVkKTtcblxuICAgIHRoaXMuX2RyYXdTdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuX2RyYXdDb3VudCA9IGNvdW50O1xuXG4gICAgaWYgKF9zY2FsZVJhbmdlc0NoYW5nZWQobWV0YSkpIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgTGluZVxuICAgIGxpbmUuX2NoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBsaW5lLl9kYXRhc2V0SW5kZXggPSB0aGlzLmluZGV4O1xuICAgIGxpbmUuX2RlY2ltYXRlZCA9ICEhX2RhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSk7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgIG9wdGlvbnMuYm9yZGVyV2lkdGggPSAwO1xuICAgIH1cbiAgICBvcHRpb25zLnNlZ21lbnQgPSB0aGlzLm9wdGlvbnMuc2VnbWVudDtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCB7XG4gICAgICBhbmltYXRlZDogIWFuaW1hdGlvbnNEaXNhYmxlZCxcbiAgICAgIG9wdGlvbnNcbiAgICB9LCBtb2RlKTtcblxuICAgIC8vIFVwZGF0ZSBQb2ludHNcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKTtcbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZSwgX3N0YWNrZWQsIF9kYXRhc2V0fSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgICBjb25zdCB7c3BhbkdhcHMsIHNlZ21lbnR9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IG1heEdhcExlbmd0aCA9IGlzTnVtYmVyKHNwYW5HYXBzKSA/IHNwYW5HYXBzIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGNvbnN0IGRpcmVjdFVwZGF0ZSA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZCB8fCByZXNldCB8fCBtb2RlID09PSAnbm9uZSc7XG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBjb3VudDtcbiAgICBjb25zdCBwb2ludHNDb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gICAgbGV0IHByZXZQYXJzZWQgPSBzdGFydCA+IDAgJiYgdGhpcy5nZXRQYXJzZWQoc3RhcnQgLSAxKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzQ291bnQ7ICsraSkge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0gZGlyZWN0VXBkYXRlID8gcG9pbnQgOiB7fTtcblxuICAgICAgaWYgKGkgPCBzdGFydCB8fCBpID49IGVuZCkge1xuICAgICAgICBwcm9wZXJ0aWVzLnNraXAgPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCBudWxsRGF0YSA9IGlzTnVsbE9yVW5kZWYocGFyc2VkW3ZBeGlzXSk7XG4gICAgICBjb25zdCBpUGl4ZWwgPSBwcm9wZXJ0aWVzW2lBeGlzXSA9IGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFtpQXhpc10sIGkpO1xuICAgICAgY29uc3QgdlBpeGVsID0gcHJvcGVydGllc1t2QXhpc10gPSByZXNldCB8fCBudWxsRGF0YSA/IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKF9zdGFja2VkID8gdGhpcy5hcHBseVN0YWNrKHZTY2FsZSwgcGFyc2VkLCBfc3RhY2tlZCkgOiBwYXJzZWRbdkF4aXNdLCBpKTtcblxuICAgICAgcHJvcGVydGllcy5za2lwID0gaXNOYU4oaVBpeGVsKSB8fCBpc05hTih2UGl4ZWwpIHx8IG51bGxEYXRhO1xuICAgICAgcHJvcGVydGllcy5zdG9wID0gaSA+IDAgJiYgKE1hdGguYWJzKHBhcnNlZFtpQXhpc10gLSBwcmV2UGFyc2VkW2lBeGlzXSkpID4gbWF4R2FwTGVuZ3RoO1xuICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgcHJvcGVydGllcy5wYXJzZWQgPSBwYXJzZWQ7XG4gICAgICAgIHByb3BlcnRpZXMucmF3ID0gX2RhdGFzZXQuZGF0YVtpXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZGlyZWN0VXBkYXRlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgICB9XG5cbiAgICAgIHByZXZQYXJzZWQgPSBwYXJzZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGFzZXQgPSBtZXRhLmRhdGFzZXQ7XG4gICAgY29uc3QgYm9yZGVyID0gZGF0YXNldC5vcHRpb25zICYmIGRhdGFzZXQub3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgIGNvbnN0IGRhdGEgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgaWYgKCFkYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGJvcmRlcjtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IGRhdGFbMF0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoMCkpO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhkYXRhLmxlbmd0aCAtIDEpKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoYm9yZGVyLCBmaXJzdFBvaW50LCBsYXN0UG9pbnQpIC8gMjtcbiAgfVxuXG4gIGRyYXcoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgbWV0YS5kYXRhc2V0LnVwZGF0ZUNvbnRyb2xQb2ludHModGhpcy5jaGFydC5jaGFydEFyZWEsIG1ldGEuaVNjYWxlLmF4aXMpO1xuICAgIHN1cGVyLmRyYXcoKTtcbiAgfVxufVxuIiwgImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHt0b1JhZGlhbnMsIFBJLCBmb3JtYXROdW1iZXIsIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvbGFyQXJlYUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ3BvbGFyQXJlYSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGF0YUVsZW1lbnRUeXBlOiAnYXJjJyxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIGFuaW1hdGVSb3RhdGU6IHRydWUsXG4gICAgICBhbmltYXRlU2NhbGU6IHRydWVcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnLCAnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnXVxuICAgICAgfSxcbiAgICB9LFxuICAgIGluZGV4QXhpczogJ3InLFxuICAgIHN0YXJ0QW5nbGU6IDAsXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIGFzcGVjdFJhdGlvOiAxLFxuXG4gICAgcGx1Z2luczoge1xuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGxhYmVsczoge1xuICAgICAgICAgIGdlbmVyYXRlTGFiZWxzKGNoYXJ0KSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZGF0YTtcbiAgICAgICAgICAgIGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29uc3Qge2xhYmVsczoge3BvaW50U3R5bGUsIGNvbG9yfX0gPSBjaGFydC5sZWdlbmQub3B0aW9ucztcblxuICAgICAgICAgICAgICByZXR1cm4gZGF0YS5sYWJlbHMubWFwKChsYWJlbCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZShpKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB0ZXh0OiBsYWJlbCxcbiAgICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgZm9udENvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogc3R5bGUuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlLFxuICAgICAgICAgICAgICAgICAgaGlkZGVuOiAhY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSksXG5cbiAgICAgICAgICAgICAgICAgIC8vIEV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGNvcnJlY3QgaXRlbVxuICAgICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DbGljayhlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcbiAgICAgICAgICBsZWdlbmQuY2hhcnQudG9nZ2xlRGF0YVZpc2liaWxpdHkobGVnZW5kSXRlbS5pbmRleCk7XG4gICAgICAgICAgbGVnZW5kLmNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNjYWxlczoge1xuICAgICAgcjoge1xuICAgICAgICB0eXBlOiAncmFkaWFsTGluZWFyJyxcbiAgICAgICAgYW5nbGVMaW5lczoge1xuICAgICAgICAgIGRpc3BsYXk6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxuICAgICAgICBncmlkOiB7XG4gICAgICAgICAgY2lyY3VsYXI6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnRMYWJlbHM6IHtcbiAgICAgICAgICBkaXNwbGF5OiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBzdGFydEFuZ2xlOiAwXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcbiAgICBzdXBlcihjaGFydCwgZGF0YXNldEluZGV4KTtcblxuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgY29uc3QgdmFsdWUgPSBmb3JtYXROdW1iZXIobWV0YS5fcGFyc2VkW2luZGV4XS5yLCBjaGFydC5vcHRpb25zLmxvY2FsZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICB2YWx1ZSxcbiAgICB9O1xuICB9XG5cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUuYmluZCh0aGlzKShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBhcmNzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuXG4gICAgdGhpcy5fdXBkYXRlUmFkaXVzKCk7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhhcmNzLCAwLCBhcmNzLmxlbmd0aCwgbW9kZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZ2V0TWluTWF4KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHJhbmdlID0ge21pbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBtYXg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWX07XG5cbiAgICBtZXRhLmRhdGEuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KS5yO1xuXG4gICAgICBpZiAoIWlzTmFOKHBhcnNlZCkgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgICAgaWYgKHBhcnNlZCA8IHJhbmdlLm1pbikge1xuICAgICAgICAgIHJhbmdlLm1pbiA9IHBhcnNlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJzZWQgPiByYW5nZS5tYXgpIHtcbiAgICAgICAgICByYW5nZS5tYXggPSBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByYW5nZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZVJhZGl1cygpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IG1pblNpemUgPSBNYXRoLm1pbihjaGFydEFyZWEucmlnaHQgLSBjaGFydEFyZWEubGVmdCwgY2hhcnRBcmVhLmJvdHRvbSAtIGNoYXJ0QXJlYS50b3ApO1xuXG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChtaW5TaXplIC8gMiwgMCk7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBNYXRoLm1heChvcHRzLmN1dG91dFBlcmNlbnRhZ2UgPyAob3V0ZXJSYWRpdXMgLyAxMDApICogKG9wdHMuY3V0b3V0UGVyY2VudGFnZSkgOiAxLCAwKTtcbiAgICBjb25zdCByYWRpdXNMZW5ndGggPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyBjaGFydC5nZXRWaXNpYmxlRGF0YXNldENvdW50KCk7XG5cbiAgICB0aGlzLm91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSAocmFkaXVzTGVuZ3RoICogdGhpcy5pbmRleCk7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHRoaXMub3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGg7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhhcmNzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEuclNjYWxlO1xuICAgIGNvbnN0IGNlbnRlclggPSBzY2FsZS54Q2VudGVyO1xuICAgIGNvbnN0IGNlbnRlclkgPSBzY2FsZS55Q2VudGVyO1xuICAgIGNvbnN0IGRhdGFzZXRTdGFydEFuZ2xlID0gc2NhbGUuZ2V0SW5kZXhBbmdsZSgwKSAtIDAuNSAqIFBJO1xuICAgIGxldCBhbmdsZSA9IGRhdGFzZXRTdGFydEFuZ2xlO1xuICAgIGxldCBpO1xuXG4gICAgY29uc3QgZGVmYXVsdEFuZ2xlID0gMzYwIC8gdGhpcy5jb3VudFZpc2libGVFbGVtZW50cygpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXJ0OyArK2kpIHtcbiAgICAgIGFuZ2xlICs9IHRoaXMuX2NvbXB1dGVBbmdsZShpLCBtb2RlLCBkZWZhdWx0QW5nbGUpO1xuICAgIH1cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgYXJjID0gYXJjc1tpXTtcbiAgICAgIGxldCBzdGFydEFuZ2xlID0gYW5nbGU7XG4gICAgICBsZXQgZW5kQW5nbGUgPSBhbmdsZSArIHRoaXMuX2NvbXB1dGVBbmdsZShpLCBtb2RlLCBkZWZhdWx0QW5nbGUpO1xuICAgICAgbGV0IG91dGVyUmFkaXVzID0gY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgPyBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLmdldFBhcnNlZChpKS5yKSA6IDA7XG4gICAgICBhbmdsZSA9IGVuZEFuZ2xlO1xuXG4gICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlKSB7XG4gICAgICAgICAgb3V0ZXJSYWRpdXMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbmltYXRpb25PcHRzLmFuaW1hdGVSb3RhdGUpIHtcbiAgICAgICAgICBzdGFydEFuZ2xlID0gZW5kQW5nbGUgPSBkYXRhc2V0U3RhcnRBbmdsZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4OiBjZW50ZXJYLFxuICAgICAgICB5OiBjZW50ZXJZLFxuICAgICAgICBpbm5lclJhZGl1czogMCxcbiAgICAgICAgb3V0ZXJSYWRpdXMsXG4gICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlLFxuICAgICAgICBvcHRpb25zOiB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYXJjLmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSlcbiAgICAgIH07XG5cbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChhcmMsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGNvdW50VmlzaWJsZUVsZW1lbnRzKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGxldCBjb3VudCA9IDA7XG5cbiAgICBtZXRhLmRhdGEuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgIGlmICghaXNOYU4odGhpcy5nZXRQYXJzZWQoaW5kZXgpLnIpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpKSB7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY291bnQ7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlQW5nbGUoaW5kZXgsIG1vZGUsIGRlZmF1bHRBbmdsZSkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KVxuICAgICAgPyB0b1JhZGlhbnModGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKS5hbmdsZSB8fCBkZWZhdWx0QW5nbGUpXG4gICAgICA6IDA7XG4gIH1cbn1cbiIsICJpbXBvcnQgRG91Z2hudXRDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci5kb3VnaG51dC5qcyc7XG5cbi8vIFBpZSBjaGFydHMgYXJlIERvdWdobnV0IGNoYXJ0IHdpdGggZGlmZmVyZW50IGRlZmF1bHRzXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQaWVDb250cm9sbGVyIGV4dGVuZHMgRG91Z2hudXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAncGllJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAvLyBUaGUgcGVyY2VudGFnZSBvZiB0aGUgY2hhcnQgdGhhdCB3ZSBjdXQgb3V0IG9mIHRoZSBtaWRkbGUuXG4gICAgY3V0b3V0OiAwLFxuXG4gICAgLy8gVGhlIHJvdGF0aW9uIG9mIHRoZSBjaGFydCwgd2hlcmUgdGhlIGZpcnN0IGRhdGEgYXJjIGJlZ2lucy5cbiAgICByb3RhdGlvbjogMCxcblxuICAgIC8vIFRoZSB0b3RhbCBjaXJjdW1mZXJlbmNlIG9mIHRoZSBjaGFydC5cbiAgICBjaXJjdW1mZXJlbmNlOiAzNjAsXG5cbiAgICAvLyBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBjaGFydFxuICAgIHJhZGl1czogJzEwMCUnXG4gIH07XG59XG4iLCAiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge19wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhZGFyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAncmFkYXInO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFzZXRFbGVtZW50VHlwZTogJ2xpbmUnLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcbiAgICBpbmRleEF4aXM6ICdyJyxcbiAgICBzaG93TGluZTogdHJ1ZSxcbiAgICBlbGVtZW50czoge1xuICAgICAgbGluZToge1xuICAgICAgICBmaWxsOiAnc3RhcnQnXG4gICAgICB9XG4gICAgfSxcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgYXNwZWN0UmF0aW86IDEsXG5cbiAgICBzY2FsZXM6IHtcbiAgICAgIHI6IHtcbiAgICAgICAgdHlwZTogJ3JhZGlhbExpbmVhcicsXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgdlNjYWxlID0gdGhpcy5fY2FjaGVkTWV0YS52U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiB2U2NhbGUuZ2V0TGFiZWxzKClbaW5kZXhdLFxuICAgICAgdmFsdWU6ICcnICsgdlNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW3ZTY2FsZS5heGlzXSlcbiAgICB9O1xuICB9XG5cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUuYmluZCh0aGlzKShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBsaW5lID0gbWV0YS5kYXRhc2V0O1xuICAgIGNvbnN0IHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcbiAgICBjb25zdCBsYWJlbHMgPSBtZXRhLmlTY2FsZS5nZXRMYWJlbHMoKTtcblxuICAgIC8vIFVwZGF0ZSBMaW5lXG4gICAgbGluZS5wb2ludHMgPSBwb2ludHM7XG4gICAgLy8gSW4gcmVzaXplIG1vZGUgb25seSBwb2ludCBsb2NhdGlvbnMgY2hhbmdlLCBzbyBubyBuZWVkIHRvIHNldCB0aGUgcG9pbnRzIG9yIG9wdGlvbnMuXG4gICAgaWYgKG1vZGUgIT09ICdyZXNpemUnKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgICAgb3B0aW9ucy5ib3JkZXJXaWR0aCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIF9sb29wOiB0cnVlLFxuICAgICAgICBfZnVsbExvb3A6IGxhYmVscy5sZW5ndGggPT09IHBvaW50cy5sZW5ndGgsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH07XG5cbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChsaW5lLCB1bmRlZmluZWQsIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBQb2ludHNcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgMCwgcG9pbnRzLmxlbmd0aCwgbW9kZSk7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5fY2FjaGVkTWV0YS5yU2NhbGU7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIGNvbnN0IHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaSwgdGhpcy5nZXRQYXJzZWQoaSkucik7XG5cbiAgICAgIGNvbnN0IHggPSByZXNldCA/IHNjYWxlLnhDZW50ZXIgOiBwb2ludFBvc2l0aW9uLng7XG4gICAgICBjb25zdCB5ID0gcmVzZXQgPyBzY2FsZS55Q2VudGVyIDogcG9pbnRQb3NpdGlvbi55O1xuXG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBhbmdsZTogcG9pbnRQb3NpdGlvbi5hbmdsZSxcbiAgICAgICAgc2tpcDogaXNOYU4oeCkgfHwgaXNOYU4oeSksXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH07XG5cbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge2lzTnVsbE9yVW5kZWZ9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtpc051bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cywgX3NjYWxlUmFuZ2VzQ2hhbmdlZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjYXR0ZXJDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdzY2F0dGVyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcbiAgICBzaG93TGluZTogZmFsc2UsXG4gICAgZmlsbDogZmFsc2VcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG5cbiAgICBpbnRlcmFjdGlvbjoge1xuICAgICAgbW9kZTogJ3BvaW50J1xuICAgIH0sXG5cbiAgICBzY2FsZXM6IHtcbiAgICAgIHg6IHtcbiAgICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICAgIH0sXG4gICAgICB5OiB7XG4gICAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5jaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgeCA9IHhTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC54KTtcbiAgICBjb25zdCB5ID0geVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLnkpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgdmFsdWU6ICcoJyArIHggKyAnLCAnICsgeSArICcpJ1xuICAgIH07XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtkYXRhOiBwb2ludHMgPSBbXX0gPSBtZXRhO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBhbmltYXRpb25zRGlzYWJsZWQgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQ7XG4gICAgbGV0IHtzdGFydCwgY291bnR9ID0gX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YSwgcG9pbnRzLCBhbmltYXRpb25zRGlzYWJsZWQpO1xuXG4gICAgdGhpcy5fZHJhd1N0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5fZHJhd0NvdW50ID0gY291bnQ7XG5cbiAgICBpZiAoX3NjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSkge1xuICAgICAgc3RhcnQgPSAwO1xuICAgICAgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcblxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzExMzMzXG4gICAgICBpZiAoIXRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKSB7XG4gICAgICAgIHRoaXMuYWRkRWxlbWVudHMoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtkYXRhc2V0OiBsaW5lLCBfZGF0YXNldH0gPSBtZXRhO1xuXG4gICAgICAvLyBVcGRhdGUgTGluZVxuICAgICAgbGluZS5fY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgICAgbGluZS5fZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgIGxpbmUuX2RlY2ltYXRlZCA9ICEhX2RhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xuXG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgICAgb3B0aW9ucy5zZWdtZW50ID0gdGhpcy5vcHRpb25zLnNlZ21lbnQ7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGFuaW1hdGVkOiAhYW5pbWF0aW9uc0Rpc2FibGVkLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9LCBtb2RlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKSB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMTEzMzNcbiAgICAgIGRlbGV0ZSBtZXRhLmRhdGFzZXQ7XG4gICAgICB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBQb2ludHNcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKTtcbiAgfVxuXG4gIGFkZEVsZW1lbnRzKCkge1xuICAgIGNvbnN0IHtzaG93TGluZX0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAoIXRoaXMuZGF0YXNldEVsZW1lbnRUeXBlICYmIHNob3dMaW5lKSB7XG4gICAgICB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSA9IHRoaXMuY2hhcnQucmVnaXN0cnkuZ2V0RWxlbWVudCgnbGluZScpO1xuICAgIH1cblxuICAgIHN1cGVyLmFkZEVsZW1lbnRzKCk7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIF9zdGFja2VkLCBfZGF0YXNldH0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGZpcnN0T3B0cyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3Qgc2hhcmVkT3B0aW9ucyA9IHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhmaXJzdE9wdHMpO1xuICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gdGhpcy5pbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3Qge3NwYW5HYXBzLCBzZWdtZW50fSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtYXhHYXBMZW5ndGggPSBpc051bWJlcihzcGFuR2FwcykgPyBzcGFuR2FwcyA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBjb25zdCBkaXJlY3RVcGRhdGUgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQgfHwgcmVzZXQgfHwgbW9kZSA9PT0gJ25vbmUnO1xuICAgIGxldCBwcmV2UGFyc2VkID0gc3RhcnQgPiAwICYmIHRoaXMuZ2V0UGFyc2VkKHN0YXJ0IC0gMSk7XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0gZGlyZWN0VXBkYXRlID8gcG9pbnQgOiB7fTtcbiAgICAgIGNvbnN0IG51bGxEYXRhID0gaXNOdWxsT3JVbmRlZihwYXJzZWRbdkF4aXNdKTtcbiAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSwgaSk7XG4gICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0IHx8IG51bGxEYXRhID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHBhcnNlZFt2QXhpc10sIGkpO1xuXG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCkgfHwgbnVsbERhdGE7XG4gICAgICBwcm9wZXJ0aWVzLnN0b3AgPSBpID4gMCAmJiAoTWF0aC5hYnMocGFyc2VkW2lBeGlzXSAtIHByZXZQYXJzZWRbaUF4aXNdKSkgPiBtYXhHYXBMZW5ndGg7XG4gICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICBwcm9wZXJ0aWVzLnBhcnNlZCA9IHBhcnNlZDtcbiAgICAgICAgcHJvcGVydGllcy5yYXcgPSBfZGF0YXNldC5kYXRhW2ldO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkaXJlY3RVcGRhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICAgIH1cblxuICAgICAgcHJldlBhcnNlZCA9IHBhcnNlZDtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhID0gbWV0YS5kYXRhIHx8IFtdO1xuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgIGxldCBtYXggPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBkYXRhW2ldLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpKSAvIDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1heCA+IDAgJiYgbWF4O1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGFzZXQgPSBtZXRhLmRhdGFzZXQ7XG4gICAgY29uc3QgYm9yZGVyID0gZGF0YXNldC5vcHRpb25zICYmIGRhdGFzZXQub3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuXG4gICAgaWYgKCFkYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGJvcmRlcjtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdFBvaW50ID0gZGF0YVswXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucygwKSk7XG4gICAgY29uc3QgbGFzdFBvaW50ID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGRhdGEubGVuZ3RoIC0gMSkpO1xuICAgIHJldHVybiBNYXRoLm1heChib3JkZXIsIGZpcnN0UG9pbnQsIGxhc3RQb2ludCkgLyAyO1xuICB9XG59XG4iLCAiLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0Ll9hZGFwdGVyc1xuICogQHNpbmNlIDIuOC4wXG4gKiBAcHJpdmF0ZVxuICovXG5cbmltcG9ydCB0eXBlIHtBbnlPYmplY3R9IGZyb20gJy4uL3R5cGVzL2Jhc2ljLmpzJztcbmltcG9ydCB0eXBlIHtDaGFydE9wdGlvbnN9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcblxuZXhwb3J0IHR5cGUgVGltZVVuaXQgPSAnbWlsbGlzZWNvbmQnIHwgJ3NlY29uZCcgfCAnbWludXRlJyB8ICdob3VyJyB8ICdkYXknIHwgJ3dlZWsnIHwgJ21vbnRoJyB8ICdxdWFydGVyJyB8ICd5ZWFyJztcblxuZXhwb3J0IGludGVyZmFjZSBEYXRlQWRhcHRlcjxUIGV4dGVuZHMgQW55T2JqZWN0ID0gQW55T2JqZWN0PiB7XG4gIHJlYWRvbmx5IG9wdGlvbnM6IFQ7XG4gIC8qKlxuICAgKiBXaWxsIGNhbGxlZCB3aXRoIGNoYXJ0IG9wdGlvbnMgYWZ0ZXIgYWRhcHRlciBjcmVhdGlvbi5cbiAgICovXG4gIGluaXQodGhpczogRGF0ZUFkYXB0ZXI8VD4sIGNoYXJ0T3B0aW9uczogQ2hhcnRPcHRpb25zKTogdm9pZDtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBtYXAgb2YgdGltZSBmb3JtYXRzIGZvciB0aGUgc3VwcG9ydGVkIGZvcm1hdHRpbmcgdW5pdHMgZGVmaW5lZFxuICAgKiBpbiBVbml0IGFzIHdlbGwgYXMgJ2RhdGV0aW1lJyByZXByZXNlbnRpbmcgYSBkZXRhaWxlZCBkYXRlL3RpbWUgc3RyaW5nLlxuICAgKi9cbiAgZm9ybWF0cyh0aGlzOiBEYXRlQWRhcHRlcjxUPik6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIGdpdmVuIGB2YWx1ZWAgYW5kIHJldHVybiB0aGUgYXNzb2NpYXRlZCB0aW1lc3RhbXAuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBwYXJzZSAodXN1YWxseSBjb21lcyBmcm9tIHRoZSBkYXRhKVxuICAgKiBAcGFyYW0gW2Zvcm1hdF0gLSB0aGUgZXhwZWN0ZWQgZGF0YSBmb3JtYXRcbiAgICovXG4gIHBhcnNlKHRoaXM6IERhdGVBZGFwdGVyPFQ+LCB2YWx1ZTogdW5rbm93biwgZm9ybWF0PzogVGltZVVuaXQpOiBudW1iZXIgfCBudWxsO1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgZm9ybWF0dGVkIGRhdGUgaW4gdGhlIHNwZWNpZmllZCBgZm9ybWF0YCBmb3IgYSBnaXZlbiBgdGltZXN0YW1wYC5cbiAgICogQHBhcmFtIHRpbWVzdGFtcCAtIHRoZSB0aW1lc3RhbXAgdG8gZm9ybWF0XG4gICAqIEBwYXJhbSBmb3JtYXQgLSB0aGUgZGF0ZS90aW1lIHRva2VuXG4gICAqL1xuICBmb3JtYXQodGhpczogRGF0ZUFkYXB0ZXI8VD4sIHRpbWVzdGFtcDogbnVtYmVyLCBmb3JtYXQ6IFRpbWVVbml0KTogc3RyaW5nO1xuICAvKipcbiAgICogQWRkcyB0aGUgc3BlY2lmaWVkIGBhbW91bnRgIG9mIGB1bml0YCB0byB0aGUgZ2l2ZW4gYHRpbWVzdGFtcGAuXG4gICAqIEBwYXJhbSB0aW1lc3RhbXAgLSB0aGUgaW5wdXQgdGltZXN0YW1wXG4gICAqIEBwYXJhbSBhbW91bnQgLSB0aGUgYW1vdW50IHRvIGFkZFxuICAgKiBAcGFyYW0gdW5pdCAtIHRoZSB1bml0IGFzIHN0cmluZ1xuICAgKi9cbiAgYWRkKHRoaXM6IERhdGVBZGFwdGVyPFQ+LCB0aW1lc3RhbXA6IG51bWJlciwgYW1vdW50OiBudW1iZXIsIHVuaXQ6IFRpbWVVbml0KTogbnVtYmVyO1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGB1bml0YCBiZXR3ZWVuIHRoZSBnaXZlbiB0aW1lc3RhbXBzLlxuICAgKiBAcGFyYW0gYSAtIHRoZSBpbnB1dCB0aW1lc3RhbXAgKHJlZmVyZW5jZSlcbiAgICogQHBhcmFtIGIgLSB0aGUgdGltZXN0YW1wIHRvIHN1YnRyYWN0XG4gICAqIEBwYXJhbSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXG4gICAqL1xuICBkaWZmKHRoaXM6IERhdGVBZGFwdGVyPFQ+LCBhOiBudW1iZXIsIGI6IG51bWJlciwgdW5pdDogVGltZVVuaXQpOiBudW1iZXI7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHN0YXJ0IG9mIGB1bml0YCBmb3IgdGhlIGdpdmVuIGB0aW1lc3RhbXBgLlxuICAgKiBAcGFyYW0gdGltZXN0YW1wIC0gdGhlIGlucHV0IHRpbWVzdGFtcFxuICAgKiBAcGFyYW0gdW5pdCAtIHRoZSB1bml0IGFzIHN0cmluZ1xuICAgKiBAcGFyYW0gW3dlZWtkYXldIC0gdGhlIElTTyBkYXkgb2YgdGhlIHdlZWsgd2l0aCAxIGJlaW5nIE1vbmRheVxuICAgKiBhbmQgNyBiZWluZyBTdW5kYXkgKG9ubHkgbmVlZGVkIGlmIHBhcmFtICp1bml0KiBpcyBgaXNvV2Vla2ApLlxuICAgKi9cbiAgc3RhcnRPZih0aGlzOiBEYXRlQWRhcHRlcjxUPiwgdGltZXN0YW1wOiBudW1iZXIsIHVuaXQ6IFRpbWVVbml0IHwgJ2lzb1dlZWsnLCB3ZWVrZGF5PzogbnVtYmVyKTogbnVtYmVyO1xuICAvKipcbiAgICogUmV0dXJucyBlbmQgb2YgYHVuaXRgIGZvciB0aGUgZ2l2ZW4gYHRpbWVzdGFtcGAuXG4gICAqIEBwYXJhbSB0aW1lc3RhbXAgLSB0aGUgaW5wdXQgdGltZXN0YW1wXG4gICAqIEBwYXJhbSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXG4gICAqL1xuICBlbmRPZih0aGlzOiBEYXRlQWRhcHRlcjxUPiwgdGltZXN0YW1wOiBudW1iZXIsIHVuaXQ6IFRpbWVVbml0IHwgJ2lzb1dlZWsnKTogbnVtYmVyO1xufVxuXG5mdW5jdGlvbiBhYnN0cmFjdDxUID0gdm9pZD4oKTogVCB7XG4gIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkOiBDaGVjayB0aGF0IGEgY29tcGxldGUgZGF0ZSBhZGFwdGVyIGlzIHByb3ZpZGVkLicpO1xufVxuXG4vKipcbiAqIERhdGUgYWRhcHRlciAoY3VycmVudCB1c2VkIGJ5IHRoZSB0aW1lIHNjYWxlKVxuICogQG5hbWVzcGFjZSBDaGFydC5fYWRhcHRlcnMuX2RhdGVcbiAqIEBtZW1iZXJvZiBDaGFydC5fYWRhcHRlcnNcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIERhdGVBZGFwdGVyQmFzZSBpbXBsZW1lbnRzIERhdGVBZGFwdGVyIHtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgZGVmYXVsdCBkYXRlIGFkYXB0ZXIgbWV0aG9kcy5cbiAgICogQWNjZXB0cyB0eXBlIHBhcmFtZXRlciB0byBkZWZpbmUgb3B0aW9ucyB0eXBlLlxuICAgKiBAZXhhbXBsZVxuICAgKiBDaGFydC5fYWRhcHRlcnMuX2RhdGUub3ZlcnJpZGU8e215QWRhcHRlck9wdGlvbjogc3RyaW5nfT4oe1xuICAgKiAgIGluaXQoKSB7XG4gICAqICAgICBjb25zb2xlLmxvZyh0aGlzLm9wdGlvbnMubXlBZGFwdGVyT3B0aW9uKTtcbiAgICogICB9XG4gICAqIH0pXG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGU8VCBleHRlbmRzIEFueU9iamVjdCA9IEFueU9iamVjdD4oXG4gICAgbWVtYmVyczogUGFydGlhbDxPbWl0PERhdGVBZGFwdGVyPFQ+LCAnb3B0aW9ucyc+PlxuICApIHtcbiAgICBPYmplY3QuYXNzaWduKERhdGVBZGFwdGVyQmFzZS5wcm90b3R5cGUsIG1lbWJlcnMpO1xuICB9XG5cbiAgcmVhZG9ubHkgb3B0aW9uczogQW55T2JqZWN0O1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IEFueU9iamVjdCkge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG4gIGluaXQoKSB7fVxuXG4gIGZvcm1hdHMoKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICBwYXJzZSgpOiBudW1iZXIgfCBudWxsIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIGZvcm1hdCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgYWRkKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICBkaWZmKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICBzdGFydE9mKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICBlbmRPZigpOiBudW1iZXIge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX2RhdGU6IERhdGVBZGFwdGVyQmFzZVxufTtcbiIsICJpbXBvcnQge19sb29rdXBCeUtleSwgX3Jsb29rdXBCeUtleX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHtnZXRSZWxhdGl2ZVBvc2l0aW9ufSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZG9tLmpzJztcbmltcG9ydCB7X2FuZ2xlQmV0d2VlbiwgZ2V0QW5nbGVGcm9tUG9pbnR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7X2lzUG9pbnRJbkFyZWF9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQ2hhcnRFdmVudCB9IENoYXJ0RXZlbnRcbiAqIEB0eXBlZGVmIHt7YXhpcz86IHN0cmluZywgaW50ZXJzZWN0PzogYm9vbGVhbiwgaW5jbHVkZUludmlzaWJsZT86IGJvb2xlYW59fSBJbnRlcmFjdGlvbk9wdGlvbnNcbiAqIEB0eXBlZGVmIHt7ZGF0YXNldEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXIsIGVsZW1lbnQ6IGltcG9ydCgnLi9jb3JlLmVsZW1lbnQuanMnKS5kZWZhdWx0fX0gSW50ZXJhY3Rpb25JdGVtXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5Qb2ludCB9IFBvaW50XG4gKi9cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZG8gYmluYXJ5IHNlYXJjaCB3aGVuIHBvc3NpYmxlXG4gKiBAcGFyYW0ge29iamVjdH0gbWV0YXNldCAtIHRoZSBkYXRhc2V0IG1ldGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4aXMgbW9kZS4geHx5fHh5fHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBmaW5kXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnRlcnNlY3RdIC0gc2hvdWxkIHRoZSBlbGVtZW50IGludGVyc2VjdFxuICogQHJldHVybnMge3tsbzpudW1iZXIsIGhpOm51bWJlcn19IGluZGljZXMgdG8gc2VhcmNoIGRhdGEgYXJyYXkgYmV0d2VlblxuICovXG5mdW5jdGlvbiBiaW5hcnlTZWFyY2gobWV0YXNldCwgYXhpcywgdmFsdWUsIGludGVyc2VjdCkge1xuICBjb25zdCB7Y29udHJvbGxlciwgZGF0YSwgX3NvcnRlZH0gPSBtZXRhc2V0O1xuICBjb25zdCBpU2NhbGUgPSBjb250cm9sbGVyLl9jYWNoZWRNZXRhLmlTY2FsZTtcbiAgaWYgKGlTY2FsZSAmJiBheGlzID09PSBpU2NhbGUuYXhpcyAmJiBheGlzICE9PSAncicgJiYgX3NvcnRlZCAmJiBkYXRhLmxlbmd0aCkge1xuICAgIGNvbnN0IGxvb2t1cE1ldGhvZCA9IGlTY2FsZS5fcmV2ZXJzZVBpeGVscyA/IF9ybG9va3VwQnlLZXkgOiBfbG9va3VwQnlLZXk7XG4gICAgaWYgKCFpbnRlcnNlY3QpIHtcbiAgICAgIHJldHVybiBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoY29udHJvbGxlci5fc2hhcmVkT3B0aW9ucykge1xuICAgICAgLy8gX3NoYXJlZE9wdGlvbnMgaW5kaWNhdGVzIHRoYXQgZWFjaCBlbGVtZW50IGhhcyBlcXVhbCBvcHRpb25zIC0+IGVxdWFsIHByb3BvcnRpb25zXG4gICAgICAvLyBTbyB3ZSBjYW4gZG8gYSByYW5nZWQgYmluYXJ5IHNlYXJjaCBiYXNlZCBvbiB0aGUgcmFuZ2Ugb2YgZmlyc3QgZWxlbWVudCBhbmRcbiAgICAgIC8vIGJlIGNvbmZpZGVudCB0byBnZXQgdGhlIGZ1bGwgcmFuZ2Ugb2YgaW5kaWNlcyB0aGF0IGNhbiBpbnRlcnNlY3Qgd2l0aCB0aGUgdmFsdWUuXG4gICAgICBjb25zdCBlbCA9IGRhdGFbMF07XG4gICAgICBjb25zdCByYW5nZSA9IHR5cGVvZiBlbC5nZXRSYW5nZSA9PT0gJ2Z1bmN0aW9uJyAmJiBlbC5nZXRSYW5nZShheGlzKTtcbiAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICBjb25zdCBzdGFydCA9IGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSAtIHJhbmdlKTtcbiAgICAgICAgY29uc3QgZW5kID0gbG9va3VwTWV0aG9kKGRhdGEsIGF4aXMsIHZhbHVlICsgcmFuZ2UpO1xuICAgICAgICByZXR1cm4ge2xvOiBzdGFydC5sbywgaGk6IGVuZC5oaX07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIERlZmF1bHQgdG8gYWxsIGVsZW1lbnRzLCB3aGVuIGJpbmFyeSBzZWFyY2ggY2FuIG5vdCBiZSB1c2VkLlxuICByZXR1cm4ge2xvOiAwLCBoaTogZGF0YS5sZW5ndGggLSAxfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gc2VsZWN0IGNhbmRpZGF0ZSBlbGVtZW50cyBmb3IgaW50ZXJhY3Rpb25cbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0XG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIG1vZGUuIHh8eXx4eXxyXG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvLCBpbiByZWxhdGl2ZSBjb29yZGluYXRlc1xuICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciAtIHRoZSBjYWxsYmFjayB0byBleGVjdXRlIGZvciBlYWNoIHZpc2libGUgaXRlbVxuICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJzZWN0XSAtIGNvbnNpZGVyIGludGVyc2VjdGluZyBpdGVtc1xuICovXG5mdW5jdGlvbiBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBoYW5kbGVyLCBpbnRlcnNlY3QpIHtcbiAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bYXhpc107XG4gIGZvciAobGV0IGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY29uc3Qge2luZGV4LCBkYXRhfSA9IG1ldGFzZXRzW2ldO1xuICAgIGNvbnN0IHtsbywgaGl9ID0gYmluYXJ5U2VhcmNoKG1ldGFzZXRzW2ldLCBheGlzLCB2YWx1ZSwgaW50ZXJzZWN0KTtcbiAgICBmb3IgKGxldCBqID0gbG87IGogPD0gaGk7ICsraikge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGRhdGFbal07XG4gICAgICBpZiAoIWVsZW1lbnQuc2tpcCkge1xuICAgICAgICBoYW5kbGVyKGVsZW1lbnQsIGluZGV4LCBqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYSBkaXN0YW5jZSBtZXRyaWMgZnVuY3Rpb24gZm9yIHR3byBwb2ludHMgYmFzZWQgb24gdGhlXG4gKiBheGlzIG1vZGUgc2V0dGluZ1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhpcyBtb2RlLiB4fHl8eHl8clxuICovXG5mdW5jdGlvbiBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMoYXhpcykge1xuICBjb25zdCB1c2VYID0gYXhpcy5pbmRleE9mKCd4JykgIT09IC0xO1xuICBjb25zdCB1c2VZID0gYXhpcy5pbmRleE9mKCd5JykgIT09IC0xO1xuXG4gIHJldHVybiBmdW5jdGlvbihwdDEsIHB0Mikge1xuICAgIGNvbnN0IGRlbHRhWCA9IHVzZVggPyBNYXRoLmFicyhwdDEueCAtIHB0Mi54KSA6IDA7XG4gICAgY29uc3QgZGVsdGFZID0gdXNlWSA/IE1hdGguYWJzKHB0MS55IC0gcHQyLnkpIDogMDtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGRlbHRhWCwgMikgKyBNYXRoLnBvdyhkZWx0YVksIDIpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBpdGVtcyB0aGF0IGludGVyc2VjdCB0aGUgZXZlbnQgcG9zaXRpb25cbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0XG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvLCBpbiByZWxhdGl2ZSBjb29yZGluYXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhpcyBtb2RlLiB4fHl8eHl8clxuICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgdGhlIGVsZW1lbnQncyBhbmltYXRpb24gdGFyZ2V0IGluc3RlYWQgb2YgY3VycmVudCBwb3NpdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZUludmlzaWJsZV0gLSBpbmNsdWRlIGludmlzaWJsZSBwb2ludHMgdGhhdCBhcmUgb3V0c2lkZSBvZiB0aGUgY2hhcnQgYXJlYVxuICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IHRoZSBuZWFyZXN0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkge1xuICBjb25zdCBpdGVtcyA9IFtdO1xuXG4gIGlmICghaW5jbHVkZUludmlzaWJsZSAmJiAhY2hhcnQuaXNQb2ludEluQXJlYShwb3NpdGlvbikpIHtcbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cblxuICBjb25zdCBldmFsdWF0aW9uRnVuYyA9IGZ1bmN0aW9uKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICBpZiAoIWluY2x1ZGVJbnZpc2libGUgJiYgIV9pc1BvaW50SW5BcmVhKGVsZW1lbnQsIGNoYXJ0LmNoYXJ0QXJlYSwgMCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgIH1cbiAgfTtcblxuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBldmFsdWF0aW9uRnVuYywgdHJ1ZSk7XG4gIHJldHVybiBpdGVtcztcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBpdGVtcyBuZWFyZXN0IHRvIHRoZSBldmVudCBwb3NpdGlvbiBmb3IgYSByYWRpYWwgY2hhcnRcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIGxvb2sgYXQgZWxlbWVudHMgZnJvbVxuICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0bywgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4ZXMgYWxvbmcgd2hpY2ggdG8gbWVhc3VyZSBkaXN0YW5jZVxuICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgdGhlIGVsZW1lbnQncyBhbmltYXRpb24gdGFyZ2V0IGluc3RlYWQgb2YgY3VycmVudCBwb3NpdGlvblxuICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IHRoZSBuZWFyZXN0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGdldE5lYXJlc3RSYWRpYWxJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgbGV0IGl0ZW1zID0gW107XG5cbiAgZnVuY3Rpb24gZXZhbHVhdGlvbkZ1bmMoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIGNvbnN0IHtzdGFydEFuZ2xlLCBlbmRBbmdsZX0gPSBlbGVtZW50LmdldFByb3BzKFsnc3RhcnRBbmdsZScsICdlbmRBbmdsZSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCB7YW5nbGV9ID0gZ2V0QW5nbGVGcm9tUG9pbnQoZWxlbWVudCwge3g6IHBvc2l0aW9uLngsIHk6IHBvc2l0aW9uLnl9KTtcblxuICAgIGlmIChfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gIH1cblxuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBldmFsdWF0aW9uRnVuYyk7XG4gIHJldHVybiBpdGVtcztcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBpdGVtcyBuZWFyZXN0IHRvIHRoZSBldmVudCBwb3NpdGlvbiBmb3IgYSBjYXJ0ZXNpYW4gY2hhcnRcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIGxvb2sgYXQgZWxlbWVudHMgZnJvbVxuICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0bywgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4ZXMgYWxvbmcgd2hpY2ggdG8gbWVhc3VyZSBkaXN0YW5jZVxuICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJzZWN0XSAtIGlmIHRydWUsIG9ubHkgY29uc2lkZXIgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSB0aGUgZWxlbWVudCdzIGFuaW1hdGlvbiB0YXJnZXQgaW5zdGVhZCBvZiBjdXJyZW50IHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlSW52aXNpYmxlXSAtIGluY2x1ZGUgaW52aXNpYmxlIHBvaW50cyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBjaGFydCBhcmVhXG4gKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gdGhlIG5lYXJlc3QgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0TmVhcmVzdENhcnRlc2lhbkl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSB7XG4gIGxldCBpdGVtcyA9IFtdO1xuICBjb25zdCBkaXN0YW5jZU1ldHJpYyA9IGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhheGlzKTtcbiAgbGV0IG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG4gIGZ1bmN0aW9uIGV2YWx1YXRpb25GdW5jKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICBjb25zdCBpblJhbmdlID0gZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGlmIChpbnRlcnNlY3QgJiYgIWluUmFuZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjZW50ZXIgPSBlbGVtZW50LmdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHBvaW50SW5BcmVhID0gISFpbmNsdWRlSW52aXNpYmxlIHx8IGNoYXJ0LmlzUG9pbnRJbkFyZWEoY2VudGVyKTtcbiAgICBpZiAoIXBvaW50SW5BcmVhICYmICFpblJhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGlzdGFuY2UgPSBkaXN0YW5jZU1ldHJpYyhwb3NpdGlvbiwgY2VudGVyKTtcbiAgICBpZiAoZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgaXRlbXMgPSBbe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9XTtcbiAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgfSBlbHNlIGlmIChkaXN0YW5jZSA9PT0gbWluRGlzdGFuY2UpIHtcbiAgICAgIC8vIENhbiBoYXZlIG11bHRpcGxlIGl0ZW1zIGF0IHRoZSBzYW1lIGRpc3RhbmNlIGluIHdoaWNoIGNhc2Ugd2Ugc29ydCBieSBzaXplXG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgfVxuICB9XG5cbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMpO1xuICByZXR1cm4gaXRlbXM7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgbmVhcmVzdCB0byB0aGUgZXZlbnQgcG9zaXRpb24gY29uc2lkZXJpbmcgYWxsIHZpc2libGUgaXRlbXMgaW4gdGhlIGNoYXJ0XG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byBsb29rIGF0IGVsZW1lbnRzIGZyb21cbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG8sIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGVzIGFsb25nIHdoaWNoIHRvIG1lYXN1cmUgZGlzdGFuY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ludGVyc2VjdF0gLSBpZiB0cnVlLCBvbmx5IGNvbnNpZGVyIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgdGhlIGVsZW1lbnQncyBhbmltYXRpb24gdGFyZ2V0IGluc3RlYWQgb2YgY3VycmVudCBwb3NpdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZUludmlzaWJsZV0gLSBpbmNsdWRlIGludmlzaWJsZSBwb2ludHMgdGhhdCBhcmUgb3V0c2lkZSBvZiB0aGUgY2hhcnQgYXJlYVxuICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IHRoZSBuZWFyZXN0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkge1xuICBpZiAoIWluY2x1ZGVJbnZpc2libGUgJiYgIWNoYXJ0LmlzUG9pbnRJbkFyZWEocG9zaXRpb24pKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcmV0dXJuIGF4aXMgPT09ICdyJyAmJiAhaW50ZXJzZWN0XG4gICAgPyBnZXROZWFyZXN0UmFkaWFsSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKVxuICAgIDogZ2V0TmVhcmVzdENhcnRlc2lhbkl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBpdGVtcyBtYXRjaGluZyBhbG9uZyB0aGUgZ2l2ZW4gWCBvciBZIGF4aXNcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIGxvb2sgYXQgZWxlbWVudHMgZnJvbVxuICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0bywgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4aXMgdG8gbWF0Y2hcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ludGVyc2VjdF0gLSBpZiB0cnVlLCBvbmx5IGNvbnNpZGVyIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgdGhlIGVsZW1lbnQncyBhbmltYXRpb24gdGFyZ2V0IGluc3RlYWQgb2YgY3VycmVudCBwb3NpdGlvblxuICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IHRoZSBuZWFyZXN0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGdldEF4aXNJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBjb25zdCByYW5nZU1ldGhvZCA9IGF4aXMgPT09ICd4JyA/ICdpblhSYW5nZScgOiAnaW5ZUmFuZ2UnO1xuICBsZXQgaW50ZXJzZWN0c0l0ZW0gPSBmYWxzZTtcblxuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCAoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkgPT4ge1xuICAgIGlmIChlbGVtZW50W3JhbmdlTWV0aG9kXSAmJiBlbGVtZW50W3JhbmdlTWV0aG9kXShwb3NpdGlvbltheGlzXSwgdXNlRmluYWxQb3NpdGlvbikpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICAgIGludGVyc2VjdHNJdGVtID0gaW50ZXJzZWN0c0l0ZW0gfHwgZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gSWYgd2Ugd2FudCB0byB0cmlnZ2VyIG9uIGFuIGludGVyc2VjdCBhbmQgd2UgZG9uJ3QgaGF2ZSBhbnkgaXRlbXNcbiAgLy8gdGhhdCBpbnRlcnNlY3QgdGhlIHBvc2l0aW9uLCByZXR1cm4gbm90aGluZ1xuICBpZiAoaW50ZXJzZWN0ICYmICFpbnRlcnNlY3RzSXRlbSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gaXRlbXM7XG59XG5cbi8qKlxuICogQ29udGFpbnMgaW50ZXJhY3Rpb24gcmVsYXRlZCBmdW5jdGlvbnNcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuSW50ZXJhY3Rpb25cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvLyBQYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIHRvIGZhY2lsaXRhdGUgZGV2ZWxvcGVycyBjcmVhdGluZyB0aGVpciBvd24gbW9kZXNcbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zLFxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiBmb3IgZGlmZmVyZW50IG1vZGVzXG4gIG1vZGVzOiB7XG4gICAgLyoqXG5cdFx0ICogUmV0dXJucyBpdGVtcyBhdCB0aGUgc2FtZSBpbmRleC4gSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IHBhcmFtZXRlciBpcyB0cnVlLCB3ZSBvbmx5IHJldHVybiBpdGVtcyBpZiB3ZSBpbnRlcnNlY3Qgc29tZXRoaW5nXG5cdFx0ICogSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IG1vZGUgaXMgZmFsc2UsIHdlIGZpbmQgdGhlIG5lYXJlc3QgaXRlbSBhbmQgcmV0dXJuIHRoZSBpdGVtcyBhdCB0aGUgc2FtZSBpbmRleCBhcyB0aGF0IGl0ZW1cblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuaW5kZXhcblx0XHQgKiBAc2luY2UgdjIuNC4wXG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgZmluYWwgZWxlbWVudCBwb3NpdGlvbiAoYW5pbWF0aW9uIHRhcmdldClcblx0XHQgKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBpdGVtcyB0aGF0IGFyZSBmb3VuZFxuXHRcdCAqL1xuICAgIGluZGV4KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgLy8gRGVmYXVsdCBheGlzIGZvciBpbmRleCBtb2RlIGlzICd4JyB0byBtYXRjaCBvbGQgYmVoYXZpb3VyXG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4JztcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICBjb25zdCBpdGVtcyA9IG9wdGlvbnMuaW50ZXJzZWN0XG4gICAgICAgID8gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKVxuICAgICAgICA6IGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGZhbHNlLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG5cbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpLmZvckVhY2goKG1ldGEpID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBpdGVtc1swXS5pbmRleDtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IG1ldGEuZGF0YVtpbmRleF07XG5cbiAgICAgICAgLy8gZG9uJ3QgY291bnQgaXRlbXMgdGhhdCBhcmUgc2tpcHBlZCAobnVsbCBkYXRhKVxuICAgICAgICBpZiAoZWxlbWVudCAmJiAhZWxlbWVudC5za2lwKSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4OiBtZXRhLmluZGV4LCBpbmRleH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH0sXG5cbiAgICAvKipcblx0XHQgKiBSZXR1cm5zIGl0ZW1zIGluIHRoZSBzYW1lIGRhdGFzZXQuIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBwYXJhbWV0ZXIgaXMgdHJ1ZSwgd2Ugb25seSByZXR1cm4gaXRlbXMgaWYgd2UgaW50ZXJzZWN0IHNvbWV0aGluZ1xuXHRcdCAqIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBpcyBmYWxzZSwgd2UgZmluZCB0aGUgbmVhcmVzdCBpdGVtIGFuZCByZXR1cm4gdGhlIGl0ZW1zIGluIHRoYXQgZGF0YXNldFxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5kYXRhc2V0XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgZmluYWwgZWxlbWVudCBwb3NpdGlvbiAoYW5pbWF0aW9uIHRhcmdldClcblx0XHQgKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBpdGVtcyB0aGF0IGFyZSBmb3VuZFxuXHRcdCAqL1xuICAgIGRhdGFzZXQoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgbGV0IGl0ZW1zID0gb3B0aW9ucy5pbnRlcnNlY3RcbiAgICAgICAgPyBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIDpcbiAgICAgICAgZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgZmFsc2UsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuXG4gICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBkYXRhc2V0SW5kZXggPSBpdGVtc1swXS5kYXRhc2V0SW5kZXg7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmRhdGE7XG4gICAgICAgIGl0ZW1zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQ6IGRhdGFbaV0sIGRhdGFzZXRJbmRleCwgaW5kZXg6IGl9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSxcblxuICAgIC8qKlxuXHRcdCAqIFBvaW50IG1vZGUgcmV0dXJucyBhbGwgZWxlbWVudHMgdGhhdCBoaXQgdGVzdCBiYXNlZCBvbiB0aGUgZXZlbnQgcG9zaXRpb25cblx0XHQgKiBvZiB0aGUgZXZlbnRcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuaW50ZXJzZWN0XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgZmluYWwgZWxlbWVudCBwb3NpdGlvbiAoYW5pbWF0aW9uIHRhcmdldClcblx0XHQgKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBpdGVtcyB0aGF0IGFyZSBmb3VuZFxuXHRcdCAqL1xuICAgIHBvaW50KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIHJldHVybiBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuICAgIH0sXG5cbiAgICAvKipcblx0XHQgKiBuZWFyZXN0IG1vZGUgcmV0dXJucyB0aGUgZWxlbWVudCBjbG9zZXN0IHRvIHRoZSBwb2ludFxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5pbnRlcnNlY3Rcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSBmaW5hbCBlbGVtZW50IHBvc2l0aW9uIChhbmltYXRpb24gdGFyZ2V0KVxuXHRcdCAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSAtIGl0ZW1zIHRoYXQgYXJlIGZvdW5kXG5cdFx0ICovXG4gICAgbmVhcmVzdChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5JztcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICByZXR1cm4gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgb3B0aW9ucy5pbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuICAgIH0sXG5cbiAgICAvKipcblx0XHQgKiB4IG1vZGUgcmV0dXJucyB0aGUgZWxlbWVudHMgdGhhdCBoaXQtdGVzdCBhdCB0aGUgY3VycmVudCB4IGNvb3JkaW5hdGVcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMueFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIGZpbmFsIGVsZW1lbnQgcG9zaXRpb24gKGFuaW1hdGlvbiB0YXJnZXQpXG5cdFx0ICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IC0gaXRlbXMgdGhhdCBhcmUgZm91bmRcblx0XHQgKi9cbiAgICB4KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgcmV0dXJuIGdldEF4aXNJdGVtcyhjaGFydCwgcG9zaXRpb24sICd4Jywgb3B0aW9ucy5pbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH0sXG5cbiAgICAvKipcblx0XHQgKiB5IG1vZGUgcmV0dXJucyB0aGUgZWxlbWVudHMgdGhhdCBoaXQtdGVzdCBhdCB0aGUgY3VycmVudCB5IGNvb3JkaW5hdGVcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMueVxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIGZpbmFsIGVsZW1lbnQgcG9zaXRpb24gKGFuaW1hdGlvbiB0YXJnZXQpXG5cdFx0ICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IC0gaXRlbXMgdGhhdCBhcmUgZm91bmRcblx0XHQgKi9cbiAgICB5KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgcmV0dXJuIGdldEF4aXNJdGVtcyhjaGFydCwgcG9zaXRpb24sICd5Jywgb3B0aW9ucy5pbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cbiAgfVxufTtcbiIsICJpbXBvcnQge2RlZmluZWQsIGVhY2gsIGlzT2JqZWN0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge3RvUGFkZGluZ30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICovXG5cbmNvbnN0IFNUQVRJQ19QT1NJVElPTlMgPSBbJ2xlZnQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbSddO1xuXG5mdW5jdGlvbiBmaWx0ZXJCeVBvc2l0aW9uKGFycmF5LCBwb3NpdGlvbikge1xuICByZXR1cm4gYXJyYXkuZmlsdGVyKHYgPT4gdi5wb3MgPT09IHBvc2l0aW9uKTtcbn1cblxuZnVuY3Rpb24gZmlsdGVyRHluYW1pY1Bvc2l0aW9uQnlBeGlzKGFycmF5LCBheGlzKSB7XG4gIHJldHVybiBhcnJheS5maWx0ZXIodiA9PiBTVEFUSUNfUE9TSVRJT05TLmluZGV4T2Yodi5wb3MpID09PSAtMSAmJiB2LmJveC5heGlzID09PSBheGlzKTtcbn1cblxuZnVuY3Rpb24gc29ydEJ5V2VpZ2h0KGFycmF5LCByZXZlcnNlKSB7XG4gIHJldHVybiBhcnJheS5zb3J0KChhLCBiKSA9PiB7XG4gICAgY29uc3QgdjAgPSByZXZlcnNlID8gYiA6IGE7XG4gICAgY29uc3QgdjEgPSByZXZlcnNlID8gYSA6IGI7XG4gICAgcmV0dXJuIHYwLndlaWdodCA9PT0gdjEud2VpZ2h0ID9cbiAgICAgIHYwLmluZGV4IC0gdjEuaW5kZXggOlxuICAgICAgdjAud2VpZ2h0IC0gdjEud2VpZ2h0O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gd3JhcEJveGVzKGJveGVzKSB7XG4gIGNvbnN0IGxheW91dEJveGVzID0gW107XG4gIGxldCBpLCBpbGVuLCBib3gsIHBvcywgc3RhY2ssIHN0YWNrV2VpZ2h0O1xuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSAoYm94ZXMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGJveCA9IGJveGVzW2ldO1xuICAgICh7cG9zaXRpb246IHBvcywgb3B0aW9uczoge3N0YWNrLCBzdGFja1dlaWdodCA9IDF9fSA9IGJveCk7XG4gICAgbGF5b3V0Qm94ZXMucHVzaCh7XG4gICAgICBpbmRleDogaSxcbiAgICAgIGJveCxcbiAgICAgIHBvcyxcbiAgICAgIGhvcml6b250YWw6IGJveC5pc0hvcml6b250YWwoKSxcbiAgICAgIHdlaWdodDogYm94LndlaWdodCxcbiAgICAgIHN0YWNrOiBzdGFjayAmJiAocG9zICsgc3RhY2spLFxuICAgICAgc3RhY2tXZWlnaHRcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbGF5b3V0Qm94ZXM7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkU3RhY2tzKGxheW91dHMpIHtcbiAgY29uc3Qgc3RhY2tzID0ge307XG4gIGZvciAoY29uc3Qgd3JhcCBvZiBsYXlvdXRzKSB7XG4gICAgY29uc3Qge3N0YWNrLCBwb3MsIHN0YWNrV2VpZ2h0fSA9IHdyYXA7XG4gICAgaWYgKCFzdGFjayB8fCAhU1RBVElDX1BPU0lUSU9OUy5pbmNsdWRlcyhwb3MpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgX3N0YWNrID0gc3RhY2tzW3N0YWNrXSB8fCAoc3RhY2tzW3N0YWNrXSA9IHtjb3VudDogMCwgcGxhY2VkOiAwLCB3ZWlnaHQ6IDAsIHNpemU6IDB9KTtcbiAgICBfc3RhY2suY291bnQrKztcbiAgICBfc3RhY2sud2VpZ2h0ICs9IHN0YWNrV2VpZ2h0O1xuICB9XG4gIHJldHVybiBzdGFja3M7XG59XG5cbi8qKlxuICogc3RvcmUgZGltZW5zaW9ucyB1c2VkIGluc3RlYWQgb2YgYXZhaWxhYmxlIGNoYXJ0QXJlYSBpbiBmaXRCb3hlc1xuICoqL1xuZnVuY3Rpb24gc2V0TGF5b3V0RGltcyhsYXlvdXRzLCBwYXJhbXMpIHtcbiAgY29uc3Qgc3RhY2tzID0gYnVpbGRTdGFja3MobGF5b3V0cyk7XG4gIGNvbnN0IHt2Qm94TWF4V2lkdGgsIGhCb3hNYXhIZWlnaHR9ID0gcGFyYW1zO1xuICBsZXQgaSwgaWxlbiwgbGF5b3V0O1xuICBmb3IgKGkgPSAwLCBpbGVuID0gbGF5b3V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBsYXlvdXQgPSBsYXlvdXRzW2ldO1xuICAgIGNvbnN0IHtmdWxsU2l6ZX0gPSBsYXlvdXQuYm94O1xuICAgIGNvbnN0IHN0YWNrID0gc3RhY2tzW2xheW91dC5zdGFja107XG4gICAgY29uc3QgZmFjdG9yID0gc3RhY2sgJiYgbGF5b3V0LnN0YWNrV2VpZ2h0IC8gc3RhY2sud2VpZ2h0O1xuICAgIGlmIChsYXlvdXQuaG9yaXpvbnRhbCkge1xuICAgICAgbGF5b3V0LndpZHRoID0gZmFjdG9yID8gZmFjdG9yICogdkJveE1heFdpZHRoIDogZnVsbFNpemUgJiYgcGFyYW1zLmF2YWlsYWJsZVdpZHRoO1xuICAgICAgbGF5b3V0LmhlaWdodCA9IGhCb3hNYXhIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxheW91dC53aWR0aCA9IHZCb3hNYXhXaWR0aDtcbiAgICAgIGxheW91dC5oZWlnaHQgPSBmYWN0b3IgPyBmYWN0b3IgKiBoQm94TWF4SGVpZ2h0IDogZnVsbFNpemUgJiYgcGFyYW1zLmF2YWlsYWJsZUhlaWdodDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YWNrcztcbn1cblxuZnVuY3Rpb24gYnVpbGRMYXlvdXRCb3hlcyhib3hlcykge1xuICBjb25zdCBsYXlvdXRCb3hlcyA9IHdyYXBCb3hlcyhib3hlcyk7XG4gIGNvbnN0IGZ1bGxTaXplID0gc29ydEJ5V2VpZ2h0KGxheW91dEJveGVzLmZpbHRlcih3cmFwID0+IHdyYXAuYm94LmZ1bGxTaXplKSwgdHJ1ZSk7XG4gIGNvbnN0IGxlZnQgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2xlZnQnKSwgdHJ1ZSk7XG4gIGNvbnN0IHJpZ2h0ID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdyaWdodCcpKTtcbiAgY29uc3QgdG9wID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICd0b3AnKSwgdHJ1ZSk7XG4gIGNvbnN0IGJvdHRvbSA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnYm90dG9tJykpO1xuICBjb25zdCBjZW50ZXJIb3Jpem9udGFsID0gZmlsdGVyRHluYW1pY1Bvc2l0aW9uQnlBeGlzKGxheW91dEJveGVzLCAneCcpO1xuICBjb25zdCBjZW50ZXJWZXJ0aWNhbCA9IGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhsYXlvdXRCb3hlcywgJ3knKTtcblxuICByZXR1cm4ge1xuICAgIGZ1bGxTaXplLFxuICAgIGxlZnRBbmRUb3A6IGxlZnQuY29uY2F0KHRvcCksXG4gICAgcmlnaHRBbmRCb3R0b206IHJpZ2h0LmNvbmNhdChjZW50ZXJWZXJ0aWNhbCkuY29uY2F0KGJvdHRvbSkuY29uY2F0KGNlbnRlckhvcml6b250YWwpLFxuICAgIGNoYXJ0QXJlYTogZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2NoYXJ0QXJlYScpLFxuICAgIHZlcnRpY2FsOiBsZWZ0LmNvbmNhdChyaWdodCkuY29uY2F0KGNlbnRlclZlcnRpY2FsKSxcbiAgICBob3Jpem9udGFsOiB0b3AuY29uY2F0KGJvdHRvbSkuY29uY2F0KGNlbnRlckhvcml6b250YWwpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgYSwgYikge1xuICByZXR1cm4gTWF0aC5tYXgobWF4UGFkZGluZ1thXSwgY2hhcnRBcmVhW2FdKSArIE1hdGgubWF4KG1heFBhZGRpbmdbYl0sIGNoYXJ0QXJlYVtiXSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU1heFBhZGRpbmcobWF4UGFkZGluZywgYm94UGFkZGluZykge1xuICBtYXhQYWRkaW5nLnRvcCA9IE1hdGgubWF4KG1heFBhZGRpbmcudG9wLCBib3hQYWRkaW5nLnRvcCk7XG4gIG1heFBhZGRpbmcubGVmdCA9IE1hdGgubWF4KG1heFBhZGRpbmcubGVmdCwgYm94UGFkZGluZy5sZWZ0KTtcbiAgbWF4UGFkZGluZy5ib3R0b20gPSBNYXRoLm1heChtYXhQYWRkaW5nLmJvdHRvbSwgYm94UGFkZGluZy5ib3R0b20pO1xuICBtYXhQYWRkaW5nLnJpZ2h0ID0gTWF0aC5tYXgobWF4UGFkZGluZy5yaWdodCwgYm94UGFkZGluZy5yaWdodCk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURpbXMoY2hhcnRBcmVhLCBwYXJhbXMsIGxheW91dCwgc3RhY2tzKSB7XG4gIGNvbnN0IHtwb3MsIGJveH0gPSBsYXlvdXQ7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcblxuICAvLyBkeW5hbWljYWxseSBwbGFjZWQgYm94ZXMgc2l6ZSBpcyBub3QgY29uc2lkZXJlZFxuICBpZiAoIWlzT2JqZWN0KHBvcykpIHtcbiAgICBpZiAobGF5b3V0LnNpemUpIHtcbiAgICAgIC8vIHRoaXMgbGF5b3V0IHdhcyBhbHJlYWR5IGNvdW50ZWQgZm9yLCBsZXRzIGZpcnN0IHJlZHVjZSBvbGQgc2l6ZVxuICAgICAgY2hhcnRBcmVhW3Bvc10gLT0gbGF5b3V0LnNpemU7XG4gICAgfVxuICAgIGNvbnN0IHN0YWNrID0gc3RhY2tzW2xheW91dC5zdGFja10gfHwge3NpemU6IDAsIGNvdW50OiAxfTtcbiAgICBzdGFjay5zaXplID0gTWF0aC5tYXgoc3RhY2suc2l6ZSwgbGF5b3V0Lmhvcml6b250YWwgPyBib3guaGVpZ2h0IDogYm94LndpZHRoKTtcbiAgICBsYXlvdXQuc2l6ZSA9IHN0YWNrLnNpemUgLyBzdGFjay5jb3VudDtcbiAgICBjaGFydEFyZWFbcG9zXSArPSBsYXlvdXQuc2l6ZTtcbiAgfVxuXG4gIGlmIChib3guZ2V0UGFkZGluZykge1xuICAgIHVwZGF0ZU1heFBhZGRpbmcobWF4UGFkZGluZywgYm94LmdldFBhZGRpbmcoKSk7XG4gIH1cblxuICBjb25zdCBuZXdXaWR0aCA9IE1hdGgubWF4KDAsIHBhcmFtcy5vdXRlcldpZHRoIC0gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCAnbGVmdCcsICdyaWdodCcpKTtcbiAgY29uc3QgbmV3SGVpZ2h0ID0gTWF0aC5tYXgoMCwgcGFyYW1zLm91dGVySGVpZ2h0IC0gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCAndG9wJywgJ2JvdHRvbScpKTtcbiAgY29uc3Qgd2lkdGhDaGFuZ2VkID0gbmV3V2lkdGggIT09IGNoYXJ0QXJlYS53O1xuICBjb25zdCBoZWlnaHRDaGFuZ2VkID0gbmV3SGVpZ2h0ICE9PSBjaGFydEFyZWEuaDtcbiAgY2hhcnRBcmVhLncgPSBuZXdXaWR0aDtcbiAgY2hhcnRBcmVhLmggPSBuZXdIZWlnaHQ7XG5cbiAgLy8gcmV0dXJuIGJvb2xlYW5zIG9uIHRoZSBjaGFuZ2VzIHBlciBkaXJlY3Rpb25cbiAgcmV0dXJuIGxheW91dC5ob3Jpem9udGFsXG4gICAgPyB7c2FtZTogd2lkdGhDaGFuZ2VkLCBvdGhlcjogaGVpZ2h0Q2hhbmdlZH1cbiAgICA6IHtzYW1lOiBoZWlnaHRDaGFuZ2VkLCBvdGhlcjogd2lkdGhDaGFuZ2VkfTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlTWF4UGFkZGluZyhjaGFydEFyZWEpIHtcbiAgY29uc3QgbWF4UGFkZGluZyA9IGNoYXJ0QXJlYS5tYXhQYWRkaW5nO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcyhwb3MpIHtcbiAgICBjb25zdCBjaGFuZ2UgPSBNYXRoLm1heChtYXhQYWRkaW5nW3Bvc10gLSBjaGFydEFyZWFbcG9zXSwgMCk7XG4gICAgY2hhcnRBcmVhW3Bvc10gKz0gY2hhbmdlO1xuICAgIHJldHVybiBjaGFuZ2U7XG4gIH1cbiAgY2hhcnRBcmVhLnkgKz0gdXBkYXRlUG9zKCd0b3AnKTtcbiAgY2hhcnRBcmVhLnggKz0gdXBkYXRlUG9zKCdsZWZ0Jyk7XG4gIHVwZGF0ZVBvcygncmlnaHQnKTtcbiAgdXBkYXRlUG9zKCdib3R0b20nKTtcbn1cblxuZnVuY3Rpb24gZ2V0TWFyZ2lucyhob3Jpem9udGFsLCBjaGFydEFyZWEpIHtcbiAgY29uc3QgbWF4UGFkZGluZyA9IGNoYXJ0QXJlYS5tYXhQYWRkaW5nO1xuXG4gIGZ1bmN0aW9uIG1hcmdpbkZvclBvc2l0aW9ucyhwb3NpdGlvbnMpIHtcbiAgICBjb25zdCBtYXJnaW4gPSB7bGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwfTtcbiAgICBwb3NpdGlvbnMuZm9yRWFjaCgocG9zKSA9PiB7XG4gICAgICBtYXJnaW5bcG9zXSA9IE1hdGgubWF4KGNoYXJ0QXJlYVtwb3NdLCBtYXhQYWRkaW5nW3Bvc10pO1xuICAgIH0pO1xuICAgIHJldHVybiBtYXJnaW47XG4gIH1cblxuICByZXR1cm4gaG9yaXpvbnRhbFxuICAgID8gbWFyZ2luRm9yUG9zaXRpb25zKFsnbGVmdCcsICdyaWdodCddKVxuICAgIDogbWFyZ2luRm9yUG9zaXRpb25zKFsndG9wJywgJ2JvdHRvbSddKTtcbn1cblxuZnVuY3Rpb24gZml0Qm94ZXMoYm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpIHtcbiAgY29uc3QgcmVmaXRCb3hlcyA9IFtdO1xuICBsZXQgaSwgaWxlbiwgbGF5b3V0LCBib3gsIHJlZml0LCBjaGFuZ2VkO1xuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBib3hlcy5sZW5ndGgsIHJlZml0ID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIGxheW91dCA9IGJveGVzW2ldO1xuICAgIGJveCA9IGxheW91dC5ib3g7XG5cbiAgICBib3gudXBkYXRlKFxuICAgICAgbGF5b3V0LndpZHRoIHx8IGNoYXJ0QXJlYS53LFxuICAgICAgbGF5b3V0LmhlaWdodCB8fCBjaGFydEFyZWEuaCxcbiAgICAgIGdldE1hcmdpbnMobGF5b3V0Lmhvcml6b250YWwsIGNoYXJ0QXJlYSlcbiAgICApO1xuICAgIGNvbnN0IHtzYW1lLCBvdGhlcn0gPSB1cGRhdGVEaW1zKGNoYXJ0QXJlYSwgcGFyYW1zLCBsYXlvdXQsIHN0YWNrcyk7XG5cbiAgICAvLyBEaW1lbnNpb25zIGNoYW5nZWQgYW5kIHRoZXJlIHdlcmUgbm9uIGZ1bGwgd2lkdGggYm94ZXMgYmVmb3JlIHRoaXNcbiAgICAvLyAtPiB3ZSBoYXZlIHRvIHJlZml0IHRob3NlXG4gICAgcmVmaXQgfD0gc2FtZSAmJiByZWZpdEJveGVzLmxlbmd0aDtcblxuICAgIC8vIENoYXJ0IGFyZWEgY2hhbmdlZCBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uXG4gICAgY2hhbmdlZCA9IGNoYW5nZWQgfHwgb3RoZXI7XG5cbiAgICBpZiAoIWJveC5mdWxsU2l6ZSkgeyAvLyBmdWxsU2l6ZSBib3hlcyBkb24ndCBuZWVkIHRvIGJlIHJlLWZpdHRlZCBpbiBhbnkgY2FzZVxuICAgICAgcmVmaXRCb3hlcy5wdXNoKGxheW91dCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlZml0ICYmIGZpdEJveGVzKHJlZml0Qm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpIHx8IGNoYW5nZWQ7XG59XG5cbmZ1bmN0aW9uIHNldEJveERpbXMoYm94LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcbiAgYm94LnRvcCA9IHRvcDtcbiAgYm94LmxlZnQgPSBsZWZ0O1xuICBib3gucmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gIGJveC5ib3R0b20gPSB0b3AgKyBoZWlnaHQ7XG4gIGJveC53aWR0aCA9IHdpZHRoO1xuICBib3guaGVpZ2h0ID0gaGVpZ2h0O1xufVxuXG5mdW5jdGlvbiBwbGFjZUJveGVzKGJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB7XG4gIGNvbnN0IHVzZXJQYWRkaW5nID0gcGFyYW1zLnBhZGRpbmc7XG4gIGxldCB7eCwgeX0gPSBjaGFydEFyZWE7XG5cbiAgZm9yIChjb25zdCBsYXlvdXQgb2YgYm94ZXMpIHtcbiAgICBjb25zdCBib3ggPSBsYXlvdXQuYm94O1xuICAgIGNvbnN0IHN0YWNrID0gc3RhY2tzW2xheW91dC5zdGFja10gfHwge2NvdW50OiAxLCBwbGFjZWQ6IDAsIHdlaWdodDogMX07XG4gICAgY29uc3Qgd2VpZ2h0ID0gKGxheW91dC5zdGFja1dlaWdodCAvIHN0YWNrLndlaWdodCkgfHwgMTtcbiAgICBpZiAobGF5b3V0Lmhvcml6b250YWwpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gY2hhcnRBcmVhLncgKiB3ZWlnaHQ7XG4gICAgICBjb25zdCBoZWlnaHQgPSBzdGFjay5zaXplIHx8IGJveC5oZWlnaHQ7XG4gICAgICBpZiAoZGVmaW5lZChzdGFjay5zdGFydCkpIHtcbiAgICAgICAgeSA9IHN0YWNrLnN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKGJveC5mdWxsU2l6ZSkge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgdXNlclBhZGRpbmcubGVmdCwgeSwgcGFyYW1zLm91dGVyV2lkdGggLSB1c2VyUGFkZGluZy5yaWdodCAtIHVzZXJQYWRkaW5nLmxlZnQsIGhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgY2hhcnRBcmVhLmxlZnQgKyBzdGFjay5wbGFjZWQsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgc3RhY2suc3RhcnQgPSB5O1xuICAgICAgc3RhY2sucGxhY2VkICs9IHdpZHRoO1xuICAgICAgeSA9IGJveC5ib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGNoYXJ0QXJlYS5oICogd2VpZ2h0O1xuICAgICAgY29uc3Qgd2lkdGggPSBzdGFjay5zaXplIHx8IGJveC53aWR0aDtcbiAgICAgIGlmIChkZWZpbmVkKHN0YWNrLnN0YXJ0KSkge1xuICAgICAgICB4ID0gc3RhY2suc3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAoYm94LmZ1bGxTaXplKSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCB4LCB1c2VyUGFkZGluZy50b3AsIHdpZHRoLCBwYXJhbXMub3V0ZXJIZWlnaHQgLSB1c2VyUGFkZGluZy5ib3R0b20gLSB1c2VyUGFkZGluZy50b3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHgsIGNoYXJ0QXJlYS50b3AgKyBzdGFjay5wbGFjZWQsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgc3RhY2suc3RhcnQgPSB4O1xuICAgICAgc3RhY2sucGxhY2VkICs9IGhlaWdodDtcbiAgICAgIHggPSBib3gucmlnaHQ7XG4gICAgfVxuICB9XG5cbiAgY2hhcnRBcmVhLnggPSB4O1xuICBjaGFydEFyZWEueSA9IHk7XG59XG5cbi8qKlxuICogQGludGVyZmFjZSBMYXlvdXRJdGVtXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBMYXlvdXRJdGVtXG4gKiBAcHJvcCB7c3RyaW5nfSBwb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgaXRlbSBpbiB0aGUgY2hhcnQgbGF5b3V0LiBQb3NzaWJsZSB2YWx1ZXMgYXJlXG4gKiAnbGVmdCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgYW5kICdjaGFydEFyZWEnXG4gKiBAcHJvcCB7bnVtYmVyfSB3ZWlnaHQgLSBUaGUgd2VpZ2h0IHVzZWQgdG8gc29ydCB0aGUgaXRlbS4gSGlnaGVyIHdlaWdodHMgYXJlIGZ1cnRoZXIgYXdheSBmcm9tIHRoZSBjaGFydCBhcmVhXG4gKiBAcHJvcCB7Ym9vbGVhbn0gZnVsbFNpemUgLSBpZiB0cnVlLCBhbmQgdGhlIGl0ZW0gaXMgaG9yaXpvbnRhbCwgdGhlbiBwdXNoIHZlcnRpY2FsIGJveGVzIGRvd25cbiAqIEBwcm9wIHtmdW5jdGlvbn0gaXNIb3Jpem9udGFsIC0gcmV0dXJucyB0cnVlIGlmIHRoZSBsYXlvdXQgaXRlbSBpcyBob3Jpem9udGFsIChpZS4gdG9wIG9yIGJvdHRvbSlcbiAqIEBwcm9wIHtmdW5jdGlvbn0gdXBkYXRlIC0gVGFrZXMgdHdvIHBhcmFtZXRlcnM6IHdpZHRoIGFuZCBoZWlnaHQuIFJldHVybnMgc2l6ZSBvZiBpdGVtXG4gKiBAcHJvcCB7ZnVuY3Rpb259IGRyYXcgLSBEcmF3cyB0aGUgZWxlbWVudFxuICogQHByb3Age2Z1bmN0aW9ufSBbZ2V0UGFkZGluZ10gLSAgUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBwYWRkaW5nIG9uIHRoZSBlZGdlc1xuICogQHByb3Age251bWJlcn0gd2lkdGggLSBXaWR0aCBvZiBpdGVtLiBNdXN0IGJlIHZhbGlkIGFmdGVyIHVwZGF0ZSgpXG4gKiBAcHJvcCB7bnVtYmVyfSBoZWlnaHQgLSBIZWlnaHQgb2YgaXRlbS4gTXVzdCBiZSB2YWxpZCBhZnRlciB1cGRhdGUoKVxuICogQHByb3Age251bWJlcn0gbGVmdCAtIExlZnQgZWRnZSBvZiB0aGUgaXRlbS4gU2V0IGJ5IGxheW91dCBzeXN0ZW0gYW5kIGNhbm5vdCBiZSB1c2VkIGluIHVwZGF0ZVxuICogQHByb3Age251bWJlcn0gdG9wIC0gVG9wIGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqIEBwcm9wIHtudW1iZXJ9IHJpZ2h0IC0gUmlnaHQgZWRnZSBvZiB0aGUgaXRlbS4gU2V0IGJ5IGxheW91dCBzeXN0ZW0gYW5kIGNhbm5vdCBiZSB1c2VkIGluIHVwZGF0ZVxuICogQHByb3Age251bWJlcn0gYm90dG9tIC0gQm90dG9tIGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqL1xuXG4vLyBUaGUgbGF5b3V0IHNlcnZpY2UgaXMgdmVyeSBzZWxmIGV4cGxhbmF0b3J5LiAgSXQncyByZXNwb25zaWJsZSBmb3IgdGhlIGxheW91dCB3aXRoaW4gYSBjaGFydC5cbi8vIFNjYWxlcywgTGVnZW5kcyBhbmQgUGx1Z2lucyBhbGwgcmVseSBvbiB0aGUgbGF5b3V0IHNlcnZpY2UgYW5kIGNhbiBlYXNpbHkgcmVnaXN0ZXIgdG8gYmUgcGxhY2VkIGFueXdoZXJlIHRoZXkgbmVlZFxuLy8gSXQgaXMgdGhpcyBzZXJ2aWNlJ3MgcmVzcG9uc2liaWxpdHkgb2YgY2Fycnlpbmcgb3V0IHRoYXQgbGF5b3V0LlxuZXhwb3J0IGRlZmF1bHQge1xuXG4gIC8qKlxuXHQgKiBSZWdpc3RlciBhIGJveCB0byBhIGNoYXJ0LlxuXHQgKiBBIGJveCBpcyBzaW1wbHkgYSByZWZlcmVuY2UgdG8gYW4gb2JqZWN0IHRoYXQgcmVxdWlyZXMgbGF5b3V0LiBlZy4gU2NhbGVzLCBMZWdlbmQsIFRpdGxlLlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byB1c2Vcblx0ICogQHBhcmFtIHtMYXlvdXRJdGVtfSBpdGVtIC0gdGhlIGl0ZW0gdG8gYWRkIHRvIGJlIGxhaWQgb3V0XG5cdCAqL1xuICBhZGRCb3goY2hhcnQsIGl0ZW0pIHtcbiAgICBpZiAoIWNoYXJ0LmJveGVzKSB7XG4gICAgICBjaGFydC5ib3hlcyA9IFtdO1xuICAgIH1cblxuICAgIC8vIGluaXRpYWxpemUgaXRlbSB3aXRoIGRlZmF1bHQgdmFsdWVzXG4gICAgaXRlbS5mdWxsU2l6ZSA9IGl0ZW0uZnVsbFNpemUgfHwgZmFsc2U7XG4gICAgaXRlbS5wb3NpdGlvbiA9IGl0ZW0ucG9zaXRpb24gfHwgJ3RvcCc7XG4gICAgaXRlbS53ZWlnaHQgPSBpdGVtLndlaWdodCB8fCAwO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpdGVtLl9sYXllcnMgPSBpdGVtLl9sYXllcnMgfHwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgejogMCxcbiAgICAgICAgZHJhdyhjaGFydEFyZWEpIHtcbiAgICAgICAgICBpdGVtLmRyYXcoY2hhcnRBcmVhKTtcbiAgICAgICAgfVxuICAgICAgfV07XG4gICAgfTtcblxuICAgIGNoYXJ0LmJveGVzLnB1c2goaXRlbSk7XG4gIH0sXG5cbiAgLyoqXG5cdCAqIFJlbW92ZSBhIGxheW91dEl0ZW0gZnJvbSBhIGNoYXJ0XG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIHJlbW92ZSB0aGUgYm94IGZyb21cblx0ICogQHBhcmFtIHtMYXlvdXRJdGVtfSBsYXlvdXRJdGVtIC0gdGhlIGl0ZW0gdG8gcmVtb3ZlIGZyb20gdGhlIGxheW91dFxuXHQgKi9cbiAgcmVtb3ZlQm94KGNoYXJ0LCBsYXlvdXRJdGVtKSB7XG4gICAgY29uc3QgaW5kZXggPSBjaGFydC5ib3hlcyA/IGNoYXJ0LmJveGVzLmluZGV4T2YobGF5b3V0SXRlbSkgOiAtMTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBjaGFydC5ib3hlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfSxcblxuICAvKipcblx0ICogU2V0cyAob3IgdXBkYXRlcykgb3B0aW9ucyBvbiB0aGUgZ2l2ZW4gYGl0ZW1gLlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCBpbiB3aGljaCB0aGUgaXRlbSBsaXZlcyAob3Igd2lsbCBiZSBhZGRlZCB0bylcblx0ICogQHBhcmFtIHtMYXlvdXRJdGVtfSBpdGVtIC0gdGhlIGl0ZW0gdG8gY29uZmlndXJlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnNcblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSB0aGUgbmV3IGl0ZW0gb3B0aW9ucy5cblx0ICovXG4gIGNvbmZpZ3VyZShjaGFydCwgaXRlbSwgb3B0aW9ucykge1xuICAgIGl0ZW0uZnVsbFNpemUgPSBvcHRpb25zLmZ1bGxTaXplO1xuICAgIGl0ZW0ucG9zaXRpb24gPSBvcHRpb25zLnBvc2l0aW9uO1xuICAgIGl0ZW0ud2VpZ2h0ID0gb3B0aW9ucy53ZWlnaHQ7XG4gIH0sXG5cbiAgLyoqXG5cdCAqIEZpdHMgYm94ZXMgb2YgdGhlIGdpdmVuIGNoYXJ0IGludG8gdGhlIGdpdmVuIHNpemUgYnkgaGF2aW5nIGVhY2ggYm94IG1lYXN1cmUgaXRzZWxmXG5cdCAqIHRoZW4gcnVubmluZyBhIGZpdHRpbmcgYWxnb3JpdGhtXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHRoZSB3aWR0aCB0byBmaXQgaW50b1xuXHQgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gdGhlIGhlaWdodCB0byBmaXQgaW50b1xuICAgKiBAcGFyYW0ge251bWJlcn0gbWluUGFkZGluZyAtIG1pbmltdW0gcGFkZGluZyByZXF1aXJlZCBmb3IgZWFjaCBzaWRlIG9mIGNoYXJ0IGFyZWFcblx0ICovXG4gIHVwZGF0ZShjaGFydCwgd2lkdGgsIGhlaWdodCwgbWluUGFkZGluZykge1xuICAgIGlmICghY2hhcnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKGNoYXJ0Lm9wdGlvbnMubGF5b3V0LnBhZGRpbmcpO1xuICAgIGNvbnN0IGF2YWlsYWJsZVdpZHRoID0gTWF0aC5tYXgod2lkdGggLSBwYWRkaW5nLndpZHRoLCAwKTtcbiAgICBjb25zdCBhdmFpbGFibGVIZWlnaHQgPSBNYXRoLm1heChoZWlnaHQgLSBwYWRkaW5nLmhlaWdodCwgMCk7XG4gICAgY29uc3QgYm94ZXMgPSBidWlsZExheW91dEJveGVzKGNoYXJ0LmJveGVzKTtcbiAgICBjb25zdCB2ZXJ0aWNhbEJveGVzID0gYm94ZXMudmVydGljYWw7XG4gICAgY29uc3QgaG9yaXpvbnRhbEJveGVzID0gYm94ZXMuaG9yaXpvbnRhbDtcblxuICAgIC8vIEJlZm9yZSBhbnkgY2hhbmdlcyBhcmUgbWFkZSwgbm90aWZ5IGJveGVzIHRoYXQgYW4gdXBkYXRlIGlzIGFib3V0IHRvIGJlaW5nXG4gICAgLy8gVGhpcyBpcyB1c2VkIHRvIGNsZWFyIGFueSBjYWNoZWQgZGF0YSAoZS5nLiBzY2FsZSBsaW1pdHMpXG4gICAgZWFjaChjaGFydC5ib3hlcywgYm94ID0+IHtcbiAgICAgIGlmICh0eXBlb2YgYm94LmJlZm9yZUxheW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBib3guYmVmb3JlTGF5b3V0KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBFc3NlbnRpYWxseSB3ZSBub3cgaGF2ZSBhbnkgbnVtYmVyIG9mIGJveGVzIG9uIGVhY2ggb2YgdGhlIDQgc2lkZXMuXG4gICAgLy8gT3VyIGNhbnZhcyBsb29rcyBsaWtlIHRoZSBmb2xsb3dpbmcuXG4gICAgLy8gVGhlIGFyZWFzIEwxIGFuZCBMMiBhcmUgdGhlIGxlZnQgYXhlcy4gUjEgaXMgdGhlIHJpZ2h0IGF4aXMsIFQxIGlzIHRoZSB0b3AgYXhpcyBhbmRcbiAgICAvLyBCMSBpcyB0aGUgYm90dG9tIGF4aXNcbiAgICAvLyBUaGVyZSBhcmUgYWxzbyA0IHF1YWRyYW50LWxpa2UgbG9jYXRpb25zIChsZWZ0IHRvIHJpZ2h0IGluc3RlYWQgb2YgY2xvY2t3aXNlKSByZXNlcnZlZCBmb3IgY2hhcnQgb3ZlcmxheXNcbiAgICAvLyBUaGVzZSBsb2NhdGlvbnMgYXJlIHNpbmdsZS1ib3ggbG9jYXRpb25zIG9ubHksIHdoZW4gdHJ5aW5nIHRvIHJlZ2lzdGVyIGEgY2hhcnRBcmVhIGxvY2F0aW9uIHRoYXQgaXMgYWxyZWFkeSB0YWtlbixcbiAgICAvLyBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICAvL1xuICAgIC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAgIC8vIHwgICAgICAgICAgICAgICAgICBUMSAoRnVsbCBXaWR0aCkgICAgICAgICAgICAgICAgICAgfFxuICAgIC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAgIC8vIHwgICAgfCAgICB8ICAgICAgICAgICAgICAgICBUMiAgICAgICAgICAgICAgICAgIHwgICAgfFxuICAgIC8vIHwgICAgfC0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tfFxuICAgIC8vIHwgICAgfCAgICB8IEMxIHwgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEMyIHwgICAgfFxuICAgIC8vIHwgICAgfCAgICB8LS0tLXwgICAgICAgICAgICAgICAgICAgICAgICAgICB8LS0tLXwgICAgfFxuICAgIC8vIHwgICAgfCAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgfFxuICAgIC8vIHwgTDEgfCBMMiB8ICAgICAgICAgICBDaGFydEFyZWEgKEMwKSAgICAgICAgICAgIHwgUjEgfFxuICAgIC8vIHwgICAgfCAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgfFxuICAgIC8vIHwgICAgfCAgICB8LS0tLXwgICAgICAgICAgICAgICAgICAgICAgICAgICB8LS0tLXwgICAgfFxuICAgIC8vIHwgICAgfCAgICB8IEMzIHwgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEM0IHwgICAgfFxuICAgIC8vIHwgICAgfC0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tfFxuICAgIC8vIHwgICAgfCAgICB8ICAgICAgICAgICAgICAgICBCMSAgICAgICAgICAgICAgICAgIHwgICAgfFxuICAgIC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAgIC8vIHwgICAgICAgICAgICAgICAgICBCMiAoRnVsbCBXaWR0aCkgICAgICAgICAgICAgICAgICAgfFxuICAgIC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAgIC8vXG5cbiAgICBjb25zdCB2aXNpYmxlVmVydGljYWxCb3hDb3VudCA9IHZlcnRpY2FsQm94ZXMucmVkdWNlKCh0b3RhbCwgd3JhcCkgPT5cbiAgICAgIHdyYXAuYm94Lm9wdGlvbnMgJiYgd3JhcC5ib3gub3B0aW9ucy5kaXNwbGF5ID09PSBmYWxzZSA/IHRvdGFsIDogdG90YWwgKyAxLCAwKSB8fCAxO1xuXG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBvdXRlcldpZHRoOiB3aWR0aCxcbiAgICAgIG91dGVySGVpZ2h0OiBoZWlnaHQsXG4gICAgICBwYWRkaW5nLFxuICAgICAgYXZhaWxhYmxlV2lkdGgsXG4gICAgICBhdmFpbGFibGVIZWlnaHQsXG4gICAgICB2Qm94TWF4V2lkdGg6IGF2YWlsYWJsZVdpZHRoIC8gMiAvIHZpc2libGVWZXJ0aWNhbEJveENvdW50LFxuICAgICAgaEJveE1heEhlaWdodDogYXZhaWxhYmxlSGVpZ2h0IC8gMlxuICAgIH0pO1xuICAgIGNvbnN0IG1heFBhZGRpbmcgPSBPYmplY3QuYXNzaWduKHt9LCBwYWRkaW5nKTtcbiAgICB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIHRvUGFkZGluZyhtaW5QYWRkaW5nKSk7XG4gICAgY29uc3QgY2hhcnRBcmVhID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBtYXhQYWRkaW5nLFxuICAgICAgdzogYXZhaWxhYmxlV2lkdGgsXG4gICAgICBoOiBhdmFpbGFibGVIZWlnaHQsXG4gICAgICB4OiBwYWRkaW5nLmxlZnQsXG4gICAgICB5OiBwYWRkaW5nLnRvcFxuICAgIH0sIHBhZGRpbmcpO1xuXG4gICAgY29uc3Qgc3RhY2tzID0gc2V0TGF5b3V0RGltcyh2ZXJ0aWNhbEJveGVzLmNvbmNhdChob3Jpem9udGFsQm94ZXMpLCBwYXJhbXMpO1xuXG4gICAgLy8gRmlyc3QgZml0IHRoZSBmdWxsU2l6ZSBib3hlcywgdG8gcmVkdWNlIHByb2JhYmlsaXR5IG9mIHJlLWZpdHRpbmcuXG4gICAgZml0Qm94ZXMoYm94ZXMuZnVsbFNpemUsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuXG4gICAgLy8gVGhlbiBmaXQgdmVydGljYWwgYm94ZXNcbiAgICBmaXRCb3hlcyh2ZXJ0aWNhbEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcblxuICAgIC8vIFRoZW4gZml0IGhvcml6b250YWwgYm94ZXNcbiAgICBpZiAoZml0Qm94ZXMoaG9yaXpvbnRhbEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSkge1xuICAgICAgLy8gaWYgdGhlIGFyZWEgY2hhbmdlZCwgcmUtZml0IHZlcnRpY2FsIGJveGVzXG4gICAgICBmaXRCb3hlcyh2ZXJ0aWNhbEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICB9XG5cbiAgICBoYW5kbGVNYXhQYWRkaW5nKGNoYXJ0QXJlYSk7XG5cbiAgICAvLyBGaW5hbGx5IHBsYWNlIHRoZSBib3hlcyB0byBjb3JyZWN0IGNvb3JkaW5hdGVzXG4gICAgcGxhY2VCb3hlcyhib3hlcy5sZWZ0QW5kVG9wLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcblxuICAgIC8vIE1vdmUgdG8gb3Bwb3NpdGUgc2lkZSBvZiBjaGFydFxuICAgIGNoYXJ0QXJlYS54ICs9IGNoYXJ0QXJlYS53O1xuICAgIGNoYXJ0QXJlYS55ICs9IGNoYXJ0QXJlYS5oO1xuXG4gICAgcGxhY2VCb3hlcyhib3hlcy5yaWdodEFuZEJvdHRvbSwgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG5cbiAgICBjaGFydC5jaGFydEFyZWEgPSB7XG4gICAgICBsZWZ0OiBjaGFydEFyZWEubGVmdCxcbiAgICAgIHRvcDogY2hhcnRBcmVhLnRvcCxcbiAgICAgIHJpZ2h0OiBjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS53LFxuICAgICAgYm90dG9tOiBjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmgsXG4gICAgICBoZWlnaHQ6IGNoYXJ0QXJlYS5oLFxuICAgICAgd2lkdGg6IGNoYXJ0QXJlYS53LFxuICAgIH07XG5cbiAgICAvLyBGaW5hbGx5IHVwZGF0ZSBib3hlcyBpbiBjaGFydEFyZWEgKHJhZGlhbCBzY2FsZSBmb3IgZXhhbXBsZSlcbiAgICBlYWNoKGJveGVzLmNoYXJ0QXJlYSwgKGxheW91dCkgPT4ge1xuICAgICAgY29uc3QgYm94ID0gbGF5b3V0LmJveDtcbiAgICAgIE9iamVjdC5hc3NpZ24oYm94LCBjaGFydC5jaGFydEFyZWEpO1xuICAgICAgYm94LnVwZGF0ZShjaGFydEFyZWEudywgY2hhcnRBcmVhLmgsIHtsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDB9KTtcbiAgICB9KTtcbiAgfVxufTtcbiIsICJcbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKi9cblxuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyB0aGF0IGFsbG93cyBhYnN0cmFjdGluZyBwbGF0Zm9ybSBkZXBlbmRlbmNpZXMgYXdheSBmcm9tIHRoZSBjaGFydC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZVBsYXRmb3JtIHtcbiAgLyoqXG5cdCAqIENhbGxlZCBhdCBjaGFydCBjb25zdHJ1Y3Rpb24gdGltZSwgcmV0dXJucyBhIGNvbnRleHQyZCBpbnN0YW5jZSBpbXBsZW1lbnRpbmdcblx0ICogdGhlIFtXM0MgQ2FudmFzIDJEIENvbnRleHQgQVBJIHN0YW5kYXJkXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvMmRjb250ZXh0L30uXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIFRoZSBjYW52YXMgZnJvbSB3aGljaCB0byBhY3F1aXJlIGNvbnRleHQgKHBsYXRmb3JtIHNwZWNpZmljKVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FzcGVjdFJhdGlvXSAtIFRoZSBjaGFydCBvcHRpb25zXG5cdCAqL1xuICBhY3F1aXJlQ29udGV4dChjYW52YXMsIGFzcGVjdFJhdGlvKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG5cdCAqIENhbGxlZCBhdCBjaGFydCBkZXN0cnVjdGlvbiB0aW1lLCByZWxlYXNlcyBhbnkgcmVzb3VyY2VzIGFzc29jaWF0ZWQgdG8gdGhlIGNvbnRleHRcblx0ICogcHJldmlvdXNseSByZXR1cm5lZCBieSB0aGUgYWNxdWlyZUNvbnRleHQoKSBtZXRob2QuXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IC0gVGhlIGNvbnRleHQyZCBpbnN0YW5jZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgbWV0aG9kIHN1Y2NlZWRlZCwgZWxzZSBmYWxzZVxuXHQgKi9cbiAgcmVsZWFzZUNvbnRleHQoY29udGV4dCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJlZ2lzdGVycyB0aGUgc3BlY2lmaWVkIGxpc3RlbmVyIG9uIHRoZSBnaXZlbiBjaGFydC5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBDaGFydCBmcm9tIHdoaWNoIHRvIGxpc3RlbiBmb3IgZXZlbnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgKHtAbGluayBDaGFydEV2ZW50fSkgdHlwZSB0byBsaXN0ZW4gZm9yXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIC0gUmVjZWl2ZXMgYSBub3RpZmljYXRpb24gKGFuIG9iamVjdCB0aGF0IGltcGxlbWVudHNcblx0ICogdGhlIHtAbGluayBDaGFydEV2ZW50fSBpbnRlcmZhY2UpIHdoZW4gYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vycy5cblx0ICovXG4gIGFkZEV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG5cdCAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBsaXN0ZW5lciBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgd2l0aCBhZGRFdmVudExpc3RlbmVyLlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIENoYXJ0IGZyb20gd2hpY2ggdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSAoe0BsaW5rIENoYXJ0RXZlbnR9KSB0eXBlIHRvIHJlbW92ZVxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byByZW1vdmUgZnJvbSB0aGUgZXZlbnQgdGFyZ2V0LlxuXHQgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKipcblx0ICogQHJldHVybnMge251bWJlcn0gdGhlIGN1cnJlbnQgZGV2aWNlUGl4ZWxSYXRpbyBvZiB0aGUgZGV2aWNlIHRoaXMgcGxhdGZvcm0gaXMgY29ubmVjdGVkIHRvLlxuXHQgKi9cbiAgZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIHNpemUgaW4gcGl4ZWxzIG9mIGdpdmVuIGNhbnZhcyBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBlbGVtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGhdIC0gY29udGVudCB3aWR0aCBvZiBwYXJlbnQgZWxlbWVudFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodF0gLSBjb250ZW50IGhlaWdodCBvZiBwYXJlbnQgZWxlbWVudFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FzcGVjdFJhdGlvXSAtIGFzcGVjdCByYXRpbyB0byBtYWludGFpblxuXHQgKi9cbiAgZ2V0TWF4aW11bVNpemUoZWxlbWVudCwgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pIHtcbiAgICB3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoIHx8IGVsZW1lbnQud2lkdGgpO1xuICAgIGhlaWdodCA9IGhlaWdodCB8fCBlbGVtZW50LmhlaWdodDtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQ6IE1hdGgubWF4KDAsIGFzcGVjdFJhdGlvID8gTWF0aC5mbG9vcih3aWR0aCAvIGFzcGVjdFJhdGlvKSA6IGhlaWdodClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2FudmFzIGlzIGF0dGFjaGVkIHRvIHRoZSBwbGF0Zm9ybSwgZmFsc2UgaWYgbm90LlxuXHQgKi9cbiAgaXNBdHRhY2hlZChjYW52YXMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgY29uZmlnIHdpdGggcGxhdGZvcm0gc3BlY2lmaWMgcmVxdWlyZW1lbnRzXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi9jb3JlL2NvcmUuY29uZmlnLmpzJykuZGVmYXVsdH0gY29uZmlnXG4gICAqL1xuICB1cGRhdGVDb25maWcoY29uZmlnKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAvLyBuby1vcFxuICB9XG59XG4iLCAiLyoqXG4gKiBQbGF0Zm9ybSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiAobWluaW1hbCkuXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDU5MSNpc3N1ZWNvbW1lbnQtMzE5NTc1OTM5XG4gKi9cblxuaW1wb3J0IEJhc2VQbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtLmJhc2UuanMnO1xuXG4vKipcbiAqIFBsYXRmb3JtIGNsYXNzIGZvciBjaGFydHMgd2l0aG91dCBhY2Nlc3MgdG8gdGhlIERPTSBvciB0byBtYW55IGVsZW1lbnQgcHJvcGVydGllc1xuICogVGhpcyBwbGF0Zm9ybSBpcyB1c2VkIGJ5IGRlZmF1bHQgZm9yIGFueSBjaGFydCBwYXNzZWQgYW4gT2Zmc2NyZWVuQ2FudmFzLlxuICogQGV4dGVuZHMgQmFzZVBsYXRmb3JtXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2ljUGxhdGZvcm0gZXh0ZW5kcyBCYXNlUGxhdGZvcm0ge1xuICBhY3F1aXJlQ29udGV4dChpdGVtKSB7XG4gICAgLy8gVG8gcHJldmVudCBjYW52YXMgZmluZ2VycHJpbnRpbmcsIHNvbWUgYWRkLW9ucyB1bmRlZmluZSB0aGUgZ2V0Q29udGV4dFxuICAgIC8vIG1ldGhvZCwgZm9yIGV4YW1wbGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ra2Fwc25lci9DYW52YXNCbG9ja2VyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI4MDdcbiAgICByZXR1cm4gaXRlbSAmJiBpdGVtLmdldENvbnRleHQgJiYgaXRlbS5nZXRDb250ZXh0KCcyZCcpIHx8IG51bGw7XG4gIH1cbiAgdXBkYXRlQ29uZmlnKGNvbmZpZykge1xuICAgIGNvbmZpZy5vcHRpb25zLmFuaW1hdGlvbiA9IGZhbHNlO1xuICB9XG59XG4iLCAiLyoqXG4gKiBDaGFydC5QbGF0Zm9ybSBpbXBsZW1lbnRhdGlvbiBmb3IgdGFyZ2V0aW5nIGEgd2ViIGJyb3dzZXJcbiAqL1xuXG5pbXBvcnQgQmFzZVBsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0uYmFzZS5qcyc7XG5pbXBvcnQge19nZXRQYXJlbnROb2RlLCBnZXRSZWxhdGl2ZVBvc2l0aW9uLCBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zLCByZWFkVXNlZFNpemUsIGdldE1heGltdW1TaXplfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZG9tLmpzJztcbmltcG9ydCB7dGhyb3R0bGVkfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcbmltcG9ydCB7aXNOdWxsT3JVbmRlZn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICovXG5cbmNvbnN0IEVYUEFORE9fS0VZID0gJyRjaGFydGpzJztcblxuLyoqXG4gKiBET00gZXZlbnQgdHlwZXMgLT4gQ2hhcnQuanMgZXZlbnQgdHlwZXMuXG4gKiBOb3RlOiBvbmx5IGV2ZW50cyB3aXRoIGRpZmZlcmVudCB0eXBlcyBhcmUgbWFwcGVkLlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHNcbiAqL1xuY29uc3QgRVZFTlRfVFlQRVMgPSB7XG4gIHRvdWNoc3RhcnQ6ICdtb3VzZWRvd24nLFxuICB0b3VjaG1vdmU6ICdtb3VzZW1vdmUnLFxuICB0b3VjaGVuZDogJ21vdXNldXAnLFxuICBwb2ludGVyZW50ZXI6ICdtb3VzZWVudGVyJyxcbiAgcG9pbnRlcmRvd246ICdtb3VzZWRvd24nLFxuICBwb2ludGVybW92ZTogJ21vdXNlbW92ZScsXG4gIHBvaW50ZXJ1cDogJ21vdXNldXAnLFxuICBwb2ludGVybGVhdmU6ICdtb3VzZW91dCcsXG4gIHBvaW50ZXJvdXQ6ICdtb3VzZW91dCdcbn07XG5cbmNvbnN0IGlzTnVsbE9yRW1wdHkgPSB2YWx1ZSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gJyc7XG4vKipcbiAqIEluaXRpYWxpemVzIHRoZSBjYW52YXMgc3R5bGUgYW5kIHJlbmRlciBzaXplIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBjYW52YXMgZGlzcGxheSBzaXplLFxuICogc2luY2UgcmVzcG9uc2l2ZW5lc3MgaXMgaGFuZGxlZCBieSB0aGUgY29udHJvbGxlci5yZXNpemUoKSBtZXRob2QuIFRoZSBjb25maWcgaXMgdXNlZFxuICogdG8gZGV0ZXJtaW5lIHRoZSBhc3BlY3QgcmF0aW8gdG8gYXBwbHkgaW4gY2FzZSBubyBleHBsaWNpdCBoZWlnaHQgaGFzIGJlZW4gc3BlY2lmaWVkLlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG4gKiBAcGFyYW0ge251bWJlcn0gW2FzcGVjdFJhdGlvXVxuICovXG5mdW5jdGlvbiBpbml0Q2FudmFzKGNhbnZhcywgYXNwZWN0UmF0aW8pIHtcbiAgY29uc3Qgc3R5bGUgPSBjYW52YXMuc3R5bGU7XG5cbiAgLy8gTk9URShTQikgY2FudmFzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSAhPT0gY2FudmFzLndpZHRoOiBpbiB0aGUgZmlyc3QgY2FzZSBpdFxuICAvLyByZXR1cm5zIG51bGwgb3IgJycgaWYgbm8gZXhwbGljaXQgdmFsdWUgaGFzIGJlZW4gc2V0IHRvIHRoZSBjYW52YXMgYXR0cmlidXRlLlxuICBjb25zdCByZW5kZXJIZWlnaHQgPSBjYW52YXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKTtcbiAgY29uc3QgcmVuZGVyV2lkdGggPSBjYW52YXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xuXG4gIC8vIENoYXJ0LmpzIG1vZGlmaWVzIHNvbWUgY2FudmFzIHZhbHVlcyB0aGF0IHdlIHdhbnQgdG8gcmVzdG9yZSBvbiBkZXN0cm95XG4gIGNhbnZhc1tFWFBBTkRPX0tFWV0gPSB7XG4gICAgaW5pdGlhbDoge1xuICAgICAgaGVpZ2h0OiByZW5kZXJIZWlnaHQsXG4gICAgICB3aWR0aDogcmVuZGVyV2lkdGgsXG4gICAgICBzdHlsZToge1xuICAgICAgICBkaXNwbGF5OiBzdHlsZS5kaXNwbGF5LFxuICAgICAgICBoZWlnaHQ6IHN0eWxlLmhlaWdodCxcbiAgICAgICAgd2lkdGg6IHN0eWxlLndpZHRoXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIEZvcmNlIGNhbnZhcyB0byBkaXNwbGF5IGFzIGJsb2NrIHRvIGF2b2lkIGV4dHJhIHNwYWNlIGNhdXNlZCBieSBpbmxpbmVcbiAgLy8gZWxlbWVudHMsIHdoaWNoIHdvdWxkIGludGVyZmVyZSB3aXRoIHRoZSByZXNwb25zaXZlIHJlc2l6ZSBwcm9jZXNzLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjUzOFxuICBzdHlsZS5kaXNwbGF5ID0gc3R5bGUuZGlzcGxheSB8fCAnYmxvY2snO1xuICAvLyBJbmNsdWRlIHBvc3NpYmxlIGJvcmRlcnMgaW4gdGhlIHNpemVcbiAgc3R5bGUuYm94U2l6aW5nID0gc3R5bGUuYm94U2l6aW5nIHx8ICdib3JkZXItYm94JztcblxuICBpZiAoaXNOdWxsT3JFbXB0eShyZW5kZXJXaWR0aCkpIHtcbiAgICBjb25zdCBkaXNwbGF5V2lkdGggPSByZWFkVXNlZFNpemUoY2FudmFzLCAnd2lkdGgnKTtcbiAgICBpZiAoZGlzcGxheVdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNhbnZhcy53aWR0aCA9IGRpc3BsYXlXaWR0aDtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNOdWxsT3JFbXB0eShyZW5kZXJIZWlnaHQpKSB7XG4gICAgaWYgKGNhbnZhcy5zdHlsZS5oZWlnaHQgPT09ICcnKSB7XG4gICAgICAvLyBJZiBubyBleHBsaWNpdCByZW5kZXIgaGVpZ2h0IGFuZCBzdHlsZSBoZWlnaHQsIGxldCdzIGFwcGx5IHRoZSBhc3BlY3QgcmF0aW8sXG4gICAgICAvLyB3aGljaCBvbmUgY2FuIGJlIHNwZWNpZmllZCBieSB0aGUgdXNlciBidXQgYWxzbyBieSBjaGFydHMgYXMgZGVmYXVsdCBvcHRpb25cbiAgICAgIC8vIChpLmUuIG9wdGlvbnMuYXNwZWN0UmF0aW8pLiBJZiBub3Qgc3BlY2lmaWVkLCB1c2UgY2FudmFzIGFzcGVjdCByYXRpbyBvZiAyLlxuICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy53aWR0aCAvIChhc3BlY3RSYXRpbyB8fCAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGlzcGxheUhlaWdodCA9IHJlYWRVc2VkU2l6ZShjYW52YXMsICdoZWlnaHQnKTtcbiAgICAgIGlmIChkaXNwbGF5SGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGRpc3BsYXlIZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNhbnZhcztcbn1cblxuLy8gRGVmYXVsdCBwYXNzaXZlIHRvIHRydWUgYXMgZXhwZWN0ZWQgYnkgQ2hyb21lIGZvciAndG91Y2hzdGFydCcgYW5kICd0b3VjaGVuZCcgZXZlbnRzLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQyODdcbmNvbnN0IGV2ZW50TGlzdGVuZXJPcHRpb25zID0gc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyA/IHtwYXNzaXZlOiB0cnVlfSA6IGZhbHNlO1xuXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihub2RlLCB0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAobm9kZSkge1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoY2hhcnQgJiYgY2hhcnQuY2FudmFzKSB7XG4gICAgY2hhcnQuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSB7XG4gIGNvbnN0IHR5cGUgPSBFVkVOVF9UWVBFU1tldmVudC50eXBlXSB8fCBldmVudC50eXBlO1xuICBjb25zdCB7eCwgeX0gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGV2ZW50LCBjaGFydCk7XG4gIHJldHVybiB7XG4gICAgdHlwZSxcbiAgICBjaGFydCxcbiAgICBuYXRpdmU6IGV2ZW50LFxuICAgIHg6IHggIT09IHVuZGVmaW5lZCA/IHggOiBudWxsLFxuICAgIHk6IHkgIT09IHVuZGVmaW5lZCA/IHkgOiBudWxsLFxuICB9O1xufVxuXG5mdW5jdGlvbiBub2RlTGlzdENvbnRhaW5zKG5vZGVMaXN0LCBjYW52YXMpIHtcbiAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVMaXN0KSB7XG4gICAgaWYgKG5vZGUgPT09IGNhbnZhcyB8fCBub2RlLmNvbnRhaW5zKGNhbnZhcykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVBdHRhY2hPYnNlcnZlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgIGxldCB0cmlnZ2VyID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICB0cmlnZ2VyID0gdHJpZ2dlciB8fCBub2RlTGlzdENvbnRhaW5zKGVudHJ5LmFkZGVkTm9kZXMsIGNhbnZhcyk7XG4gICAgICB0cmlnZ2VyID0gdHJpZ2dlciAmJiAhbm9kZUxpc3RDb250YWlucyhlbnRyeS5yZW1vdmVkTm9kZXMsIGNhbnZhcyk7XG4gICAgfVxuICAgIGlmICh0cmlnZ2VyKSB7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQsIHtjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWV9KTtcbiAgcmV0dXJuIG9ic2VydmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEZXRhY2hPYnNlcnZlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgIGxldCB0cmlnZ2VyID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICB0cmlnZ2VyID0gdHJpZ2dlciB8fCBub2RlTGlzdENvbnRhaW5zKGVudHJ5LnJlbW92ZWROb2RlcywgY2FudmFzKTtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyICYmICFub2RlTGlzdENvbnRhaW5zKGVudHJ5LmFkZGVkTm9kZXMsIGNhbnZhcyk7XG4gICAgfVxuICAgIGlmICh0cmlnZ2VyKSB7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQsIHtjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWV9KTtcbiAgcmV0dXJuIG9ic2VydmVyO1xufVxuXG5jb25zdCBkcnBMaXN0ZW5pbmdDaGFydHMgPSBuZXcgTWFwKCk7XG5sZXQgb2xkRGV2aWNlUGl4ZWxSYXRpbyA9IDA7XG5cbmZ1bmN0aW9uIG9uV2luZG93UmVzaXplKCkge1xuICBjb25zdCBkcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgaWYgKGRwciA9PT0gb2xkRGV2aWNlUGl4ZWxSYXRpbykge1xuICAgIHJldHVybjtcbiAgfVxuICBvbGREZXZpY2VQaXhlbFJhdGlvID0gZHByO1xuICBkcnBMaXN0ZW5pbmdDaGFydHMuZm9yRWFjaCgocmVzaXplLCBjaGFydCkgPT4ge1xuICAgIGlmIChjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyAhPT0gZHByKSB7XG4gICAgICByZXNpemUoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBsaXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCwgcmVzaXplKSB7XG4gIGlmICghZHJwTGlzdGVuaW5nQ2hhcnRzLnNpemUpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25XaW5kb3dSZXNpemUpO1xuICB9XG4gIGRycExpc3RlbmluZ0NoYXJ0cy5zZXQoY2hhcnQsIHJlc2l6ZSk7XG59XG5cbmZ1bmN0aW9uIHVubGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQpIHtcbiAgZHJwTGlzdGVuaW5nQ2hhcnRzLmRlbGV0ZShjaGFydCk7XG4gIGlmICghZHJwTGlzdGVuaW5nQ2hhcnRzLnNpemUpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25XaW5kb3dSZXNpemUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlc2l6ZU9ic2VydmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGNhbnZhcyAmJiBfZ2V0UGFyZW50Tm9kZShjYW52YXMpO1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCByZXNpemUgPSB0aHJvdHRsZWQoKHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCB3ID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgIGxpc3RlbmVyKHdpZHRoLCBoZWlnaHQpO1xuICAgIGlmICh3IDwgY29udGFpbmVyLmNsaWVudFdpZHRoKSB7XG4gICAgICAvLyBJZiB0aGUgY29udGFpbmVyIHNpemUgc2hyYW5rIGR1cmluZyBjaGFydCByZXNpemUsIGxldCdzIGFzc3VtZVxuICAgICAgLy8gc2Nyb2xsYmFyIGFwcGVhcmVkLiBTbyB3ZSByZXNpemUgYWdhaW4gd2l0aCB0aGUgc2Nyb2xsYmFyIHZpc2libGUgLVxuICAgICAgLy8gZWZmZWN0aXZlbHkgbWFraW5nIGNoYXJ0IHNtYWxsZXIgYW5kIHRoZSBzY3JvbGxiYXIgaGlkZGVuIGFnYWluLlxuICAgICAgLy8gQmVjYXVzZSB3ZSBhcmUgaW5zaWRlIGB0aHJvdHRsZWRgLCBhbmQgY3VycmVudGx5IGB0aWNraW5nYCwgc2Nyb2xsXG4gICAgICAvLyBldmVudHMgYXJlIGlnbm9yZWQgZHVyaW5nIHRoaXMgd2hvbGUgMiByZXNpemUgcHJvY2Vzcy5cbiAgICAgIC8vIElmIHdlIGFzc3VtZWQgd3JvbmcgYW5kIHNvbWV0aGluZyBlbHNlIGhhcHBlbmVkLCB3ZSBhcmUgcmVzaXppbmdcbiAgICAgIC8vIHR3aWNlIGluIGEgZnJhbWUgKHBvdGVudGlhbCBwZXJmb3JtYW5jZSBpc3N1ZSlcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuICB9LCB3aW5kb3cpO1xuXG4gIC8vIEB0cy1pZ25vcmUgdW50aWwgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8zNzg2MSBpbXBsZW1lbnRlZFxuICBjb25zdCBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbMF07XG4gICAgY29uc3Qgd2lkdGggPSBlbnRyeS5jb250ZW50UmVjdC53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBlbnRyeS5jb250ZW50UmVjdC5oZWlnaHQ7XG4gICAgLy8gV2hlbiBpdHMgY29udGFpbmVyJ3MgZGlzcGxheSBpcyBzZXQgdG8gJ25vbmUnIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aXRoIGFcbiAgICAvLyBzaXplIG9mICgwLCAwKSwgd2hpY2ggd2lsbCBjYXVzZSB0aGUgY2hhcnQgdG8gbG9zZSBpdHMgb3JpZ2luYWwgaGVpZ2h0LCBzbyBza2lwXG4gICAgLy8gcmVzaXppbmcgaW4gc3VjaCBjYXNlLlxuICAgIGlmICh3aWR0aCA9PT0gMCAmJiBoZWlnaHQgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShjb250YWluZXIpO1xuICBsaXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCwgcmVzaXplKTtcblxuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VPYnNlcnZlcihjaGFydCwgdHlwZSwgb2JzZXJ2ZXIpIHtcbiAgaWYgKG9ic2VydmVyKSB7XG4gICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9XG4gIGlmICh0eXBlID09PSAncmVzaXplJykge1xuICAgIHVubGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByb3h5QW5kTGlzdGVuKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IHByb3h5ID0gdGhyb3R0bGVkKChldmVudCkgPT4ge1xuICAgIC8vIFRoaXMgY2FzZSBjYW4gb2NjdXIgaWYgdGhlIGNoYXJ0IGlzIGRlc3Ryb3llZCB3aGlsZSB3YWl0aW5nXG4gICAgLy8gZm9yIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gdG8gb2NjdXIuIFdlIHByZXZlbnQgY3Jhc2hlcyBieSBjaGVja2luZ1xuICAgIC8vIGZvciBhIGRlc3Ryb3llZCBjaGFydFxuICAgIGlmIChjaGFydC5jdHggIT09IG51bGwpIHtcbiAgICAgIGxpc3RlbmVyKGZyb21OYXRpdmVFdmVudChldmVudCwgY2hhcnQpKTtcbiAgICB9XG4gIH0sIGNoYXJ0KTtcblxuICBhZGRMaXN0ZW5lcihjYW52YXMsIHR5cGUsIHByb3h5KTtcblxuICByZXR1cm4gcHJveHk7XG59XG5cbi8qKlxuICogUGxhdGZvcm0gY2xhc3MgZm9yIGNoYXJ0cyB0aGF0IGNhbiBhY2Nlc3MgdGhlIERPTSBhbmQgZ2xvYmFsIHdpbmRvdy9kb2N1bWVudCBwcm9wZXJ0aWVzXG4gKiBAZXh0ZW5kcyBCYXNlUGxhdGZvcm1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG9tUGxhdGZvcm0gZXh0ZW5kcyBCYXNlUGxhdGZvcm0ge1xuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IFthc3BlY3RSYXRpb11cblx0ICogQHJldHVybiB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfG51bGx9XG5cdCAqL1xuICBhY3F1aXJlQ29udGV4dChjYW52YXMsIGFzcGVjdFJhdGlvKSB7XG4gICAgLy8gVG8gcHJldmVudCBjYW52YXMgZmluZ2VycHJpbnRpbmcsIHNvbWUgYWRkLW9ucyB1bmRlZmluZSB0aGUgZ2V0Q29udGV4dFxuICAgIC8vIG1ldGhvZCwgZm9yIGV4YW1wbGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ra2Fwc25lci9DYW52YXNCbG9ja2VyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI4MDdcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzICYmIGNhbnZhcy5nZXRDb250ZXh0ICYmIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgLy8gYGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEYCBmYWlscyB3aGVuIHRoZSBjYW52YXMgaXNcbiAgICAvLyBpbnNpZGUgYW4gaWZyYW1lIG9yIHdoZW4gcnVubmluZyBpbiBhIHByb3RlY3RlZCBlbnZpcm9ubWVudC4gV2UgY291bGQgZ3Vlc3MgdGhlXG4gICAgLy8gdHlwZXMgZnJvbSB0aGVpciB0b1N0cmluZygpIHZhbHVlIGJ1dCBsZXQncyBrZWVwIHRoaW5ncyBmbGV4aWJsZSBhbmQgYXNzdW1lIGl0J3NcbiAgICAvLyBhIHN1ZmZpY2llbnQgY29uZGl0aW9uIGlmIHRoZSBjYW52YXMgaGFzIGEgY29udGV4dDJEIHdoaWNoIGhhcyBjYW52YXMgYXMgYGNhbnZhc2AuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzM4ODdcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDEwMlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80MTUyXG4gICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5jYW52YXMgPT09IGNhbnZhcykge1xuICAgICAgLy8gTG9hZCBwbGF0Zm9ybSByZXNvdXJjZXMgb24gZmlyc3QgY2hhcnQgY3JlYXRpb24sIHRvIG1ha2UgaXQgcG9zc2libGUgdG9cbiAgICAgIC8vIGltcG9ydCB0aGUgbGlicmFyeSBiZWZvcmUgc2V0dGluZyBwbGF0Zm9ybSBvcHRpb25zLlxuICAgICAgaW5pdENhbnZhcyhjYW52YXMsIGFzcGVjdFJhdGlvKTtcbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0XG5cdCAqL1xuICByZWxlYXNlQ29udGV4dChjb250ZXh0KSB7XG4gICAgY29uc3QgY2FudmFzID0gY29udGV4dC5jYW52YXM7XG4gICAgaWYgKCFjYW52YXNbRVhQQU5ET19LRVldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgaW5pdGlhbCA9IGNhbnZhc1tFWFBBTkRPX0tFWV0uaW5pdGlhbDtcbiAgICBbJ2hlaWdodCcsICd3aWR0aCddLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gaW5pdGlhbFtwcm9wXTtcbiAgICAgIGlmIChpc051bGxPclVuZGVmKHZhbHVlKSkge1xuICAgICAgICBjYW52YXMucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZShwcm9wLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBzdHlsZSA9IGluaXRpYWwuc3R5bGUgfHwge307XG4gICAgT2JqZWN0LmtleXMoc3R5bGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY2FudmFzLnN0eWxlW2tleV0gPSBzdHlsZVtrZXldO1xuICAgIH0pO1xuXG4gICAgLy8gVGhlIGNhbnZhcyByZW5kZXIgc2l6ZSBtaWdodCBoYXZlIGJlZW4gY2hhbmdlZCAoYW5kIHRodXMgdGhlIHN0YXRlIHN0YWNrIGRpc2NhcmRlZCksXG4gICAgLy8gd2UgY2FuJ3QgdXNlIHNhdmUoKSBhbmQgcmVzdG9yZSgpIHRvIHJlc3RvcmUgdGhlIGluaXRpYWwgc3RhdGUuIFNvIG1ha2Ugc3VyZSB0aGF0IGF0XG4gICAgLy8gbGVhc3QgdGhlIGNhbnZhcyBjb250ZXh0IGlzIHJlc2V0IHRvIHRoZSBkZWZhdWx0IHN0YXRlIGJ5IHNldHRpbmcgdGhlIGNhbnZhcyB3aWR0aC5cbiAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAxMS9XRC1odG1sNS0yMDExMDUyNS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWFzc2lnblxuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy53aWR0aDtcblxuICAgIGRlbGV0ZSBjYW52YXNbRVhQQU5ET19LRVldO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG5cdCAqXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyXG5cdCAqL1xuICBhZGRFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICAgIC8vIENhbiBoYXZlIG9ubHkgb25lIGxpc3RlbmVyIHBlciB0eXBlLCBzbyBtYWtlIHN1cmUgcHJldmlvdXMgaXMgcmVtb3ZlZFxuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSk7XG5cbiAgICBjb25zdCBwcm94aWVzID0gY2hhcnQuJHByb3hpZXMgfHwgKGNoYXJ0LiRwcm94aWVzID0ge30pO1xuICAgIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgICAgYXR0YWNoOiBjcmVhdGVBdHRhY2hPYnNlcnZlcixcbiAgICAgIGRldGFjaDogY3JlYXRlRGV0YWNoT2JzZXJ2ZXIsXG4gICAgICByZXNpemU6IGNyZWF0ZVJlc2l6ZU9ic2VydmVyXG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbdHlwZV0gfHwgY3JlYXRlUHJveHlBbmRMaXN0ZW47XG4gICAgcHJveGllc1t0eXBlXSA9IGhhbmRsZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG5cdCAqL1xuICByZW1vdmVFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlKSB7XG4gICAgY29uc3QgcHJveGllcyA9IGNoYXJ0LiRwcm94aWVzIHx8IChjaGFydC4kcHJveGllcyA9IHt9KTtcbiAgICBjb25zdCBwcm94eSA9IHByb3hpZXNbdHlwZV07XG5cbiAgICBpZiAoIXByb3h5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgICBhdHRhY2g6IHJlbGVhc2VPYnNlcnZlcixcbiAgICAgIGRldGFjaDogcmVsZWFzZU9ic2VydmVyLFxuICAgICAgcmVzaXplOiByZWxlYXNlT2JzZXJ2ZXJcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyc1t0eXBlXSB8fCByZW1vdmVMaXN0ZW5lcjtcbiAgICBoYW5kbGVyKGNoYXJ0LCB0eXBlLCBwcm94eSk7XG4gICAgcHJveGllc1t0eXBlXSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoXSAtIGNvbnRlbnQgd2lkdGggb2YgcGFyZW50IGVsZW1lbnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdIC0gY29udGVudCBoZWlnaHQgb2YgcGFyZW50IGVsZW1lbnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IFthc3BlY3RSYXRpb10gLSBhc3BlY3QgcmF0aW8gdG8gbWFpbnRhaW5cblx0ICovXG4gIGdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pIHtcbiAgICByZXR1cm4gZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG5cdCAqL1xuICBpc0F0dGFjaGVkKGNhbnZhcykge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGNhbnZhcyAmJiBfZ2V0UGFyZW50Tm9kZShjYW52YXMpO1xuICAgIHJldHVybiAhIShjb250YWluZXIgJiYgY29udGFpbmVyLmlzQ29ubmVjdGVkKTtcbiAgfVxufVxuIiwgImltcG9ydCB7X2lzRG9tU3VwcG9ydGVkfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCBCYXNlUGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybS5iYXNlLmpzJztcbmltcG9ydCBCYXNpY1BsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0uYmFzaWMuanMnO1xuaW1wb3J0IERvbVBsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0uZG9tLmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIF9kZXRlY3RQbGF0Zm9ybShjYW52YXMpIHtcbiAgaWYgKCFfaXNEb21TdXBwb3J0ZWQoKSB8fCAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSkge1xuICAgIHJldHVybiBCYXNpY1BsYXRmb3JtO1xuICB9XG4gIHJldHVybiBEb21QbGF0Zm9ybTtcbn1cblxuZXhwb3J0IHtCYXNlUGxhdGZvcm0sIEJhc2ljUGxhdGZvcm0sIERvbVBsYXRmb3JtfTtcbiIsICJpbXBvcnQgdHlwZSB7QW55T2JqZWN0fSBmcm9tICcuLi90eXBlcy9iYXNpYy5qcyc7XG5pbXBvcnQgdHlwZSB7UG9pbnR9IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5pbXBvcnQgdHlwZSB7QW5pbWF0aW9ufSBmcm9tICcuLi90eXBlcy9hbmltYXRpb24uanMnO1xuaW1wb3J0IHtpc051bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbGVtZW50PFQgPSBBbnlPYmplY3QsIE8gPSBBbnlPYmplY3Q+IHtcblxuICBzdGF0aWMgZGVmYXVsdHMgPSB7fTtcbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB1bmRlZmluZWQ7XG5cbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG4gIGFjdGl2ZSA9IGZhbHNlO1xuICBvcHRpb25zOiBPO1xuICAkYW5pbWF0aW9uczogUmVjb3JkPGtleW9mIFQsIEFuaW1hdGlvbj47XG5cbiAgdG9vbHRpcFBvc2l0aW9uKHVzZUZpbmFsUG9zaXRpb246IGJvb2xlYW4pOiBQb2ludCB7XG4gICAgY29uc3Qge3gsIHl9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICByZXR1cm4ge3gsIHl9IGFzIFBvaW50O1xuICB9XG5cbiAgaGFzVmFsdWUoKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyKHRoaXMueCkgJiYgaXNOdW1iZXIodGhpcy55KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IG9yIGZpbmFsIHZhbHVlIG9mIGVhY2ggcHJvcC4gQ2FuIHJldHVybiBleHRyYSBwcm9wZXJ0aWVzICh3aG9sZSBvYmplY3QpLlxuICAgKiBAcGFyYW0gcHJvcHMgLSBwcm9wZXJ0aWVzIHRvIGdldFxuICAgKiBAcGFyYW0gW2ZpbmFsXSAtIGdldCB0aGUgZmluYWwgdmFsdWUgKGFuaW1hdGlvbiB0YXJnZXQpXG4gICAqL1xuICBnZXRQcm9wczxQIGV4dGVuZHMgKGtleW9mIFQpW10+KHByb3BzOiBQLCBmaW5hbD86IGJvb2xlYW4pOiBQaWNrPFQsIFBbbnVtYmVyXT47XG4gIGdldFByb3BzPFAgZXh0ZW5kcyBzdHJpbmc+KHByb3BzOiBQW10sIGZpbmFsPzogYm9vbGVhbik6IFBhcnRpYWw8UmVjb3JkPFAsIHVua25vd24+PjtcbiAgZ2V0UHJvcHMocHJvcHM6IHN0cmluZ1tdLCBmaW5hbD86IGJvb2xlYW4pOiBQYXJ0aWFsPFJlY29yZDxzdHJpbmcsIHVua25vd24+PiB7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLiRhbmltYXRpb25zO1xuICAgIGlmICghZmluYWwgfHwgIWFuaW1zKSB7XG4gICAgICAvLyBsZXQncyBub3QgY3JlYXRlIGFuIG9iamVjdCwgaWYgbm90IG5lZWRlZFxuICAgICAgcmV0dXJuIHRoaXMgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgfVxuICAgIGNvbnN0IHJldDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fTtcbiAgICBwcm9wcy5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICByZXRbcHJvcF0gPSBhbmltc1twcm9wXSAmJiBhbmltc1twcm9wXS5hY3RpdmUoKSA/IGFuaW1zW3Byb3BdLl90byA6IHRoaXNbcHJvcCBhcyBzdHJpbmddO1xuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbn1cbiIsICJpbXBvcnQge2lzTnVsbE9yVW5kZWYsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge19mYWN0b3JpemV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYge3t2YWx1ZTpudW1iZXIgfCBzdHJpbmcsIGxhYmVsPzpzdHJpbmcsIG1ham9yPzpib29sZWFuLCAkY29udGV4dD86YW55fX0gVGlja1xuICovXG5cbi8qKlxuICogUmV0dXJucyBhIHN1YnNldCBvZiB0aWNrcyB0byBiZSBwbG90dGVkIHRvIGF2b2lkIG92ZXJsYXBwaW5nIGxhYmVscy5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2NvcmUuc2NhbGUuanMnKS5kZWZhdWx0fSBzY2FsZVxuICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG4gKiBAcmV0dXJuIHtUaWNrW119XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXV0b1NraXAoc2NhbGUsIHRpY2tzKSB7XG4gIGNvbnN0IHRpY2tPcHRzID0gc2NhbGUub3B0aW9ucy50aWNrcztcbiAgY29uc3QgZGV0ZXJtaW5lZE1heFRpY2tzID0gZGV0ZXJtaW5lTWF4VGlja3Moc2NhbGUpO1xuICBjb25zdCB0aWNrc0xpbWl0ID0gTWF0aC5taW4odGlja09wdHMubWF4VGlja3NMaW1pdCB8fCBkZXRlcm1pbmVkTWF4VGlja3MsIGRldGVybWluZWRNYXhUaWNrcyk7XG4gIGNvbnN0IG1ham9ySW5kaWNlcyA9IHRpY2tPcHRzLm1ham9yLmVuYWJsZWQgPyBnZXRNYWpvckluZGljZXModGlja3MpIDogW107XG4gIGNvbnN0IG51bU1ham9ySW5kaWNlcyA9IG1ham9ySW5kaWNlcy5sZW5ndGg7XG4gIGNvbnN0IGZpcnN0ID0gbWFqb3JJbmRpY2VzWzBdO1xuICBjb25zdCBsYXN0ID0gbWFqb3JJbmRpY2VzW251bU1ham9ySW5kaWNlcyAtIDFdO1xuICBjb25zdCBuZXdUaWNrcyA9IFtdO1xuXG4gIC8vIElmIHRoZXJlIGFyZSB0b28gbWFueSBtYWpvciB0aWNrcyB0byBkaXNwbGF5IHRoZW0gYWxsXG4gIGlmIChudW1NYWpvckluZGljZXMgPiB0aWNrc0xpbWl0KSB7XG4gICAgc2tpcE1ham9ycyh0aWNrcywgbmV3VGlja3MsIG1ham9ySW5kaWNlcywgbnVtTWFqb3JJbmRpY2VzIC8gdGlja3NMaW1pdCk7XG4gICAgcmV0dXJuIG5ld1RpY2tzO1xuICB9XG5cbiAgY29uc3Qgc3BhY2luZyA9IGNhbGN1bGF0ZVNwYWNpbmcobWFqb3JJbmRpY2VzLCB0aWNrcywgdGlja3NMaW1pdCk7XG5cbiAgaWYgKG51bU1ham9ySW5kaWNlcyA+IDApIHtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBjb25zdCBhdmdNYWpvclNwYWNpbmcgPSBudW1NYWpvckluZGljZXMgPiAxID8gTWF0aC5yb3VuZCgobGFzdCAtIGZpcnN0KSAvIChudW1NYWpvckluZGljZXMgLSAxKSkgOiBudWxsO1xuICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBpc051bGxPclVuZGVmKGF2Z01ham9yU3BhY2luZykgPyAwIDogZmlyc3QgLSBhdmdNYWpvclNwYWNpbmcsIGZpcnN0KTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbnVtTWFqb3JJbmRpY2VzIC0gMTsgaSA8IGlsZW47IGkrKykge1xuICAgICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIG1ham9ySW5kaWNlc1tpXSwgbWFqb3JJbmRpY2VzW2kgKyAxXSk7XG4gICAgfVxuICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBsYXN0LCBpc051bGxPclVuZGVmKGF2Z01ham9yU3BhY2luZykgPyB0aWNrcy5sZW5ndGggOiBsYXN0ICsgYXZnTWFqb3JTcGFjaW5nKTtcbiAgICByZXR1cm4gbmV3VGlja3M7XG4gIH1cbiAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcpO1xuICByZXR1cm4gbmV3VGlja3M7XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZU1heFRpY2tzKHNjYWxlKSB7XG4gIGNvbnN0IG9mZnNldCA9IHNjYWxlLm9wdGlvbnMub2Zmc2V0O1xuICBjb25zdCB0aWNrTGVuZ3RoID0gc2NhbGUuX3RpY2tTaXplKCk7XG4gIGNvbnN0IG1heFNjYWxlID0gc2NhbGUuX2xlbmd0aCAvIHRpY2tMZW5ndGggKyAob2Zmc2V0ID8gMCA6IDEpO1xuICBjb25zdCBtYXhDaGFydCA9IHNjYWxlLl9tYXhMZW5ndGggLyB0aWNrTGVuZ3RoO1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLm1pbihtYXhTY2FsZSwgbWF4Q2hhcnQpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcltdfSBtYWpvckluZGljZXNcbiAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuICogQHBhcmFtIHtudW1iZXJ9IHRpY2tzTGltaXRcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlU3BhY2luZyhtYWpvckluZGljZXMsIHRpY2tzLCB0aWNrc0xpbWl0KSB7XG4gIGNvbnN0IGV2ZW5NYWpvclNwYWNpbmcgPSBnZXRFdmVuU3BhY2luZyhtYWpvckluZGljZXMpO1xuICBjb25zdCBzcGFjaW5nID0gdGlja3MubGVuZ3RoIC8gdGlja3NMaW1pdDtcblxuICAvLyBJZiB0aGUgbWFqb3IgdGlja3MgYXJlIGV2ZW5seSBzcGFjZWQgYXBhcnQsIHBsYWNlIHRoZSBtaW5vciB0aWNrc1xuICAvLyBzbyB0aGF0IHRoZXkgZGl2aWRlIHRoZSBtYWpvciB0aWNrcyBpbnRvIGV2ZW4gY2h1bmtzXG4gIGlmICghZXZlbk1ham9yU3BhY2luZykge1xuICAgIHJldHVybiBNYXRoLm1heChzcGFjaW5nLCAxKTtcbiAgfVxuXG4gIGNvbnN0IGZhY3RvcnMgPSBfZmFjdG9yaXplKGV2ZW5NYWpvclNwYWNpbmcpO1xuICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IGZhY3RvcnMubGVuZ3RoIC0gMTsgaSA8IGlsZW47IGkrKykge1xuICAgIGNvbnN0IGZhY3RvciA9IGZhY3RvcnNbaV07XG4gICAgaWYgKGZhY3RvciA+IHNwYWNpbmcpIHtcbiAgICAgIHJldHVybiBmYWN0b3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBNYXRoLm1heChzcGFjaW5nLCAxKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpY2tbXX0gdGlja3NcbiAqL1xuZnVuY3Rpb24gZ2V0TWFqb3JJbmRpY2VzKHRpY2tzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgaSwgaWxlbjtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgIGlmICh0aWNrc1tpXS5tYWpvcikge1xuICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG4gKiBAcGFyYW0ge1RpY2tbXX0gbmV3VGlja3NcbiAqIEBwYXJhbSB7bnVtYmVyW119IG1ham9ySW5kaWNlc1xuICogQHBhcmFtIHtudW1iZXJ9IHNwYWNpbmdcbiAqL1xuZnVuY3Rpb24gc2tpcE1ham9ycyh0aWNrcywgbmV3VGlja3MsIG1ham9ySW5kaWNlcywgc3BhY2luZykge1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgbmV4dCA9IG1ham9ySW5kaWNlc1swXTtcbiAgbGV0IGk7XG5cbiAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nKTtcbiAgZm9yIChpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGkgPT09IG5leHQpIHtcbiAgICAgIG5ld1RpY2tzLnB1c2godGlja3NbaV0pO1xuICAgICAgY291bnQrKztcbiAgICAgIG5leHQgPSBtYWpvckluZGljZXNbY291bnQgKiBzcGFjaW5nXTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpY2tbXX0gdGlja3NcbiAqIEBwYXJhbSB7VGlja1tdfSBuZXdUaWNrc1xuICogQHBhcmFtIHtudW1iZXJ9IHNwYWNpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWFqb3JTdGFydF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWFqb3JFbmRdXG4gKi9cbmZ1bmN0aW9uIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBtYWpvclN0YXJ0LCBtYWpvckVuZCkge1xuICBjb25zdCBzdGFydCA9IHZhbHVlT3JEZWZhdWx0KG1ham9yU3RhcnQsIDApO1xuICBjb25zdCBlbmQgPSBNYXRoLm1pbih2YWx1ZU9yRGVmYXVsdChtYWpvckVuZCwgdGlja3MubGVuZ3RoKSwgdGlja3MubGVuZ3RoKTtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IGxlbmd0aCwgaSwgbmV4dDtcblxuICBzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcpO1xuICBpZiAobWFqb3JFbmQpIHtcbiAgICBsZW5ndGggPSBtYWpvckVuZCAtIG1ham9yU3RhcnQ7XG4gICAgc3BhY2luZyA9IGxlbmd0aCAvIE1hdGguZmxvb3IobGVuZ3RoIC8gc3BhY2luZyk7XG4gIH1cblxuICBuZXh0ID0gc3RhcnQ7XG5cbiAgd2hpbGUgKG5leHQgPCAwKSB7XG4gICAgY291bnQrKztcbiAgICBuZXh0ID0gTWF0aC5yb3VuZChzdGFydCArIGNvdW50ICogc3BhY2luZyk7XG4gIH1cblxuICBmb3IgKGkgPSBNYXRoLm1heChzdGFydCwgMCk7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChpID09PSBuZXh0KSB7XG4gICAgICBuZXdUaWNrcy5wdXNoKHRpY2tzW2ldKTtcbiAgICAgIGNvdW50Kys7XG4gICAgICBuZXh0ID0gTWF0aC5yb3VuZChzdGFydCArIGNvdW50ICogc3BhY2luZyk7XG4gICAgfVxuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcltdfSBhcnJcbiAqL1xuZnVuY3Rpb24gZ2V0RXZlblNwYWNpbmcoYXJyKSB7XG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gIGxldCBpLCBkaWZmO1xuXG4gIGlmIChsZW4gPCAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChkaWZmID0gYXJyWzBdLCBpID0gMTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFycltpXSAtIGFycltpIC0gMV0gIT09IGRpZmYpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpZmY7XG59XG4iLCAiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IHtfYWxpZ25QaXhlbCwgX21lYXN1cmVUZXh0LCByZW5kZXJUZXh0LCBjbGlwQXJlYSwgdW5jbGlwQXJlYX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQge2NhbGxiYWNrIGFzIGNhbGwsIGVhY2gsIGZpbml0ZU9yRGVmYXVsdCwgaXNBcnJheSwgaXNGaW5pdGUsIGlzTnVsbE9yVW5kZWYsIGlzT2JqZWN0LCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b0RlZ3JlZXMsIHRvUmFkaWFucywgX2ludDE2UmFuZ2UsIF9saW1pdFZhbHVlLCBIQUxGX1BJfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19hbGlnblN0YXJ0RW5kLCBfdG9MZWZ0UmlnaHRDZW50ZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuaW1wb3J0IHtjcmVhdGVDb250ZXh0LCB0b0ZvbnQsIHRvUGFkZGluZywgX2FkZEdyYWNlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5pbXBvcnQge2F1dG9Ta2lwfSBmcm9tICcuL2NvcmUuc2NhbGUuYXV0b3NraXAuanMnO1xuXG5jb25zdCByZXZlcnNlQWxpZ24gPSAoYWxpZ24pID0+IGFsaWduID09PSAnbGVmdCcgPyAncmlnaHQnIDogYWxpZ24gPT09ICdyaWdodCcgPyAnbGVmdCcgOiBhbGlnbjtcbmNvbnN0IG9mZnNldEZyb21FZGdlID0gKHNjYWxlLCBlZGdlLCBvZmZzZXQpID0+IGVkZ2UgPT09ICd0b3AnIHx8IGVkZ2UgPT09ICdsZWZ0JyA/IHNjYWxlW2VkZ2VdICsgb2Zmc2V0IDogc2NhbGVbZWRnZV0gLSBvZmZzZXQ7XG5jb25zdCBnZXRUaWNrc0xpbWl0ID0gKHRpY2tzTGVuZ3RoLCBtYXhUaWNrc0xpbWl0KSA9PiBNYXRoLm1pbihtYXhUaWNrc0xpbWl0IHx8IHRpY2tzTGVuZ3RoLCB0aWNrc0xlbmd0aCk7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQ2hhcnQgfSBDaGFydFxuICogQHR5cGVkZWYge3t2YWx1ZTpudW1iZXIgfCBzdHJpbmcsIGxhYmVsPzpzdHJpbmcsIG1ham9yPzpib29sZWFuLCAkY29udGV4dD86YW55fX0gVGlja1xuICovXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBhcnJheSBjb250YWluaW5nIG51bUl0ZW1zIGZyb20gYXJyXG4gKiBAcGFyYW0ge2FueVtdfSBhcnJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1JdGVtc1xuICovXG5mdW5jdGlvbiBzYW1wbGUoYXJyLCBudW1JdGVtcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgaW5jcmVtZW50ID0gYXJyLmxlbmd0aCAvIG51bUl0ZW1zO1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBsZW47IGkgKz0gaW5jcmVtZW50KSB7XG4gICAgcmVzdWx0LnB1c2goYXJyW01hdGguZmxvb3IoaSldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb2Zmc2V0R3JpZExpbmVzXG4gKi9cbmZ1bmN0aW9uIGdldFBpeGVsRm9yR3JpZExpbmUoc2NhbGUsIGluZGV4LCBvZmZzZXRHcmlkTGluZXMpIHtcbiAgY29uc3QgbGVuZ3RoID0gc2NhbGUudGlja3MubGVuZ3RoO1xuICBjb25zdCB2YWxpZEluZGV4ID0gTWF0aC5taW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICBjb25zdCBzdGFydCA9IHNjYWxlLl9zdGFydFBpeGVsO1xuICBjb25zdCBlbmQgPSBzY2FsZS5fZW5kUGl4ZWw7XG4gIGNvbnN0IGVwc2lsb24gPSAxZS02OyAvLyAxZS02IGlzIG1hcmdpbiBpbiBwaXhlbHMgZm9yIGFjY3VtdWxhdGVkIGVycm9yLlxuICBsZXQgbGluZVZhbHVlID0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKHZhbGlkSW5kZXgpO1xuICBsZXQgb2Zmc2V0O1xuXG4gIGlmIChvZmZzZXRHcmlkTGluZXMpIHtcbiAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICBvZmZzZXQgPSBNYXRoLm1heChsaW5lVmFsdWUgLSBzdGFydCwgZW5kIC0gbGluZVZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICBvZmZzZXQgPSAoc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKDEpIC0gbGluZVZhbHVlKSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCA9IChsaW5lVmFsdWUgLSBzY2FsZS5nZXRQaXhlbEZvclRpY2sodmFsaWRJbmRleCAtIDEpKSAvIDI7XG4gICAgfVxuICAgIGxpbmVWYWx1ZSArPSB2YWxpZEluZGV4IDwgaW5kZXggPyBvZmZzZXQgOiAtb2Zmc2V0O1xuXG4gICAgLy8gUmV0dXJuIHVuZGVmaW5lZCBpZiB0aGUgcGl4ZWwgaXMgb3V0IG9mIHRoZSByYW5nZVxuICAgIGlmIChsaW5lVmFsdWUgPCBzdGFydCAtIGVwc2lsb24gfHwgbGluZVZhbHVlID4gZW5kICsgZXBzaWxvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGluZVZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBjYWNoZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gZ2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpIHtcbiAgZWFjaChjYWNoZXMsIChjYWNoZSkgPT4ge1xuICAgIGNvbnN0IGdjID0gY2FjaGUuZ2M7XG4gICAgY29uc3QgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuICAgIGxldCBpO1xuICAgIGlmIChnY0xlbiA+IGxlbmd0aCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGdjTGVuOyArK2kpIHtcbiAgICAgICAgZGVsZXRlIGNhY2hlLmRhdGFbZ2NbaV1dO1xuICAgICAgfVxuICAgICAgZ2Muc3BsaWNlKDAsIGdjTGVuKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuZHJhd1RpY2tzID8gb3B0aW9ucy50aWNrTGVuZ3RoIDogMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBnZXRUaXRsZUhlaWdodChvcHRpb25zLCBmYWxsYmFjaykge1xuICBpZiAoIW9wdGlvbnMuZGlzcGxheSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgY29uc3QgZm9udCA9IHRvRm9udChvcHRpb25zLmZvbnQsIGZhbGxiYWNrKTtcbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICBjb25zdCBsaW5lcyA9IGlzQXJyYXkob3B0aW9ucy50ZXh0KSA/IG9wdGlvbnMudGV4dC5sZW5ndGggOiAxO1xuXG4gIHJldHVybiAobGluZXMgKiBmb250LmxpbmVIZWlnaHQpICsgcGFkZGluZy5oZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNjYWxlQ29udGV4dChwYXJlbnQsIHNjYWxlKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHNjYWxlLFxuICAgIHR5cGU6ICdzY2FsZSdcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRpY2tDb250ZXh0KHBhcmVudCwgaW5kZXgsIHRpY2spIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgdGljayxcbiAgICBpbmRleCxcbiAgICB0eXBlOiAndGljaydcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRpdGxlQWxpZ24oYWxpZ24sIHBvc2l0aW9uLCByZXZlcnNlKSB7XG4gIC8qKiBAdHlwZSB7Q2FudmFzVGV4dEFsaWdufSAqL1xuICBsZXQgcmV0ID0gX3RvTGVmdFJpZ2h0Q2VudGVyKGFsaWduKTtcbiAgaWYgKChyZXZlcnNlICYmIHBvc2l0aW9uICE9PSAncmlnaHQnKSB8fCAoIXJldmVyc2UgJiYgcG9zaXRpb24gPT09ICdyaWdodCcpKSB7XG4gICAgcmV0ID0gcmV2ZXJzZUFsaWduKHJldCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gdGl0bGVBcmdzKHNjYWxlLCBvZmZzZXQsIHBvc2l0aW9uLCBhbGlnbikge1xuICBjb25zdCB7dG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0LCBjaGFydH0gPSBzY2FsZTtcbiAgY29uc3Qge2NoYXJ0QXJlYSwgc2NhbGVzfSA9IGNoYXJ0O1xuICBsZXQgcm90YXRpb24gPSAwO1xuICBsZXQgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xuICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuXG4gIGlmIChzY2FsZS5pc0hvcml6b250YWwoKSkge1xuICAgIHRpdGxlWCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBsZWZ0LCByaWdodCk7XG5cbiAgICBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgdGl0bGVZID0gc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSArIGhlaWdodCAtIG9mZnNldDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgdGl0bGVZID0gKGNoYXJ0QXJlYS5ib3R0b20gKyBjaGFydEFyZWEudG9wKSAvIDIgKyBoZWlnaHQgLSBvZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlWSA9IG9mZnNldEZyb21FZGdlKHNjYWxlLCBwb3NpdGlvbiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgbWF4V2lkdGggPSByaWdodCAtIGxlZnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgIHRpdGxlWCA9IHNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgLSB3aWR0aCArIG9mZnNldDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgdGl0bGVYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIgLSB3aWR0aCArIG9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGVYID0gb2Zmc2V0RnJvbUVkZ2Uoc2NhbGUsIHBvc2l0aW9uLCBvZmZzZXQpO1xuICAgIH1cbiAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgYm90dG9tLCB0b3ApO1xuICAgIHJvdGF0aW9uID0gcG9zaXRpb24gPT09ICdsZWZ0JyA/IC1IQUxGX1BJIDogSEFMRl9QSTtcbiAgfVxuICByZXR1cm4ge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2FsZSBleHRlbmRzIEVsZW1lbnQge1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50c1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpcy5pZCA9IGNmZy5pZDtcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICB0aGlzLnR5cGUgPSBjZmcudHlwZTtcbiAgICAvKiogQHR5cGUge2FueX0gKi9cbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICovXG4gICAgdGhpcy5jdHggPSBjZmcuY3R4O1xuICAgIC8qKiBAdHlwZSB7Q2hhcnR9ICovXG4gICAgdGhpcy5jaGFydCA9IGNmZy5jaGFydDtcblxuICAgIC8vIGltcGxlbWVudHMgYm94XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9tYXJnaW5zID0ge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfTtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLm1heFdpZHRoID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMucGFkZGluZ1RvcCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5wYWRkaW5nTGVmdCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnBhZGRpbmdSaWdodCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIHNjYWxlLXNwZWNpZmljIHByb3BlcnRpZXNcbiAgICAvKiogQHR5cGUge3N0cmluZz19ICovXG4gICAgdGhpcy5heGlzID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyPX0gKi9cbiAgICB0aGlzLmxhYmVsUm90YXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5taW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtUaWNrW119ICovXG4gICAgdGhpcy50aWNrcyA9IFtdO1xuICAgIC8qKiBAdHlwZSB7b2JqZWN0W118bnVsbH0gKi9cbiAgICB0aGlzLl9ncmlkTGluZUl0ZW1zID0gbnVsbDtcbiAgICAvKiogQHR5cGUge29iamVjdFtdfG51bGx9ICovXG4gICAgdGhpcy5fbGFiZWxJdGVtcyA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtvYmplY3R8bnVsbH0gKi9cbiAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHRoaXMuX21heExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbG9uZ2VzdFRleHRDYWNoZSA9IHt9O1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX3N0YXJ0UGl4ZWwgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fZW5kUGl4ZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9IGZhbHNlO1xuICAgIHRoaXMuX3VzZXJNYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdXNlck1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3RpY2tzTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9ib3JkZXJWYWx1ZSA9IDA7XG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gZmFsc2U7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge2FueX0gb3B0aW9uc1xuXHQgKiBAc2luY2UgMy4wXG5cdCAqL1xuICBpbml0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuXG4gICAgdGhpcy5heGlzID0gb3B0aW9ucy5heGlzO1xuXG4gICAgLy8gcGFyc2UgbWluL21heCB2YWx1ZSwgc28gd2UgY2FuIHByb3Blcmx5IGRldGVybWluZSBtaW4vbWF4IGZvciBvdGhlciBzY2FsZXNcbiAgICB0aGlzLl91c2VyTWluID0gdGhpcy5wYXJzZShvcHRpb25zLm1pbik7XG4gICAgdGhpcy5fdXNlck1heCA9IHRoaXMucGFyc2Uob3B0aW9ucy5tYXgpO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1pbiA9IHRoaXMucGFyc2Uob3B0aW9ucy5zdWdnZXN0ZWRNaW4pO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1heCA9IHRoaXMucGFyc2Uob3B0aW9ucy5zdWdnZXN0ZWRNYXgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGEgc3VwcG9ydGVkIGlucHV0IHZhbHVlIHRvIGludGVybmFsIHJlcHJlc2VudGF0aW9uLlxuXHQgKiBAcGFyYW0geyp9IHJhd1xuXHQgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4XVxuXHQgKiBAc2luY2UgMy4wXG5cdCAqL1xuICBwYXJzZShyYXcsIGluZGV4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICByZXR1cm4gcmF3O1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXIsIG1pbkRlZmluZWQ6IGJvb2xlYW4sIG1heERlZmluZWQ6IGJvb2xlYW59fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAzLjBcblx0ICovXG4gIGdldFVzZXJCb3VuZHMoKSB7XG4gICAgbGV0IHtfdXNlck1pbiwgX3VzZXJNYXgsIF9zdWdnZXN0ZWRNaW4sIF9zdWdnZXN0ZWRNYXh9ID0gdGhpcztcbiAgICBfdXNlck1pbiA9IGZpbml0ZU9yRGVmYXVsdChfdXNlck1pbiwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICBfdXNlck1heCA9IGZpbml0ZU9yRGVmYXVsdChfdXNlck1heCwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICBfc3VnZ2VzdGVkTWluID0gZmluaXRlT3JEZWZhdWx0KF9zdWdnZXN0ZWRNaW4sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgX3N1Z2dlc3RlZE1heCA9IGZpbml0ZU9yRGVmYXVsdChfc3VnZ2VzdGVkTWF4LCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuICAgIHJldHVybiB7XG4gICAgICBtaW46IGZpbml0ZU9yRGVmYXVsdChfdXNlck1pbiwgX3N1Z2dlc3RlZE1pbiksXG4gICAgICBtYXg6IGZpbml0ZU9yRGVmYXVsdChfdXNlck1heCwgX3N1Z2dlc3RlZE1heCksXG4gICAgICBtaW5EZWZpbmVkOiBpc0Zpbml0ZShfdXNlck1pbiksXG4gICAgICBtYXhEZWZpbmVkOiBpc0Zpbml0ZShfdXNlck1heClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gY2FuU3RhY2tcblx0ICogQHJldHVybiB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDMuMFxuXHQgKi9cbiAgZ2V0TWluTWF4KGNhblN0YWNrKSB7XG4gICAgbGV0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQgcmFuZ2U7XG5cbiAgICBpZiAobWluRGVmaW5lZCAmJiBtYXhEZWZpbmVkKSB7XG4gICAgICByZXR1cm4ge21pbiwgbWF4fTtcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcmFuZ2UgPSBtZXRhc1tpXS5jb250cm9sbGVyLmdldE1pbk1heCh0aGlzLCBjYW5TdGFjayk7XG4gICAgICBpZiAoIW1pbkRlZmluZWQpIHtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCByYW5nZS5taW4pO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXhEZWZpbmVkKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgcmFuZ2UubWF4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgbWluIDw9IG1heCB3aGVuIG9ubHkgbWluIG9yIG1heCBpcyBkZWZpbmVkIGJ5IHVzZXIgYW5kIHRoZSBkYXRhIGlzIG91dHNpZGUgdGhhdCByYW5nZVxuICAgIG1pbiA9IG1heERlZmluZWQgJiYgbWluID4gbWF4ID8gbWF4IDogbWluO1xuICAgIG1heCA9IG1pbkRlZmluZWQgJiYgbWluID4gbWF4ID8gbWluIDogbWF4O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogZmluaXRlT3JEZWZhdWx0KG1pbiwgZmluaXRlT3JEZWZhdWx0KG1heCwgbWluKSksXG4gICAgICBtYXg6IGZpbml0ZU9yRGVmYXVsdChtYXgsIGZpbml0ZU9yRGVmYXVsdChtaW4sIG1heCkpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXQgdGhlIHBhZGRpbmcgbmVlZGVkIGZvciB0aGUgc2NhbGVcblx0ICogQHJldHVybiB7e3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXIsIGJvdHRvbTogbnVtYmVyLCByaWdodDogbnVtYmVyfX0gdGhlIG5lY2Vzc2FyeSBwYWRkaW5nXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBnZXRQYWRkaW5nKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiB0aGlzLnBhZGRpbmdMZWZ0IHx8IDAsXG4gICAgICB0b3A6IHRoaXMucGFkZGluZ1RvcCB8fCAwLFxuICAgICAgcmlnaHQ6IHRoaXMucGFkZGluZ1JpZ2h0IHx8IDAsXG4gICAgICBib3R0b206IHRoaXMucGFkZGluZ0JvdHRvbSB8fCAwXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzY2FsZSB0aWNrIG9iamVjdHNcblx0ICogQHJldHVybiB7VGlja1tdfVxuXHQgKiBAc2luY2UgMi43XG5cdCAqL1xuICBnZXRUaWNrcygpIHtcbiAgICByZXR1cm4gdGhpcy50aWNrcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtzdHJpbmdbXX1cblx0ICovXG4gIGdldExhYmVscygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5jaGFydC5kYXRhO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGFiZWxzIHx8ICh0aGlzLmlzSG9yaXpvbnRhbCgpID8gZGF0YS54TGFiZWxzIDogZGF0YS55TGFiZWxzKSB8fCBkYXRhLmxhYmVscyB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoJy4uL3R5cGVzLmpzJykuTGFiZWxJdGVtW119XG4gICAqL1xuICBnZXRMYWJlbEl0ZW1zKGNoYXJ0QXJlYSA9IHRoaXMuY2hhcnQuY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9sYWJlbEl0ZW1zIHx8ICh0aGlzLl9sYWJlbEl0ZW1zID0gdGhpcy5fY29tcHV0ZUxhYmVsSXRlbXMoY2hhcnRBcmVhKSk7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbiAgLy8gV2hlbiBhIG5ldyBsYXlvdXQgaXMgY3JlYXRlZCwgcmVzZXQgdGhlIGRhdGEgbGltaXRzIGNhY2hlXG4gIGJlZm9yZUxheW91dCgpIHtcbiAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIFRoZXNlIG1ldGhvZHMgYXJlIG9yZGVyZWQgYnkgbGlmZWN5Y2xlLiBVdGlsaXRpZXMgdGhlbiBmb2xsb3cuXG4gIC8vIEFueSBmdW5jdGlvbiBkZWZpbmVkIGhlcmUgaXMgaW5oZXJpdGVkIGJ5IGFsbCBzY2FsZSB0eXBlcy5cbiAgLy8gQW55IGZ1bmN0aW9uIGNhbiBiZSBleHRlbmRlZCBieSB0aGUgc2NhbGUgdHlwZVxuXG4gIGJlZm9yZVVwZGF0ZSgpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5iZWZvcmVVcGRhdGUsIFt0aGlzXSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heFdpZHRoIC0gdGhlIG1heCB3aWR0aCBpbiBwaXhlbHNcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heEhlaWdodCAtIHRoZSBtYXggaGVpZ2h0IGluIHBpeGVsc1xuXHQgKiBAcGFyYW0ge3t0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyLCBib3R0b206IG51bWJlciwgcmlnaHQ6IG51bWJlcn19IG1hcmdpbnMgLSB0aGUgc3BhY2UgYmV0d2VlbiB0aGUgZWRnZSBvZiB0aGUgb3RoZXIgc2NhbGVzIGFuZCBlZGdlIG9mIHRoZSBjaGFydFxuXHQgKiAgIFRoaXMgc3BhY2UgY29tZXMgZnJvbSB0d28gc291cmNlczpcblx0ICogICAgIC0gcGFkZGluZyAtIHNwYWNlIHRoYXQncyByZXF1aXJlZCB0byBzaG93IHRoZSBsYWJlbHMgYXQgdGhlIGVkZ2VzIG9mIHRoZSBzY2FsZVxuXHQgKiAgICAgLSB0aGlja25lc3Mgb2Ygc2NhbGVzIG9yIGxlZ2VuZHMgaW4gYW5vdGhlciBvcmllbnRhdGlvblxuXHQgKi9cbiAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcbiAgICBjb25zdCB7YmVnaW5BdFplcm8sIGdyYWNlLCB0aWNrczogdGlja09wdHN9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNhbXBsZVNpemUgPSB0aWNrT3B0cy5zYW1wbGVTaXplO1xuXG4gICAgLy8gVXBkYXRlIExpZmVjeWNsZSAtIFByb2JhYmx5IGRvbid0IHdhbnQgdG8gZXZlciBleHRlbmQgb3Igb3ZlcndyaXRlIHRoaXMgZnVuY3Rpb24gOylcbiAgICB0aGlzLmJlZm9yZVVwZGF0ZSgpO1xuXG4gICAgLy8gQWJzb3JiIHRoZSBtYXN0ZXIgbWVhc3VyZW1lbnRzXG4gICAgdGhpcy5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuICAgIHRoaXMuX21hcmdpbnMgPSBtYXJnaW5zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBib3R0b206IDBcbiAgICB9LCBtYXJnaW5zKTtcblxuICAgIHRoaXMudGlja3MgPSBudWxsO1xuICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsO1xuICAgIHRoaXMuX2dyaWRMaW5lSXRlbXMgPSBudWxsO1xuICAgIHRoaXMuX2xhYmVsSXRlbXMgPSBudWxsO1xuXG4gICAgLy8gRGltZW5zaW9uc1xuICAgIHRoaXMuYmVmb3JlU2V0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuc2V0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuYWZ0ZXJTZXREaW1lbnNpb25zKCk7XG5cbiAgICB0aGlzLl9tYXhMZW5ndGggPSB0aGlzLmlzSG9yaXpvbnRhbCgpXG4gICAgICA/IHRoaXMud2lkdGggKyBtYXJnaW5zLmxlZnQgKyBtYXJnaW5zLnJpZ2h0XG4gICAgICA6IHRoaXMuaGVpZ2h0ICsgbWFyZ2lucy50b3AgKyBtYXJnaW5zLmJvdHRvbTtcblxuICAgIC8vIERhdGEgbWluL21heFxuICAgIGlmICghdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCkge1xuICAgICAgdGhpcy5iZWZvcmVEYXRhTGltaXRzKCk7XG4gICAgICB0aGlzLmRldGVybWluZURhdGFMaW1pdHMoKTtcbiAgICAgIHRoaXMuYWZ0ZXJEYXRhTGltaXRzKCk7XG4gICAgICB0aGlzLl9yYW5nZSA9IF9hZGRHcmFjZSh0aGlzLCBncmFjZSwgYmVnaW5BdFplcm8pO1xuICAgICAgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5iZWZvcmVCdWlsZFRpY2tzKCk7XG5cbiAgICB0aGlzLnRpY2tzID0gdGhpcy5idWlsZFRpY2tzKCkgfHwgW107XG5cbiAgICAvLyBBbGxvdyBtb2RpZmljYXRpb24gb2YgdGlja3MgaW4gY2FsbGJhY2suXG4gICAgdGhpcy5hZnRlckJ1aWxkVGlja3MoKTtcblxuICAgIC8vIENvbXB1dGUgdGljayByb3RhdGlvbiBhbmQgZml0IHVzaW5nIGEgc2FtcGxlZCBzdWJzZXQgb2YgbGFiZWxzXG4gICAgLy8gV2UgZ2VuZXJhbGx5IGRvbid0IG5lZWQgdG8gY29tcHV0ZSB0aGUgc2l6ZSBvZiBldmVyeSBzaW5nbGUgbGFiZWwgZm9yIGRldGVybWluaW5nIHNjYWxlIHNpemVcbiAgICBjb25zdCBzYW1wbGluZ0VuYWJsZWQgPSBzYW1wbGVTaXplIDwgdGhpcy50aWNrcy5sZW5ndGg7XG4gICAgdGhpcy5fY29udmVydFRpY2tzVG9MYWJlbHMoc2FtcGxpbmdFbmFibGVkID8gc2FtcGxlKHRoaXMudGlja3MsIHNhbXBsZVNpemUpIDogdGhpcy50aWNrcyk7XG5cbiAgICAvLyBjb25maWd1cmUgaXMgY2FsbGVkIHR3aWNlLCBvbmNlIGhlcmUsIG9uY2UgZnJvbSBjb3JlLmNvbnRyb2xsZXIudXBkYXRlTGF5b3V0LlxuICAgIC8vIEhlcmUgd2UgaGF2ZW4ndCBiZWVuIHBvc2l0aW9uZWQgeWV0LCBidXQgZGltZW5zaW9ucyBhcmUgY29ycmVjdC5cbiAgICAvLyBWYXJpYWJsZXMgc2V0IGluIGNvbmZpZ3VyZSBhcmUgbmVlZGVkIGZvciBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uLCBhbmRcbiAgICAvLyBpdCdzIG9rIHRoYXQgY29vcmRpbmF0ZXMgYXJlIG5vdCBjb3JyZWN0IHRoZXJlLCBvbmx5IGRpbWVuc2lvbnMgbWF0dGVyLlxuICAgIHRoaXMuY29uZmlndXJlKCk7XG5cbiAgICAvLyBUaWNrIFJvdGF0aW9uXG4gICAgdGhpcy5iZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCk7XG4gICAgdGhpcy5jYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCk7IC8vIFByZWNvbmRpdGlvbnM6IG51bWJlciBvZiB0aWNrcyBhbmQgc2l6ZXMgb2YgbGFyZ2VzdCBsYWJlbHMgbXVzdCBiZSBjYWxjdWxhdGVkIGJlZm9yZWhhbmRcbiAgICB0aGlzLmFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpO1xuXG4gICAgLy8gQXV0by1za2lwXG4gICAgaWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgKHRpY2tPcHRzLmF1dG9Ta2lwIHx8IHRpY2tPcHRzLnNvdXJjZSA9PT0gJ2F1dG8nKSkge1xuICAgICAgdGhpcy50aWNrcyA9IGF1dG9Ta2lwKHRoaXMsIHRoaXMudGlja3MpO1xuICAgICAgdGhpcy5fbGFiZWxTaXplcyA9IG51bGw7XG4gICAgICB0aGlzLmFmdGVyQXV0b1NraXAoKTtcbiAgICB9XG5cbiAgICBpZiAoc2FtcGxpbmdFbmFibGVkKSB7XG4gICAgICAvLyBHZW5lcmF0ZSBsYWJlbHMgdXNpbmcgYWxsIG5vbi1za2lwcGVkIHRpY2tzXG4gICAgICB0aGlzLl9jb252ZXJ0VGlja3NUb0xhYmVscyh0aGlzLnRpY2tzKTtcbiAgICB9XG5cbiAgICB0aGlzLmJlZm9yZUZpdCgpO1xuICAgIHRoaXMuZml0KCk7IC8vIFByZWNvbmRpdGlvbnM6IGxhYmVsIHJvdGF0aW9uIGFuZCBsYWJlbCBzaXplcyBtdXN0IGJlIGNhbGN1bGF0ZWQgYmVmb3JlaGFuZFxuICAgIHRoaXMuYWZ0ZXJGaXQoKTtcblxuICAgIC8vIElNUE9SVEFOVDogYWZ0ZXIgdGhpcyBwb2ludCwgd2UgY29uc2lkZXIgdGhhdCBgdGhpcy50aWNrc2Agd2lsbCBORVZFUiBjaGFuZ2UhXG5cbiAgICB0aGlzLmFmdGVyVXBkYXRlKCk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgY29uZmlndXJlKCkge1xuICAgIGxldCByZXZlcnNlUGl4ZWxzID0gdGhpcy5vcHRpb25zLnJldmVyc2U7XG4gICAgbGV0IHN0YXJ0UGl4ZWwsIGVuZFBpeGVsO1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHN0YXJ0UGl4ZWwgPSB0aGlzLmxlZnQ7XG4gICAgICBlbmRQaXhlbCA9IHRoaXMucmlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0UGl4ZWwgPSB0aGlzLnRvcDtcbiAgICAgIGVuZFBpeGVsID0gdGhpcy5ib3R0b207XG4gICAgICAvLyBieSBkZWZhdWx0IHZlcnRpY2FsIHNjYWxlcyBhcmUgZnJvbSBib3R0b20gdG8gdG9wLCBzbyBwaXhlbHMgYXJlIHJldmVyc2VkXG4gICAgICByZXZlcnNlUGl4ZWxzID0gIXJldmVyc2VQaXhlbHM7XG4gICAgfVxuICAgIHRoaXMuX3N0YXJ0UGl4ZWwgPSBzdGFydFBpeGVsO1xuICAgIHRoaXMuX2VuZFBpeGVsID0gZW5kUGl4ZWw7XG4gICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9IHJldmVyc2VQaXhlbHM7XG4gICAgdGhpcy5fbGVuZ3RoID0gZW5kUGl4ZWwgLSBzdGFydFBpeGVsO1xuICAgIHRoaXMuX2FsaWduVG9QaXhlbHMgPSB0aGlzLm9wdGlvbnMuYWxpZ25Ub1BpeGVscztcbiAgfVxuXG4gIGFmdGVyVXBkYXRlKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmFmdGVyVXBkYXRlLCBbdGhpc10pO1xuICB9XG5cbiAgLy9cblxuICBiZWZvcmVTZXREaW1lbnNpb25zKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmJlZm9yZVNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG4gIH1cbiAgc2V0RGltZW5zaW9ucygpIHtcbiAgICAvLyBTZXQgdGhlIHVuY29uc3RyYWluZWQgZGltZW5zaW9uIGJlZm9yZSBsYWJlbCByb3RhdGlvblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgdGhpcy5sZWZ0ID0gMDtcbiAgICAgIHRoaXMucmlnaHQgPSB0aGlzLndpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuXG4gICAgICAvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cbiAgICAgIHRoaXMudG9wID0gMDtcbiAgICAgIHRoaXMuYm90dG9tID0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgcGFkZGluZ1xuICAgIHRoaXMucGFkZGluZ0xlZnQgPSAwO1xuICAgIHRoaXMucGFkZGluZ1RvcCA9IDA7XG4gICAgdGhpcy5wYWRkaW5nUmlnaHQgPSAwO1xuICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IDA7XG4gIH1cbiAgYWZ0ZXJTZXREaW1lbnNpb25zKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmFmdGVyU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcbiAgfVxuXG4gIF9jYWxsSG9va3MobmFtZSkge1xuICAgIHRoaXMuY2hhcnQubm90aWZ5UGx1Z2lucyhuYW1lLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnNbbmFtZV0sIFt0aGlzXSk7XG4gIH1cblxuICAvLyBEYXRhIGxpbWl0c1xuICBiZWZvcmVEYXRhTGltaXRzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYmVmb3JlRGF0YUxpbWl0cycpO1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7fVxuICBhZnRlckRhdGFMaW1pdHMoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdhZnRlckRhdGFMaW1pdHMnKTtcbiAgfVxuXG4gIC8vXG4gIGJlZm9yZUJ1aWxkVGlja3MoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdiZWZvcmVCdWlsZFRpY2tzJyk7XG4gIH1cbiAgLyoqXG5cdCAqIEByZXR1cm4ge29iamVjdFtdfSB0aGUgdGlja3Ncblx0ICovXG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGFmdGVyQnVpbGRUaWNrcygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2FmdGVyQnVpbGRUaWNrcycpO1xuICB9XG5cbiAgYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbiwgW3RoaXNdKTtcbiAgfVxuICAvKipcblx0ICogQ29udmVydCB0aWNrcyB0byBsYWJlbCBzdHJpbmdzXG5cdCAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuXHQgKi9cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgY29uc3QgdGlja09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgbGV0IGksIGlsZW4sIHRpY2s7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgdGljay5sYWJlbCA9IGNhbGwodGlja09wdHMuY2FsbGJhY2ssIFt0aWNrLnZhbHVlLCBpLCB0aWNrc10sIHRoaXMpO1xuICAgIH1cbiAgfVxuICBhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbigpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5hZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbiwgW3RoaXNdKTtcbiAgfVxuXG4gIC8vXG5cbiAgYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5iZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uLCBbdGhpc10pO1xuICB9XG4gIGNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgbnVtVGlja3MgPSBnZXRUaWNrc0xpbWl0KHRoaXMudGlja3MubGVuZ3RoLCBvcHRpb25zLnRpY2tzLm1heFRpY2tzTGltaXQpO1xuICAgIGNvbnN0IG1pblJvdGF0aW9uID0gdGlja09wdHMubWluUm90YXRpb24gfHwgMDtcbiAgICBjb25zdCBtYXhSb3RhdGlvbiA9IHRpY2tPcHRzLm1heFJvdGF0aW9uO1xuICAgIGxldCBsYWJlbFJvdGF0aW9uID0gbWluUm90YXRpb247XG4gICAgbGV0IHRpY2tXaWR0aCwgbWF4SGVpZ2h0LCBtYXhMYWJlbERpYWdvbmFsO1xuXG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCAhdGlja09wdHMuZGlzcGxheSB8fCBtaW5Sb3RhdGlvbiA+PSBtYXhSb3RhdGlvbiB8fCBudW1UaWNrcyA8PSAxIHx8ICF0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLmxhYmVsUm90YXRpb24gPSBtaW5Sb3RhdGlvbjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IG1heExhYmVsV2lkdGggPSBsYWJlbFNpemVzLndpZGVzdC53aWR0aDtcbiAgICBjb25zdCBtYXhMYWJlbEhlaWdodCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQ7XG5cbiAgICAvLyBFc3RpbWF0ZSB0aGUgd2lkdGggb2YgZWFjaCBncmlkIGJhc2VkIG9uIHRoZSBjYW52YXMgd2lkdGgsIHRoZSBtYXhpbXVtXG4gICAgLy8gbGFiZWwgd2lkdGggYW5kIHRoZSBudW1iZXIgb2YgdGljayBpbnRlcnZhbHNcbiAgICBjb25zdCBtYXhXaWR0aCA9IF9saW1pdFZhbHVlKHRoaXMuY2hhcnQud2lkdGggLSBtYXhMYWJlbFdpZHRoLCAwLCB0aGlzLm1heFdpZHRoKTtcbiAgICB0aWNrV2lkdGggPSBvcHRpb25zLm9mZnNldCA/IHRoaXMubWF4V2lkdGggLyBudW1UaWNrcyA6IG1heFdpZHRoIC8gKG51bVRpY2tzIC0gMSk7XG5cbiAgICAvLyBBbGxvdyAzIHBpeGVscyB4MiBwYWRkaW5nIGVpdGhlciBzaWRlIGZvciBsYWJlbCByZWFkYWJpbGl0eVxuICAgIGlmIChtYXhMYWJlbFdpZHRoICsgNiA+IHRpY2tXaWR0aCkge1xuICAgICAgdGlja1dpZHRoID0gbWF4V2lkdGggLyAobnVtVGlja3MgLSAob3B0aW9ucy5vZmZzZXQgPyAwLjUgOiAxKSk7XG4gICAgICBtYXhIZWlnaHQgPSB0aGlzLm1heEhlaWdodCAtIGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMuZ3JpZClcblx0XHRcdFx0LSB0aWNrT3B0cy5wYWRkaW5nIC0gZ2V0VGl0bGVIZWlnaHQob3B0aW9ucy50aXRsZSwgdGhpcy5jaGFydC5vcHRpb25zLmZvbnQpO1xuICAgICAgbWF4TGFiZWxEaWFnb25hbCA9IE1hdGguc3FydChtYXhMYWJlbFdpZHRoICogbWF4TGFiZWxXaWR0aCArIG1heExhYmVsSGVpZ2h0ICogbWF4TGFiZWxIZWlnaHQpO1xuICAgICAgbGFiZWxSb3RhdGlvbiA9IHRvRGVncmVlcyhNYXRoLm1pbihcbiAgICAgICAgTWF0aC5hc2luKF9saW1pdFZhbHVlKChsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgNikgLyB0aWNrV2lkdGgsIC0xLCAxKSksXG4gICAgICAgIE1hdGguYXNpbihfbGltaXRWYWx1ZShtYXhIZWlnaHQgLyBtYXhMYWJlbERpYWdvbmFsLCAtMSwgMSkpIC0gTWF0aC5hc2luKF9saW1pdFZhbHVlKG1heExhYmVsSGVpZ2h0IC8gbWF4TGFiZWxEaWFnb25hbCwgLTEsIDEpKVxuICAgICAgKSk7XG4gICAgICBsYWJlbFJvdGF0aW9uID0gTWF0aC5tYXgobWluUm90YXRpb24sIE1hdGgubWluKG1heFJvdGF0aW9uLCBsYWJlbFJvdGF0aW9uKSk7XG4gICAgfVxuXG4gICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gbGFiZWxSb3RhdGlvbjtcbiAgfVxuICBhZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uLCBbdGhpc10pO1xuICB9XG4gIGFmdGVyQXV0b1NraXAoKSB7fVxuXG4gIC8vXG5cbiAgYmVmb3JlRml0KCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmJlZm9yZUZpdCwgW3RoaXNdKTtcbiAgfVxuICBmaXQoKSB7XG4gICAgLy8gUmVzZXRcbiAgICBjb25zdCBtaW5TaXplID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuXG4gICAgY29uc3Qge2NoYXJ0LCBvcHRpb25zOiB7dGlja3M6IHRpY2tPcHRzLCB0aXRsZTogdGl0bGVPcHRzLCBncmlkOiBncmlkT3B0c319ID0gdGhpcztcbiAgICBjb25zdCBkaXNwbGF5ID0gdGhpcy5faXNWaXNpYmxlKCk7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcblxuICAgIGlmIChkaXNwbGF5KSB7XG4gICAgICBjb25zdCB0aXRsZUhlaWdodCA9IGdldFRpdGxlSGVpZ2h0KHRpdGxlT3B0cywgY2hhcnQub3B0aW9ucy5mb250KTtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgbWluU2l6ZS53aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICAgIG1pblNpemUuaGVpZ2h0ID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZE9wdHMpICsgdGl0bGVIZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW5TaXplLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0OyAvLyBmaWxsIGFsbCB0aGUgaGVpZ2h0XG4gICAgICAgIG1pblNpemUud2lkdGggPSBnZXRUaWNrTWFya0xlbmd0aChncmlkT3B0cykgKyB0aXRsZUhlaWdodDtcbiAgICAgIH1cblxuICAgICAgLy8gRG9uJ3QgYm90aGVyIGZpdHRpbmcgdGhlIHRpY2tzIGlmIHdlIGFyZSBub3Qgc2hvd2luZyB0aGUgbGFiZWxzXG4gICAgICBpZiAodGlja09wdHMuZGlzcGxheSAmJiB0aGlzLnRpY2tzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCB7Zmlyc3QsIGxhc3QsIHdpZGVzdCwgaGlnaGVzdH0gPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgICAgIGNvbnN0IHRpY2tQYWRkaW5nID0gdGlja09wdHMucGFkZGluZyAqIDI7XG4gICAgICAgIGNvbnN0IGFuZ2xlUmFkaWFucyA9IHRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuICAgICAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xuICAgICAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZVJhZGlhbnMpO1xuXG4gICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgLy8gQSBob3Jpem9udGFsIGF4aXMgaXMgbW9yZSBjb25zdHJhaW5lZCBieSB0aGUgaGVpZ2h0LlxuICAgICAgICAgIGNvbnN0IGxhYmVsSGVpZ2h0ID0gdGlja09wdHMubWlycm9yID8gMCA6IHNpbiAqIHdpZGVzdC53aWR0aCArIGNvcyAqIGhpZ2hlc3QuaGVpZ2h0O1xuICAgICAgICAgIG1pblNpemUuaGVpZ2h0ID0gTWF0aC5taW4odGhpcy5tYXhIZWlnaHQsIG1pblNpemUuaGVpZ2h0ICsgbGFiZWxIZWlnaHQgKyB0aWNrUGFkZGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEEgdmVydGljYWwgYXhpcyBpcyBtb3JlIGNvbnN0cmFpbmVkIGJ5IHRoZSB3aWR0aC4gTGFiZWxzIGFyZSB0aGVcbiAgICAgICAgLy8gZG9taW5hbnQgZmFjdG9yIGhlcmUsIHNvIGdldCB0aGF0IGxlbmd0aCBmaXJzdCBhbmQgYWNjb3VudCBmb3IgcGFkZGluZ1xuICAgICAgICAgIGNvbnN0IGxhYmVsV2lkdGggPSB0aWNrT3B0cy5taXJyb3IgPyAwIDogY29zICogd2lkZXN0LndpZHRoICsgc2luICogaGlnaGVzdC5oZWlnaHQ7XG5cbiAgICAgICAgICBtaW5TaXplLndpZHRoID0gTWF0aC5taW4odGhpcy5tYXhXaWR0aCwgbWluU2l6ZS53aWR0aCArIGxhYmVsV2lkdGggKyB0aWNrUGFkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlUGFkZGluZyhmaXJzdCwgbGFzdCwgc2luLCBjb3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2hhbmRsZU1hcmdpbnMoKTtcblxuICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLl9sZW5ndGggPSBjaGFydC53aWR0aCAtIHRoaXMuX21hcmdpbnMubGVmdCAtIHRoaXMuX21hcmdpbnMucmlnaHQ7XG4gICAgICB0aGlzLmhlaWdodCA9IG1pblNpemUuaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gbWluU2l6ZS53aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5fbGVuZ3RoID0gY2hhcnQuaGVpZ2h0IC0gdGhpcy5fbWFyZ2lucy50b3AgLSB0aGlzLl9tYXJnaW5zLmJvdHRvbTtcbiAgICB9XG4gIH1cblxuICBfY2FsY3VsYXRlUGFkZGluZyhmaXJzdCwgbGFzdCwgc2luLCBjb3MpIHtcbiAgICBjb25zdCB7dGlja3M6IHthbGlnbiwgcGFkZGluZ30sIHBvc2l0aW9ufSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBpc1JvdGF0ZWQgPSB0aGlzLmxhYmVsUm90YXRpb24gIT09IDA7XG4gICAgY29uc3QgbGFiZWxzQmVsb3dUaWNrcyA9IHBvc2l0aW9uICE9PSAndG9wJyAmJiB0aGlzLmF4aXMgPT09ICd4JztcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBjb25zdCBvZmZzZXRMZWZ0ID0gdGhpcy5nZXRQaXhlbEZvclRpY2soMCkgLSB0aGlzLmxlZnQ7XG4gICAgICBjb25zdCBvZmZzZXRSaWdodCA9IHRoaXMucmlnaHQgLSB0aGlzLmdldFBpeGVsRm9yVGljayh0aGlzLnRpY2tzLmxlbmd0aCAtIDEpO1xuICAgICAgbGV0IHBhZGRpbmdMZWZ0ID0gMDtcbiAgICAgIGxldCBwYWRkaW5nUmlnaHQgPSAwO1xuXG4gICAgICAvLyBFbnN1cmUgdGhhdCBvdXIgdGlja3MgYXJlIGFsd2F5cyBpbnNpZGUgdGhlIGNhbnZhcy4gV2hlbiByb3RhdGVkLCB0aWNrcyBhcmUgcmlnaHQgYWxpZ25lZFxuICAgICAgLy8gd2hpY2ggbWVhbnMgdGhhdCB0aGUgcmlnaHQgcGFkZGluZyBpcyBkb21pbmF0ZWQgYnkgdGhlIGZvbnQgaGVpZ2h0XG4gICAgICBpZiAoaXNSb3RhdGVkKSB7XG4gICAgICAgIGlmIChsYWJlbHNCZWxvd1RpY2tzKSB7XG4gICAgICAgICAgcGFkZGluZ0xlZnQgPSBjb3MgKiBmaXJzdC53aWR0aDtcbiAgICAgICAgICBwYWRkaW5nUmlnaHQgPSBzaW4gKiBsYXN0LmhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYWRkaW5nTGVmdCA9IHNpbiAqIGZpcnN0LmhlaWdodDtcbiAgICAgICAgICBwYWRkaW5nUmlnaHQgPSBjb3MgKiBsYXN0LndpZHRoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHBhZGRpbmdSaWdodCA9IGxhc3Qud2lkdGg7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICBwYWRkaW5nTGVmdCA9IGZpcnN0LndpZHRoO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiAhPT0gJ2lubmVyJykge1xuICAgICAgICBwYWRkaW5nTGVmdCA9IGZpcnN0LndpZHRoIC8gMjtcbiAgICAgICAgcGFkZGluZ1JpZ2h0ID0gbGFzdC53aWR0aCAvIDI7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkanVzdCBwYWRkaW5nIHRha2luZyBpbnRvIGFjY291bnQgY2hhbmdlcyBpbiBvZmZzZXRzXG4gICAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gTWF0aC5tYXgoKHBhZGRpbmdMZWZ0IC0gb2Zmc2V0TGVmdCArIHBhZGRpbmcpICogdGhpcy53aWR0aCAvICh0aGlzLndpZHRoIC0gb2Zmc2V0TGVmdCksIDApO1xuICAgICAgdGhpcy5wYWRkaW5nUmlnaHQgPSBNYXRoLm1heCgocGFkZGluZ1JpZ2h0IC0gb2Zmc2V0UmlnaHQgKyBwYWRkaW5nKSAqIHRoaXMud2lkdGggLyAodGhpcy53aWR0aCAtIG9mZnNldFJpZ2h0KSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYWRkaW5nVG9wID0gbGFzdC5oZWlnaHQgLyAyO1xuICAgICAgbGV0IHBhZGRpbmdCb3R0b20gPSBmaXJzdC5oZWlnaHQgLyAyO1xuXG4gICAgICBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgcGFkZGluZ1RvcCA9IDA7XG4gICAgICAgIHBhZGRpbmdCb3R0b20gPSBmaXJzdC5oZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICBwYWRkaW5nVG9wID0gbGFzdC5oZWlnaHQ7XG4gICAgICAgIHBhZGRpbmdCb3R0b20gPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBhZGRpbmdUb3AgPSBwYWRkaW5nVG9wICsgcGFkZGluZztcbiAgICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IHBhZGRpbmdCb3R0b20gKyBwYWRkaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBIYW5kbGUgbWFyZ2lucyBhbmQgcGFkZGluZyBpbnRlcmFjdGlvbnNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9oYW5kbGVNYXJnaW5zKCkge1xuICAgIGlmICh0aGlzLl9tYXJnaW5zKSB7XG4gICAgICB0aGlzLl9tYXJnaW5zLmxlZnQgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdMZWZ0LCB0aGlzLl9tYXJnaW5zLmxlZnQpO1xuICAgICAgdGhpcy5fbWFyZ2lucy50b3AgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdUb3AsIHRoaXMuX21hcmdpbnMudG9wKTtcbiAgICAgIHRoaXMuX21hcmdpbnMucmlnaHQgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdSaWdodCwgdGhpcy5fbWFyZ2lucy5yaWdodCk7XG4gICAgICB0aGlzLl9tYXJnaW5zLmJvdHRvbSA9IE1hdGgubWF4KHRoaXMucGFkZGluZ0JvdHRvbSwgdGhpcy5fbWFyZ2lucy5ib3R0b20pO1xuICAgIH1cbiAgfVxuXG4gIGFmdGVyRml0KCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmFmdGVyRml0LCBbdGhpc10pO1xuICB9XG5cbiAgLy8gU2hhcmVkIE1ldGhvZHNcbiAgLyoqXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuICBpc0hvcml6b250YWwoKSB7XG4gICAgY29uc3Qge2F4aXMsIHBvc2l0aW9ufSA9IHRoaXMub3B0aW9ucztcbiAgICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCBheGlzID09PSAneCc7XG4gIH1cbiAgLyoqXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuICBpc0Z1bGxTaXplKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZnVsbFNpemU7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29udmVydFRpY2tzVG9MYWJlbHModGlja3MpIHtcbiAgICB0aGlzLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuXG4gICAgdGhpcy5nZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpO1xuXG4gICAgLy8gVGlja3Mgc2hvdWxkIGJlIHNraXBwZWQgd2hlbiBjYWxsYmFjayByZXR1cm5zIG51bGwgb3IgdW5kZWYsIHNvIGxldHMgcmVtb3ZlIHRob3NlLlxuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGlmIChpc051bGxPclVuZGVmKHRpY2tzW2ldLmxhYmVsKSkge1xuICAgICAgICB0aWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGlsZW4tLTtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHt7IGZpcnN0OiBvYmplY3QsIGxhc3Q6IG9iamVjdCwgd2lkZXN0OiBvYmplY3QsIGhpZ2hlc3Q6IG9iamVjdCwgd2lkdGhzOiBBcnJheSwgaGVpZ2h0czogYXJyYXkgfX1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRMYWJlbFNpemVzKCkge1xuICAgIGxldCBsYWJlbFNpemVzID0gdGhpcy5fbGFiZWxTaXplcztcblxuICAgIGlmICghbGFiZWxTaXplcykge1xuICAgICAgY29uc3Qgc2FtcGxlU2l6ZSA9IHRoaXMub3B0aW9ucy50aWNrcy5zYW1wbGVTaXplO1xuICAgICAgbGV0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICAgIGlmIChzYW1wbGVTaXplIDwgdGlja3MubGVuZ3RoKSB7XG4gICAgICAgIHRpY2tzID0gc2FtcGxlKHRpY2tzLCBzYW1wbGVTaXplKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbGFiZWxTaXplcyA9IGxhYmVsU2l6ZXMgPSB0aGlzLl9jb21wdXRlTGFiZWxTaXplcyh0aWNrcywgdGlja3MubGVuZ3RoLCB0aGlzLm9wdGlvbnMudGlja3MubWF4VGlja3NMaW1pdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhYmVsU2l6ZXM7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB7d2lkdGgsIGhlaWdodCwgb2Zmc2V0fSBvYmplY3RzIGZvciB0aGUgZmlyc3QsIGxhc3QsIHdpZGVzdCwgaGlnaGVzdCB0aWNrXG5cdCAqIGxhYmVscyB3aGVyZSBvZmZzZXQgaW5kaWNhdGVzIHRoZSBhbmNob3IgcG9pbnQgb2Zmc2V0IGZyb20gdGhlIHRvcCBpbiBwaXhlbHMuXG5cdCAqIEByZXR1cm4ge3sgZmlyc3Q6IG9iamVjdCwgbGFzdDogb2JqZWN0LCB3aWRlc3Q6IG9iamVjdCwgaGlnaGVzdDogb2JqZWN0LCB3aWR0aHM6IEFycmF5LCBoZWlnaHRzOiBhcnJheSB9fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NvbXB1dGVMYWJlbFNpemVzKHRpY2tzLCBsZW5ndGgsIG1heFRpY2tzTGltaXQpIHtcbiAgICBjb25zdCB7Y3R4LCBfbG9uZ2VzdFRleHRDYWNoZTogY2FjaGVzfSA9IHRoaXM7XG4gICAgY29uc3Qgd2lkdGhzID0gW107XG4gICAgY29uc3QgaGVpZ2h0cyA9IFtdO1xuICAgIGNvbnN0IGluY3JlbWVudCA9IE1hdGguZmxvb3IobGVuZ3RoIC8gZ2V0VGlja3NMaW1pdChsZW5ndGgsIG1heFRpY2tzTGltaXQpKTtcbiAgICBsZXQgd2lkZXN0TGFiZWxTaXplID0gMDtcbiAgICBsZXQgaGlnaGVzdExhYmVsU2l6ZSA9IDA7XG4gICAgbGV0IGksIGosIGpsZW4sIGxhYmVsLCB0aWNrRm9udCwgZm9udFN0cmluZywgY2FjaGUsIGxpbmVIZWlnaHQsIHdpZHRoLCBoZWlnaHQsIG5lc3RlZExhYmVsO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBpbmNyZW1lbnQpIHtcbiAgICAgIGxhYmVsID0gdGlja3NbaV0ubGFiZWw7XG4gICAgICB0aWNrRm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaSk7XG4gICAgICBjdHguZm9udCA9IGZvbnRTdHJpbmcgPSB0aWNrRm9udC5zdHJpbmc7XG4gICAgICBjYWNoZSA9IGNhY2hlc1tmb250U3RyaW5nXSA9IGNhY2hlc1tmb250U3RyaW5nXSB8fCB7ZGF0YToge30sIGdjOiBbXX07XG4gICAgICBsaW5lSGVpZ2h0ID0gdGlja0ZvbnQubGluZUhlaWdodDtcbiAgICAgIHdpZHRoID0gaGVpZ2h0ID0gMDtcbiAgICAgIC8vIFVuZGVmaW5lZCBsYWJlbHMgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobGFiZWwpICYmICFpc0FycmF5KGxhYmVsKSkge1xuICAgICAgICB3aWR0aCA9IF9tZWFzdXJlVGV4dChjdHgsIGNhY2hlLmRhdGEsIGNhY2hlLmdjLCB3aWR0aCwgbGFiZWwpO1xuICAgICAgICBoZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGxhYmVsKSkge1xuICAgICAgICAvLyBpZiBpdCBpcyBhbiBhcnJheSBsZXQncyBtZWFzdXJlIGVhY2ggZWxlbWVudFxuICAgICAgICBmb3IgKGogPSAwLCBqbGVuID0gbGFiZWwubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG4gICAgICAgICAgbmVzdGVkTGFiZWwgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKGxhYmVsW2pdKTtcbiAgICAgICAgICAvLyBVbmRlZmluZWQgbGFiZWxzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZihuZXN0ZWRMYWJlbCkgJiYgIWlzQXJyYXkobmVzdGVkTGFiZWwpKSB7XG4gICAgICAgICAgICB3aWR0aCA9IF9tZWFzdXJlVGV4dChjdHgsIGNhY2hlLmRhdGEsIGNhY2hlLmdjLCB3aWR0aCwgbmVzdGVkTGFiZWwpO1xuICAgICAgICAgICAgaGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aWR0aHMucHVzaCh3aWR0aCk7XG4gICAgICBoZWlnaHRzLnB1c2goaGVpZ2h0KTtcbiAgICAgIHdpZGVzdExhYmVsU2l6ZSA9IE1hdGgubWF4KHdpZHRoLCB3aWRlc3RMYWJlbFNpemUpO1xuICAgICAgaGlnaGVzdExhYmVsU2l6ZSA9IE1hdGgubWF4KGhlaWdodCwgaGlnaGVzdExhYmVsU2l6ZSk7XG4gICAgfVxuICAgIGdhcmJhZ2VDb2xsZWN0KGNhY2hlcywgbGVuZ3RoKTtcblxuICAgIGNvbnN0IHdpZGVzdCA9IHdpZHRocy5pbmRleE9mKHdpZGVzdExhYmVsU2l6ZSk7XG4gICAgY29uc3QgaGlnaGVzdCA9IGhlaWdodHMuaW5kZXhPZihoaWdoZXN0TGFiZWxTaXplKTtcblxuICAgIGNvbnN0IHZhbHVlQXQgPSAoaWR4KSA9PiAoe3dpZHRoOiB3aWR0aHNbaWR4XSB8fCAwLCBoZWlnaHQ6IGhlaWdodHNbaWR4XSB8fCAwfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZmlyc3Q6IHZhbHVlQXQoMCksXG4gICAgICBsYXN0OiB2YWx1ZUF0KGxlbmd0aCAtIDEpLFxuICAgICAgd2lkZXN0OiB2YWx1ZUF0KHdpZGVzdCksXG4gICAgICBoaWdoZXN0OiB2YWx1ZUF0KGhpZ2hlc3QpLFxuICAgICAgd2lkdGhzLFxuICAgICAgaGVpZ2h0cyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIFVzZWQgdG8gZ2V0IHRoZSBsYWJlbCB0byBkaXNwbGF5IGluIHRoZSB0b29sdGlwIGZvciB0aGUgZ2l2ZW4gdmFsdWVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZVxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIGxvY2F0aW9uIG9mIHRoZSBnaXZlbiBkYXRhIHBvaW50LiBWYWx1ZSBjYW4gZWl0aGVyIGJlIGFuIGluZGV4IG9yIGEgbnVtZXJpY2FsIHZhbHVlXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0geyp9IHZhbHVlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXhdXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUsIGluZGV4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICByZXR1cm4gTmFOO1xuICB9XG5cbiAgLyoqXG5cdCAqIFVzZWQgdG8gZ2V0IHRoZSBkYXRhIHZhbHVlIGZyb20gYSBnaXZlbiBwaXhlbC4gVGhpcyBpcyB0aGUgaW52ZXJzZSBvZiBnZXRQaXhlbEZvclZhbHVlXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxcblx0ICogQHJldHVybiB7Kn1cblx0ICovXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgbG9jYXRpb24gb2YgdGhlIHRpY2sgYXQgdGhlIGdpdmVuIGluZGV4XG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aWNrcy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aWNrc1tpbmRleF0udmFsdWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFV0aWxpdHkgZm9yIGdldHRpbmcgdGhlIHBpeGVsIGxvY2F0aW9uIG9mIGEgcGVyY2VudGFnZSBvZiBzY2FsZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IGRlY2ltYWxcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0UGl4ZWxGb3JEZWNpbWFsKGRlY2ltYWwpIHtcbiAgICBpZiAodGhpcy5fcmV2ZXJzZVBpeGVscykge1xuICAgICAgZGVjaW1hbCA9IDEgLSBkZWNpbWFsO1xuICAgIH1cblxuICAgIGNvbnN0IHBpeGVsID0gdGhpcy5fc3RhcnRQaXhlbCArIGRlY2ltYWwgKiB0aGlzLl9sZW5ndGg7XG4gICAgcmV0dXJuIF9pbnQxNlJhbmdlKHRoaXMuX2FsaWduVG9QaXhlbHMgPyBfYWxpZ25QaXhlbCh0aGlzLmNoYXJ0LCBwaXhlbCwgMCkgOiBwaXhlbCk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IGRlY2ltYWwgPSAocGl4ZWwgLSB0aGlzLl9zdGFydFBpeGVsKSAvIHRoaXMuX2xlbmd0aDtcbiAgICByZXR1cm4gdGhpcy5fcmV2ZXJzZVBpeGVscyA/IDEgLSBkZWNpbWFsIDogZGVjaW1hbDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBwaXhlbCBmb3IgdGhlIG1pbmltdW0gY2hhcnQgdmFsdWVcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldEJhc2VQaXhlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0QmFzZVZhbHVlKCkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldEJhc2VWYWx1ZSgpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcztcblxuICAgIHJldHVybiBtaW4gPCAwICYmIG1heCA8IDAgPyBtYXggOlxuICAgICAgbWluID4gMCAmJiBtYXggPiAwID8gbWluIDpcbiAgICAgIDA7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0Q29udGV4dChpbmRleCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcyB8fCBbXTtcblxuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGlja3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCB0aWNrID0gdGlja3NbaW5kZXhdO1xuICAgICAgcmV0dXJuIHRpY2suJGNvbnRleHQgfHxcblx0XHRcdFx0KHRpY2suJGNvbnRleHQgPSBjcmVhdGVUaWNrQ29udGV4dCh0aGlzLmdldENvbnRleHQoKSwgaW5kZXgsIHRpY2spKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHxcblx0XHRcdCh0aGlzLiRjb250ZXh0ID0gY3JlYXRlU2NhbGVDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzKSk7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3RpY2tTaXplKCkge1xuICAgIGNvbnN0IG9wdGlvblRpY2tzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHNwYWNlIG5lZWRlZCBieSBsYWJlbCBpbiBheGlzIGRpcmVjdGlvbi5cbiAgICBjb25zdCByb3QgPSB0b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICBjb25zdCBjb3MgPSBNYXRoLmFicyhNYXRoLmNvcyhyb3QpKTtcbiAgICBjb25zdCBzaW4gPSBNYXRoLmFicyhNYXRoLnNpbihyb3QpKTtcblxuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgY29uc3QgcGFkZGluZyA9IG9wdGlvblRpY2tzLmF1dG9Ta2lwUGFkZGluZyB8fCAwO1xuICAgIGNvbnN0IHcgPSBsYWJlbFNpemVzID8gbGFiZWxTaXplcy53aWRlc3Qud2lkdGggKyBwYWRkaW5nIDogMDtcbiAgICBjb25zdCBoID0gbGFiZWxTaXplcyA/IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyBwYWRkaW5nIDogMDtcblxuICAgIC8vIENhbGN1bGF0ZSBzcGFjZSBuZWVkZWQgZm9yIDEgdGljayBpbiBheGlzIGRpcmVjdGlvbi5cbiAgICByZXR1cm4gdGhpcy5pc0hvcml6b250YWwoKVxuICAgICAgPyBoICogY29zID4gdyAqIHNpbiA/IHcgLyBjb3MgOiBoIC8gc2luXG4gICAgICA6IGggKiBzaW4gPCB3ICogY29zID8gaCAvIGNvcyA6IHcgLyBzaW47XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9pc1Zpc2libGUoKSB7XG4gICAgY29uc3QgZGlzcGxheSA9IHRoaXMub3B0aW9ucy5kaXNwbGF5O1xuXG4gICAgaWYgKGRpc3BsYXkgIT09ICdhdXRvJykge1xuICAgICAgcmV0dXJuICEhZGlzcGxheTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygpLmxlbmd0aCA+IDA7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlR3JpZExpbmVJdGVtcyhjaGFydEFyZWEpIHtcbiAgICBjb25zdCBheGlzID0gdGhpcy5heGlzO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHtncmlkLCBwb3NpdGlvbiwgYm9yZGVyfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgb2Zmc2V0ID0gZ3JpZC5vZmZzZXQ7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgY29uc3QgdGlja3NMZW5ndGggPSB0aWNrcy5sZW5ndGggKyAob2Zmc2V0ID8gMSA6IDApO1xuICAgIGNvbnN0IHRsID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZCk7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcblxuICAgIGNvbnN0IGJvcmRlck9wdHMgPSBib3JkZXIuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYXhpc1dpZHRoID0gYm9yZGVyT3B0cy5kaXNwbGF5ID8gYm9yZGVyT3B0cy53aWR0aCA6IDA7XG4gICAgY29uc3QgYXhpc0hhbGZXaWR0aCA9IGF4aXNXaWR0aCAvIDI7XG4gICAgY29uc3QgYWxpZ25Cb3JkZXJWYWx1ZSA9IGZ1bmN0aW9uKHBpeGVsKSB7XG4gICAgICByZXR1cm4gX2FsaWduUGl4ZWwoY2hhcnQsIHBpeGVsLCBheGlzV2lkdGgpO1xuICAgIH07XG4gICAgbGV0IGJvcmRlclZhbHVlLCBpLCBsaW5lVmFsdWUsIGFsaWduZWRMaW5lVmFsdWU7XG4gICAgbGV0IHR4MSwgdHkxLCB0eDIsIHR5MiwgeDEsIHkxLCB4MiwgeTI7XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5ib3R0b20pO1xuICAgICAgdHkxID0gdGhpcy5ib3R0b20gLSB0bDtcbiAgICAgIHR5MiA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHkxID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEudG9wKSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB5MiA9IGNoYXJ0QXJlYS5ib3R0b207XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLnRvcCk7XG4gICAgICB5MSA9IGNoYXJ0QXJlYS50b3A7XG4gICAgICB5MiA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLmJvdHRvbSkgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHkxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xuICAgICAgdHkyID0gdGhpcy50b3AgKyB0bDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLnJpZ2h0KTtcbiAgICAgIHR4MSA9IHRoaXMucmlnaHQgLSB0bDtcbiAgICAgIHR4MiA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHgxID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEubGVmdCkgKyBheGlzSGFsZldpZHRoO1xuICAgICAgeDIgPSBjaGFydEFyZWEucmlnaHQ7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMubGVmdCk7XG4gICAgICB4MSA9IGNoYXJ0QXJlYS5sZWZ0O1xuICAgICAgeDIgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5yaWdodCkgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHgxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xuICAgICAgdHgyID0gdGhpcy5sZWZ0ICsgdGw7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneCcpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyICsgMC41KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSk7XG4gICAgICB9XG5cbiAgICAgIHkxID0gY2hhcnRBcmVhLnRvcDtcbiAgICAgIHkyID0gY2hhcnRBcmVhLmJvdHRvbTtcbiAgICAgIHR5MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR5MiA9IHR5MSArIHRsO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSgoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMik7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkpO1xuICAgICAgfVxuXG4gICAgICB0eDEgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eDIgPSB0eDEgLSB0bDtcbiAgICAgIHgxID0gY2hhcnRBcmVhLmxlZnQ7XG4gICAgICB4MiA9IGNoYXJ0QXJlYS5yaWdodDtcbiAgICB9XG5cbiAgICBjb25zdCBsaW1pdCA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMudGlja3MubWF4VGlja3NMaW1pdCwgdGlja3NMZW5ndGgpO1xuICAgIGNvbnN0IHN0ZXAgPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwodGlja3NMZW5ndGggLyBsaW1pdCkpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aWNrc0xlbmd0aDsgaSArPSBzdGVwKSB7XG4gICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KGkpO1xuICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBncmlkLnNldENvbnRleHQoY29udGV4dCk7XG4gICAgICBjb25zdCBvcHRzQXRJbmRleEJvcmRlciA9IGJvcmRlci5zZXRDb250ZXh0KGNvbnRleHQpO1xuXG4gICAgICBjb25zdCBsaW5lV2lkdGggPSBvcHRzQXRJbmRleC5saW5lV2lkdGg7XG4gICAgICBjb25zdCBsaW5lQ29sb3IgPSBvcHRzQXRJbmRleC5jb2xvcjtcbiAgICAgIGNvbnN0IGJvcmRlckRhc2ggPSBvcHRzQXRJbmRleEJvcmRlci5kYXNoIHx8IFtdO1xuICAgICAgY29uc3QgYm9yZGVyRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4Qm9yZGVyLmRhc2hPZmZzZXQ7XG5cbiAgICAgIGNvbnN0IHRpY2tXaWR0aCA9IG9wdHNBdEluZGV4LnRpY2tXaWR0aDtcbiAgICAgIGNvbnN0IHRpY2tDb2xvciA9IG9wdHNBdEluZGV4LnRpY2tDb2xvcjtcbiAgICAgIGNvbnN0IHRpY2tCb3JkZXJEYXNoID0gb3B0c0F0SW5kZXgudGlja0JvcmRlckRhc2ggfHwgW107XG4gICAgICBjb25zdCB0aWNrQm9yZGVyRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4LnRpY2tCb3JkZXJEYXNoT2Zmc2V0O1xuXG4gICAgICBsaW5lVmFsdWUgPSBnZXRQaXhlbEZvckdyaWRMaW5lKHRoaXMsIGksIG9mZnNldCk7XG5cbiAgICAgIC8vIFNraXAgaWYgdGhlIHBpeGVsIGlzIG91dCBvZiB0aGUgcmFuZ2VcbiAgICAgIGlmIChsaW5lVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYWxpZ25lZExpbmVWYWx1ZSA9IF9hbGlnblBpeGVsKGNoYXJ0LCBsaW5lVmFsdWUsIGxpbmVXaWR0aCk7XG5cbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgdHgxID0gdHgyID0geDEgPSB4MiA9IGFsaWduZWRMaW5lVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eTEgPSB0eTIgPSB5MSA9IHkyID0gYWxpZ25lZExpbmVWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgIHR4MSxcbiAgICAgICAgdHkxLFxuICAgICAgICB0eDIsXG4gICAgICAgIHR5MixcbiAgICAgICAgeDEsXG4gICAgICAgIHkxLFxuICAgICAgICB4MixcbiAgICAgICAgeTIsXG4gICAgICAgIHdpZHRoOiBsaW5lV2lkdGgsXG4gICAgICAgIGNvbG9yOiBsaW5lQ29sb3IsXG4gICAgICAgIGJvcmRlckRhc2gsXG4gICAgICAgIGJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgIHRpY2tXaWR0aCxcbiAgICAgICAgdGlja0NvbG9yLFxuICAgICAgICB0aWNrQm9yZGVyRGFzaCxcbiAgICAgICAgdGlja0JvcmRlckRhc2hPZmZzZXQsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl90aWNrc0xlbmd0aCA9IHRpY2tzTGVuZ3RoO1xuICAgIHRoaXMuX2JvcmRlclZhbHVlID0gYm9yZGVyVmFsdWU7XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlTGFiZWxJdGVtcyhjaGFydEFyZWEpIHtcbiAgICBjb25zdCBheGlzID0gdGhpcy5heGlzO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge3Bvc2l0aW9uLCB0aWNrczogb3B0aW9uVGlja3N9ID0gb3B0aW9ucztcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBjb25zdCB7YWxpZ24sIGNyb3NzQWxpZ24sIHBhZGRpbmcsIG1pcnJvcn0gPSBvcHRpb25UaWNrcztcbiAgICBjb25zdCB0bCA9IGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMuZ3JpZCk7XG4gICAgY29uc3QgdGlja0FuZFBhZGRpbmcgPSB0bCArIHBhZGRpbmc7XG4gICAgY29uc3QgaFRpY2tBbmRQYWRkaW5nID0gbWlycm9yID8gLXBhZGRpbmcgOiB0aWNrQW5kUGFkZGluZztcbiAgICBjb25zdCByb3RhdGlvbiA9IC10b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCB0aWNrLCBsYWJlbCwgeCwgeSwgdGV4dEFsaWduLCBwaXhlbCwgZm9udCwgbGluZUhlaWdodCwgbGluZUNvdW50LCB0ZXh0T2Zmc2V0O1xuICAgIGxldCB0ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgIHkgPSB0aGlzLmJvdHRvbSAtIGhUaWNrQW5kUGFkZGluZztcbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgeSA9IHRoaXMudG9wICsgaFRpY2tBbmRQYWRkaW5nO1xuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgY29uc3QgcmV0ID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCk7XG4gICAgICB0ZXh0QWxpZ24gPSByZXQudGV4dEFsaWduO1xuICAgICAgeCA9IHJldC54O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIGNvbnN0IHJldCA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpO1xuICAgICAgdGV4dEFsaWduID0gcmV0LnRleHRBbGlnbjtcbiAgICAgIHggPSByZXQueDtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd4Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICB5ID0gKChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyKSArIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICB5ID0gdGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpICsgdGlja0FuZFBhZGRpbmc7XG4gICAgICB9XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneScpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgeCA9ICgoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMikgLSB0aWNrQW5kUGFkZGluZztcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgeCA9IHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpLnRleHRBbGlnbjtcbiAgICB9XG5cbiAgICBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICB0ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgIGxhYmVsID0gdGljay5sYWJlbDtcblxuICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBvcHRpb25UaWNrcy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpKSk7XG4gICAgICBwaXhlbCA9IHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKGkpICsgb3B0aW9uVGlja3MubGFiZWxPZmZzZXQ7XG4gICAgICBmb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhpKTtcbiAgICAgIGxpbmVIZWlnaHQgPSBmb250LmxpbmVIZWlnaHQ7XG4gICAgICBsaW5lQ291bnQgPSBpc0FycmF5KGxhYmVsKSA/IGxhYmVsLmxlbmd0aCA6IDE7XG4gICAgICBjb25zdCBoYWxmQ291bnQgPSBsaW5lQ291bnQgLyAyO1xuICAgICAgY29uc3QgY29sb3IgPSBvcHRzQXRJbmRleC5jb2xvcjtcbiAgICAgIGNvbnN0IHN0cm9rZUNvbG9yID0gb3B0c0F0SW5kZXgudGV4dFN0cm9rZUNvbG9yO1xuICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBvcHRzQXRJbmRleC50ZXh0U3Ryb2tlV2lkdGg7XG4gICAgICBsZXQgdGlja1RleHRBbGlnbiA9IHRleHRBbGlnbjtcblxuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICB4ID0gcGl4ZWw7XG5cbiAgICAgICAgaWYgKHRleHRBbGlnbiA9PT0gJ2lubmVyJykge1xuICAgICAgICAgIGlmIChpID09PSBpbGVuIC0gMSkge1xuICAgICAgICAgICAgdGlja1RleHRBbGlnbiA9ICF0aGlzLm9wdGlvbnMucmV2ZXJzZSA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgfSBlbHNlIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICB0aWNrVGV4dEFsaWduID0gIXRoaXMub3B0aW9ucy5yZXZlcnNlID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGlja1RleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInIHx8IHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxpbmVDb3VudCAqIGxpbmVIZWlnaHQgKyBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgLyAyIC0gaGFsZkNvdW50ICogbGluZUhlaWdodCArIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSAtbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZWx5LWlmXG4gICAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJyB8fCByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC8gMiAtIGhhbGZDb3VudCAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC0gbGluZUNvdW50ICogbGluZUhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICAgIHRleHRPZmZzZXQgKj0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdGF0aW9uICE9PSAwICYmICFvcHRzQXRJbmRleC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICAgIHggKz0gKGxpbmVIZWlnaHQgLyAyKSAqIE1hdGguc2luKHJvdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeSA9IHBpeGVsO1xuICAgICAgICB0ZXh0T2Zmc2V0ID0gKDEgLSBsaW5lQ291bnQpICogbGluZUhlaWdodCAvIDI7XG4gICAgICB9XG5cbiAgICAgIGxldCBiYWNrZHJvcDtcblxuICAgICAgaWYgKG9wdHNBdEluZGV4LnNob3dMYWJlbEJhY2tkcm9wKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsUGFkZGluZyA9IHRvUGFkZGluZyhvcHRzQXRJbmRleC5iYWNrZHJvcFBhZGRpbmcpO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBsYWJlbFNpemVzLmhlaWdodHNbaV07XG4gICAgICAgIGNvbnN0IHdpZHRoID0gbGFiZWxTaXplcy53aWR0aHNbaV07XG5cbiAgICAgICAgbGV0IHRvcCA9IHRleHRPZmZzZXQgLSBsYWJlbFBhZGRpbmcudG9wO1xuICAgICAgICBsZXQgbGVmdCA9IDAgLSBsYWJlbFBhZGRpbmcubGVmdDtcblxuICAgICAgICBzd2l0Y2ggKHRleHRCYXNlbGluZSkge1xuICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgIHRvcCAtPSBoZWlnaHQgLyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHRleHRBbGlnbikge1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIGxlZnQgLT0gd2lkdGggLyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW5uZXInOlxuICAgICAgICAgIGlmIChpID09PSBpbGVuIC0gMSkge1xuICAgICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoIC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBiYWNrZHJvcCA9IHtcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIHRvcCxcbiAgICAgICAgICB3aWR0aDogd2lkdGggKyBsYWJlbFBhZGRpbmcud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKyBsYWJlbFBhZGRpbmcuaGVpZ2h0LFxuXG4gICAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmJhY2tkcm9wQ29sb3IsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICBsYWJlbCxcbiAgICAgICAgZm9udCxcbiAgICAgICAgdGV4dE9mZnNldCxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgIHN0cm9rZUNvbG9yLFxuICAgICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICAgIHRleHRBbGlnbjogdGlja1RleHRBbGlnbixcbiAgICAgICAgICB0ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgdHJhbnNsYXRpb246IFt4LCB5XSxcbiAgICAgICAgICBiYWNrZHJvcCxcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbiAgX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKSB7XG4gICAgY29uc3Qge3Bvc2l0aW9uLCB0aWNrc30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgcm90YXRpb24gPSAtdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG5cbiAgICBpZiAocm90YXRpb24pIHtcbiAgICAgIHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH1cblxuICAgIGxldCBhbGlnbiA9ICdjZW50ZXInO1xuXG4gICAgaWYgKHRpY2tzLmFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICBhbGlnbiA9ICdsZWZ0JztcbiAgICB9IGVsc2UgaWYgKHRpY2tzLmFsaWduID09PSAnZW5kJykge1xuICAgICAgYWxpZ24gPSAncmlnaHQnO1xuICAgIH0gZWxzZSBpZiAodGlja3MuYWxpZ24gPT09ICdpbm5lcicpIHtcbiAgICAgIGFsaWduID0gJ2lubmVyJztcbiAgICB9XG5cbiAgICByZXR1cm4gYWxpZ247XG4gIH1cblxuICBfZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCkge1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3M6IHtjcm9zc0FsaWduLCBtaXJyb3IsIHBhZGRpbmd9fSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IHRpY2tBbmRQYWRkaW5nID0gdGwgKyBwYWRkaW5nO1xuICAgIGNvbnN0IHdpZGVzdCA9IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoO1xuXG4gICAgbGV0IHRleHRBbGlnbjtcbiAgICBsZXQgeDtcblxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBpZiAobWlycm9yKSB7XG4gICAgICAgIHggPSB0aGlzLnJpZ2h0ICsgcGFkZGluZztcblxuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCArPSAod2lkZXN0IC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICB4ICs9IHdpZGVzdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHRoaXMucmlnaHQgLSB0aWNrQW5kUGFkZGluZztcblxuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggLT0gKHdpZGVzdCAvIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICB4ID0gdGhpcy5sZWZ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICB4ID0gdGhpcy5sZWZ0ICsgcGFkZGluZztcblxuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggLT0gKHdpZGVzdCAvIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICB4IC09IHdpZGVzdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHRoaXMubGVmdCArIHRpY2tBbmRQYWRkaW5nO1xuXG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4ICs9IHdpZGVzdCAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICB4ID0gdGhpcy5yaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgIH1cblxuICAgIHJldHVybiB7dGV4dEFsaWduLCB4fTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NvbXB1dGVMYWJlbEFyZWEoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50aWNrcy5taXJyb3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICdsZWZ0JyB8fCBwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgcmV0dXJuIHt0b3A6IDAsIGxlZnQ6IHRoaXMubGVmdCwgYm90dG9tOiBjaGFydC5oZWlnaHQsIHJpZ2h0OiB0aGlzLnJpZ2h0fTtcbiAgICB9IGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICByZXR1cm4ge3RvcDogdGhpcy50b3AsIGxlZnQ6IDAsIGJvdHRvbTogdGhpcy5ib3R0b20sIHJpZ2h0OiBjaGFydC53aWR0aH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGRyYXdCYWNrZ3JvdW5kKCkge1xuICAgIGNvbnN0IHtjdHgsIG9wdGlvbnM6IHtiYWNrZ3JvdW5kQ29sb3J9LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHR9ID0gdGhpcztcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgIGN0eC5maWxsUmVjdChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cblxuICBnZXRMaW5lV2lkdGhGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IGdyaWQgPSB0aGlzLm9wdGlvbnMuZ3JpZDtcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpIHx8ICFncmlkLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgY29uc3QgaW5kZXggPSB0aWNrcy5maW5kSW5kZXgodCA9PiB0LnZhbHVlID09PSB2YWx1ZSk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIGNvbnN0IG9wdHMgPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgICByZXR1cm4gb3B0cy5saW5lV2lkdGg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdHcmlkKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IGdyaWQgPSB0aGlzLm9wdGlvbnMuZ3JpZDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2dyaWRMaW5lSXRlbXMgfHwgKHRoaXMuX2dyaWRMaW5lSXRlbXMgPSB0aGlzLl9jb21wdXRlR3JpZExpbmVJdGVtcyhjaGFydEFyZWEpKTtcbiAgICBsZXQgaSwgaWxlbjtcblxuICAgIGNvbnN0IGRyYXdMaW5lID0gKHAxLCBwMiwgc3R5bGUpID0+IHtcbiAgICAgIGlmICghc3R5bGUud2lkdGggfHwgIXN0eWxlLmNvbG9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChzdHlsZS5ib3JkZXJEYXNoIHx8IFtdKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHN0eWxlLmJvcmRlckRhc2hPZmZzZXQ7XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8ocDEueCwgcDEueSk7XG4gICAgICBjdHgubGluZVRvKHAyLngsIHAyLnkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuXG4gICAgaWYgKGdyaWQuZGlzcGxheSkge1xuICAgICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG5cbiAgICAgICAgaWYgKGdyaWQuZHJhd09uQ2hhcnRBcmVhKSB7XG4gICAgICAgICAgZHJhd0xpbmUoXG4gICAgICAgICAgICB7eDogaXRlbS54MSwgeTogaXRlbS55MX0sXG4gICAgICAgICAgICB7eDogaXRlbS54MiwgeTogaXRlbS55Mn0sXG4gICAgICAgICAgICBpdGVtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChncmlkLmRyYXdUaWNrcykge1xuICAgICAgICAgIGRyYXdMaW5lKFxuICAgICAgICAgICAge3g6IGl0ZW0udHgxLCB5OiBpdGVtLnR5MX0sXG4gICAgICAgICAgICB7eDogaXRlbS50eDIsIHk6IGl0ZW0udHkyfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29sb3I6IGl0ZW0udGlja0NvbG9yLFxuICAgICAgICAgICAgICB3aWR0aDogaXRlbS50aWNrV2lkdGgsXG4gICAgICAgICAgICAgIGJvcmRlckRhc2g6IGl0ZW0udGlja0JvcmRlckRhc2gsXG4gICAgICAgICAgICAgIGJvcmRlckRhc2hPZmZzZXQ6IGl0ZW0udGlja0JvcmRlckRhc2hPZmZzZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdCb3JkZXIoKSB7XG4gICAgY29uc3Qge2NoYXJ0LCBjdHgsIG9wdGlvbnM6IHtib3JkZXIsIGdyaWR9fSA9IHRoaXM7XG4gICAgY29uc3QgYm9yZGVyT3B0cyA9IGJvcmRlci5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBheGlzV2lkdGggPSBib3JkZXIuZGlzcGxheSA/IGJvcmRlck9wdHMud2lkdGggOiAwO1xuICAgIGlmICghYXhpc1dpZHRoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhc3RMaW5lV2lkdGggPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KDApKS5saW5lV2lkdGg7XG4gICAgY29uc3QgYm9yZGVyVmFsdWUgPSB0aGlzLl9ib3JkZXJWYWx1ZTtcbiAgICBsZXQgeDEsIHgyLCB5MSwgeTI7XG5cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgeDEgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy5sZWZ0LCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcbiAgICAgIHgyID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMucmlnaHQsIGxhc3RMaW5lV2lkdGgpICsgbGFzdExpbmVXaWR0aCAvIDI7XG4gICAgICB5MSA9IHkyID0gYm9yZGVyVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkxID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMudG9wLCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcbiAgICAgIHkyID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMuYm90dG9tLCBsYXN0TGluZVdpZHRoKSArIGxhc3RMaW5lV2lkdGggLyAyO1xuICAgICAgeDEgPSB4MiA9IGJvcmRlclZhbHVlO1xuICAgIH1cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJPcHRzLndpZHRoO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IGJvcmRlck9wdHMuY29sb3I7XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdMYWJlbHMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3Qgb3B0aW9uVGlja3MgPSB0aGlzLm9wdGlvbnMudGlja3M7XG5cbiAgICBpZiAoIW9wdGlvblRpY2tzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcblxuICAgIGNvbnN0IGFyZWEgPSB0aGlzLl9jb21wdXRlTGFiZWxBcmVhKCk7XG4gICAgaWYgKGFyZWEpIHtcbiAgICAgIGNsaXBBcmVhKGN0eCwgYXJlYSk7XG4gICAgfVxuXG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLmdldExhYmVsSXRlbXMoY2hhcnRBcmVhKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgIGNvbnN0IHJlbmRlclRleHRPcHRpb25zID0gaXRlbS5vcHRpb25zO1xuICAgICAgY29uc3QgdGlja0ZvbnQgPSBpdGVtLmZvbnQ7XG4gICAgICBjb25zdCBsYWJlbCA9IGl0ZW0ubGFiZWw7XG4gICAgICBjb25zdCB5ID0gaXRlbS50ZXh0T2Zmc2V0O1xuICAgICAgcmVuZGVyVGV4dChjdHgsIGxhYmVsLCAwLCB5LCB0aWNrRm9udCwgcmVuZGVyVGV4dE9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChhcmVhKSB7XG4gICAgICB1bmNsaXBBcmVhKGN0eCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdUaXRsZSgpIHtcbiAgICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7cG9zaXRpb24sIHRpdGxlLCByZXZlcnNlfX0gPSB0aGlzO1xuXG4gICAgaWYgKCF0aXRsZS5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZm9udCA9IHRvRm9udCh0aXRsZS5mb250KTtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKHRpdGxlLnBhZGRpbmcpO1xuICAgIGNvbnN0IGFsaWduID0gdGl0bGUuYWxpZ247XG4gICAgbGV0IG9mZnNldCA9IGZvbnQubGluZUhlaWdodCAvIDI7XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICdib3R0b20nIHx8IHBvc2l0aW9uID09PSAnY2VudGVyJyB8fCBpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgIG9mZnNldCArPSBwYWRkaW5nLmJvdHRvbTtcbiAgICAgIGlmIChpc0FycmF5KHRpdGxlLnRleHQpKSB7XG4gICAgICAgIG9mZnNldCArPSBmb250LmxpbmVIZWlnaHQgKiAodGl0bGUudGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ICs9IHBhZGRpbmcudG9wO1xuICAgIH1cblxuICAgIGNvbnN0IHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufSA9IHRpdGxlQXJncyh0aGlzLCBvZmZzZXQsIHBvc2l0aW9uLCBhbGlnbik7XG5cbiAgICByZW5kZXJUZXh0KGN0eCwgdGl0bGUudGV4dCwgMCwgMCwgZm9udCwge1xuICAgICAgY29sb3I6IHRpdGxlLmNvbG9yLFxuICAgICAgbWF4V2lkdGgsXG4gICAgICByb3RhdGlvbixcbiAgICAgIHRleHRBbGlnbjogdGl0bGVBbGlnbihhbGlnbiwgcG9zaXRpb24sIHJldmVyc2UpLFxuICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgIHRyYW5zbGF0aW9uOiBbdGl0bGVYLCB0aXRsZVldLFxuICAgIH0pO1xuICB9XG5cbiAgZHJhdyhjaGFydEFyZWEpIHtcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kcmF3QmFja2dyb3VuZCgpO1xuICAgIHRoaXMuZHJhd0dyaWQoY2hhcnRBcmVhKTtcbiAgICB0aGlzLmRyYXdCb3JkZXIoKTtcbiAgICB0aGlzLmRyYXdUaXRsZSgpO1xuICAgIHRoaXMuZHJhd0xhYmVscyhjaGFydEFyZWEpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge29iamVjdFtdfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2xheWVycygpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHR6ID0gb3B0cy50aWNrcyAmJiBvcHRzLnRpY2tzLnogfHwgMDtcbiAgICBjb25zdCBneiA9IHZhbHVlT3JEZWZhdWx0KG9wdHMuZ3JpZCAmJiBvcHRzLmdyaWQueiwgLTEpO1xuICAgIGNvbnN0IGJ6ID0gdmFsdWVPckRlZmF1bHQob3B0cy5ib3JkZXIgJiYgb3B0cy5ib3JkZXIueiwgMCk7XG5cbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpIHx8IHRoaXMuZHJhdyAhPT0gU2NhbGUucHJvdG90eXBlLmRyYXcpIHtcbiAgICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IGRyYXcgaGFzIGJlZW4gb3ZlcnJpZGRlbiBieSBjdXN0b20gc2NhbGVcbiAgICAgIHJldHVybiBbe1xuICAgICAgICB6OiB0eixcbiAgICAgICAgZHJhdzogKGNoYXJ0QXJlYSkgPT4ge1xuICAgICAgICAgIHRoaXMuZHJhdyhjaGFydEFyZWEpO1xuICAgICAgICB9XG4gICAgICB9XTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3tcbiAgICAgIHo6IGd6LFxuICAgICAgZHJhdzogKGNoYXJ0QXJlYSkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKCk7XG4gICAgICAgIHRoaXMuZHJhd0dyaWQoY2hhcnRBcmVhKTtcbiAgICAgICAgdGhpcy5kcmF3VGl0bGUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB6OiBieixcbiAgICAgIGRyYXc6ICgpID0+IHtcbiAgICAgICAgdGhpcy5kcmF3Qm9yZGVyKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgejogdHosXG4gICAgICBkcmF3OiAoY2hhcnRBcmVhKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd0xhYmVscyhjaGFydEFyZWEpO1xuICAgICAgfVxuICAgIH1dO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdmlzaWJsZSBkYXRhc2V0IG1ldGFzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIHRoaXMgc2NhbGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSAtIGlmIHNwZWNpZmllZCwgYWxzbyBmaWx0ZXIgYnkgZGF0YXNldCB0eXBlXG5cdCAqIEByZXR1cm4ge29iamVjdFtdfVxuXHQgKi9cbiAgZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSkge1xuICAgIGNvbnN0IG1ldGFzID0gdGhpcy5jaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgY29uc3QgYXhpc0lEID0gdGhpcy5heGlzICsgJ0F4aXNJRCc7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBtZXRhID0gbWV0YXNbaV07XG4gICAgICBpZiAobWV0YVtheGlzSURdID09PSB0aGlzLmlkICYmICghdHlwZSB8fCBtZXRhLnR5cGUgPT09IHR5cGUpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1ldGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuXHQgKiBAcmV0dXJuIHtvYmplY3R9XG5cdCAqIEBwcm90ZWN0ZWRcbiBcdCAqL1xuICBfcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhpbmRleCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnMudGlja3Muc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXgpKTtcbiAgICByZXR1cm4gdG9Gb250KG9wdHMuZm9udCk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX21heERpZ2l0cygpIHtcbiAgICBjb25zdCBmb250U2l6ZSA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCkubGluZUhlaWdodDtcbiAgICByZXR1cm4gKHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aGlzLndpZHRoIDogdGhpcy5oZWlnaHQpIC8gZm9udFNpemU7XG4gIH1cbn1cbiIsICJpbXBvcnQge21lcmdlfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCBkZWZhdWx0cywge292ZXJyaWRlc30gZnJvbSAnLi9jb3JlLmRlZmF1bHRzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7e2lkOiBzdHJpbmcsIGRlZmF1bHRzOiBhbnksIG92ZXJyaWRlcz86IGFueSwgZGVmYXVsdFJvdXRlczogYW55fX0gSUNoYXJ0Q29tcG9uZW50XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHlwZWRSZWdpc3RyeSB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIHNjb3BlLCBvdmVycmlkZSkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIHRoaXMub3ZlcnJpZGUgPSBvdmVycmlkZTtcbiAgICB0aGlzLml0ZW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuXG4gIGlzRm9yVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZi5jYWxsKHRoaXMudHlwZS5wcm90b3R5cGUsIHR5cGUucHJvdG90eXBlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0lDaGFydENvbXBvbmVudH0gaXRlbVxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc2NvcGUgd2hlcmUgaXRlbXMgZGVmYXVsdHMgd2VyZSByZWdpc3RlcmVkIHRvLlxuXHQgKi9cbiAgcmVnaXN0ZXIoaXRlbSkge1xuICAgIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGl0ZW0pO1xuICAgIGxldCBwYXJlbnRTY29wZTtcblxuICAgIGlmIChpc0lDaGFydENvbXBvbmVudChwcm90bykpIHtcbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgcGFyZW50IGlzIHJlZ2lzdGVyZWQgYW5kIG5vdGUgdGhlIHNjb3BlIHdoZXJlIGl0cyBkZWZhdWx0cyBhcmUuXG4gICAgICBwYXJlbnRTY29wZSA9IHRoaXMucmVnaXN0ZXIocHJvdG8pO1xuICAgIH1cblxuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICBjb25zdCBpZCA9IGl0ZW0uaWQ7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLnNjb3BlICsgJy4nICsgaWQ7XG5cbiAgICBpZiAoIWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsYXNzIGRvZXMgbm90IGhhdmUgaWQ6ICcgKyBpdGVtKTtcbiAgICB9XG5cbiAgICBpZiAoaWQgaW4gaXRlbXMpIHtcbiAgICAgIC8vIGFscmVhZHkgcmVnaXN0ZXJlZFxuICAgICAgcmV0dXJuIHNjb3BlO1xuICAgIH1cblxuICAgIGl0ZW1zW2lkXSA9IGl0ZW07XG4gICAgcmVnaXN0ZXJEZWZhdWx0cyhpdGVtLCBzY29wZSwgcGFyZW50U2NvcGUpO1xuICAgIGlmICh0aGlzLm92ZXJyaWRlKSB7XG4gICAgICBkZWZhdWx0cy5vdmVycmlkZShpdGVtLmlkLCBpdGVtLm92ZXJyaWRlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjb3BlO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuXHQgKiBAcmV0dXJucyB7b2JqZWN0P31cblx0ICovXG4gIGdldChpZCkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zW2lkXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0lDaGFydENvbXBvbmVudH0gaXRlbVxuXHQgKi9cbiAgdW5yZWdpc3RlcihpdGVtKSB7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgIGNvbnN0IGlkID0gaXRlbS5pZDtcbiAgICBjb25zdCBzY29wZSA9IHRoaXMuc2NvcGU7XG5cbiAgICBpZiAoaWQgaW4gaXRlbXMpIHtcbiAgICAgIGRlbGV0ZSBpdGVtc1tpZF07XG4gICAgfVxuXG4gICAgaWYgKHNjb3BlICYmIGlkIGluIGRlZmF1bHRzW3Njb3BlXSkge1xuICAgICAgZGVsZXRlIGRlZmF1bHRzW3Njb3BlXVtpZF07XG4gICAgICBpZiAodGhpcy5vdmVycmlkZSkge1xuICAgICAgICBkZWxldGUgb3ZlcnJpZGVzW2lkXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0cyhpdGVtLCBzY29wZSwgcGFyZW50U2NvcGUpIHtcbiAgLy8gSW5oZXJpdCB0aGUgcGFyZW50J3MgZGVmYXVsdHMgYW5kIGtlZXAgZXhpc3RpbmcgZGVmYXVsdHNcbiAgY29uc3QgaXRlbURlZmF1bHRzID0gbWVyZ2UoT2JqZWN0LmNyZWF0ZShudWxsKSwgW1xuICAgIHBhcmVudFNjb3BlID8gZGVmYXVsdHMuZ2V0KHBhcmVudFNjb3BlKSA6IHt9LFxuICAgIGRlZmF1bHRzLmdldChzY29wZSksXG4gICAgaXRlbS5kZWZhdWx0c1xuICBdKTtcblxuICBkZWZhdWx0cy5zZXQoc2NvcGUsIGl0ZW1EZWZhdWx0cyk7XG5cbiAgaWYgKGl0ZW0uZGVmYXVsdFJvdXRlcykge1xuICAgIHJvdXRlRGVmYXVsdHMoc2NvcGUsIGl0ZW0uZGVmYXVsdFJvdXRlcyk7XG4gIH1cblxuICBpZiAoaXRlbS5kZXNjcmlwdG9ycykge1xuICAgIGRlZmF1bHRzLmRlc2NyaWJlKHNjb3BlLCBpdGVtLmRlc2NyaXB0b3JzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByb3V0ZURlZmF1bHRzKHNjb3BlLCByb3V0ZXMpIHtcbiAgT2JqZWN0LmtleXMocm91dGVzKS5mb3JFYWNoKHByb3BlcnR5ID0+IHtcbiAgICBjb25zdCBwcm9wZXJ0eVBhcnRzID0gcHJvcGVydHkuc3BsaXQoJy4nKTtcbiAgICBjb25zdCBzb3VyY2VOYW1lID0gcHJvcGVydHlQYXJ0cy5wb3AoKTtcbiAgICBjb25zdCBzb3VyY2VTY29wZSA9IFtzY29wZV0uY29uY2F0KHByb3BlcnR5UGFydHMpLmpvaW4oJy4nKTtcbiAgICBjb25zdCBwYXJ0cyA9IHJvdXRlc1twcm9wZXJ0eV0uc3BsaXQoJy4nKTtcbiAgICBjb25zdCB0YXJnZXROYW1lID0gcGFydHMucG9wKCk7XG4gICAgY29uc3QgdGFyZ2V0U2NvcGUgPSBwYXJ0cy5qb2luKCcuJyk7XG4gICAgZGVmYXVsdHMucm91dGUoc291cmNlU2NvcGUsIHNvdXJjZU5hbWUsIHRhcmdldFNjb3BlLCB0YXJnZXROYW1lKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzSUNoYXJ0Q29tcG9uZW50KHByb3RvKSB7XG4gIHJldHVybiAnaWQnIGluIHByb3RvICYmICdkZWZhdWx0cycgaW4gcHJvdG87XG59XG4iLCAiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4vY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQgRWxlbWVudCBmcm9tICcuL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQgU2NhbGUgZnJvbSAnLi9jb3JlLnNjYWxlLmpzJztcbmltcG9ydCBUeXBlZFJlZ2lzdHJ5IGZyb20gJy4vY29yZS50eXBlZFJlZ2lzdHJ5LmpzJztcbmltcG9ydCB7ZWFjaCwgY2FsbGJhY2sgYXMgY2FsbCwgX2NhcGl0YWxpemV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcblxuLyoqXG4gKiBQbGVhc2UgdXNlIHRoZSBtb2R1bGUncyBkZWZhdWx0IGV4cG9ydCB3aGljaCBwcm92aWRlcyBhIHNpbmdsZXRvbiBpbnN0YW5jZVxuICogTm90ZTogY2xhc3MgaXMgZXhwb3J0ZWQgZm9yIHR5cGVkb2NcbiAqL1xuZXhwb3J0IGNsYXNzIFJlZ2lzdHJ5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jb250cm9sbGVycyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KERhdGFzZXRDb250cm9sbGVyLCAnZGF0YXNldHMnLCB0cnVlKTtcbiAgICB0aGlzLmVsZW1lbnRzID0gbmV3IFR5cGVkUmVnaXN0cnkoRWxlbWVudCwgJ2VsZW1lbnRzJyk7XG4gICAgdGhpcy5wbHVnaW5zID0gbmV3IFR5cGVkUmVnaXN0cnkoT2JqZWN0LCAncGx1Z2lucycpO1xuICAgIHRoaXMuc2NhbGVzID0gbmV3IFR5cGVkUmVnaXN0cnkoU2NhbGUsICdzY2FsZXMnKTtcbiAgICAvLyBPcmRlciBpcyBpbXBvcnRhbnQsIFNjYWxlIGhhcyBFbGVtZW50IGluIHByb3RvdHlwZSBjaGFpbixcbiAgICAvLyBzbyBTY2FsZXMgbXVzdCBiZSBiZWZvcmUgRWxlbWVudHMuIFBsdWdpbnMgYXJlIGEgZmFsbGJhY2ssIHNvIG5vdCBsaXN0ZWQgaGVyZS5cbiAgICB0aGlzLl90eXBlZFJlZ2lzdHJpZXMgPSBbdGhpcy5jb250cm9sbGVycywgdGhpcy5zY2FsZXMsIHRoaXMuZWxlbWVudHNdO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuXHQgKi9cbiAgYWRkKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MpO1xuICB9XG5cbiAgcmVtb3ZlKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4udHlwZW9mIERhdGFzZXRDb250cm9sbGVyfSBhcmdzXG5cdCAqL1xuICBhZGRDb250cm9sbGVycyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLmNvbnRyb2xsZXJzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi50eXBlb2YgRWxlbWVudH0gYXJnc1xuXHQgKi9cbiAgYWRkRWxlbWVudHMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5lbGVtZW50cyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4uYW55fSBhcmdzXG5cdCAqL1xuICBhZGRQbHVnaW5zKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMucGx1Z2lucyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4udHlwZW9mIFNjYWxlfSBhcmdzXG5cdCAqL1xuICBhZGRTY2FsZXMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5zY2FsZXMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuXHQgKiBAcmV0dXJucyB7dHlwZW9mIERhdGFzZXRDb250cm9sbGVyfVxuXHQgKi9cbiAgZ2V0Q29udHJvbGxlcihpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMuY29udHJvbGxlcnMsICdjb250cm9sbGVyJyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkXG5cdCAqIEByZXR1cm5zIHt0eXBlb2YgRWxlbWVudH1cblx0ICovXG4gIGdldEVsZW1lbnQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLmVsZW1lbnRzLCAnZWxlbWVudCcpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fVxuXHQgKi9cbiAgZ2V0UGx1Z2luKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5wbHVnaW5zLCAncGx1Z2luJyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkXG5cdCAqIEByZXR1cm5zIHt0eXBlb2YgU2NhbGV9XG5cdCAqL1xuICBnZXRTY2FsZShpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMuc2NhbGVzLCAnc2NhbGUnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi50eXBlb2YgRGF0YXNldENvbnRyb2xsZXJ9IGFyZ3Ncblx0ICovXG4gIHJlbW92ZUNvbnRyb2xsZXJzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5jb250cm9sbGVycyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4udHlwZW9mIEVsZW1lbnR9IGFyZ3Ncblx0ICovXG4gIHJlbW92ZUVsZW1lbnRzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5lbGVtZW50cyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4uYW55fSBhcmdzXG5cdCAqL1xuICByZW1vdmVQbHVnaW5zKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5wbHVnaW5zKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi50eXBlb2YgU2NhbGV9IGFyZ3Ncblx0ICovXG4gIHJlbW92ZVNjYWxlcyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuc2NhbGVzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2VhY2gobWV0aG9kLCBhcmdzLCB0eXBlZFJlZ2lzdHJ5KSB7XG4gICAgWy4uLmFyZ3NdLmZvckVhY2goYXJnID0+IHtcbiAgICAgIGNvbnN0IHJlZyA9IHR5cGVkUmVnaXN0cnkgfHwgdGhpcy5fZ2V0UmVnaXN0cnlGb3JUeXBlKGFyZyk7XG4gICAgICBpZiAodHlwZWRSZWdpc3RyeSB8fCByZWcuaXNGb3JUeXBlKGFyZykgfHwgKHJlZyA9PT0gdGhpcy5wbHVnaW5zICYmIGFyZy5pZCkpIHtcbiAgICAgICAgdGhpcy5fZXhlYyhtZXRob2QsIHJlZywgYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEhhbmRsZSBsb29wYWJsZSBhcmdzXG4gICAgICAgIC8vIFVzZSBjYXNlOlxuICAgICAgICAvLyAgaW1wb3J0ICogYXMgcGx1Z2lucyBmcm9tICcuL3BsdWdpbnMuanMnO1xuICAgICAgICAvLyAgQ2hhcnQucmVnaXN0ZXIocGx1Z2lucyk7XG4gICAgICAgIGVhY2goYXJnLCBpdGVtID0+IHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbWl4ZWQgdHlwZXMgaW4gdGhlIGxvb3BhYmxlLCBtYWtlIHN1cmUgdGhvc2UgYXJlXG4gICAgICAgICAgLy8gcmVnaXN0ZXJlZCBpbiBjb3JyZWN0IHJlZ2lzdHJ5XG4gICAgICAgICAgLy8gVXNlIGNhc2U6ICh0cmVlbWFwIGV4cG9ydGluZyBjb250cm9sbGVyLCBlbGVtZW50cyBldGMpXG4gICAgICAgICAgLy8gIGltcG9ydCAqIGFzIHRyZWVtYXAgZnJvbSAnY2hhcnRqcy1jaGFydC10cmVlbWFwLmpzJztcbiAgICAgICAgICAvLyAgQ2hhcnQucmVnaXN0ZXIodHJlZW1hcCk7XG5cbiAgICAgICAgICBjb25zdCBpdGVtUmVnID0gdHlwZWRSZWdpc3RyeSB8fCB0aGlzLl9nZXRSZWdpc3RyeUZvclR5cGUoaXRlbSk7XG4gICAgICAgICAgdGhpcy5fZXhlYyhtZXRob2QsIGl0ZW1SZWcsIGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2V4ZWMobWV0aG9kLCByZWdpc3RyeSwgY29tcG9uZW50KSB7XG4gICAgY29uc3QgY2FtZWxNZXRob2QgPSBfY2FwaXRhbGl6ZShtZXRob2QpO1xuICAgIGNhbGwoY29tcG9uZW50WydiZWZvcmUnICsgY2FtZWxNZXRob2RdLCBbXSwgY29tcG9uZW50KTsgLy8gYmVmb3JlUmVnaXN0ZXIgLyBiZWZvcmVVbnJlZ2lzdGVyXG4gICAgcmVnaXN0cnlbbWV0aG9kXShjb21wb25lbnQpO1xuICAgIGNhbGwoY29tcG9uZW50WydhZnRlcicgKyBjYW1lbE1ldGhvZF0sIFtdLCBjb21wb25lbnQpOyAvLyBhZnRlclJlZ2lzdGVyIC8gYWZ0ZXJVbnJlZ2lzdGVyXG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRSZWdpc3RyeUZvclR5cGUodHlwZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdHlwZWRSZWdpc3RyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZWcgPSB0aGlzLl90eXBlZFJlZ2lzdHJpZXNbaV07XG4gICAgICBpZiAocmVnLmlzRm9yVHlwZSh0eXBlKSkge1xuICAgICAgICByZXR1cm4gcmVnO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBwbHVnaW5zIGlzIHRoZSBmYWxsYmFjayByZWdpc3RyeVxuICAgIHJldHVybiB0aGlzLnBsdWdpbnM7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXQoaWQsIHR5cGVkUmVnaXN0cnksIHR5cGUpIHtcbiAgICBjb25zdCBpdGVtID0gdHlwZWRSZWdpc3RyeS5nZXQoaWQpO1xuICAgIGlmIChpdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgaWQgKyAnXCIgaXMgbm90IGEgcmVnaXN0ZXJlZCAnICsgdHlwZSArICcuJyk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xuICB9XG5cbn1cblxuLy8gc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgZGVmYXVsdCAvKiAjX19QVVJFX18gKi8gbmV3IFJlZ2lzdHJ5KCk7XG4iLCAiaW1wb3J0IHJlZ2lzdHJ5IGZyb20gJy4vY29yZS5yZWdpc3RyeS5qcyc7XG5pbXBvcnQge2NhbGxiYWNrIGFzIGNhbGxDYWxsYmFjaywgaXNOdWxsT3JVbmRlZiwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkNoYXJ0RXZlbnQgfSBDaGFydEV2ZW50XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vcGx1Z2lucy9wbHVnaW4udG9vbHRpcC5qcycpLmRlZmF1bHQgfSBUb29sdGlwXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgZmlsdGVyQ2FsbGJhY2tcbiAqIEBwYXJhbSB7e3BsdWdpbjogb2JqZWN0LCBvcHRpb25zOiBvYmplY3R9fSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleF1cbiAqIEBwYXJhbSB7YXJyYXl9IFthcnJheV1cbiAqIEBwYXJhbSB7b2JqZWN0fSBbdGhpc0FyZ11cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQbHVnaW5TZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5faW5pdCA9IFtdO1xuICB9XG5cbiAgLyoqXG5cdCAqIENhbGxzIGVuYWJsZWQgcGx1Z2lucyBmb3IgYGNoYXJ0YCBvbiB0aGUgc3BlY2lmaWVkIGhvb2sgYW5kIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG5cdCAqIFRoaXMgbWV0aG9kIGltbWVkaWF0ZWx5IHJldHVybnMgYXMgc29vbiBhcyBhIHBsdWdpbiBleHBsaWNpdGx5IHJldHVybnMgZmFsc2UuIFRoZVxuXHQgKiByZXR1cm5lZCB2YWx1ZSBjYW4gYmUgdXNlZCwgZm9yIGluc3RhbmNlLCB0byBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgYWN0aW9uLlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZSBmb3Igd2hpY2ggcGx1Z2lucyBzaG91bGQgYmUgY2FsbGVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaG9vayAtIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gbWV0aG9kIHRvIGNhbGwgKGUuZy4gJ2JlZm9yZVVwZGF0ZScpLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gW2FyZ3NdIC0gRXh0cmEgYXJndW1lbnRzIHRvIGFwcGx5IHRvIHRoZSBob29rIGNhbGwuXG4gICAqIEBwYXJhbSB7ZmlsdGVyQ2FsbGJhY2t9IFtmaWx0ZXJdIC0gRmlsdGVyaW5nIGZ1bmN0aW9uIGZvciBsaW1pdGluZyB3aGljaCBwbHVnaW5zIGFyZSBub3RpZmllZFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gZmFsc2UgaWYgYW55IG9mIHRoZSBwbHVnaW5zIHJldHVybiBmYWxzZSwgZWxzZSByZXR1cm5zIHRydWUuXG5cdCAqL1xuICBub3RpZnkoY2hhcnQsIGhvb2ssIGFyZ3MsIGZpbHRlcikge1xuICAgIGlmIChob29rID09PSAnYmVmb3JlSW5pdCcpIHtcbiAgICAgIHRoaXMuX2luaXQgPSB0aGlzLl9jcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgdHJ1ZSk7XG4gICAgICB0aGlzLl9ub3RpZnkodGhpcy5faW5pdCwgY2hhcnQsICdpbnN0YWxsJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSBmaWx0ZXIgPyB0aGlzLl9kZXNjcmlwdG9ycyhjaGFydCkuZmlsdGVyKGZpbHRlcikgOiB0aGlzLl9kZXNjcmlwdG9ycyhjaGFydCk7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fbm90aWZ5KGRlc2NyaXB0b3JzLCBjaGFydCwgaG9vaywgYXJncyk7XG5cbiAgICBpZiAoaG9vayA9PT0gJ2FmdGVyRGVzdHJveScpIHtcbiAgICAgIHRoaXMuX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsICdzdG9wJyk7XG4gICAgICB0aGlzLl9ub3RpZnkodGhpcy5faW5pdCwgY2hhcnQsICd1bmluc3RhbGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsIGhvb2ssIGFyZ3MpIHtcbiAgICBhcmdzID0gYXJncyB8fCB7fTtcbiAgICBmb3IgKGNvbnN0IGRlc2NyaXB0b3Igb2YgZGVzY3JpcHRvcnMpIHtcbiAgICAgIGNvbnN0IHBsdWdpbiA9IGRlc2NyaXB0b3IucGx1Z2luO1xuICAgICAgY29uc3QgbWV0aG9kID0gcGx1Z2luW2hvb2tdO1xuICAgICAgY29uc3QgcGFyYW1zID0gW2NoYXJ0LCBhcmdzLCBkZXNjcmlwdG9yLm9wdGlvbnNdO1xuICAgICAgaWYgKGNhbGxDYWxsYmFjayhtZXRob2QsIHBhcmFtcywgcGx1Z2luKSA9PT0gZmFsc2UgJiYgYXJncy5jYW5jZWxhYmxlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGludmFsaWRhdGUoKSB7XG4gICAgLy8gV2hlbiBwbHVnaW5zIGFyZSByZWdpc3RlcmVkLCB0aGVyZSBpcyB0aGUgcG9zc2liaWxpdHkgb2YgYSBkb3VibGVcbiAgICAvLyBpbnZhbGlkYXRlIHNpdHVhdGlvbi4gSW4gdGhpcyBjYXNlLCB3ZSBvbmx5IHdhbnQgdG8gaW52YWxpZGF0ZSBvbmNlLlxuICAgIC8vIElmIHdlIGludmFsaWRhdGUgbXVsdGlwbGUgdGltZXMsIHRoZSBgX29sZENhY2hlYCBpcyBsb3N0IGFuZCBhbGwgb2YgdGhlXG4gICAgLy8gcGx1Z2lucyBhcmUgcmVzdGFydGVkIHdpdGhvdXQgYmVpbmcgY29ycmVjdGx5IHN0b3BwZWQuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy84MTQ3XG4gICAgaWYgKCFpc051bGxPclVuZGVmKHRoaXMuX2NhY2hlKSkge1xuICAgICAgdGhpcy5fb2xkQ2FjaGUgPSB0aGlzLl9jYWNoZTtcbiAgICAgIHRoaXMuX2NhY2hlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2Rlc2NyaXB0b3JzKGNoYXJ0KSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGU7XG4gICAgfVxuXG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSB0aGlzLl9jYWNoZSA9IHRoaXMuX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0KTtcblxuICAgIHRoaXMuX25vdGlmeVN0YXRlQ2hhbmdlcyhjaGFydCk7XG5cbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gIH1cblxuICBfY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIGFsbCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IGNoYXJ0ICYmIGNoYXJ0LmNvbmZpZztcbiAgICBjb25zdCBvcHRpb25zID0gdmFsdWVPckRlZmF1bHQoY29uZmlnLm9wdGlvbnMgJiYgY29uZmlnLm9wdGlvbnMucGx1Z2lucywge30pO1xuICAgIGNvbnN0IHBsdWdpbnMgPSBhbGxQbHVnaW5zKGNvbmZpZyk7XG4gICAgLy8gb3B0aW9ucyA9PT0gZmFsc2UgPT4gYWxsIHBsdWdpbnMgYXJlIGRpc2FibGVkXG4gICAgcmV0dXJuIG9wdGlvbnMgPT09IGZhbHNlICYmICFhbGwgPyBbXSA6IGNyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCBwbHVnaW5zLCBvcHRpb25zLCBhbGwpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfbm90aWZ5U3RhdGVDaGFuZ2VzKGNoYXJ0KSB7XG4gICAgY29uc3QgcHJldmlvdXNEZXNjcmlwdG9ycyA9IHRoaXMuX29sZENhY2hlIHx8IFtdO1xuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gdGhpcy5fY2FjaGU7XG4gICAgY29uc3QgZGlmZiA9IChhLCBiKSA9PiBhLmZpbHRlcih4ID0+ICFiLnNvbWUoeSA9PiB4LnBsdWdpbi5pZCA9PT0geS5wbHVnaW4uaWQpKTtcbiAgICB0aGlzLl9ub3RpZnkoZGlmZihwcmV2aW91c0Rlc2NyaXB0b3JzLCBkZXNjcmlwdG9ycyksIGNoYXJ0LCAnc3RvcCcpO1xuICAgIHRoaXMuX25vdGlmeShkaWZmKGRlc2NyaXB0b3JzLCBwcmV2aW91c0Rlc2NyaXB0b3JzKSwgY2hhcnQsICdzdGFydCcpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vY29yZS5jb25maWcuanMnKS5kZWZhdWx0fSBjb25maWdcbiAqL1xuZnVuY3Rpb24gYWxsUGx1Z2lucyhjb25maWcpIHtcbiAgY29uc3QgbG9jYWxJZHMgPSB7fTtcbiAgY29uc3QgcGx1Z2lucyA9IFtdO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocmVnaXN0cnkucGx1Z2lucy5pdGVtcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHBsdWdpbnMucHVzaChyZWdpc3RyeS5nZXRQbHVnaW4oa2V5c1tpXSkpO1xuICB9XG5cbiAgY29uc3QgbG9jYWwgPSBjb25maWcucGx1Z2lucyB8fCBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBsdWdpbiA9IGxvY2FsW2ldO1xuXG4gICAgaWYgKHBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID09PSAtMSkge1xuICAgICAgcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgICBsb2NhbElkc1twbHVnaW4uaWRdID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge3BsdWdpbnMsIGxvY2FsSWRzfTtcbn1cblxuZnVuY3Rpb24gZ2V0T3B0cyhvcHRpb25zLCBhbGwpIHtcbiAgaWYgKCFhbGwgJiYgb3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHtwbHVnaW5zLCBsb2NhbElkc30sIG9wdGlvbnMsIGFsbCkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgY29udGV4dCA9IGNoYXJ0LmdldENvbnRleHQoKTtcblxuICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zKSB7XG4gICAgY29uc3QgaWQgPSBwbHVnaW4uaWQ7XG4gICAgY29uc3Qgb3B0cyA9IGdldE9wdHMob3B0aW9uc1tpZF0sIGFsbCk7XG4gICAgaWYgKG9wdHMgPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCh7XG4gICAgICBwbHVnaW4sXG4gICAgICBvcHRpb25zOiBwbHVnaW5PcHRzKGNoYXJ0LmNvbmZpZywge3BsdWdpbiwgbG9jYWw6IGxvY2FsSWRzW2lkXX0sIG9wdHMsIGNvbnRleHQpXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwbHVnaW5PcHRzKGNvbmZpZywge3BsdWdpbiwgbG9jYWx9LCBvcHRzLCBjb250ZXh0KSB7XG4gIGNvbnN0IGtleXMgPSBjb25maWcucGx1Z2luU2NvcGVLZXlzKHBsdWdpbik7XG4gIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXMob3B0cywga2V5cyk7XG4gIGlmIChsb2NhbCAmJiBwbHVnaW4uZGVmYXVsdHMpIHtcbiAgICAvLyBtYWtlIHN1cmUgcGx1Z2luIGRlZmF1bHRzIGFyZSBpbiBzY29wZXMgZm9yIGxvY2FsIChub3QgcmVnaXN0ZXJlZCkgcGx1Z2luc1xuICAgIHNjb3Blcy5wdXNoKHBsdWdpbi5kZWZhdWx0cyk7XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIFsnJ10sIHtcbiAgICAvLyBUaGVzZSBhcmUganVzdCBkZWZhdWx0cyB0aGF0IHBsdWdpbnMgY2FuIG92ZXJyaWRlXG4gICAgc2NyaXB0YWJsZTogZmFsc2UsXG4gICAgaW5kZXhhYmxlOiBmYWxzZSxcbiAgICBhbGxLZXlzOiB0cnVlXG4gIH0pO1xufVxuIiwgImltcG9ydCBkZWZhdWx0cywge292ZXJyaWRlcywgZGVzY3JpcHRvcnN9IGZyb20gJy4vY29yZS5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge21lcmdlSWYsIHJlc29sdmVPYmplY3RLZXksIGlzQXJyYXksIGlzRnVuY3Rpb24sIHZhbHVlT3JEZWZhdWx0LCBpc09iamVjdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtfYXR0YWNoQ29udGV4dCwgX2NyZWF0ZVJlc29sdmVyLCBfZGVzY3JpcHRvcnN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb25maWcuanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5kZXhBeGlzKHR5cGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgZGF0YXNldERlZmF1bHRzID0gZGVmYXVsdHMuZGF0YXNldHNbdHlwZV0gfHwge307XG4gIGNvbnN0IGRhdGFzZXRPcHRpb25zID0gKG9wdGlvbnMuZGF0YXNldHMgfHwge30pW3R5cGVdIHx8IHt9O1xuICByZXR1cm4gZGF0YXNldE9wdGlvbnMuaW5kZXhBeGlzIHx8IG9wdGlvbnMuaW5kZXhBeGlzIHx8IGRhdGFzZXREZWZhdWx0cy5pbmRleEF4aXMgfHwgJ3gnO1xufVxuXG5mdW5jdGlvbiBnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEKGlkLCBpbmRleEF4aXMpIHtcbiAgbGV0IGF4aXMgPSBpZDtcbiAgaWYgKGlkID09PSAnX2luZGV4XycpIHtcbiAgICBheGlzID0gaW5kZXhBeGlzO1xuICB9IGVsc2UgaWYgKGlkID09PSAnX3ZhbHVlXycpIHtcbiAgICBheGlzID0gaW5kZXhBeGlzID09PSAneCcgPyAneScgOiAneCc7XG4gIH1cbiAgcmV0dXJuIGF4aXM7XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRTY2FsZUlERnJvbUF4aXMoYXhpcywgaW5kZXhBeGlzKSB7XG4gIHJldHVybiBheGlzID09PSBpbmRleEF4aXMgPyAnX2luZGV4XycgOiAnX3ZhbHVlXyc7XG59XG5cbmZ1bmN0aW9uIGlkTWF0Y2hlc0F4aXMoaWQpIHtcbiAgaWYgKGlkID09PSAneCcgfHwgaWQgPT09ICd5JyB8fCBpZCA9PT0gJ3InKSB7XG4gICAgcmV0dXJuIGlkO1xuICB9XG59XG5cbmZ1bmN0aW9uIGF4aXNGcm9tUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgaWYgKHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICByZXR1cm4gJ3gnO1xuICB9XG4gIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgcmV0dXJuICd5JztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5lQXhpcyhpZCwgLi4uc2NhbGVPcHRpb25zKSB7XG4gIGlmIChpZE1hdGNoZXNBeGlzKGlkKSkge1xuICAgIHJldHVybiBpZDtcbiAgfVxuICBmb3IgKGNvbnN0IG9wdHMgb2Ygc2NhbGVPcHRpb25zKSB7XG4gICAgY29uc3QgYXhpcyA9IG9wdHMuYXhpc1xuICAgICAgfHwgYXhpc0Zyb21Qb3NpdGlvbihvcHRzLnBvc2l0aW9uKVxuICAgICAgfHwgaWQubGVuZ3RoID4gMSAmJiBpZE1hdGNoZXNBeGlzKGlkWzBdLnRvTG93ZXJDYXNlKCkpO1xuICAgIGlmIChheGlzKSB7XG4gICAgICByZXR1cm4gYXhpcztcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZGV0ZXJtaW5lIHR5cGUgb2YgJyR7aWR9JyBheGlzLiBQbGVhc2UgcHJvdmlkZSAnYXhpcycgb3IgJ3Bvc2l0aW9uJyBvcHRpb24uYCk7XG59XG5cbmZ1bmN0aW9uIGdldEF4aXNGcm9tRGF0YXNldChpZCwgYXhpcywgZGF0YXNldCkge1xuICBpZiAoZGF0YXNldFtheGlzICsgJ0F4aXNJRCddID09PSBpZCkge1xuICAgIHJldHVybiB7YXhpc307XG4gIH1cbn1cblxuZnVuY3Rpb24gcmV0cmlldmVBeGlzRnJvbURhdGFzZXRzKGlkLCBjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5kYXRhICYmIGNvbmZpZy5kYXRhLmRhdGFzZXRzKSB7XG4gICAgY29uc3QgYm91bmREcyA9IGNvbmZpZy5kYXRhLmRhdGFzZXRzLmZpbHRlcigoZCkgPT4gZC54QXhpc0lEID09PSBpZCB8fCBkLnlBeGlzSUQgPT09IGlkKTtcbiAgICBpZiAoYm91bmREcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBnZXRBeGlzRnJvbURhdGFzZXQoaWQsICd4JywgYm91bmREc1swXSkgfHwgZ2V0QXhpc0Zyb21EYXRhc2V0KGlkLCAneScsIGJvdW5kRHNbMF0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge307XG59XG5cbmZ1bmN0aW9uIG1lcmdlU2NhbGVDb25maWcoY29uZmlnLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNoYXJ0RGVmYXVsdHMgPSBvdmVycmlkZXNbY29uZmlnLnR5cGVdIHx8IHtzY2FsZXM6IHt9fTtcbiAgY29uc3QgY29uZmlnU2NhbGVzID0gb3B0aW9ucy5zY2FsZXMgfHwge307XG4gIGNvbnN0IGNoYXJ0SW5kZXhBeGlzID0gZ2V0SW5kZXhBeGlzKGNvbmZpZy50eXBlLCBvcHRpb25zKTtcbiAgY29uc3Qgc2NhbGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvLyBGaXJzdCBmaWd1cmUgb3V0IGZpcnN0IHNjYWxlIGlkJ3MgcGVyIGF4aXMuXG4gIE9iamVjdC5rZXlzKGNvbmZpZ1NjYWxlcykuZm9yRWFjaChpZCA9PiB7XG4gICAgY29uc3Qgc2NhbGVDb25mID0gY29uZmlnU2NhbGVzW2lkXTtcbiAgICBpZiAoIWlzT2JqZWN0KHNjYWxlQ29uZikpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKGBJbnZhbGlkIHNjYWxlIGNvbmZpZ3VyYXRpb24gZm9yIHNjYWxlOiAke2lkfWApO1xuICAgIH1cbiAgICBpZiAoc2NhbGVDb25mLl9wcm94eSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihgSWdub3JpbmcgcmVzb2x2ZXIgcGFzc2VkIGFzIG9wdGlvbnMgZm9yIHNjYWxlOiAke2lkfWApO1xuICAgIH1cbiAgICBjb25zdCBheGlzID0gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVDb25mLCByZXRyaWV2ZUF4aXNGcm9tRGF0YXNldHMoaWQsIGNvbmZpZyksIGRlZmF1bHRzLnNjYWxlc1tzY2FsZUNvbmYudHlwZV0pO1xuICAgIGNvbnN0IGRlZmF1bHRJZCA9IGdldERlZmF1bHRTY2FsZUlERnJvbUF4aXMoYXhpcywgY2hhcnRJbmRleEF4aXMpO1xuICAgIGNvbnN0IGRlZmF1bHRTY2FsZU9wdGlvbnMgPSBjaGFydERlZmF1bHRzLnNjYWxlcyB8fCB7fTtcbiAgICBzY2FsZXNbaWRdID0gbWVyZ2VJZihPYmplY3QuY3JlYXRlKG51bGwpLCBbe2F4aXN9LCBzY2FsZUNvbmYsIGRlZmF1bHRTY2FsZU9wdGlvbnNbYXhpc10sIGRlZmF1bHRTY2FsZU9wdGlvbnNbZGVmYXVsdElkXV0pO1xuICB9KTtcblxuICAvLyBUaGVuIG1lcmdlIGRhdGFzZXQgZGVmYXVsdHMgdG8gc2NhbGUgY29uZmlnc1xuICBjb25maWcuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKGRhdGFzZXQgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBkYXRhc2V0LnR5cGUgfHwgY29uZmlnLnR5cGU7XG4gICAgY29uc3QgaW5kZXhBeGlzID0gZGF0YXNldC5pbmRleEF4aXMgfHwgZ2V0SW5kZXhBeGlzKHR5cGUsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGRhdGFzZXREZWZhdWx0cyA9IG92ZXJyaWRlc1t0eXBlXSB8fCB7fTtcbiAgICBjb25zdCBkZWZhdWx0U2NhbGVPcHRpb25zID0gZGF0YXNldERlZmF1bHRzLnNjYWxlcyB8fCB7fTtcbiAgICBPYmplY3Qua2V5cyhkZWZhdWx0U2NhbGVPcHRpb25zKS5mb3JFYWNoKGRlZmF1bHRJRCA9PiB7XG4gICAgICBjb25zdCBheGlzID0gZ2V0QXhpc0Zyb21EZWZhdWx0U2NhbGVJRChkZWZhdWx0SUQsIGluZGV4QXhpcyk7XG4gICAgICBjb25zdCBpZCA9IGRhdGFzZXRbYXhpcyArICdBeGlzSUQnXSB8fCBheGlzO1xuICAgICAgc2NhbGVzW2lkXSA9IHNjYWxlc1tpZF0gfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIG1lcmdlSWYoc2NhbGVzW2lkXSwgW3theGlzfSwgY29uZmlnU2NhbGVzW2lkXSwgZGVmYXVsdFNjYWxlT3B0aW9uc1tkZWZhdWx0SURdXSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGFwcGx5IHNjYWxlIGRlZmF1bHRzLCBpZiBub3Qgb3ZlcnJpZGRlbiBieSBkYXRhc2V0IGRlZmF1bHRzXG4gIE9iamVjdC5rZXlzKHNjYWxlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgIGNvbnN0IHNjYWxlID0gc2NhbGVzW2tleV07XG4gICAgbWVyZ2VJZihzY2FsZSwgW2RlZmF1bHRzLnNjYWxlc1tzY2FsZS50eXBlXSwgZGVmYXVsdHMuc2NhbGVdKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHNjYWxlcztcbn1cblxuZnVuY3Rpb24gaW5pdE9wdGlvbnMoY29uZmlnKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBjb25maWcub3B0aW9ucyB8fCAoY29uZmlnLm9wdGlvbnMgPSB7fSk7XG5cbiAgb3B0aW9ucy5wbHVnaW5zID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5wbHVnaW5zLCB7fSk7XG4gIG9wdGlvbnMuc2NhbGVzID0gbWVyZ2VTY2FsZUNvbmZpZyhjb25maWcsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YShkYXRhKSB7XG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuICBkYXRhLmRhdGFzZXRzID0gZGF0YS5kYXRhc2V0cyB8fCBbXTtcbiAgZGF0YS5sYWJlbHMgPSBkYXRhLmxhYmVscyB8fCBbXTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGluaXRDb25maWcoY29uZmlnKSB7XG4gIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgY29uZmlnLmRhdGEgPSBpbml0RGF0YShjb25maWcuZGF0YSk7XG5cbiAgaW5pdE9wdGlvbnMoY29uZmlnKTtcblxuICByZXR1cm4gY29uZmlnO1xufVxuXG5jb25zdCBrZXlDYWNoZSA9IG5ldyBNYXAoKTtcbmNvbnN0IGtleXNDYWNoZWQgPSBuZXcgU2V0KCk7XG5cbmZ1bmN0aW9uIGNhY2hlZEtleXMoY2FjaGVLZXksIGdlbmVyYXRlKSB7XG4gIGxldCBrZXlzID0ga2V5Q2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFrZXlzKSB7XG4gICAga2V5cyA9IGdlbmVyYXRlKCk7XG4gICAga2V5Q2FjaGUuc2V0KGNhY2hlS2V5LCBrZXlzKTtcbiAgICBrZXlzQ2FjaGVkLmFkZChrZXlzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuY29uc3QgYWRkSWZGb3VuZCA9IChzZXQsIG9iaiwga2V5KSA9PiB7XG4gIGNvbnN0IG9wdHMgPSByZXNvbHZlT2JqZWN0S2V5KG9iaiwga2V5KTtcbiAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHNldC5hZGQob3B0cyk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbmZpZyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuX2NvbmZpZyA9IGluaXRDb25maWcoY29uZmlnKTtcbiAgICB0aGlzLl9zY29wZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3Jlc29sdmVyQ2FjaGUgPSBuZXcgTWFwKCk7XG4gIH1cblxuICBnZXQgcGxhdGZvcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5wbGF0Zm9ybTtcbiAgfVxuXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcudHlwZTtcbiAgfVxuXG4gIHNldCB0eXBlKHR5cGUpIHtcbiAgICB0aGlzLl9jb25maWcudHlwZSA9IHR5cGU7XG4gIH1cblxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLmRhdGE7XG4gIH1cblxuICBzZXQgZGF0YShkYXRhKSB7XG4gICAgdGhpcy5fY29uZmlnLmRhdGEgPSBpbml0RGF0YShkYXRhKTtcbiAgfVxuXG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcub3B0aW9ucztcbiAgfVxuXG4gIHNldCBvcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9jb25maWcub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICBnZXQgcGx1Z2lucygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnBsdWdpbnM7XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5fY29uZmlnO1xuICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuICAgIGluaXRPcHRpb25zKGNvbmZpZyk7XG4gIH1cblxuICBjbGVhckNhY2hlKCkge1xuICAgIHRoaXMuX3Njb3BlQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLl9yZXNvbHZlckNhY2hlLmNsZWFyKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3B0aW9uIHNjb3BlIGtleXMgZm9yIHJlc29sdmluZyBkYXRhc2V0IG9wdGlvbnMuXG4gICAqIFRoZXNlIGtleXMgZG8gbm90IGluY2x1ZGUgdGhlIGRhdGFzZXQgaXRzZWxmLCBiZWNhdXNlIGl0IGlzIG5vdCB1bmRlciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YXNldFR5cGVcbiAgICogQHJldHVybiB7c3RyaW5nW11bXX1cbiAgICovXG4gIGRhdGFzZXRTY29wZUtleXMoZGF0YXNldFR5cGUpIHtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhkYXRhc2V0VHlwZSxcbiAgICAgICgpID0+IFtbXG4gICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfWAsXG4gICAgICAgICcnXG4gICAgICBdXSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3B0aW9uIHNjb3BlIGtleXMgZm9yIHJlc29sdmluZyBkYXRhc2V0IGFuaW1hdGlvbiBvcHRpb25zLlxuICAgKiBUaGVzZSBrZXlzIGRvIG5vdCBpbmNsdWRlIHRoZSBkYXRhc2V0IGl0c2VsZiwgYmVjYXVzZSBpdCBpcyBub3QgdW5kZXIgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFzZXRUeXBlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc2l0aW9uXG4gICAqIEByZXR1cm4ge3N0cmluZ1tdW119XG4gICAqL1xuICBkYXRhc2V0QW5pbWF0aW9uU2NvcGVLZXlzKGRhdGFzZXRUeXBlLCB0cmFuc2l0aW9uKSB7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7ZGF0YXNldFR5cGV9LnRyYW5zaXRpb24uJHt0cmFuc2l0aW9ufWAsXG4gICAgICAoKSA9PiBbXG4gICAgICAgIFtcbiAgICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX0udHJhbnNpdGlvbnMuJHt0cmFuc2l0aW9ufWAsXG4gICAgICAgICAgYHRyYW5zaXRpb25zLiR7dHJhbnNpdGlvbn1gLFxuICAgICAgICBdLFxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGFyZSB1c2VkIGZvciBsb29raW5nIHVwIHRoZSBgYW5pbWF0aW9uc2AgYW5kIGBhbmltYXRpb25gIGtleXNcbiAgICAgICAgW1xuICAgICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfWAsXG4gICAgICAgICAgJydcbiAgICAgICAgXVxuICAgICAgXSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3B0aW9ucyBzY29wZSBrZXlzIGZvciByZXNvbHZpbmcgZWxlbWVudCBvcHRpb25zIHRoYXQgYmVsb25nXG4gICAqIHRvIGFuIGRhdGFzZXQuIFRoZXNlIGtleXMgZG8gbm90IGluY2x1ZGUgdGhlIGRhdGFzZXQgaXRzZWxmLCBiZWNhdXNlIGl0XG4gICAqIGlzIG5vdCB1bmRlciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YXNldFR5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnRUeXBlXG4gICAqIEByZXR1cm4ge3N0cmluZ1tdW119XG4gICAqL1xuICBkYXRhc2V0RWxlbWVudFNjb3BlS2V5cyhkYXRhc2V0VHlwZSwgZWxlbWVudFR5cGUpIHtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHtkYXRhc2V0VHlwZX0tJHtlbGVtZW50VHlwZX1gLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9LmVsZW1lbnRzLiR7ZWxlbWVudFR5cGV9YCxcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgYGVsZW1lbnRzLiR7ZWxlbWVudFR5cGV9YCxcbiAgICAgICAgJydcbiAgICAgIF1dKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcHRpb25zIHNjb3BlIGtleXMgZm9yIHJlc29sdmluZyBwbHVnaW4gb3B0aW9ucy5cbiAgICogQHBhcmFtIHt7aWQ6IHN0cmluZywgYWRkaXRpb25hbE9wdGlvblNjb3Blcz86IHN0cmluZ1tdfX0gcGx1Z2luXG4gICAqIEByZXR1cm4ge3N0cmluZ1tdW119XG4gICAqL1xuICBwbHVnaW5TY29wZUtleXMocGx1Z2luKSB7XG4gICAgY29uc3QgaWQgPSBwbHVnaW4uaWQ7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMudHlwZTtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHt0eXBlfS1wbHVnaW4tJHtpZH1gLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYHBsdWdpbnMuJHtpZH1gLFxuICAgICAgICAuLi5wbHVnaW4uYWRkaXRpb25hbE9wdGlvblNjb3BlcyB8fCBbXSxcbiAgICAgIF1dKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NhY2hlZFNjb3BlcyhtYWluU2NvcGUsIHJlc2V0Q2FjaGUpIHtcbiAgICBjb25zdCBfc2NvcGVDYWNoZSA9IHRoaXMuX3Njb3BlQ2FjaGU7XG4gICAgbGV0IGNhY2hlID0gX3Njb3BlQ2FjaGUuZ2V0KG1haW5TY29wZSk7XG4gICAgaWYgKCFjYWNoZSB8fCByZXNldENhY2hlKSB7XG4gICAgICBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgIF9zY29wZUNhY2hlLnNldChtYWluU2NvcGUsIGNhY2hlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIHRoZSBvYmplY3RzIGZyb20gb3B0aW9ucyBhbmQgZGVmYXVsdHMgZm9yIG9wdGlvbiB2YWx1ZSByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbWFpblNjb3BlIC0gVGhlIG1haW4gc2NvcGUgb2JqZWN0IGZvciBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nW11bXX0ga2V5TGlzdHMgLSBUaGUgYXJyYXlzIG9mIGtleXMgaW4gcmVzb2x1dGlvbiBvcmRlclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNldENhY2hlXSAtIHJlc2V0IHRoZSBjYWNoZSBmb3IgdGhpcyBtYWluU2NvcGVcbiAgICovXG4gIGdldE9wdGlvblNjb3BlcyhtYWluU2NvcGUsIGtleUxpc3RzLCByZXNldENhY2hlKSB7XG4gICAgY29uc3Qge29wdGlvbnMsIHR5cGV9ID0gdGhpcztcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZFNjb3BlcyhtYWluU2NvcGUsIHJlc2V0Q2FjaGUpO1xuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChrZXlMaXN0cyk7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG5cbiAgICBjb25zdCBzY29wZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBrZXlMaXN0cy5mb3JFYWNoKGtleXMgPT4ge1xuICAgICAgaWYgKG1haW5TY29wZSkge1xuICAgICAgICBzY29wZXMuYWRkKG1haW5TY29wZSk7XG4gICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIG1haW5TY29wZSwga2V5KSk7XG4gICAgICB9XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBvcHRpb25zLCBrZXkpKTtcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIG92ZXJyaWRlc1t0eXBlXSB8fCB7fSwga2V5KSk7XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBkZWZhdWx0cywga2V5KSk7XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBkZXNjcmlwdG9ycywga2V5KSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBhcnJheSA9IEFycmF5LmZyb20oc2NvcGVzKTtcbiAgICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICBhcnJheS5wdXNoKE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgIH1cbiAgICBpZiAoa2V5c0NhY2hlZC5oYXMoa2V5TGlzdHMpKSB7XG4gICAgICBjYWNoZS5zZXQoa2V5TGlzdHMsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wdGlvbiBzY29wZXMgZm9yIHJlc29sdmluZyBjaGFydCBvcHRpb25zXG4gICAqIEByZXR1cm4ge29iamVjdFtdfVxuICAgKi9cbiAgY2hhcnRPcHRpb25TY29wZXMoKSB7XG4gICAgY29uc3Qge29wdGlvbnMsIHR5cGV9ID0gdGhpcztcblxuICAgIHJldHVybiBbXG4gICAgICBvcHRpb25zLFxuICAgICAgb3ZlcnJpZGVzW3R5cGVdIHx8IHt9LFxuICAgICAgZGVmYXVsdHMuZGF0YXNldHNbdHlwZV0gfHwge30sIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy84NTMxXG4gICAgICB7dHlwZX0sXG4gICAgICBkZWZhdWx0cyxcbiAgICAgIGRlc2NyaXB0b3JzXG4gICAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdFtdfSBzY29wZXNcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gbmFtZXNcbiAgICogQHBhcmFtIHtmdW5jdGlvbnxvYmplY3R9IGNvbnRleHRcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gW3ByZWZpeGVzXVxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqL1xuICByZXNvbHZlTmFtZWRPcHRpb25zKHNjb3BlcywgbmFtZXMsIGNvbnRleHQsIHByZWZpeGVzID0gWycnXSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHskc2hhcmVkOiB0cnVlfTtcbiAgICBjb25zdCB7cmVzb2x2ZXIsIHN1YlByZWZpeGVzfSA9IGdldFJlc29sdmVyKHRoaXMuX3Jlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpO1xuICAgIGxldCBvcHRpb25zID0gcmVzb2x2ZXI7XG4gICAgaWYgKG5lZWRDb250ZXh0KHJlc29sdmVyLCBuYW1lcykpIHtcbiAgICAgIHJlc3VsdC4kc2hhcmVkID0gZmFsc2U7XG4gICAgICBjb250ZXh0ID0gaXNGdW5jdGlvbihjb250ZXh0KSA/IGNvbnRleHQoKSA6IGNvbnRleHQ7XG4gICAgICAvLyBzdWJSZXNvbHZlciBpcyBwYXNzZWQgdG8gc2NyaXB0YWJsZSBvcHRpb25zLiBJdCBzaG91bGQgbm90IHJlc29sdmUgdG8gaG92ZXIgb3B0aW9ucy5cbiAgICAgIGNvbnN0IHN1YlJlc29sdmVyID0gdGhpcy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIHN1YlByZWZpeGVzKTtcbiAgICAgIG9wdGlvbnMgPSBfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgY29udGV4dCwgc3ViUmVzb2x2ZXIpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBuYW1lcykge1xuICAgICAgcmVzdWx0W3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdFtdfSBzY29wZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XVxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbcHJlZml4ZXNdXG4gICAqIEBwYXJhbSB7e3NjcmlwdGFibGU6IGJvb2xlYW4sIGluZGV4YWJsZTogYm9vbGVhbiwgYWxsS2V5cz86IGJvb2xlYW59fSBbZGVzY3JpcHRvckRlZmF1bHRzXVxuICAgKi9cbiAgY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBwcmVmaXhlcyA9IFsnJ10sIGRlc2NyaXB0b3JEZWZhdWx0cykge1xuICAgIGNvbnN0IHtyZXNvbHZlcn0gPSBnZXRSZXNvbHZlcih0aGlzLl9yZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKTtcbiAgICByZXR1cm4gaXNPYmplY3QoY29udGV4dClcbiAgICAgID8gX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIGNvbnRleHQsIHVuZGVmaW5lZCwgZGVzY3JpcHRvckRlZmF1bHRzKVxuICAgICAgOiByZXNvbHZlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZXNvbHZlcihyZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKSB7XG4gIGxldCBjYWNoZSA9IHJlc29sdmVyQ2FjaGUuZ2V0KHNjb3Blcyk7XG4gIGlmICghY2FjaGUpIHtcbiAgICBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICByZXNvbHZlckNhY2hlLnNldChzY29wZXMsIGNhY2hlKTtcbiAgfVxuICBjb25zdCBjYWNoZUtleSA9IHByZWZpeGVzLmpvaW4oKTtcbiAgbGV0IGNhY2hlZCA9IGNhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmICghY2FjaGVkKSB7XG4gICAgY29uc3QgcmVzb2x2ZXIgPSBfY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgY2FjaGVkID0ge1xuICAgICAgcmVzb2x2ZXIsXG4gICAgICBzdWJQcmVmaXhlczogcHJlZml4ZXMuZmlsdGVyKHAgPT4gIXAudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnaG92ZXInKSlcbiAgICB9O1xuICAgIGNhY2hlLnNldChjYWNoZUtleSwgY2FjaGVkKTtcbiAgfVxuICByZXR1cm4gY2FjaGVkO1xufVxuXG5jb25zdCBoYXNGdW5jdGlvbiA9IHZhbHVlID0+IGlzT2JqZWN0KHZhbHVlKVxuICAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSkuc29tZSgoa2V5KSA9PiBpc0Z1bmN0aW9uKHZhbHVlW2tleV0pKTtcblxuZnVuY3Rpb24gbmVlZENvbnRleHQocHJveHksIG5hbWVzKSB7XG4gIGNvbnN0IHtpc1NjcmlwdGFibGUsIGlzSW5kZXhhYmxlfSA9IF9kZXNjcmlwdG9ycyhwcm94eSk7XG5cbiAgZm9yIChjb25zdCBwcm9wIG9mIG5hbWVzKSB7XG4gICAgY29uc3Qgc2NyaXB0YWJsZSA9IGlzU2NyaXB0YWJsZShwcm9wKTtcbiAgICBjb25zdCBpbmRleGFibGUgPSBpc0luZGV4YWJsZShwcm9wKTtcbiAgICBjb25zdCB2YWx1ZSA9IChpbmRleGFibGUgfHwgc2NyaXB0YWJsZSkgJiYgcHJveHlbcHJvcF07XG4gICAgaWYgKChzY3JpcHRhYmxlICYmIChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBoYXNGdW5jdGlvbih2YWx1ZSkpKVxuICAgICAgfHwgKGluZGV4YWJsZSAmJiBpc0FycmF5KHZhbHVlKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4iLCAiaW1wb3J0IGFuaW1hdG9yIGZyb20gJy4vY29yZS5hbmltYXRvci5qcyc7XG5pbXBvcnQgZGVmYXVsdHMsIHtvdmVycmlkZXN9IGZyb20gJy4vY29yZS5kZWZhdWx0cy5qcyc7XG5pbXBvcnQgSW50ZXJhY3Rpb24gZnJvbSAnLi9jb3JlLmludGVyYWN0aW9uLmpzJztcbmltcG9ydCBsYXlvdXRzIGZyb20gJy4vY29yZS5sYXlvdXRzLmpzJztcbmltcG9ydCB7X2RldGVjdFBsYXRmb3JtfSBmcm9tICcuLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5pbXBvcnQgUGx1Z2luU2VydmljZSBmcm9tICcuL2NvcmUucGx1Z2lucy5qcyc7XG5pbXBvcnQgcmVnaXN0cnkgZnJvbSAnLi9jb3JlLnJlZ2lzdHJ5LmpzJztcbmltcG9ydCBDb25maWcsIHtkZXRlcm1pbmVBeGlzLCBnZXRJbmRleEF4aXN9IGZyb20gJy4vY29yZS5jb25maWcuanMnO1xuaW1wb3J0IHtyZXRpbmFTY2FsZSwgX2lzRG9tU3VwcG9ydGVkfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZG9tLmpzJztcbmltcG9ydCB7ZWFjaCwgY2FsbGJhY2sgYXMgY2FsbENhbGxiYWNrLCB1aWQsIHZhbHVlT3JEZWZhdWx0LCBfZWxlbWVudHNFcXVhbCwgaXNOdWxsT3JVbmRlZiwgc2V0c0VxdWFsLCBkZWZpbmVkLCBpc0Z1bmN0aW9uLCBfaXNDbGlja0V2ZW50fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2NsZWFyQ2FudmFzLCBjbGlwQXJlYSwgY3JlYXRlQ29udGV4dCwgdW5jbGlwQXJlYSwgX2lzUG9pbnRJbkFyZWF9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHt2ZXJzaW9ufSBmcm9tICcuLi8uLi9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHtkZWJvdW5jZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQ2hhcnRFdmVudCB9IENoYXJ0RXZlbnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLlBvaW50IH0gUG9pbnRcbiAqL1xuXG5jb25zdCBLTk9XTl9QT1NJVElPTlMgPSBbJ3RvcCcsICdib3R0b20nLCAnbGVmdCcsICdyaWdodCcsICdjaGFydEFyZWEnXTtcbmZ1bmN0aW9uIHBvc2l0aW9uSXNIb3Jpem9udGFsKHBvc2l0aW9uLCBheGlzKSB7XG4gIHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nIHx8IChLTk9XTl9QT1NJVElPTlMuaW5kZXhPZihwb3NpdGlvbikgPT09IC0xICYmIGF4aXMgPT09ICd4Jyk7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmUyTGV2ZWwobDEsIGwyKSB7XG4gIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGFbbDFdID09PSBiW2wxXVxuICAgICAgPyBhW2wyXSAtIGJbbDJdXG4gICAgICA6IGFbbDFdIC0gYltsMV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9uQW5pbWF0aW9uc0NvbXBsZXRlKGNvbnRleHQpIHtcbiAgY29uc3QgY2hhcnQgPSBjb250ZXh0LmNoYXJ0O1xuICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gY2hhcnQub3B0aW9ucy5hbmltYXRpb247XG5cbiAgY2hhcnQubm90aWZ5UGx1Z2lucygnYWZ0ZXJSZW5kZXInKTtcbiAgY2FsbENhbGxiYWNrKGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5vbkNvbXBsZXRlLCBbY29udGV4dF0sIGNoYXJ0KTtcbn1cblxuZnVuY3Rpb24gb25BbmltYXRpb25Qcm9ncmVzcyhjb250ZXh0KSB7XG4gIGNvbnN0IGNoYXJ0ID0gY29udGV4dC5jaGFydDtcbiAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uO1xuICBjYWxsQ2FsbGJhY2soYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLm9uUHJvZ3Jlc3MsIFtjb250ZXh0XSwgY2hhcnQpO1xufVxuXG4vKipcbiAqIENoYXJ0LmpzIGNhbiB0YWtlIGEgc3RyaW5nIGlkIG9mIGEgY2FudmFzIGVsZW1lbnQsIGEgMmQgY29udGV4dCwgb3IgYSBjYW52YXMgZWxlbWVudCBpdHNlbGYuXG4gKiBBdHRlbXB0IHRvIHVud3JhcCB0aGUgaXRlbSBwYXNzZWQgaW50byB0aGUgY2hhcnQgY29uc3RydWN0b3Igc28gdGhhdCBpdCBpcyBhIGNhbnZhcyBlbGVtZW50IChpZiBwb3NzaWJsZSkuXG4gKi9cbmZ1bmN0aW9uIGdldENhbnZhcyhpdGVtKSB7XG4gIGlmIChfaXNEb21TdXBwb3J0ZWQoKSAmJiB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICBpdGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaXRlbSk7XG4gIH0gZWxzZSBpZiAoaXRlbSAmJiBpdGVtLmxlbmd0aCkge1xuICAgIC8vIFN1cHBvcnQgZm9yIGFycmF5IGJhc2VkIHF1ZXJpZXMgKHN1Y2ggYXMgalF1ZXJ5KVxuICAgIGl0ZW0gPSBpdGVtWzBdO1xuICB9XG5cbiAgaWYgKGl0ZW0gJiYgaXRlbS5jYW52YXMpIHtcbiAgICAvLyBTdXBwb3J0IGZvciBhbnkgb2JqZWN0IGFzc29jaWF0ZWQgdG8gYSBjYW52YXMgKGluY2x1ZGluZyBhIGNvbnRleHQyZClcbiAgICBpdGVtID0gaXRlbS5jYW52YXM7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59XG5cbmNvbnN0IGluc3RhbmNlcyA9IHt9O1xuY29uc3QgZ2V0Q2hhcnQgPSAoa2V5KSA9PiB7XG4gIGNvbnN0IGNhbnZhcyA9IGdldENhbnZhcyhrZXkpO1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhpbnN0YW5jZXMpLmZpbHRlcigoYykgPT4gYy5jYW52YXMgPT09IGNhbnZhcykucG9wKCk7XG59O1xuXG5mdW5jdGlvbiBtb3ZlTnVtZXJpY0tleXMob2JqLCBzdGFydCwgbW92ZSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGNvbnN0IGludEtleSA9ICtrZXk7XG4gICAgaWYgKGludEtleSA+PSBzdGFydCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgIGlmIChtb3ZlID4gMCB8fCBpbnRLZXkgPiBzdGFydCkge1xuICAgICAgICBvYmpbaW50S2V5ICsgbW92ZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoYXJ0RXZlbnR9IGVcbiAqIEBwYXJhbSB7Q2hhcnRFdmVudHxudWxsfSBsYXN0RXZlbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5DaGFydEFyZWFcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNDbGlja1xuICogQHJldHVybnMge0NoYXJ0RXZlbnR8bnVsbH1cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lTGFzdEV2ZW50KGUsIGxhc3RFdmVudCwgaW5DaGFydEFyZWEsIGlzQ2xpY2spIHtcbiAgaWYgKCFpbkNoYXJ0QXJlYSB8fCBlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoaXNDbGljaykge1xuICAgIHJldHVybiBsYXN0RXZlbnQ7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5cbmZ1bmN0aW9uIGdldFNpemVGb3JBcmVhKHNjYWxlLCBjaGFydEFyZWEsIGZpZWxkKSB7XG4gIHJldHVybiBzY2FsZS5vcHRpb25zLmNsaXAgPyBzY2FsZVtmaWVsZF0gOiBjaGFydEFyZWFbZmllbGRdO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhc2V0QXJlYShtZXRhLCBjaGFydEFyZWEpIHtcbiAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gIGlmICh4U2NhbGUgJiYgeVNjYWxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGdldFNpemVGb3JBcmVhKHhTY2FsZSwgY2hhcnRBcmVhLCAnbGVmdCcpLFxuICAgICAgcmlnaHQ6IGdldFNpemVGb3JBcmVhKHhTY2FsZSwgY2hhcnRBcmVhLCAncmlnaHQnKSxcbiAgICAgIHRvcDogZ2V0U2l6ZUZvckFyZWEoeVNjYWxlLCBjaGFydEFyZWEsICd0b3AnKSxcbiAgICAgIGJvdHRvbTogZ2V0U2l6ZUZvckFyZWEoeVNjYWxlLCBjaGFydEFyZWEsICdib3R0b20nKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGNoYXJ0QXJlYTtcbn1cblxuY2xhc3MgQ2hhcnQge1xuXG4gIHN0YXRpYyBkZWZhdWx0cyA9IGRlZmF1bHRzO1xuICBzdGF0aWMgaW5zdGFuY2VzID0gaW5zdGFuY2VzO1xuICBzdGF0aWMgb3ZlcnJpZGVzID0gb3ZlcnJpZGVzO1xuICBzdGF0aWMgcmVnaXN0cnkgPSByZWdpc3RyeTtcbiAgc3RhdGljIHZlcnNpb24gPSB2ZXJzaW9uO1xuICBzdGF0aWMgZ2V0Q2hhcnQgPSBnZXRDaGFydDtcblxuICBzdGF0aWMgcmVnaXN0ZXIoLi4uaXRlbXMpIHtcbiAgICByZWdpc3RyeS5hZGQoLi4uaXRlbXMpO1xuICAgIGludmFsaWRhdGVQbHVnaW5zKCk7XG4gIH1cblxuICBzdGF0aWMgdW5yZWdpc3RlciguLi5pdGVtcykge1xuICAgIHJlZ2lzdHJ5LnJlbW92ZSguLi5pdGVtcyk7XG4gICAgaW52YWxpZGF0ZVBsdWdpbnMoKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50c1xuICBjb25zdHJ1Y3RvcihpdGVtLCB1c2VyQ29uZmlnKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWcgPSBuZXcgQ29uZmlnKHVzZXJDb25maWcpO1xuICAgIGNvbnN0IGluaXRpYWxDYW52YXMgPSBnZXRDYW52YXMoaXRlbSk7XG4gICAgY29uc3QgZXhpc3RpbmdDaGFydCA9IGdldENoYXJ0KGluaXRpYWxDYW52YXMpO1xuICAgIGlmIChleGlzdGluZ0NoYXJ0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDYW52YXMgaXMgYWxyZWFkeSBpbiB1c2UuIENoYXJ0IHdpdGggSUQgXFwnJyArIGV4aXN0aW5nQ2hhcnQuaWQgKyAnXFwnJyArXG5cdFx0XHRcdCcgbXVzdCBiZSBkZXN0cm95ZWQgYmVmb3JlIHRoZSBjYW52YXMgd2l0aCBJRCBcXCcnICsgZXhpc3RpbmdDaGFydC5jYW52YXMuaWQgKyAnXFwnIGNhbiBiZSByZXVzZWQuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKGNvbmZpZy5jaGFydE9wdGlvblNjb3BlcygpLCB0aGlzLmdldENvbnRleHQoKSk7XG5cbiAgICB0aGlzLnBsYXRmb3JtID0gbmV3IChjb25maWcucGxhdGZvcm0gfHwgX2RldGVjdFBsYXRmb3JtKGluaXRpYWxDYW52YXMpKSgpO1xuICAgIHRoaXMucGxhdGZvcm0udXBkYXRlQ29uZmlnKGNvbmZpZyk7XG5cbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5wbGF0Zm9ybS5hY3F1aXJlQ29udGV4dChpbml0aWFsQ2FudmFzLCBvcHRpb25zLmFzcGVjdFJhdGlvKTtcbiAgICBjb25zdCBjYW52YXMgPSBjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzO1xuICAgIGNvbnN0IGhlaWdodCA9IGNhbnZhcyAmJiBjYW52YXMuaGVpZ2h0O1xuICAgIGNvbnN0IHdpZHRoID0gY2FudmFzICYmIGNhbnZhcy53aWR0aDtcblxuICAgIHRoaXMuaWQgPSB1aWQoKTtcbiAgICB0aGlzLmN0eCA9IGNvbnRleHQ7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIFN0b3JlIHRoZSBwcmV2aW91c2x5IHVzZWQgYXNwZWN0IHJhdGlvIHRvIGRldGVybWluZSBpZiBhIHJlc2l6ZVxuICAgIC8vIGlzIG5lZWRlZCBkdXJpbmcgdXBkYXRlcy4gRG8gdGhpcyBhZnRlciBfb3B0aW9ucyBpcyBzZXQgc2luY2VcbiAgICAvLyBhc3BlY3RSYXRpbyB1c2VzIGEgZ2V0dGVyXG4gICAgdGhpcy5fYXNwZWN0UmF0aW8gPSB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIHRoaXMuX2xheWVycyA9IFtdO1xuICAgIHRoaXMuX21ldGFzZXRzID0gW107XG4gICAgdGhpcy5fc3RhY2tzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm94ZXMgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2hhcnRBcmVhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2FjdGl2ZSA9IFtdO1xuICAgIHRoaXMuX2xhc3RFdmVudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICAvKiogQHR5cGUgez97YXR0YWNoPzogZnVuY3Rpb24sIGRldGFjaD86IGZ1bmN0aW9uLCByZXNpemU/OiBmdW5jdGlvbn19ICovXG4gICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zb3J0ZWRNZXRhc2V0cyA9IFtdO1xuICAgIHRoaXMuc2NhbGVzID0ge307XG4gICAgdGhpcy5fcGx1Z2lucyA9IG5ldyBQbHVnaW5TZXJ2aWNlKCk7XG4gICAgdGhpcy4kcHJveGllcyA9IHt9O1xuICAgIHRoaXMuX2hpZGRlbkluZGljZXMgPSB7fTtcbiAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYW5pbWF0aW9uc0Rpc2FibGVkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZG9SZXNpemUgPSBkZWJvdW5jZShtb2RlID0+IHRoaXMudXBkYXRlKG1vZGUpLCBvcHRpb25zLnJlc2l6ZURlbGF5IHx8IDApO1xuICAgIHRoaXMuX2RhdGFDaGFuZ2VzID0gW107XG5cbiAgICAvLyBBZGQgdGhlIGNoYXJ0IGluc3RhbmNlIHRvIHRoZSBnbG9iYWwgbmFtZXNwYWNlXG4gICAgaW5zdGFuY2VzW3RoaXMuaWRdID0gdGhpcztcblxuICAgIGlmICghY29udGV4dCB8fCAhY2FudmFzKSB7XG4gICAgICAvLyBUaGUgZ2l2ZW4gaXRlbSBpcyBub3QgYSBjb21wYXRpYmxlIGNvbnRleHQyZCBlbGVtZW50LCBsZXQncyByZXR1cm4gYmVmb3JlIGZpbmFsaXppbmdcbiAgICAgIC8vIHRoZSBjaGFydCBpbml0aWFsaXphdGlvbiBidXQgYWZ0ZXIgc2V0dGluZyBiYXNpYyBjaGFydCAvIGNvbnRyb2xsZXIgcHJvcGVydGllcyB0aGF0XG4gICAgICAvLyBjYW4gaGVscCB0byBmaWd1cmUgb3V0IHRoYXQgdGhlIGNoYXJ0IGlzIG5vdCB2YWxpZCAoZS5nIGNoYXJ0LmNhbnZhcyAhPT0gbnVsbCk7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjgwN1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgY2hhcnQ6IGNhbid0IGFjcXVpcmUgY29udGV4dCBmcm9tIHRoZSBnaXZlbiBpdGVtXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFuaW1hdG9yLmxpc3Rlbih0aGlzLCAnY29tcGxldGUnLCBvbkFuaW1hdGlvbnNDb21wbGV0ZSk7XG4gICAgYW5pbWF0b3IubGlzdGVuKHRoaXMsICdwcm9ncmVzcycsIG9uQW5pbWF0aW9uUHJvZ3Jlc3MpO1xuXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpO1xuICAgIGlmICh0aGlzLmF0dGFjaGVkKSB7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBhc3BlY3RSYXRpbygpIHtcbiAgICBjb25zdCB7b3B0aW9uczoge2FzcGVjdFJhdGlvLCBtYWludGFpbkFzcGVjdFJhdGlvfSwgd2lkdGgsIGhlaWdodCwgX2FzcGVjdFJhdGlvfSA9IHRoaXM7XG4gICAgaWYgKCFpc051bGxPclVuZGVmKGFzcGVjdFJhdGlvKSkge1xuICAgICAgLy8gSWYgYXNwZWN0UmF0aW8gaXMgZGVmaW5lZCBpbiBvcHRpb25zLCB1c2UgdGhhdC5cbiAgICAgIHJldHVybiBhc3BlY3RSYXRpbztcbiAgICB9XG5cbiAgICBpZiAobWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiBfYXNwZWN0UmF0aW8pIHtcbiAgICAgIC8vIElmIG1haW50YWluQXNwZWN0UmF0aW8gaXMgdHJ1dGhseSBhbmQgd2UgaGFkIHByZXZpb3VzbHkgZGV0ZXJtaW5lZCBfYXNwZWN0UmF0aW8sIHVzZSB0aGF0XG4gICAgICByZXR1cm4gX2FzcGVjdFJhdGlvO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZVxuICAgIHJldHVybiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IG51bGw7XG4gIH1cblxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuZGF0YTtcbiAgfVxuXG4gIHNldCBkYXRhKGRhdGEpIHtcbiAgICB0aGlzLmNvbmZpZy5kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICB9XG5cbiAgc2V0IG9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMuY29uZmlnLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG5cbiAgZ2V0IHJlZ2lzdHJ5KCkge1xuICAgIHJldHVybiByZWdpc3RyeTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgLy8gQmVmb3JlIGluaXQgcGx1Z2luIG5vdGlmaWNhdGlvblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlSW5pdCcpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRpbmFTY2FsZSh0aGlzLCB0aGlzLm9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgfVxuXG4gICAgdGhpcy5iaW5kRXZlbnRzKCk7XG5cbiAgICAvLyBBZnRlciBpbml0IHBsdWdpbiBub3RpZmljYXRpb25cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVySW5pdCcpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICBjbGVhckNhbnZhcyh0aGlzLmNhbnZhcywgdGhpcy5jdHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc3RvcCgpIHtcbiAgICBhbmltYXRvci5zdG9wKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJlc2l6ZSB0aGUgY2hhcnQgdG8gaXRzIGNvbnRhaW5lciBvciB0byBleHBsaWNpdCBkaW1lbnNpb25zLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoXVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodF1cblx0ICovXG4gIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKCFhbmltYXRvci5ydW5uaW5nKHRoaXMpKSB7XG4gICAgICB0aGlzLl9yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcgPSB7d2lkdGgsIGhlaWdodH07XG4gICAgfVxuICB9XG5cbiAgX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IG9wdGlvbnMubWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIGNvbnN0IG5ld1NpemUgPSB0aGlzLnBsYXRmb3JtLmdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pO1xuICAgIGNvbnN0IG5ld1JhdGlvID0gb3B0aW9ucy5kZXZpY2VQaXhlbFJhdGlvIHx8IHRoaXMucGxhdGZvcm0uZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgIGNvbnN0IG1vZGUgPSB0aGlzLndpZHRoID8gJ3Jlc2l6ZScgOiAnYXR0YWNoJztcblxuICAgIHRoaXMud2lkdGggPSBuZXdTaXplLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gbmV3U2l6ZS5oZWlnaHQ7XG4gICAgdGhpcy5fYXNwZWN0UmF0aW8gPSB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIGlmICghcmV0aW5hU2NhbGUodGhpcywgbmV3UmF0aW8sIHRydWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdyZXNpemUnLCB7c2l6ZTogbmV3U2l6ZX0pO1xuXG4gICAgY2FsbENhbGxiYWNrKG9wdGlvbnMub25SZXNpemUsIFt0aGlzLCBuZXdTaXplXSwgdGhpcyk7XG5cbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgaWYgKHRoaXMuX2RvUmVzaXplKG1vZGUpKSB7XG4gICAgICAgIC8vIFRoZSByZXNpemUgdXBkYXRlIGlzIGRlbGF5ZWQsIG9ubHkgZHJhdyB3aXRob3V0IHVwZGF0aW5nLlxuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVuc3VyZVNjYWxlc0hhdmVJRHMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzY2FsZXNPcHRpb25zID0gb3B0aW9ucy5zY2FsZXMgfHwge307XG5cbiAgICBlYWNoKHNjYWxlc09wdGlvbnMsIChheGlzT3B0aW9ucywgYXhpc0lEKSA9PiB7XG4gICAgICBheGlzT3B0aW9ucy5pZCA9IGF4aXNJRDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBCdWlsZHMgYSBtYXAgb2Ygc2NhbGUgSUQgdG8gc2NhbGUgb2JqZWN0IGZvciBmdXR1cmUgbG9va3VwLlxuXHQgKi9cbiAgYnVpbGRPclVwZGF0ZVNjYWxlcygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNjYWxlT3B0cyA9IG9wdGlvbnMuc2NhbGVzO1xuICAgIGNvbnN0IHNjYWxlcyA9IHRoaXMuc2NhbGVzO1xuICAgIGNvbnN0IHVwZGF0ZWQgPSBPYmplY3Qua2V5cyhzY2FsZXMpLnJlZHVjZSgob2JqLCBpZCkgPT4ge1xuICAgICAgb2JqW2lkXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LCB7fSk7XG4gICAgbGV0IGl0ZW1zID0gW107XG5cbiAgICBpZiAoc2NhbGVPcHRzKSB7XG4gICAgICBpdGVtcyA9IGl0ZW1zLmNvbmNhdChcbiAgICAgICAgT2JqZWN0LmtleXMoc2NhbGVPcHRzKS5tYXAoKGlkKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2NhbGVPcHRpb25zID0gc2NhbGVPcHRzW2lkXTtcbiAgICAgICAgICBjb25zdCBheGlzID0gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVPcHRpb25zKTtcbiAgICAgICAgICBjb25zdCBpc1JhZGlhbCA9IGF4aXMgPT09ICdyJztcbiAgICAgICAgICBjb25zdCBpc0hvcml6b250YWwgPSBheGlzID09PSAneCc7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHNjYWxlT3B0aW9ucyxcbiAgICAgICAgICAgIGRwb3NpdGlvbjogaXNSYWRpYWwgPyAnY2hhcnRBcmVhJyA6IGlzSG9yaXpvbnRhbCA/ICdib3R0b20nIDogJ2xlZnQnLFxuICAgICAgICAgICAgZHR5cGU6IGlzUmFkaWFsID8gJ3JhZGlhbExpbmVhcicgOiBpc0hvcml6b250YWwgPyAnY2F0ZWdvcnknIDogJ2xpbmVhcidcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBlYWNoKGl0ZW1zLCAoaXRlbSkgPT4ge1xuICAgICAgY29uc3Qgc2NhbGVPcHRpb25zID0gaXRlbS5vcHRpb25zO1xuICAgICAgY29uc3QgaWQgPSBzY2FsZU9wdGlvbnMuaWQ7XG4gICAgICBjb25zdCBheGlzID0gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVPcHRpb25zKTtcbiAgICAgIGNvbnN0IHNjYWxlVHlwZSA9IHZhbHVlT3JEZWZhdWx0KHNjYWxlT3B0aW9ucy50eXBlLCBpdGVtLmR0eXBlKTtcblxuICAgICAgaWYgKHNjYWxlT3B0aW9ucy5wb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9uSXNIb3Jpem9udGFsKHNjYWxlT3B0aW9ucy5wb3NpdGlvbiwgYXhpcykgIT09IHBvc2l0aW9uSXNIb3Jpem9udGFsKGl0ZW0uZHBvc2l0aW9uKSkge1xuICAgICAgICBzY2FsZU9wdGlvbnMucG9zaXRpb24gPSBpdGVtLmRwb3NpdGlvbjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlZFtpZF0gPSB0cnVlO1xuICAgICAgbGV0IHNjYWxlID0gbnVsbDtcbiAgICAgIGlmIChpZCBpbiBzY2FsZXMgJiYgc2NhbGVzW2lkXS50eXBlID09PSBzY2FsZVR5cGUpIHtcbiAgICAgICAgc2NhbGUgPSBzY2FsZXNbaWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2NhbGVDbGFzcyA9IHJlZ2lzdHJ5LmdldFNjYWxlKHNjYWxlVHlwZSk7XG4gICAgICAgIHNjYWxlID0gbmV3IHNjYWxlQ2xhc3Moe1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIHR5cGU6IHNjYWxlVHlwZSxcbiAgICAgICAgICBjdHg6IHRoaXMuY3R4LFxuICAgICAgICAgIGNoYXJ0OiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICBzY2FsZXNbc2NhbGUuaWRdID0gc2NhbGU7XG4gICAgICB9XG5cbiAgICAgIHNjYWxlLmluaXQoc2NhbGVPcHRpb25zLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgICAvLyBjbGVhciB1cCBkaXNjYXJkZWQgc2NhbGVzXG4gICAgZWFjaCh1cGRhdGVkLCAoaGFzVXBkYXRlZCwgaWQpID0+IHtcbiAgICAgIGlmICghaGFzVXBkYXRlZCkge1xuICAgICAgICBkZWxldGUgc2NhbGVzW2lkXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGVhY2goc2NhbGVzLCAoc2NhbGUpID0+IHtcbiAgICAgIGxheW91dHMuY29uZmlndXJlKHRoaXMsIHNjYWxlLCBzY2FsZS5vcHRpb25zKTtcbiAgICAgIGxheW91dHMuYWRkQm94KHRoaXMsIHNjYWxlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZU1ldGFzZXRzKCkge1xuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5fbWV0YXNldHM7XG4gICAgY29uc3QgbnVtRGF0YSA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7XG4gICAgY29uc3QgbnVtTWV0YSA9IG1ldGFzZXRzLmxlbmd0aDtcblxuICAgIG1ldGFzZXRzLnNvcnQoKGEsIGIpID0+IGEuaW5kZXggLSBiLmluZGV4KTtcbiAgICBpZiAobnVtTWV0YSA+IG51bURhdGEpIHtcbiAgICAgIGZvciAobGV0IGkgPSBudW1EYXRhOyBpIDwgbnVtTWV0YTsgKytpKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICAgIH1cbiAgICAgIG1ldGFzZXRzLnNwbGljZShudW1EYXRhLCBudW1NZXRhIC0gbnVtRGF0YSk7XG4gICAgfVxuICAgIHRoaXMuX3NvcnRlZE1ldGFzZXRzID0gbWV0YXNldHMuc2xpY2UoMCkuc29ydChjb21wYXJlMkxldmVsKCdvcmRlcicsICdpbmRleCcpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzKCkge1xuICAgIGNvbnN0IHtfbWV0YXNldHM6IG1ldGFzZXRzLCBkYXRhOiB7ZGF0YXNldHN9fSA9IHRoaXM7XG4gICAgaWYgKG1ldGFzZXRzLmxlbmd0aCA+IGRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgZGVsZXRlIHRoaXMuX3N0YWNrcztcbiAgICB9XG4gICAgbWV0YXNldHMuZm9yRWFjaCgobWV0YSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChkYXRhc2V0cy5maWx0ZXIoeCA9PiB4ID09PSBtZXRhLl9kYXRhc2V0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGluZGV4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGJ1aWxkT3JVcGRhdGVDb250cm9sbGVycygpIHtcbiAgICBjb25zdCBuZXdDb250cm9sbGVycyA9IFtdO1xuICAgIGNvbnN0IGRhdGFzZXRzID0gdGhpcy5kYXRhLmRhdGFzZXRzO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgdGhpcy5fcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMoKTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGRhdGFzZXQgPSBkYXRhc2V0c1tpXTtcbiAgICAgIGxldCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIGNvbnN0IHR5cGUgPSBkYXRhc2V0LnR5cGUgfHwgdGhpcy5jb25maWcudHlwZTtcblxuICAgICAgaWYgKG1ldGEudHlwZSAmJiBtZXRhLnR5cGUgIT09IHR5cGUpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuICAgICAgICBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIH1cbiAgICAgIG1ldGEudHlwZSA9IHR5cGU7XG4gICAgICBtZXRhLmluZGV4QXhpcyA9IGRhdGFzZXQuaW5kZXhBeGlzIHx8IGdldEluZGV4QXhpcyh0eXBlLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgbWV0YS5vcmRlciA9IGRhdGFzZXQub3JkZXIgfHwgMDtcbiAgICAgIG1ldGEuaW5kZXggPSBpO1xuICAgICAgbWV0YS5sYWJlbCA9ICcnICsgZGF0YXNldC5sYWJlbDtcbiAgICAgIG1ldGEudmlzaWJsZSA9IHRoaXMuaXNEYXRhc2V0VmlzaWJsZShpKTtcblxuICAgICAgaWYgKG1ldGEuY29udHJvbGxlcikge1xuICAgICAgICBtZXRhLmNvbnRyb2xsZXIudXBkYXRlSW5kZXgoaSk7XG4gICAgICAgIG1ldGEuY29udHJvbGxlci5saW5rU2NhbGVzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBDb250cm9sbGVyQ2xhc3MgPSByZWdpc3RyeS5nZXRDb250cm9sbGVyKHR5cGUpO1xuICAgICAgICBjb25zdCB7ZGF0YXNldEVsZW1lbnRUeXBlLCBkYXRhRWxlbWVudFR5cGV9ID0gZGVmYXVsdHMuZGF0YXNldHNbdHlwZV07XG4gICAgICAgIE9iamVjdC5hc3NpZ24oQ29udHJvbGxlckNsYXNzLCB7XG4gICAgICAgICAgZGF0YUVsZW1lbnRUeXBlOiByZWdpc3RyeS5nZXRFbGVtZW50KGRhdGFFbGVtZW50VHlwZSksXG4gICAgICAgICAgZGF0YXNldEVsZW1lbnRUeXBlOiBkYXRhc2V0RWxlbWVudFR5cGUgJiYgcmVnaXN0cnkuZ2V0RWxlbWVudChkYXRhc2V0RWxlbWVudFR5cGUpXG4gICAgICAgIH0pO1xuICAgICAgICBtZXRhLmNvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlckNsYXNzKHRoaXMsIGkpO1xuICAgICAgICBuZXdDb250cm9sbGVycy5wdXNoKG1ldGEuY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlTWV0YXNldHMoKTtcbiAgICByZXR1cm4gbmV3Q29udHJvbGxlcnM7XG4gIH1cblxuICAvKipcblx0ICogUmVzZXQgdGhlIGVsZW1lbnRzIG9mIGFsbCBkYXRhc2V0c1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc2V0RWxlbWVudHMoKSB7XG4gICAgZWFjaCh0aGlzLmRhdGEuZGF0YXNldHMsIChkYXRhc2V0LCBkYXRhc2V0SW5kZXgpID0+IHtcbiAgICAgIHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyLnJlc2V0KCk7XG4gICAgfSwgdGhpcyk7XG4gIH1cblxuICAvKipcblx0KiBSZXNldHMgdGhlIGNoYXJ0IGJhY2sgdG8gaXRzIHN0YXRlIGJlZm9yZSB0aGUgaW5pdGlhbCBhbmltYXRpb25cblx0Ki9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fcmVzZXRFbGVtZW50cygpO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygncmVzZXQnKTtcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG5cbiAgICBjb25maWcudXBkYXRlKCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoY29uZmlnLmNoYXJ0T3B0aW9uU2NvcGVzKCksIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBhbmltc0Rpc2FibGVkID0gdGhpcy5fYW5pbWF0aW9uc0Rpc2FibGVkID0gIW9wdGlvbnMuYW5pbWF0aW9uO1xuXG4gICAgdGhpcy5fdXBkYXRlU2NhbGVzKCk7XG4gICAgdGhpcy5fY2hlY2tFdmVudEJpbmRpbmdzKCk7XG4gICAgdGhpcy5fdXBkYXRlSGlkZGVuSW5kaWNlcygpO1xuXG4gICAgLy8gcGx1Z2lucyBvcHRpb25zIHJlZmVyZW5jZXMgbWlnaHQgaGF2ZSBjaGFuZ2UsIGxldCdzIGludmFsaWRhdGUgdGhlIGNhY2hlXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzUxMTEjaXNzdWVjb21tZW50LTM1NTkzNDE2N1xuICAgIHRoaXMuX3BsdWdpbnMuaW52YWxpZGF0ZSgpO1xuXG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlVXBkYXRlJywge21vZGUsIGNhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgZGF0YXNldCBjb250cm9sbGVycyBhcmUgdXBkYXRlZCBhbmQgbmV3IGNvbnRyb2xsZXJzIGFyZSByZXNldFxuICAgIGNvbnN0IG5ld0NvbnRyb2xsZXJzID0gdGhpcy5idWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKTtcblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRWxlbWVudHNVcGRhdGUnKTtcblxuICAgIC8vIE1ha2Ugc3VyZSBhbGwgZGF0YXNldCBjb250cm9sbGVycyBoYXZlIGNvcnJlY3QgbWV0YSBkYXRhIGNvdW50c1xuICAgIGxldCBtaW5QYWRkaW5nID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IHtjb250cm9sbGVyfSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICBjb25zdCByZXNldCA9ICFhbmltc0Rpc2FibGVkICYmIG5ld0NvbnRyb2xsZXJzLmluZGV4T2YoY29udHJvbGxlcikgPT09IC0xO1xuICAgICAgLy8gTmV3IGNvbnRyb2xsZXJzIHdpbGwgYmUgcmVzZXQgYWZ0ZXIgdGhlIGxheW91dCBwYXNzLCBzbyB3ZSBvbmx5IHdhbnQgdG8gbW9kaWZ5XG4gICAgICAvLyBlbGVtZW50cyBhZGRlZCB0byBuZXcgZGF0YXNldHNcbiAgICAgIGNvbnRyb2xsZXIuYnVpbGRPclVwZGF0ZUVsZW1lbnRzKHJlc2V0KTtcbiAgICAgIG1pblBhZGRpbmcgPSBNYXRoLm1heCgrY29udHJvbGxlci5nZXRNYXhPdmVyZmxvdygpLCBtaW5QYWRkaW5nKTtcbiAgICB9XG4gICAgbWluUGFkZGluZyA9IHRoaXMuX21pblBhZGRpbmcgPSBvcHRpb25zLmxheW91dC5hdXRvUGFkZGluZyA/IG1pblBhZGRpbmcgOiAwO1xuICAgIHRoaXMuX3VwZGF0ZUxheW91dChtaW5QYWRkaW5nKTtcblxuICAgIC8vIE9ubHkgcmVzZXQgdGhlIGNvbnRyb2xsZXJzIGlmIHdlIGhhdmUgYW5pbWF0aW9uc1xuICAgIGlmICghYW5pbXNEaXNhYmxlZCkge1xuICAgICAgLy8gQ2FuIG9ubHkgcmVzZXQgdGhlIG5ldyBjb250cm9sbGVycyBhZnRlciB0aGUgc2NhbGVzIGhhdmUgYmVlbiB1cGRhdGVkXG4gICAgICAvLyBSZXNldCBpcyBkb25lIHRvIGdldCB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIHRoZSBpbml0aWFsIGFuaW1hdGlvblxuICAgICAgZWFjaChuZXdDb250cm9sbGVycywgKGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5yZXNldCgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlRGF0YXNldHMobW9kZSk7XG5cbiAgICAvLyBEbyB0aGlzIGJlZm9yZSByZW5kZXIgc28gdGhhdCBhbnkgcGx1Z2lucyB0aGF0IG5lZWQgZmluYWwgc2NhbGUgdXBkYXRlcyBjYW4gdXNlIGl0XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlclVwZGF0ZScsIHttb2RlfSk7XG5cbiAgICB0aGlzLl9sYXllcnMuc29ydChjb21wYXJlMkxldmVsKCd6JywgJ19pZHgnKSk7XG5cbiAgICAvLyBSZXBsYXkgbGFzdCBldmVudCBmcm9tIGJlZm9yZSB1cGRhdGUsIG9yIHNldCBob3ZlciBzdHlsZXMgb24gYWN0aXZlIGVsZW1lbnRzXG4gICAgY29uc3Qge19hY3RpdmUsIF9sYXN0RXZlbnR9ID0gdGhpcztcbiAgICBpZiAoX2xhc3RFdmVudCkge1xuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyKF9sYXN0RXZlbnQsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoX2FjdGl2ZS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKF9hY3RpdmUsIF9hY3RpdmUsIHRydWUpO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVTY2FsZXMoKSB7XG4gICAgZWFjaCh0aGlzLnNjYWxlcywgKHNjYWxlKSA9PiB7XG4gICAgICBsYXlvdXRzLnJlbW92ZUJveCh0aGlzLCBzY2FsZSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmVuc3VyZVNjYWxlc0hhdmVJRHMoKTtcbiAgICB0aGlzLmJ1aWxkT3JVcGRhdGVTY2FsZXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NoZWNrRXZlbnRCaW5kaW5ncygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGV4aXN0aW5nRXZlbnRzID0gbmV3IFNldChPYmplY3Qua2V5cyh0aGlzLl9saXN0ZW5lcnMpKTtcbiAgICBjb25zdCBuZXdFdmVudHMgPSBuZXcgU2V0KG9wdGlvbnMuZXZlbnRzKTtcblxuICAgIGlmICghc2V0c0VxdWFsKGV4aXN0aW5nRXZlbnRzLCBuZXdFdmVudHMpIHx8ICEhdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyAhPT0gb3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICAvLyBUaGUgY29uZmlndXJlZCBldmVudHMgaGF2ZSBjaGFuZ2VkLiBSZWJpbmQuXG4gICAgICB0aGlzLnVuYmluZEV2ZW50cygpO1xuICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlSGlkZGVuSW5kaWNlcygpIHtcbiAgICBjb25zdCB7X2hpZGRlbkluZGljZXN9ID0gdGhpcztcbiAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5fZ2V0VW5pZm9ybURhdGFDaGFuZ2VzKCkgfHwgW107XG4gICAgZm9yIChjb25zdCB7bWV0aG9kLCBzdGFydCwgY291bnR9IG9mIGNoYW5nZXMpIHtcbiAgICAgIGNvbnN0IG1vdmUgPSBtZXRob2QgPT09ICdfcmVtb3ZlRWxlbWVudHMnID8gLWNvdW50IDogY291bnQ7XG4gICAgICBtb3ZlTnVtZXJpY0tleXMoX2hpZGRlbkluZGljZXMsIHN0YXJ0LCBtb3ZlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRVbmlmb3JtRGF0YUNoYW5nZXMoKSB7XG4gICAgY29uc3QgX2RhdGFDaGFuZ2VzID0gdGhpcy5fZGF0YUNoYW5nZXM7XG4gICAgaWYgKCFfZGF0YUNoYW5nZXMgfHwgIV9kYXRhQ2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9kYXRhQ2hhbmdlcyA9IFtdO1xuICAgIGNvbnN0IGRhdGFzZXRDb3VudCA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7XG4gICAgY29uc3QgbWFrZVNldCA9IChpZHgpID0+IG5ldyBTZXQoXG4gICAgICBfZGF0YUNoYW5nZXNcbiAgICAgICAgLmZpbHRlcihjID0+IGNbMF0gPT09IGlkeClcbiAgICAgICAgLm1hcCgoYywgaSkgPT4gaSArICcsJyArIGMuc3BsaWNlKDEpLmpvaW4oJywnKSlcbiAgICApO1xuXG4gICAgY29uc3QgY2hhbmdlU2V0ID0gbWFrZVNldCgwKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGRhdGFzZXRDb3VudDsgaSsrKSB7XG4gICAgICBpZiAoIXNldHNFcXVhbChjaGFuZ2VTZXQsIG1ha2VTZXQoaSkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20oY2hhbmdlU2V0KVxuICAgICAgLm1hcChjID0+IGMuc3BsaXQoJywnKSlcbiAgICAgIC5tYXAoYSA9PiAoe21ldGhvZDogYVsxXSwgc3RhcnQ6ICthWzJdLCBjb3VudDogK2FbM119KSk7XG4gIH1cblxuICAvKipcblx0ICogVXBkYXRlcyB0aGUgY2hhcnQgbGF5b3V0IHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVMYXlvdXRgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckxheW91dGAuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlTGF5b3V0KG1pblBhZGRpbmcpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVMYXlvdXQnLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxheW91dHMudXBkYXRlKHRoaXMsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBtaW5QYWRkaW5nKTtcblxuICAgIGNvbnN0IGFyZWEgPSB0aGlzLmNoYXJ0QXJlYTtcbiAgICBjb25zdCBub0FyZWEgPSBhcmVhLndpZHRoIDw9IDAgfHwgYXJlYS5oZWlnaHQgPD0gMDtcblxuICAgIHRoaXMuX2xheWVycyA9IFtdO1xuICAgIGVhY2godGhpcy5ib3hlcywgKGJveCkgPT4ge1xuICAgICAgaWYgKG5vQXJlYSAmJiBib3gucG9zaXRpb24gPT09ICdjaGFydEFyZWEnKSB7XG4gICAgICAgIC8vIFNraXAgZHJhd2luZyBhbmQgY29uZmlndXJpbmcgY2hhcnRBcmVhIGJveGVzIHdoZW4gY2hhcnRBcmVhIGlzIHplcm8gb3IgbmVnYXRpdmVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBjb25maWd1cmUgaXMgY2FsbGVkIHR3aWNlLCBvbmNlIGluIGNvcmUuc2NhbGUudXBkYXRlIGFuZCBvbmNlIGhlcmUuXG4gICAgICAvLyBIZXJlIHRoZSBib3hlcyBhcmUgZnVsbHkgdXBkYXRlZCBhbmQgYXQgdGhlaXIgZmluYWwgcG9zaXRpb25zLlxuICAgICAgaWYgKGJveC5jb25maWd1cmUpIHtcbiAgICAgICAgYm94LmNvbmZpZ3VyZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGF5ZXJzLnB1c2goLi4uYm94Ll9sYXllcnMoKSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLl9sYXllcnMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIGl0ZW0uX2lkeCA9IGluZGV4O1xuICAgIH0pO1xuXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckxheW91dCcpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFVwZGF0ZXMgYWxsIGRhdGFzZXRzIHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0c1VwZGF0ZWBcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldHNVcGRhdGVgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZURhdGFzZXRzKG1vZGUpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0c1VwZGF0ZScsIHttb2RlLCBjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aGlzLmdldERhdGFzZXRNZXRhKGkpLmNvbnRyb2xsZXIuY29uZmlndXJlKCk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aGlzLl91cGRhdGVEYXRhc2V0KGksIGlzRnVuY3Rpb24obW9kZSkgPyBtb2RlKHtkYXRhc2V0SW5kZXg6IGl9KSA6IG1vZGUpO1xuICAgIH1cblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0c1VwZGF0ZScsIHttb2RlfSk7XG4gIH1cblxuICAvKipcblx0ICogVXBkYXRlcyBkYXRhc2V0IGF0IGluZGV4IHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0VXBkYXRlYFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0VXBkYXRlYC5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVEYXRhc2V0KGluZGV4LCBtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuICAgIGNvbnN0IGFyZ3MgPSB7bWV0YSwgaW5kZXgsIG1vZGUsIGNhbmNlbGFibGU6IHRydWV9O1xuXG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldFVwZGF0ZScsIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG1ldGEuY29udHJvbGxlci5fdXBkYXRlKG1vZGUpO1xuXG4gICAgYXJncy5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRVcGRhdGUnLCBhcmdzKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVSZW5kZXInLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChhbmltYXRvci5oYXModGhpcykpIHtcbiAgICAgIGlmICh0aGlzLmF0dGFjaGVkICYmICFhbmltYXRvci5ydW5uaW5nKHRoaXMpKSB7XG4gICAgICAgIGFuaW1hdG9yLnN0YXJ0KHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRyYXcoKTtcbiAgICAgIG9uQW5pbWF0aW9uc0NvbXBsZXRlKHtjaGFydDogdGhpc30pO1xuICAgIH1cbiAgfVxuXG4gIGRyYXcoKSB7XG4gICAgbGV0IGk7XG4gICAgaWYgKHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcpIHtcbiAgICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXc7XG4gICAgICAvLyBVbnNldCBwZW5kaW5nIHJlc2l6ZSByZXF1ZXN0IG5vdyB0byBhdm9pZCBwb3NzaWJsZSByZWN1cnNpb24gd2l0aGluIF9yZXNpemVcbiAgICAgIHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcgPSBudWxsO1xuICAgICAgdGhpcy5fcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICBpZiAodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEcmF3Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBCZWNhdXNlIG9mIHBsdWdpbiBob29rcyAoYmVmb3JlL2FmdGVyRGF0YXNldHNEcmF3KSwgZGF0YXNldHMgY2FuJ3RcbiAgICAvLyBjdXJyZW50bHkgYmUgcGFydCBvZiBsYXllcnMuIEluc3RlYWQsIHdlIGRyYXdcbiAgICAvLyBsYXllcnMgPD0gMCBiZWZvcmUoZGVmYXVsdCwgYmFja3dhcmQgY29tcGF0KSwgYW5kIHRoZSByZXN0IGFmdGVyXG4gICAgY29uc3QgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoICYmIGxheWVyc1tpXS56IDw9IDA7ICsraSkge1xuICAgICAgbGF5ZXJzW2ldLmRyYXcodGhpcy5jaGFydEFyZWEpO1xuICAgIH1cblxuICAgIHRoaXMuX2RyYXdEYXRhc2V0cygpO1xuXG4gICAgLy8gUmVzdCBvZiBsYXllcnNcbiAgICBmb3IgKDsgaSA8IGxheWVycy5sZW5ndGg7ICsraSkge1xuICAgICAgbGF5ZXJzW2ldLmRyYXcodGhpcy5jaGFydEFyZWEpO1xuICAgIH1cblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEcmF3Jyk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoZmlsdGVyVmlzaWJsZSkge1xuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5fc29ydGVkTWV0YXNldHM7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBtZXRhID0gbWV0YXNldHNbaV07XG4gICAgICBpZiAoIWZpbHRlclZpc2libGUgfHwgbWV0YS52aXNpYmxlKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1ldGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcblx0ICogR2V0cyB0aGUgdmlzaWJsZSBkYXRhc2V0IG1ldGFzIGluIGRyYXdpbmcgb3JkZXJcblx0ICogQHJldHVybiB7b2JqZWN0W119XG5cdCAqL1xuICBnZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTb3J0ZWREYXRhc2V0TWV0YXModHJ1ZSk7XG4gIH1cblxuICAvKipcblx0ICogRHJhd3MgYWxsIGRhdGFzZXRzIHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0c0RyYXdgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXRzRHJhd2AuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZHJhd0RhdGFzZXRzKCkge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRzRHJhdycsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRoaXMuX2RyYXdEYXRhc2V0KG1ldGFzZXRzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldHNEcmF3Jyk7XG4gIH1cblxuICAvKipcblx0ICogRHJhd3MgZGF0YXNldCBhdCBpbmRleCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldERyYXdgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXREcmF3YC5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kcmF3RGF0YXNldChtZXRhKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgY2xpcCA9IG1ldGEuX2NsaXA7XG4gICAgY29uc3QgdXNlQ2xpcCA9ICFjbGlwLmRpc2FibGVkO1xuICAgIGNvbnN0IGFyZWEgPSBnZXREYXRhc2V0QXJlYShtZXRhLCB0aGlzLmNoYXJ0QXJlYSk7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIG1ldGEsXG4gICAgICBpbmRleDogbWV0YS5pbmRleCxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldERyYXcnLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodXNlQ2xpcCkge1xuICAgICAgY2xpcEFyZWEoY3R4LCB7XG4gICAgICAgIGxlZnQ6IGNsaXAubGVmdCA9PT0gZmFsc2UgPyAwIDogYXJlYS5sZWZ0IC0gY2xpcC5sZWZ0LFxuICAgICAgICByaWdodDogY2xpcC5yaWdodCA9PT0gZmFsc2UgPyB0aGlzLndpZHRoIDogYXJlYS5yaWdodCArIGNsaXAucmlnaHQsXG4gICAgICAgIHRvcDogY2xpcC50b3AgPT09IGZhbHNlID8gMCA6IGFyZWEudG9wIC0gY2xpcC50b3AsXG4gICAgICAgIGJvdHRvbTogY2xpcC5ib3R0b20gPT09IGZhbHNlID8gdGhpcy5oZWlnaHQgOiBhcmVhLmJvdHRvbSArIGNsaXAuYm90dG9tXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBtZXRhLmNvbnRyb2xsZXIuZHJhdygpO1xuXG4gICAgaWYgKHVzZUNsaXApIHtcbiAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICB9XG5cbiAgICBhcmdzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldERyYXcnLCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gcG9pbnQgaXMgaW4gdGhlIGNoYXJ0IGFyZWEuXG4gICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXMgKHNlZSwgZS5nLiwgZ2V0UmVsYXRpdmVQb3NpdGlvbilcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc1BvaW50SW5BcmVhKHBvaW50KSB7XG4gICAgcmV0dXJuIF9pc1BvaW50SW5BcmVhKHBvaW50LCB0aGlzLmNoYXJ0QXJlYSwgdGhpcy5fbWluUGFkZGluZyk7XG4gIH1cblxuICBnZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIG1vZGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCBtZXRob2QgPSBJbnRlcmFjdGlvbi5tb2Rlc1ttb2RlXTtcbiAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG1ldGhvZCh0aGlzLCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG4gIH1cblxuICBnZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9tZXRhc2V0cztcbiAgICBsZXQgbWV0YSA9IG1ldGFzZXRzLmZpbHRlcih4ID0+IHggJiYgeC5fZGF0YXNldCA9PT0gZGF0YXNldCkucG9wKCk7XG5cbiAgICBpZiAoIW1ldGEpIHtcbiAgICAgIG1ldGEgPSB7XG4gICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgIGRhdGE6IFtdLFxuICAgICAgICBkYXRhc2V0OiBudWxsLFxuICAgICAgICBjb250cm9sbGVyOiBudWxsLFxuICAgICAgICBoaWRkZW46IG51bGwsXHRcdFx0Ly8gU2VlIGlzRGF0YXNldFZpc2libGUoKSBjb21tZW50XG4gICAgICAgIHhBeGlzSUQ6IG51bGwsXG4gICAgICAgIHlBeGlzSUQ6IG51bGwsXG4gICAgICAgIG9yZGVyOiBkYXRhc2V0ICYmIGRhdGFzZXQub3JkZXIgfHwgMCxcbiAgICAgICAgaW5kZXg6IGRhdGFzZXRJbmRleCxcbiAgICAgICAgX2RhdGFzZXQ6IGRhdGFzZXQsXG4gICAgICAgIF9wYXJzZWQ6IFtdLFxuICAgICAgICBfc29ydGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIG1ldGFzZXRzLnB1c2gobWV0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGE7XG4gIH1cblxuICBnZXRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8ICh0aGlzLiRjb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsLCB7Y2hhcnQ6IHRoaXMsIHR5cGU6ICdjaGFydCd9KSk7XG4gIH1cblxuICBnZXRWaXNpYmxlRGF0YXNldENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKS5sZW5ndGg7XG4gIH1cblxuICBpc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBpZiAoIWRhdGFzZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXG4gICAgLy8gbWV0YS5oaWRkZW4gaXMgYSBwZXIgY2hhcnQgZGF0YXNldCBoaWRkZW4gZmxhZyBvdmVycmlkZSB3aXRoIDMgc3RhdGVzOiBpZiB0cnVlIG9yIGZhbHNlLFxuICAgIC8vIHRoZSBkYXRhc2V0LmhpZGRlbiB2YWx1ZSBpcyBpZ25vcmVkLCBlbHNlIGlmIG51bGwsIHRoZSBkYXRhc2V0IGhpZGRlbiBzdGF0ZSBpcyByZXR1cm5lZC5cbiAgICByZXR1cm4gdHlwZW9mIG1ldGEuaGlkZGVuID09PSAnYm9vbGVhbicgPyAhbWV0YS5oaWRkZW4gOiAhZGF0YXNldC5oaWRkZW47XG4gIH1cblxuICBzZXREYXRhc2V0VmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIHZpc2libGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgIG1ldGEuaGlkZGVuID0gIXZpc2libGU7XG4gIH1cblxuICB0b2dnbGVEYXRhVmlzaWJpbGl0eShpbmRleCkge1xuICAgIHRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdID0gIXRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdO1xuICB9XG5cbiAgZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpIHtcbiAgICByZXR1cm4gIXRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlVmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCwgdmlzaWJsZSkge1xuICAgIGNvbnN0IG1vZGUgPSB2aXNpYmxlID8gJ3Nob3cnIDogJ2hpZGUnO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgY29uc3QgYW5pbXMgPSBtZXRhLmNvbnRyb2xsZXIuX3Jlc29sdmVBbmltYXRpb25zKHVuZGVmaW5lZCwgbW9kZSk7XG5cbiAgICBpZiAoZGVmaW5lZChkYXRhSW5kZXgpKSB7XG4gICAgICBtZXRhLmRhdGFbZGF0YUluZGV4XS5oaWRkZW4gPSAhdmlzaWJsZTtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0RGF0YXNldFZpc2liaWxpdHkoZGF0YXNldEluZGV4LCB2aXNpYmxlKTtcbiAgICAgIC8vIEFuaW1hdGUgdmlzaWJsZSBzdGF0ZSwgc28gaGlkZSBhbmltYXRpb24gY2FuIGJlIHNlZW4uIFRoaXMgY291bGQgYmUgaGFuZGxlZCBiZXR0ZXIgaWYgdXBkYXRlIC8gdXBkYXRlRGF0YXNldCByZXR1cm5lZCBhIFByb21pc2UuXG4gICAgICBhbmltcy51cGRhdGUobWV0YSwge3Zpc2libGV9KTtcbiAgICAgIHRoaXMudXBkYXRlKChjdHgpID0+IGN0eC5kYXRhc2V0SW5kZXggPT09IGRhdGFzZXRJbmRleCA/IG1vZGUgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgfVxuXG4gIGhpZGUoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgpIHtcbiAgICB0aGlzLl91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCBmYWxzZSk7XG4gIH1cblxuICBzaG93KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4KSB7XG4gICAgdGhpcy5fdXBkYXRlVmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCwgdHJ1ZSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kZXN0cm95RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX21ldGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKG1ldGEgJiYgbWV0YS5jb250cm9sbGVyKSB7XG4gICAgICBtZXRhLmNvbnRyb2xsZXIuX2Rlc3Ryb3koKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuX21ldGFzZXRzW2RhdGFzZXRJbmRleF07XG4gIH1cblxuICBfc3RvcCgpIHtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICB0aGlzLnN0b3AoKTtcbiAgICBhbmltYXRvci5yZW1vdmUodGhpcyk7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEZXN0cm95Jyk7XG4gICAgY29uc3Qge2NhbnZhcywgY3R4fSA9IHRoaXM7XG5cbiAgICB0aGlzLl9zdG9wKCk7XG4gICAgdGhpcy5jb25maWcuY2xlYXJDYWNoZSgpO1xuXG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgICAgIGNsZWFyQ2FudmFzKGNhbnZhcywgY3R4KTtcbiAgICAgIHRoaXMucGxhdGZvcm0ucmVsZWFzZUNvbnRleHQoY3R4KTtcbiAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgIHRoaXMuY3R4ID0gbnVsbDtcbiAgICB9XG5cbiAgICBkZWxldGUgaW5zdGFuY2VzW3RoaXMuaWRdO1xuXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRlc3Ryb3knKTtcbiAgfVxuXG4gIHRvQmFzZTY0SW1hZ2UoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmNhbnZhcy50b0RhdGFVUkwoLi4uYXJncyk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIGJpbmRFdmVudHMoKSB7XG4gICAgdGhpcy5iaW5kVXNlckV2ZW50cygpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgdGhpcy5iaW5kUmVzcG9uc2l2ZUV2ZW50cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmF0dGFjaGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGJpbmRVc2VyRXZlbnRzKCkge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICBjb25zdCBwbGF0Zm9ybSA9IHRoaXMucGxhdGZvcm07XG5cbiAgICBjb25zdCBfYWRkID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICBwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIGxpc3RlbmVyc1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgIH07XG5cbiAgICBjb25zdCBsaXN0ZW5lciA9IChlLCB4LCB5KSA9PiB7XG4gICAgICBlLm9mZnNldFggPSB4O1xuICAgICAgZS5vZmZzZXRZID0geTtcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcihlKTtcbiAgICB9O1xuXG4gICAgZWFjaCh0aGlzLm9wdGlvbnMuZXZlbnRzLCAodHlwZSkgPT4gX2FkZCh0eXBlLCBsaXN0ZW5lcikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBiaW5kUmVzcG9uc2l2ZUV2ZW50cygpIHtcbiAgICBpZiAoIXRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycztcbiAgICBjb25zdCBwbGF0Zm9ybSA9IHRoaXMucGxhdGZvcm07XG5cbiAgICBjb25zdCBfYWRkID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICBwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIGxpc3RlbmVyc1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgIH07XG4gICAgY29uc3QgX3JlbW92ZSA9ICh0eXBlLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgaWYgKGxpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgICBwbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1t0eXBlXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgbGlzdGVuZXIgPSAod2lkdGgsIGhlaWdodCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsZXQgZGV0YWNoZWQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgY29uc3QgYXR0YWNoZWQgPSAoKSA9PiB7XG4gICAgICBfcmVtb3ZlKCdhdHRhY2gnLCBhdHRhY2hlZCk7XG5cbiAgICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlO1xuICAgICAgdGhpcy5yZXNpemUoKTtcblxuICAgICAgX2FkZCgncmVzaXplJywgbGlzdGVuZXIpO1xuICAgICAgX2FkZCgnZGV0YWNoJywgZGV0YWNoZWQpO1xuICAgIH07XG5cbiAgICBkZXRhY2hlZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcblxuICAgICAgX3JlbW92ZSgncmVzaXplJywgbGlzdGVuZXIpO1xuXG4gICAgICAvLyBTdG9wIGFuaW1hdGluZyBhbmQgcmVtb3ZlIG1ldGFzZXRzLCBzbyB3aGVuIHJlLWF0dGFjaGVkLCB0aGUgYW5pbWF0aW9ucyBzdGFydCBmcm9tIGJlZ2lubmluZy5cbiAgICAgIHRoaXMuX3N0b3AoKTtcbiAgICAgIHRoaXMuX3Jlc2l6ZSgwLCAwKTtcblxuICAgICAgX2FkZCgnYXR0YWNoJywgYXR0YWNoZWQpO1xuICAgIH07XG5cbiAgICBpZiAocGxhdGZvcm0uaXNBdHRhY2hlZCh0aGlzLmNhbnZhcykpIHtcbiAgICAgIGF0dGFjaGVkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRldGFjaGVkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICB1bmJpbmRFdmVudHMoKSB7XG4gICAgZWFjaCh0aGlzLl9saXN0ZW5lcnMsIChsaXN0ZW5lciwgdHlwZSkgPT4ge1xuICAgICAgdGhpcy5wbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9KTtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcblxuICAgIGVhY2godGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycywgKGxpc3RlbmVyLCB0eXBlKSA9PiB7XG4gICAgICB0aGlzLnBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgIH0pO1xuICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB1cGRhdGVIb3ZlclN0eWxlKGl0ZW1zLCBtb2RlLCBlbmFibGVkKSB7XG4gICAgY29uc3QgcHJlZml4ID0gZW5hYmxlZCA/ICdzZXQnIDogJ3JlbW92ZSc7XG4gICAgbGV0IG1ldGEsIGl0ZW0sIGksIGlsZW47XG5cbiAgICBpZiAobW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpdGVtc1swXS5kYXRhc2V0SW5kZXgpO1xuICAgICAgbWV0YS5jb250cm9sbGVyWydfJyArIHByZWZpeCArICdEYXRhc2V0SG92ZXJTdHlsZSddKCk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgY29uc3QgY29udHJvbGxlciA9IGl0ZW0gJiYgdGhpcy5nZXREYXRhc2V0TWV0YShpdGVtLmRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcbiAgICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXJbcHJlZml4ICsgJ0hvdmVyU3R5bGUnXShpdGVtLmVsZW1lbnQsIGl0ZW0uZGF0YXNldEluZGV4LCBpdGVtLmluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogR2V0IGFjdGl2ZSAoaG92ZXJlZCkgZWxlbWVudHNcblx0ICogQHJldHVybnMgYXJyYXlcblx0ICovXG4gIGdldEFjdGl2ZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmUgfHwgW107XG4gIH1cblxuICAvKipcblx0ICogU2V0IGFjdGl2ZSAoaG92ZXJlZCkgZWxlbWVudHNcblx0ICogQHBhcmFtIHthcnJheX0gYWN0aXZlRWxlbWVudHMgTmV3IGFjdGl2ZSBkYXRhIHBvaW50c1xuXHQgKi9cbiAgc2V0QWN0aXZlRWxlbWVudHMoYWN0aXZlRWxlbWVudHMpIHtcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICAgIGNvbnN0IGFjdGl2ZSA9IGFjdGl2ZUVsZW1lbnRzLm1hcCgoe2RhdGFzZXRJbmRleCwgaW5kZXh9KSA9PiB7XG4gICAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGF0YXNldCBmb3VuZCBhdCBpbmRleCAnICsgZGF0YXNldEluZGV4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YXNldEluZGV4LFxuICAgICAgICBlbGVtZW50OiBtZXRhLmRhdGFbaW5kZXhdLFxuICAgICAgICBpbmRleCxcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgY2hhbmdlZCA9ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpO1xuXG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCB1c2UgdGhlIHByZXZpb3VzIG1vdXNlIGV2ZW50IHRvIG92ZXJyaWRlIHRoZSBhY3RpdmUgZWxlbWVudHMgaW4gdXBkYXRlLlxuICAgICAgdGhpcy5fbGFzdEV2ZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIENhbGxzIGVuYWJsZWQgcGx1Z2lucyBvbiB0aGUgc3BlY2lmaWVkIGhvb2sgYW5kIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG5cdCAqIFRoaXMgbWV0aG9kIGltbWVkaWF0ZWx5IHJldHVybnMgYXMgc29vbiBhcyBhIHBsdWdpbiBleHBsaWNpdGx5IHJldHVybnMgZmFsc2UuIFRoZVxuXHQgKiByZXR1cm5lZCB2YWx1ZSBjYW4gYmUgdXNlZCwgZm9yIGluc3RhbmNlLCB0byBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgYWN0aW9uLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaG9vayAtIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gbWV0aG9kIHRvIGNhbGwgKGUuZy4gJ2JlZm9yZVVwZGF0ZScpLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW2FyZ3NdIC0gRXh0cmEgYXJndW1lbnRzIHRvIGFwcGx5IHRvIHRoZSBob29rIGNhbGwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuL2NvcmUucGx1Z2lucy5qcycpLmZpbHRlckNhbGxiYWNrfSBbZmlsdGVyXSAtIEZpbHRlcmluZyBmdW5jdGlvbiBmb3IgbGltaXRpbmcgd2hpY2ggcGx1Z2lucyBhcmUgbm90aWZpZWRcblx0ICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlIGlmIGFueSBvZiB0aGUgcGx1Z2lucyByZXR1cm4gZmFsc2UsIGVsc2UgcmV0dXJucyB0cnVlLlxuXHQgKi9cbiAgbm90aWZ5UGx1Z2lucyhob29rLCBhcmdzLCBmaWx0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1Z2lucy5ub3RpZnkodGhpcywgaG9vaywgYXJncywgZmlsdGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHBsdWdpbiB3aXRoIHRoZSBzcGVjaWZpYyBJRCBpcyByZWdpc3RlcmVkIGFuZCBlbmFibGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwbHVnaW5JZCAtIFRoZSBJRCBvZiB0aGUgcGx1Z2luIG9mIHdoaWNoIHRvIGNoZWNrIGlmIGl0IGlzIGVuYWJsZWRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc1BsdWdpbkVuYWJsZWQocGx1Z2luSWQpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1Z2lucy5fY2FjaGUuZmlsdGVyKHAgPT4gcC5wbHVnaW4uaWQgPT09IHBsdWdpbklkKS5sZW5ndGggPT09IDE7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVIb3ZlclN0eWxlcyhhY3RpdmUsIGxhc3RBY3RpdmUsIHJlcGxheSkge1xuICAgIGNvbnN0IGhvdmVyT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5ob3ZlcjtcbiAgICBjb25zdCBkaWZmID0gKGEsIGIpID0+IGEuZmlsdGVyKHggPT4gIWIuc29tZSh5ID0+IHguZGF0YXNldEluZGV4ID09PSB5LmRhdGFzZXRJbmRleCAmJiB4LmluZGV4ID09PSB5LmluZGV4KSk7XG4gICAgY29uc3QgZGVhY3RpdmF0ZWQgPSBkaWZmKGxhc3RBY3RpdmUsIGFjdGl2ZSk7XG4gICAgY29uc3QgYWN0aXZhdGVkID0gcmVwbGF5ID8gYWN0aXZlIDogZGlmZihhY3RpdmUsIGxhc3RBY3RpdmUpO1xuXG4gICAgaWYgKGRlYWN0aXZhdGVkLmxlbmd0aCkge1xuICAgICAgdGhpcy51cGRhdGVIb3ZlclN0eWxlKGRlYWN0aXZhdGVkLCBob3Zlck9wdGlvbnMubW9kZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChhY3RpdmF0ZWQubGVuZ3RoICYmIGhvdmVyT3B0aW9ucy5tb2RlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUhvdmVyU3R5bGUoYWN0aXZhdGVkLCBob3Zlck9wdGlvbnMubW9kZSwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZXZlbnRIYW5kbGVyKGUsIHJlcGxheSkge1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBldmVudDogZSxcbiAgICAgIHJlcGxheSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBpbkNoYXJ0QXJlYTogdGhpcy5pc1BvaW50SW5BcmVhKGUpXG4gICAgfTtcbiAgICBjb25zdCBldmVudEZpbHRlciA9IChwbHVnaW4pID0+IChwbHVnaW4ub3B0aW9ucy5ldmVudHMgfHwgdGhpcy5vcHRpb25zLmV2ZW50cykuaW5jbHVkZXMoZS5uYXRpdmUudHlwZSk7XG5cbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVFdmVudCcsIGFyZ3MsIGV2ZW50RmlsdGVyKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5faGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBhcmdzLmluQ2hhcnRBcmVhKTtcblxuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJFdmVudCcsIGFyZ3MsIGV2ZW50RmlsdGVyKTtcblxuICAgIGlmIChjaGFuZ2VkIHx8IGFyZ3MuY2hhbmdlZCkge1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBIYW5kbGUgYW4gZXZlbnRcblx0ICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIHRoZSBldmVudCB0byBoYW5kbGVcblx0ICogQHBhcmFtIHtib29sZWFufSBbcmVwbGF5XSAtIHRydWUgaWYgdGhlIGV2ZW50IHdhcyByZXBsYXllZCBieSBgdXBkYXRlYFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbkNoYXJ0QXJlYV0gLSB0cnVlIGlmIHRoZSBldmVudCBpcyBpbnNpZGUgY2hhcnRBcmVhXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGNoYXJ0IG5lZWRzIHRvIHJlLXJlbmRlclxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2hhbmRsZUV2ZW50KGUsIHJlcGxheSwgaW5DaGFydEFyZWEpIHtcbiAgICBjb25zdCB7X2FjdGl2ZTogbGFzdEFjdGl2ZSA9IFtdLCBvcHRpb25zfSA9IHRoaXM7XG5cbiAgICAvLyBJZiB0aGUgZXZlbnQgaXMgcmVwbGF5ZWQgZnJvbSBgdXBkYXRlYCwgd2Ugc2hvdWxkIGV2YWx1YXRlIHdpdGggdGhlIGZpbmFsIHBvc2l0aW9ucy5cbiAgICAvL1xuICAgIC8vIFRoZSBgcmVwbGF5YDpcbiAgICAvLyBJdCdzIHRoZSBsYXN0IGV2ZW50IChleGNsdWRpbmcgY2xpY2spIHRoYXQgaGFzIG9jY3VycmVkIGJlZm9yZSBgdXBkYXRlYC5cbiAgICAvLyBTbyBtb3VzZSBoYXMgbm90IG1vdmVkLiBJdCdzIGFsc28gb3ZlciB0aGUgY2hhcnQsIGJlY2F1c2UgdGhlcmUgaXMgYSBgcmVwbGF5YC5cbiAgICAvL1xuICAgIC8vIFRoZSB3aHk6XG4gICAgLy8gSWYgYW5pbWF0aW9ucyBhcmUgYWN0aXZlLCB0aGUgZWxlbWVudHMgaGF2ZW4ndCBtb3ZlZCB5ZXQgY29tcGFyZWQgdG8gc3RhdGUgYmVmb3JlIHVwZGF0ZS5cbiAgICAvLyBCdXQgaWYgdGhleSB3aWxsLCB3ZSBhcmUgYWN0aXZhdGluZyB0aGUgZWxlbWVudHMgdGhhdCB3b3VsZCBiZSBhY3RpdmUsIGlmIHRoaXMgY2hlY2tcbiAgICAvLyB3YXMgZG9uZSBhZnRlciB0aGUgYW5pbWF0aW9ucyBoYXZlIGNvbXBsZXRlZC4gPT4gXCJmaW5hbCBwb3NpdGlvbnNcIi5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbmltYXRpb25zLCB0aGUgXCJmaW5hbFwiIGFuZCBcImN1cnJlbnRcIiBwb3NpdGlvbnMgYXJlIGVxdWFsLlxuICAgIC8vIFRoaXMgaXMgZG9uZSBzbyB3ZSBkbyBub3QgaGF2ZSB0byBldmFsdWF0ZSB0aGUgYWN0aXZlIGVsZW1lbnRzIGVhY2ggYW5pbWF0aW9uIGZyYW1lXG4gICAgLy8gLSBpdCB3b3VsZCBiZSBleHBlbnNpdmUuXG4gICAgY29uc3QgdXNlRmluYWxQb3NpdGlvbiA9IHJlcGxheTtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCBpbkNoYXJ0QXJlYSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgaXNDbGljayA9IF9pc0NsaWNrRXZlbnQoZSk7XG4gICAgY29uc3QgbGFzdEV2ZW50ID0gZGV0ZXJtaW5lTGFzdEV2ZW50KGUsIHRoaXMuX2xhc3RFdmVudCwgaW5DaGFydEFyZWEsIGlzQ2xpY2spO1xuXG4gICAgaWYgKGluQ2hhcnRBcmVhKSB7XG4gICAgICAvLyBTZXQgX2xhc3RFdmVudCB0byBudWxsIHdoaWxlIHdlIGFyZSBwcm9jZXNzaW5nIHRoZSBldmVudCBoYW5kbGVycy5cbiAgICAgIC8vIFRoaXMgcHJldmVudHMgcmVjdXJzaW9uIGlmIHRoZSBoYW5kbGVyIGNhbGxzIGNoYXJ0LnVwZGF0ZSgpXG4gICAgICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xuXG4gICAgICAvLyBJbnZva2Ugb25Ib3ZlciBob29rXG4gICAgICBjYWxsQ2FsbGJhY2sob3B0aW9ucy5vbkhvdmVyLCBbZSwgYWN0aXZlLCB0aGlzXSwgdGhpcyk7XG5cbiAgICAgIGlmIChpc0NsaWNrKSB7XG4gICAgICAgIGNhbGxDYWxsYmFjayhvcHRpb25zLm9uQ2xpY2ssIFtlLCBhY3RpdmUsIHRoaXNdLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgaWYgKGNoYW5nZWQgfHwgcmVwbGF5KSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICB0aGlzLl91cGRhdGVIb3ZlclN0eWxlcyhhY3RpdmUsIGxhc3RBY3RpdmUsIHJlcGxheSk7XG4gICAgfVxuXG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gbGFzdEV2ZW50O1xuXG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIC0gVGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkFjdGl2ZUVsZW1lbnRbXX0gbGFzdEFjdGl2ZSAtIFByZXZpb3VzbHkgYWN0aXZlIGVsZW1lbnRzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5DaGFydEFyZWEgLSBJcyB0aGUgZXZlbnQgaW5zaWRlIGNoYXJ0QXJlYVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVzZUZpbmFsUG9zaXRpb24gLSBTaG91bGQgdGhlIGV2YWx1YXRpb24gYmUgZG9uZSB3aXRoIGN1cnJlbnQgb3IgZmluYWwgKGFmdGVyIGFuaW1hdGlvbikgZWxlbWVudCBwb3NpdGlvbnNcbiAgICogQHJldHVybnMge2ltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5BY3RpdmVFbGVtZW50W119IC0gVGhlIGFjdGl2ZSBlbGVtZW50c1xuICAgKiBAcHJhdmF0ZVxuICAgKi9cbiAgX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIGluQ2hhcnRBcmVhLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmICghaW5DaGFydEFyZWEpIHtcbiAgICAgIC8vIExldCB1c2VyIGNvbnRyb2wgdGhlIGFjdGl2ZSBlbGVtZW50cyBvdXRzaWRlIGNoYXJ0QXJlYS4gRWcuIHVzaW5nIExlZ2VuZC5cbiAgICAgIHJldHVybiBsYXN0QWN0aXZlO1xuICAgIH1cblxuICAgIGNvbnN0IGhvdmVyT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5ob3ZlcjtcbiAgICByZXR1cm4gdGhpcy5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIGhvdmVyT3B0aW9ucy5tb2RlLCBob3Zlck9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG59XG5cbi8vIEB0cy1pZ25vcmVcbmZ1bmN0aW9uIGludmFsaWRhdGVQbHVnaW5zKCkge1xuICByZXR1cm4gZWFjaChDaGFydC5pbnN0YW5jZXMsIChjaGFydCkgPT4gY2hhcnQuX3BsdWdpbnMuaW52YWxpZGF0ZSgpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2hhcnQ7XG4iLCAiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vY29yZS9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IHtfYW5nbGVCZXR3ZWVuLCBnZXRBbmdsZUZyb21Qb2ludCwgVEFVLCBIQUxGX1BJLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge1BJLCBfaXNCZXR3ZWVuLCBfbGltaXRWYWx1ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfcmVhZFZhbHVlVG9Qcm9wc30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuaW1wb3J0IHR5cGUge0FyY09wdGlvbnMsIFBvaW50fSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cblxuZnVuY3Rpb24gY2xpcEFyYyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgZWxlbWVudDogQXJjRWxlbWVudCwgZW5kQW5nbGU6IG51bWJlcikge1xuICBjb25zdCB7c3RhcnRBbmdsZSwgcGl4ZWxNYXJnaW4sIHgsIHksIG91dGVyUmFkaXVzLCBpbm5lclJhZGl1c30gPSBlbGVtZW50O1xuICBsZXQgYW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIG91dGVyUmFkaXVzO1xuXG4gIC8vIERyYXcgYW4gaW5uZXIgYm9yZGVyIGJ5IGNsaXBwaW5nIHRoZSBhcmMgYW5kIGRyYXdpbmcgYSBkb3VibGUtd2lkdGggYm9yZGVyXG4gIC8vIEVubGFyZ2UgdGhlIGNsaXBwaW5nIGFyYyBieSAwLjMzIHBpeGVscyB0byBlbGltaW5hdGUgZ2xpdGNoZXMgYmV0d2VlbiBib3JkZXJzXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgc3RhcnRBbmdsZSAtIGFuZ2xlTWFyZ2luLCBlbmRBbmdsZSArIGFuZ2xlTWFyZ2luKTtcbiAgaWYgKGlubmVyUmFkaXVzID4gcGl4ZWxNYXJnaW4pIHtcbiAgICBhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gaW5uZXJSYWRpdXM7XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgZW5kQW5nbGUgKyBhbmdsZU1hcmdpbiwgc3RhcnRBbmdsZSAtIGFuZ2xlTWFyZ2luLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBjdHguYXJjKHgsIHksIHBpeGVsTWFyZ2luLCBlbmRBbmdsZSArIEhBTEZfUEksIHN0YXJ0QW5nbGUgLSBIQUxGX1BJKTtcbiAgfVxuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5jbGlwKCk7XG59XG5cbmZ1bmN0aW9uIHRvUmFkaXVzQ29ybmVycyh2YWx1ZSkge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIFsnb3V0ZXJTdGFydCcsICdvdXRlckVuZCcsICdpbm5lclN0YXJ0JywgJ2lubmVyRW5kJ10pO1xufVxuXG4vKipcbiAqIFBhcnNlIGJvcmRlciByYWRpdXMgZnJvbSB0aGUgcHJvdmlkZWQgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBwYXJzZUJvcmRlclJhZGl1cyhhcmM6IEFyY0VsZW1lbnQsIGlubmVyUmFkaXVzOiBudW1iZXIsIG91dGVyUmFkaXVzOiBudW1iZXIsIGFuZ2xlRGVsdGE6IG51bWJlcikge1xuICBjb25zdCBvID0gdG9SYWRpdXNDb3JuZXJzKGFyYy5vcHRpb25zLmJvcmRlclJhZGl1cyk7XG4gIGNvbnN0IGhhbGZUaGlja25lc3MgPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyAyO1xuICBjb25zdCBpbm5lckxpbWl0ID0gTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgYW5nbGVEZWx0YSAqIGlubmVyUmFkaXVzIC8gMik7XG5cbiAgLy8gT3V0ZXIgbGltaXRzIGFyZSBjb21wbGljYXRlZC4gV2Ugd2FudCB0byBjb21wdXRlIHRoZSBhdmFpbGFibGUgYW5ndWxhciBkaXN0YW5jZSBhdFxuICAvLyBhIHJhZGl1cyBvZiBvdXRlclJhZGl1cyAtIGJvcmRlclJhZGl1cyBiZWNhdXNlIGZvciBzbWFsbCBhbmd1bGFyIGRpc3RhbmNlcywgdGhpcyB0ZXJtIGxpbWl0cy5cbiAgLy8gV2UgY29tcHV0ZSBhdCByID0gb3V0ZXJSYWRpdXMgLSBib3JkZXJSYWRpdXMgYmVjYXVzZSB0aGlzIGNpcmNsZSBkZWZpbmVzIHRoZSBjZW50ZXIgb2YgdGhlIGJvcmRlciBjb3JuZXJzLlxuICAvL1xuICAvLyBJZiB0aGUgYm9yZGVyUmFkaXVzIGlzIGxhcmdlLCB0aGF0IHZhbHVlIGNhbiBiZWNvbWUgbmVnYXRpdmUuXG4gIC8vIFRoaXMgY2F1c2VzIHRoZSBvdXRlciBib3JkZXJzIHRvIGxvc2UgdGhlaXIgcmFkaXVzIGVudGlyZWx5LCB3aGljaCBpcyByYXRoZXIgdW5leHBlY3RlZC4gVG8gc29sdmUgdGhhdCwgaWYgYm9yZGVyUmFkaXVzID4gb3V0ZXJSYWRpdXNcbiAgLy8gd2Uga25vdyB0aGF0IHRoZSB0aGlja25lc3MgdGVybSB3aWxsIGRvbWluYXRlIGFuZCBjb21wdXRlIHRoZSBsaW1pdHMgYXQgdGhhdCBwb2ludFxuICBjb25zdCBjb21wdXRlT3V0ZXJMaW1pdCA9ICh2YWwpID0+IHtcbiAgICBjb25zdCBvdXRlckFyY0xpbWl0ID0gKG91dGVyUmFkaXVzIC0gTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgdmFsKSkgKiBhbmdsZURlbHRhIC8gMjtcbiAgICByZXR1cm4gX2xpbWl0VmFsdWUodmFsLCAwLCBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCBvdXRlckFyY0xpbWl0KSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBvdXRlclN0YXJ0OiBjb21wdXRlT3V0ZXJMaW1pdChvLm91dGVyU3RhcnQpLFxuICAgIG91dGVyRW5kOiBjb21wdXRlT3V0ZXJMaW1pdChvLm91dGVyRW5kKSxcbiAgICBpbm5lclN0YXJ0OiBfbGltaXRWYWx1ZShvLmlubmVyU3RhcnQsIDAsIGlubmVyTGltaXQpLFxuICAgIGlubmVyRW5kOiBfbGltaXRWYWx1ZShvLmlubmVyRW5kLCAwLCBpbm5lckxpbWl0KSxcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IChyLCDwnZyDKSB0byAoeCwgeSlcbiAqL1xuZnVuY3Rpb24gclRoZXRhVG9YWShyOiBudW1iZXIsIHRoZXRhOiBudW1iZXIsIHg6IG51bWJlciwgeTogbnVtYmVyKSB7XG4gIHJldHVybiB7XG4gICAgeDogeCArIHIgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgeTogeSArIHIgKiBNYXRoLnNpbih0aGV0YSksXG4gIH07XG59XG5cblxuLyoqXG4gKiBQYXRoIHRoZSBhcmMsIHJlc3BlY3RpbmcgYm9yZGVyIHJhZGl1cyBieSBzZXBhcmF0aW5nIGludG8gbGVmdCBhbmQgcmlnaHQgaGFsdmVzLlxuICpcbiAqICAgU3RhcnQgICAgICBFbmRcbiAqXG4gKiAgICAxLS0tPmEtLS0+MiAgICBPdXRlclxuICogICAvICAgICAgICAgICBcXFxuICogICA4ICAgICAgICAgICAzXG4gKiAgIHwgICAgICAgICAgIHxcbiAqICAgfCAgICAgICAgICAgfFxuICogICA3ICAgICAgICAgICA0XG4gKiAgIFxcICAgICAgICAgICAvXG4gKiAgICA2PC0tLWI8LS0tNSAgICBJbm5lclxuICovXG5mdW5jdGlvbiBwYXRoQXJjKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgZWxlbWVudDogQXJjRWxlbWVudCxcbiAgb2Zmc2V0OiBudW1iZXIsXG4gIHNwYWNpbmc6IG51bWJlcixcbiAgZW5kOiBudW1iZXIsXG4gIGNpcmN1bGFyOiBib29sZWFuLFxuKSB7XG4gIGNvbnN0IHt4LCB5LCBzdGFydEFuZ2xlOiBzdGFydCwgcGl4ZWxNYXJnaW4sIGlubmVyUmFkaXVzOiBpbm5lclJ9ID0gZWxlbWVudDtcblxuICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KGVsZW1lbnQub3V0ZXJSYWRpdXMgKyBzcGFjaW5nICsgb2Zmc2V0IC0gcGl4ZWxNYXJnaW4sIDApO1xuICBjb25zdCBpbm5lclJhZGl1cyA9IGlubmVyUiA+IDAgPyBpbm5lclIgKyBzcGFjaW5nICsgb2Zmc2V0ICsgcGl4ZWxNYXJnaW4gOiAwO1xuXG4gIGxldCBzcGFjaW5nT2Zmc2V0ID0gMDtcbiAgY29uc3QgYWxwaGEgPSBlbmQgLSBzdGFydDtcblxuICBpZiAoc3BhY2luZykge1xuICAgIC8vIFdoZW4gc3BhY2luZyBpcyBwcmVzZW50LCBpdCBpcyB0aGUgc2FtZSBmb3IgYWxsIGl0ZW1zXG4gICAgLy8gU28gd2UgYWRqdXN0IHRoZSBzdGFydCBhbmQgZW5kIGFuZ2xlIG9mIHRoZSBhcmMgc3VjaCB0aGF0XG4gICAgLy8gdGhlIGRpc3RhbmNlIGlzIHRoZSBzYW1lIGFzIGl0IHdvdWxkIGJlIHdpdGhvdXQgdGhlIHNwYWNpbmdcbiAgICBjb25zdCBub1NwYWNpbmdJbm5lclJhZGl1cyA9IGlubmVyUiA+IDAgPyBpbm5lclIgLSBzcGFjaW5nIDogMDtcbiAgICBjb25zdCBub1NwYWNpbmdPdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzID4gMCA/IG91dGVyUmFkaXVzIC0gc3BhY2luZyA6IDA7XG4gICAgY29uc3QgYXZOb2dTcGFjaW5nUmFkaXVzID0gKG5vU3BhY2luZ0lubmVyUmFkaXVzICsgbm9TcGFjaW5nT3V0ZXJSYWRpdXMpIC8gMjtcbiAgICBjb25zdCBhZGp1c3RlZEFuZ2xlID0gYXZOb2dTcGFjaW5nUmFkaXVzICE9PSAwID8gKGFscGhhICogYXZOb2dTcGFjaW5nUmFkaXVzKSAvIChhdk5vZ1NwYWNpbmdSYWRpdXMgKyBzcGFjaW5nKSA6IGFscGhhO1xuICAgIHNwYWNpbmdPZmZzZXQgPSAoYWxwaGEgLSBhZGp1c3RlZEFuZ2xlKSAvIDI7XG4gIH1cblxuICBjb25zdCBiZXRhID0gTWF0aC5tYXgoMC4wMDEsIGFscGhhICogb3V0ZXJSYWRpdXMgLSBvZmZzZXQgLyBQSSkgLyBvdXRlclJhZGl1cztcbiAgY29uc3QgYW5nbGVPZmZzZXQgPSAoYWxwaGEgLSBiZXRhKSAvIDI7XG4gIGNvbnN0IHN0YXJ0QW5nbGUgPSBzdGFydCArIGFuZ2xlT2Zmc2V0ICsgc3BhY2luZ09mZnNldDtcbiAgY29uc3QgZW5kQW5nbGUgPSBlbmQgLSBhbmdsZU9mZnNldCAtIHNwYWNpbmdPZmZzZXQ7XG4gIGNvbnN0IHtvdXRlclN0YXJ0LCBvdXRlckVuZCwgaW5uZXJTdGFydCwgaW5uZXJFbmR9ID0gcGFyc2VCb3JkZXJSYWRpdXMoZWxlbWVudCwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xuXG4gIGNvbnN0IG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cyA9IG91dGVyUmFkaXVzIC0gb3V0ZXJTdGFydDtcbiAgY29uc3Qgb3V0ZXJFbmRBZGp1c3RlZFJhZGl1cyA9IG91dGVyUmFkaXVzIC0gb3V0ZXJFbmQ7XG4gIGNvbnN0IG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlID0gc3RhcnRBbmdsZSArIG91dGVyU3RhcnQgLyBvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IG91dGVyRW5kQWRqdXN0ZWRBbmdsZSA9IGVuZEFuZ2xlIC0gb3V0ZXJFbmQgLyBvdXRlckVuZEFkanVzdGVkUmFkaXVzO1xuXG4gIGNvbnN0IGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cyA9IGlubmVyUmFkaXVzICsgaW5uZXJTdGFydDtcbiAgY29uc3QgaW5uZXJFbmRBZGp1c3RlZFJhZGl1cyA9IGlubmVyUmFkaXVzICsgaW5uZXJFbmQ7XG4gIGNvbnN0IGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlID0gc3RhcnRBbmdsZSArIGlubmVyU3RhcnQgLyBpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IGlubmVyRW5kQWRqdXN0ZWRBbmdsZSA9IGVuZEFuZ2xlIC0gaW5uZXJFbmQgLyBpbm5lckVuZEFkanVzdGVkUmFkaXVzO1xuXG4gIGN0eC5iZWdpblBhdGgoKTtcblxuICBpZiAoY2lyY3VsYXIpIHtcbiAgICAvLyBUaGUgZmlyc3QgYXJjIHNlZ21lbnRzIGZyb20gcG9pbnQgMSB0byBwb2ludCBhIHRvIHBvaW50IDJcbiAgICBjb25zdCBvdXRlck1pZEFkanVzdGVkQW5nbGUgPSAob3V0ZXJTdGFydEFkanVzdGVkQW5nbGUgKyBvdXRlckVuZEFkanVzdGVkQW5nbGUpIC8gMjtcbiAgICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSwgb3V0ZXJNaWRBZGp1c3RlZEFuZ2xlKTtcbiAgICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzLCBvdXRlck1pZEFkanVzdGVkQW5nbGUsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSk7XG5cbiAgICAvLyBUaGUgY29ybmVyIHNlZ21lbnQgZnJvbSBwb2ludCAyIHRvIHBvaW50IDNcbiAgICBpZiAob3V0ZXJFbmQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShvdXRlckVuZEFkanVzdGVkUmFkaXVzLCBvdXRlckVuZEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgb3V0ZXJFbmQsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSwgZW5kQW5nbGUgKyBIQUxGX1BJKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgbGluZSBmcm9tIHBvaW50IDMgdG8gcG9pbnQgNFxuICAgIGNvbnN0IHA0ID0gclRoZXRhVG9YWShpbm5lckVuZEFkanVzdGVkUmFkaXVzLCBlbmRBbmdsZSwgeCwgeSk7XG4gICAgY3R4LmxpbmVUbyhwNC54LCBwNC55KTtcblxuICAgIC8vIFRoZSBjb3JuZXIgc2VnbWVudCBmcm9tIHBvaW50IDQgdG8gcG9pbnQgNVxuICAgIGlmIChpbm5lckVuZCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKGlubmVyRW5kQWRqdXN0ZWRSYWRpdXMsIGlubmVyRW5kQWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBpbm5lckVuZCwgZW5kQW5nbGUgKyBIQUxGX1BJLCBpbm5lckVuZEFkanVzdGVkQW5nbGUgKyBNYXRoLlBJKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgaW5uZXIgYXJjIGZyb20gcG9pbnQgNSB0byBwb2ludCBiIHRvIHBvaW50IDZcbiAgICBjb25zdCBpbm5lck1pZEFkanVzdGVkQW5nbGUgPSAoKGVuZEFuZ2xlIC0gKGlubmVyRW5kIC8gaW5uZXJSYWRpdXMpKSArIChzdGFydEFuZ2xlICsgKGlubmVyU3RhcnQgLyBpbm5lclJhZGl1cykpKSAvIDI7XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgZW5kQW5nbGUgLSAoaW5uZXJFbmQgLyBpbm5lclJhZGl1cyksIGlubmVyTWlkQWRqdXN0ZWRBbmdsZSwgdHJ1ZSk7XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgaW5uZXJNaWRBZGp1c3RlZEFuZ2xlLCBzdGFydEFuZ2xlICsgKGlubmVyU3RhcnQgLyBpbm5lclJhZGl1cyksIHRydWUpO1xuXG4gICAgLy8gVGhlIGNvcm5lciBzZWdtZW50IGZyb20gcG9pbnQgNiB0byBwb2ludCA3XG4gICAgaWYgKGlubmVyU3RhcnQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIGlubmVyU3RhcnQsIGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlICsgTWF0aC5QSSwgc3RhcnRBbmdsZSAtIEhBTEZfUEkpO1xuICAgIH1cblxuICAgIC8vIFRoZSBsaW5lIGZyb20gcG9pbnQgNyB0byBwb2ludCA4XG4gICAgY29uc3QgcDggPSByVGhldGFUb1hZKG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cywgc3RhcnRBbmdsZSwgeCwgeSk7XG4gICAgY3R4LmxpbmVUbyhwOC54LCBwOC55KTtcblxuICAgIC8vIFRoZSBjb3JuZXIgc2VnbWVudCBmcm9tIHBvaW50IDggdG8gcG9pbnQgMVxuICAgIGlmIChvdXRlclN0YXJ0ID4gMCkge1xuICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkob3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBvdXRlclN0YXJ0LCBzdGFydEFuZ2xlIC0gSEFMRl9QSSwgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjdHgubW92ZVRvKHgsIHkpO1xuXG4gICAgY29uc3Qgb3V0ZXJTdGFydFggPSBNYXRoLmNvcyhvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHg7XG4gICAgY29uc3Qgb3V0ZXJTdGFydFkgPSBNYXRoLnNpbihvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHk7XG4gICAgY3R4LmxpbmVUbyhvdXRlclN0YXJ0WCwgb3V0ZXJTdGFydFkpO1xuXG4gICAgY29uc3Qgb3V0ZXJFbmRYID0gTWF0aC5jb3Mob3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeDtcbiAgICBjb25zdCBvdXRlckVuZFkgPSBNYXRoLnNpbihvdXRlckVuZEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB5O1xuICAgIGN0eC5saW5lVG8ob3V0ZXJFbmRYLCBvdXRlckVuZFkpO1xuICB9XG5cbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxuXG5mdW5jdGlvbiBkcmF3QXJjKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgZWxlbWVudDogQXJjRWxlbWVudCxcbiAgb2Zmc2V0OiBudW1iZXIsXG4gIHNwYWNpbmc6IG51bWJlcixcbiAgY2lyY3VsYXI6IGJvb2xlYW4sXG4pIHtcbiAgY29uc3Qge2Z1bGxDaXJjbGVzLCBzdGFydEFuZ2xlLCBjaXJjdW1mZXJlbmNlfSA9IGVsZW1lbnQ7XG4gIGxldCBlbmRBbmdsZSA9IGVsZW1lbnQuZW5kQW5nbGU7XG4gIGlmIChmdWxsQ2lyY2xlcykge1xuICAgIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKSB7XG4gICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBpZiAoIWlzTmFOKGNpcmN1bWZlcmVuY2UpKSB7XG4gICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyAoY2lyY3VtZmVyZW5jZSAlIFRBVSB8fCBUQVUpO1xuICAgIH1cbiAgfVxuICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICBjdHguZmlsbCgpO1xuICByZXR1cm4gZW5kQW5nbGU7XG59XG5cbmZ1bmN0aW9uIGRyYXdCb3JkZXIoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBlbGVtZW50OiBBcmNFbGVtZW50LFxuICBvZmZzZXQ6IG51bWJlcixcbiAgc3BhY2luZzogbnVtYmVyLFxuICBjaXJjdWxhcjogYm9vbGVhbixcbikge1xuICBjb25zdCB7ZnVsbENpcmNsZXMsIHN0YXJ0QW5nbGUsIGNpcmN1bWZlcmVuY2UsIG9wdGlvbnN9ID0gZWxlbWVudDtcbiAgY29uc3Qge2JvcmRlcldpZHRoLCBib3JkZXJKb2luU3R5bGUsIGJvcmRlckRhc2gsIGJvcmRlckRhc2hPZmZzZXR9ID0gb3B0aW9ucztcbiAgY29uc3QgaW5uZXIgPSBvcHRpb25zLmJvcmRlckFsaWduID09PSAnaW5uZXInO1xuXG4gIGlmICghYm9yZGVyV2lkdGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdHguc2V0TGluZURhc2goYm9yZGVyRGFzaCB8fCBbXSk7XG4gIGN0eC5saW5lRGFzaE9mZnNldCA9IGJvcmRlckRhc2hPZmZzZXQ7XG5cbiAgaWYgKGlubmVyKSB7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoICogMjtcbiAgICBjdHgubGluZUpvaW4gPSBib3JkZXJKb2luU3R5bGUgfHwgJ3JvdW5kJztcbiAgfSBlbHNlIHtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgY3R4LmxpbmVKb2luID0gYm9yZGVySm9pblN0eWxlIHx8ICdiZXZlbCc7XG4gIH1cblxuICBsZXQgZW5kQW5nbGUgPSBlbGVtZW50LmVuZEFuZ2xlO1xuICBpZiAoZnVsbENpcmNsZXMpIHtcbiAgICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnVsbENpcmNsZXM7ICsraSkge1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICBpZiAoIWlzTmFOKGNpcmN1bWZlcmVuY2UpKSB7XG4gICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyAoY2lyY3VtZmVyZW5jZSAlIFRBVSB8fCBUQVUpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpbm5lcikge1xuICAgIGNsaXBBcmMoY3R4LCBlbGVtZW50LCBlbmRBbmdsZSk7XG4gIH1cblxuICBpZiAoIWZ1bGxDaXJjbGVzKSB7XG4gICAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBcmNQcm9wcyBleHRlbmRzIFBvaW50IHtcbiAgc3RhcnRBbmdsZTogbnVtYmVyO1xuICBlbmRBbmdsZTogbnVtYmVyO1xuICBpbm5lclJhZGl1czogbnVtYmVyO1xuICBvdXRlclJhZGl1czogbnVtYmVyO1xuICBjaXJjdW1mZXJlbmNlOiBudW1iZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFyY0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PEFyY1Byb3BzLCBBcmNPcHRpb25zPiB7XG5cbiAgc3RhdGljIGlkID0gJ2FyYyc7XG5cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGJvcmRlckFsaWduOiAnY2VudGVyJyxcbiAgICBib3JkZXJDb2xvcjogJyNmZmYnLFxuICAgIGJvcmRlckRhc2g6IFtdLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IDAsXG4gICAgYm9yZGVySm9pblN0eWxlOiB1bmRlZmluZWQsXG4gICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgIGJvcmRlcldpZHRoOiAyLFxuICAgIG9mZnNldDogMCxcbiAgICBzcGFjaW5nOiAwLFxuICAgIGFuZ2xlOiB1bmRlZmluZWQsXG4gICAgY2lyY3VsYXI6IHRydWUsXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJ1xuICB9O1xuXG4gIHN0YXRpYyBkZXNjcmlwdG9ycyA9IHtcbiAgICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnXG4gIH07XG5cbiAgY2lyY3VtZmVyZW5jZTogbnVtYmVyO1xuICBlbmRBbmdsZTogbnVtYmVyO1xuICBmdWxsQ2lyY2xlczogbnVtYmVyO1xuICBpbm5lclJhZGl1czogbnVtYmVyO1xuICBvdXRlclJhZGl1czogbnVtYmVyO1xuICBwaXhlbE1hcmdpbjogbnVtYmVyO1xuICBzdGFydEFuZ2xlOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNpcmN1bWZlcmVuY2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdGFydEFuZ2xlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5kQW5nbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGl4ZWxNYXJnaW4gPSAwO1xuICAgIHRoaXMuZnVsbENpcmNsZXMgPSAwO1xuXG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuXG4gIGluUmFuZ2UoY2hhcnRYOiBudW1iZXIsIGNoYXJ0WTogbnVtYmVyLCB1c2VGaW5hbFBvc2l0aW9uOiBib29sZWFuKSB7XG4gICAgY29uc3QgcG9pbnQgPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHthbmdsZSwgZGlzdGFuY2V9ID0gZ2V0QW5nbGVGcm9tUG9pbnQocG9pbnQsIHt4OiBjaGFydFgsIHk6IGNoYXJ0WX0pO1xuICAgIGNvbnN0IHtzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBjaXJjdW1mZXJlbmNlfSA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgJ3N0YXJ0QW5nbGUnLFxuICAgICAgJ2VuZEFuZ2xlJyxcbiAgICAgICdpbm5lclJhZGl1cycsXG4gICAgICAnb3V0ZXJSYWRpdXMnLFxuICAgICAgJ2NpcmN1bWZlcmVuY2UnXG4gICAgXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgckFkanVzdCA9ICh0aGlzLm9wdGlvbnMuc3BhY2luZyArIHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aCkgLyAyO1xuICAgIGNvbnN0IF9jaXJjdW1mZXJlbmNlID0gdmFsdWVPckRlZmF1bHQoY2lyY3VtZmVyZW5jZSwgZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgICBjb25zdCBub25aZXJvQmV0d2VlbiA9IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSAmJiBzdGFydEFuZ2xlICE9PSBlbmRBbmdsZTtcbiAgICBjb25zdCBiZXR3ZWVuQW5nbGVzID0gX2NpcmN1bWZlcmVuY2UgPj0gVEFVIHx8IG5vblplcm9CZXR3ZWVuO1xuICAgIGNvbnN0IHdpdGhpblJhZGl1cyA9IF9pc0JldHdlZW4oZGlzdGFuY2UsIGlubmVyUmFkaXVzICsgckFkanVzdCwgb3V0ZXJSYWRpdXMgKyByQWRqdXN0KTtcblxuICAgIHJldHVybiAoYmV0d2VlbkFuZ2xlcyAmJiB3aXRoaW5SYWRpdXMpO1xuICB9XG5cbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbjogYm9vbGVhbikge1xuICAgIGNvbnN0IHt4LCB5LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzfSA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgJ3gnLFxuICAgICAgJ3knLFxuICAgICAgJ3N0YXJ0QW5nbGUnLFxuICAgICAgJ2VuZEFuZ2xlJyxcbiAgICAgICdpbm5lclJhZGl1cycsXG4gICAgICAnb3V0ZXJSYWRpdXMnXG4gICAgXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3Qge29mZnNldCwgc3BhY2luZ30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgaGFsZkFuZ2xlID0gKHN0YXJ0QW5nbGUgKyBlbmRBbmdsZSkgLyAyO1xuICAgIGNvbnN0IGhhbGZSYWRpdXMgPSAoaW5uZXJSYWRpdXMgKyBvdXRlclJhZGl1cyArIHNwYWNpbmcgKyBvZmZzZXQpIC8gMjtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCArIE1hdGguY29zKGhhbGZBbmdsZSkgKiBoYWxmUmFkaXVzLFxuICAgICAgeTogeSArIE1hdGguc2luKGhhbGZBbmdsZSkgKiBoYWxmUmFkaXVzXG4gICAgfTtcbiAgfVxuXG4gIHRvb2x0aXBQb3NpdGlvbih1c2VGaW5hbFBvc2l0aW9uOiBib29sZWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBkcmF3KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gICAgY29uc3Qge29wdGlvbnMsIGNpcmN1bWZlcmVuY2V9ID0gdGhpcztcbiAgICBjb25zdCBvZmZzZXQgPSAob3B0aW9ucy5vZmZzZXQgfHwgMCkgLyA0O1xuICAgIGNvbnN0IHNwYWNpbmcgPSAob3B0aW9ucy5zcGFjaW5nIHx8IDApIC8gMjtcbiAgICBjb25zdCBjaXJjdWxhciA9IG9wdGlvbnMuY2lyY3VsYXI7XG4gICAgdGhpcy5waXhlbE1hcmdpbiA9IChvcHRpb25zLmJvcmRlckFsaWduID09PSAnaW5uZXInKSA/IDAuMzMgOiAwO1xuICAgIHRoaXMuZnVsbENpcmNsZXMgPSBjaXJjdW1mZXJlbmNlID4gVEFVID8gTWF0aC5mbG9vcihjaXJjdW1mZXJlbmNlIC8gVEFVKSA6IDA7XG5cbiAgICBpZiAoY2lyY3VtZmVyZW5jZSA9PT0gMCB8fCB0aGlzLmlubmVyUmFkaXVzIDwgMCB8fCB0aGlzLm91dGVyUmFkaXVzIDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN0eC5zYXZlKCk7XG5cbiAgICBjb25zdCBoYWxmQW5nbGUgPSAodGhpcy5zdGFydEFuZ2xlICsgdGhpcy5lbmRBbmdsZSkgLyAyO1xuICAgIGN0eC50cmFuc2xhdGUoTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIG9mZnNldCwgTWF0aC5zaW4oaGFsZkFuZ2xlKSAqIG9mZnNldCk7XG4gICAgY29uc3QgZml4ID0gMSAtIE1hdGguc2luKE1hdGgubWluKFBJLCBjaXJjdW1mZXJlbmNlIHx8IDApKTtcbiAgICBjb25zdCByYWRpdXNPZmZzZXQgPSBvZmZzZXQgKiBmaXg7XG5cbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcblxuICAgIGRyYXdBcmMoY3R4LCB0aGlzLCByYWRpdXNPZmZzZXQsIHNwYWNpbmcsIGNpcmN1bGFyKTtcbiAgICBkcmF3Qm9yZGVyKGN0eCwgdGhpcywgcmFkaXVzT2Zmc2V0LCBzcGFjaW5nLCBjaXJjdWxhcik7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59XG4iLCAiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vY29yZS9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IHtfYmV6aWVySW50ZXJwb2xhdGlvbiwgX3BvaW50SW5MaW5lLCBfc3RlcHBlZEludGVycG9sYXRpb259IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5pbnRlcnBvbGF0aW9uLmpzJztcbmltcG9ydCB7X2NvbXB1dGVTZWdtZW50cywgX2JvdW5kU2VnbWVudHN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5zZWdtZW50LmpzJztcbmltcG9ydCB7X3N0ZXBwZWRMaW5lVG8sIF9iZXppZXJDdXJ2ZVRvfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB7X3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jdXJ2ZS5qcyc7XG5pbXBvcnQge3ZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9lbGVtZW50LnBvaW50LmpzJykuZGVmYXVsdCB9IFBvaW50RWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIHNldFN0eWxlKGN0eCwgb3B0aW9ucywgc3R5bGUgPSBvcHRpb25zKSB7XG4gIGN0eC5saW5lQ2FwID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyQ2FwU3R5bGUsIG9wdGlvbnMuYm9yZGVyQ2FwU3R5bGUpO1xuICBjdHguc2V0TGluZURhc2godmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyRGFzaCwgb3B0aW9ucy5ib3JkZXJEYXNoKSk7XG4gIGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckRhc2hPZmZzZXQsIG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCk7XG4gIGN0eC5saW5lSm9pbiA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckpvaW5TdHlsZSwgb3B0aW9ucy5ib3JkZXJKb2luU3R5bGUpO1xuICBjdHgubGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgpO1xuICBjdHguc3Ryb2tlU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJDb2xvciwgb3B0aW9ucy5ib3JkZXJDb2xvcik7XG59XG5cbmZ1bmN0aW9uIGxpbmVUbyhjdHgsIHByZXZpb3VzLCB0YXJnZXQpIHtcbiAgY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGdldExpbmVNZXRob2Qob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5zdGVwcGVkKSB7XG4gICAgcmV0dXJuIF9zdGVwcGVkTGluZVRvO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICByZXR1cm4gX2JlemllckN1cnZlVG87XG4gIH1cblxuICByZXR1cm4gbGluZVRvO1xufVxuXG5mdW5jdGlvbiBwYXRoVmFycyhwb2ludHMsIHNlZ21lbnQsIHBhcmFtcyA9IHt9KSB7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3Qge3N0YXJ0OiBwYXJhbXNTdGFydCA9IDAsIGVuZDogcGFyYW1zRW5kID0gY291bnQgLSAxfSA9IHBhcmFtcztcbiAgY29uc3Qge3N0YXJ0OiBzZWdtZW50U3RhcnQsIGVuZDogc2VnbWVudEVuZH0gPSBzZWdtZW50O1xuICBjb25zdCBzdGFydCA9IE1hdGgubWF4KHBhcmFtc1N0YXJ0LCBzZWdtZW50U3RhcnQpO1xuICBjb25zdCBlbmQgPSBNYXRoLm1pbihwYXJhbXNFbmQsIHNlZ21lbnRFbmQpO1xuICBjb25zdCBvdXRzaWRlID0gcGFyYW1zU3RhcnQgPCBzZWdtZW50U3RhcnQgJiYgcGFyYW1zRW5kIDwgc2VnbWVudFN0YXJ0IHx8IHBhcmFtc1N0YXJ0ID4gc2VnbWVudEVuZCAmJiBwYXJhbXNFbmQgPiBzZWdtZW50RW5kO1xuXG4gIHJldHVybiB7XG4gICAgY291bnQsXG4gICAgc3RhcnQsXG4gICAgbG9vcDogc2VnbWVudC5sb29wLFxuICAgIGlsZW46IGVuZCA8IHN0YXJ0ICYmICFvdXRzaWRlID8gY291bnQgKyBlbmQgLSBzdGFydCA6IGVuZCAtIHN0YXJ0XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlIHBhdGggZnJvbSBwb2ludHMsIGdyb3VwaW5nIGJ5IHRydW5jYXRlZCB4LWNvb3JkaW5hdGVcbiAqIFBvaW50cyBuZWVkIHRvIGJlIGluIG9yZGVyIGJ5IHgtY29vcmRpbmF0ZSBmb3IgdGhpcyB0byB3b3JrIGVmZmljaWVudGx5XG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxQYXRoMkR9IGN0eCAtIENvbnRleHRcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEBwYXJhbSB7b2JqZWN0fSBzZWdtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5zdGFydCAtIHN0YXJ0IGluZGV4IG9mIHRoZSBzZWdtZW50LCByZWZlcnJpbmcgdGhlIHBvaW50cyBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQuZW5kIC0gZW5kIGluZGV4IG9mIHRoZSBzZWdtZW50LCByZWZlcnJpbmcgdGhlIHBvaW50cyBhcnJheVxuICogQHBhcmFtIHtib29sZWFufSBzZWdtZW50Lmxvb3AgLSBpbmRpY2F0ZXMgdGhhdCB0aGUgc2VnbWVudCBpcyBhIGxvb3BcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLm1vdmUgLSBtb3ZlIHRvIHN0YXJ0aW5nIHBvaW50ICh2cyBsaW5lIHRvIGl0KVxuICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMucmV2ZXJzZSAtIHBhdGggdGhlIHNlZ21lbnQgZnJvbSBlbmQgdG8gc3RhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuc3RhcnQgLSBsaW1pdCBzZWdtZW50IHRvIHBvaW50cyBzdGFydGluZyBmcm9tIGBzdGFydGAgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZW5kIC0gbGltaXQgc2VnbWVudCB0byBwb2ludHMgZW5kaW5nIGF0IGBzdGFydGAgKyBgY291bnRgIGluZGV4XG4gKi9cbmZ1bmN0aW9uIHBhdGhTZWdtZW50KGN0eCwgbGluZSwgc2VnbWVudCwgcGFyYW1zKSB7XG4gIGNvbnN0IHtwb2ludHMsIG9wdGlvbnN9ID0gbGluZTtcbiAgY29uc3Qge2NvdW50LCBzdGFydCwgbG9vcCwgaWxlbn0gPSBwYXRoVmFycyhwb2ludHMsIHNlZ21lbnQsIHBhcmFtcyk7XG4gIGNvbnN0IGxpbmVNZXRob2QgPSBnZXRMaW5lTWV0aG9kKG9wdGlvbnMpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gIGxldCB7bW92ZSA9IHRydWUsIHJldmVyc2V9ID0gcGFyYW1zIHx8IHt9O1xuICBsZXQgaSwgcG9pbnQsIHByZXY7XG5cbiAgZm9yIChpID0gMDsgaSA8PSBpbGVuOyArK2kpIHtcbiAgICBwb2ludCA9IHBvaW50c1soc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gLSBpIDogaSkpICUgY291bnRdO1xuXG4gICAgaWYgKHBvaW50LnNraXApIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIGEgc2tpcHBlZCBwb2ludCBpbnNpZGUgYSBzZWdtZW50LCBzcGFuR2FwcyBtdXN0IGJlIHRydWVcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAobW92ZSkge1xuICAgICAgY3R4Lm1vdmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgICAgIG1vdmUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZU1ldGhvZChjdHgsIHByZXYsIHBvaW50LCByZXZlcnNlLCBvcHRpb25zLnN0ZXBwZWQpO1xuICAgIH1cblxuICAgIHByZXYgPSBwb2ludDtcbiAgfVxuXG4gIGlmIChsb29wKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIDogMCkpICUgY291bnRdO1xuICAgIGxpbmVNZXRob2QoY3R4LCBwcmV2LCBwb2ludCwgcmV2ZXJzZSwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgfVxuXG4gIHJldHVybiAhIWxvb3A7XG59XG5cbi8qKlxuICogQ3JlYXRlIHBhdGggZnJvbSBwb2ludHMsIGdyb3VwaW5nIGJ5IHRydW5jYXRlZCB4LWNvb3JkaW5hdGVcbiAqIFBvaW50cyBuZWVkIHRvIGJlIGluIG9yZGVyIGJ5IHgtY29vcmRpbmF0ZSBmb3IgdGhpcyB0byB3b3JrIGVmZmljaWVudGx5XG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxQYXRoMkR9IGN0eCAtIENvbnRleHRcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEBwYXJhbSB7b2JqZWN0fSBzZWdtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5zdGFydCAtIHN0YXJ0IGluZGV4IG9mIHRoZSBzZWdtZW50LCByZWZlcnJpbmcgdGhlIHBvaW50cyBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQuZW5kIC0gZW5kIGluZGV4IG9mIHRoZSBzZWdtZW50LCByZWZlcnJpbmcgdGhlIHBvaW50cyBhcnJheVxuICogQHBhcmFtIHtib29sZWFufSBzZWdtZW50Lmxvb3AgLSBpbmRpY2F0ZXMgdGhhdCB0aGUgc2VnbWVudCBpcyBhIGxvb3BcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLm1vdmUgLSBtb3ZlIHRvIHN0YXJ0aW5nIHBvaW50ICh2cyBsaW5lIHRvIGl0KVxuICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMucmV2ZXJzZSAtIHBhdGggdGhlIHNlZ21lbnQgZnJvbSBlbmQgdG8gc3RhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuc3RhcnQgLSBsaW1pdCBzZWdtZW50IHRvIHBvaW50cyBzdGFydGluZyBmcm9tIGBzdGFydGAgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZW5kIC0gbGltaXQgc2VnbWVudCB0byBwb2ludHMgZW5kaW5nIGF0IGBzdGFydGAgKyBgY291bnRgIGluZGV4XG4gKi9cbmZ1bmN0aW9uIGZhc3RQYXRoU2VnbWVudChjdHgsIGxpbmUsIHNlZ21lbnQsIHBhcmFtcykge1xuICBjb25zdCBwb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3Qge2NvdW50LCBzdGFydCwgaWxlbn0gPSBwYXRoVmFycyhwb2ludHMsIHNlZ21lbnQsIHBhcmFtcyk7XG4gIGNvbnN0IHttb3ZlID0gdHJ1ZSwgcmV2ZXJzZX0gPSBwYXJhbXMgfHwge307XG4gIGxldCBhdmdYID0gMDtcbiAgbGV0IGNvdW50WCA9IDA7XG4gIGxldCBpLCBwb2ludCwgcHJldlgsIG1pblksIG1heFksIGxhc3RZO1xuXG4gIGNvbnN0IHBvaW50SW5kZXggPSAoaW5kZXgpID0+IChzdGFydCArIChyZXZlcnNlID8gaWxlbiAtIGluZGV4IDogaW5kZXgpKSAlIGNvdW50O1xuICBjb25zdCBkcmF3WCA9ICgpID0+IHtcbiAgICBpZiAobWluWSAhPT0gbWF4WSkge1xuICAgICAgLy8gRHJhdyBsaW5lIHRvIG1heFkgYW5kIG1pblksIHVzaW5nIHRoZSBhdmVyYWdlIHgtY29vcmRpbmF0ZVxuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBtYXhZKTtcbiAgICAgIGN0eC5saW5lVG8oYXZnWCwgbWluWSk7XG4gICAgICAvLyBMaW5lIHRvIHktdmFsdWUgb2YgbGFzdCBwb2ludCBpbiBncm91cC4gU28gdGhlIGxpbmUgY29udGludWVzXG4gICAgICAvLyBmcm9tIGNvcnJlY3QgcG9zaXRpb24uIE5vdCB1c2luZyBtb3ZlLCB0byBoYXZlIHNvbGlkIHBhdGguXG4gICAgICBjdHgubGluZVRvKGF2Z1gsIGxhc3RZKTtcbiAgICB9XG4gIH07XG5cbiAgaWYgKG1vdmUpIHtcbiAgICBwb2ludCA9IHBvaW50c1twb2ludEluZGV4KDApXTtcbiAgICBjdHgubW92ZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8PSBpbGVuOyArK2kpIHtcbiAgICBwb2ludCA9IHBvaW50c1twb2ludEluZGV4KGkpXTtcblxuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBhIHNraXBwZWQgcG9pbnQgaW5zaWRlIGEgc2VnbWVudCwgc3BhbkdhcHMgbXVzdCBiZSB0cnVlXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCB4ID0gcG9pbnQueDtcbiAgICBjb25zdCB5ID0gcG9pbnQueTtcbiAgICBjb25zdCB0cnVuY1ggPSB4IHwgMDsgLy8gdHJ1bmNhdGVkIHgtY29vcmRpbmF0ZVxuXG4gICAgaWYgKHRydW5jWCA9PT0gcHJldlgpIHtcbiAgICAgIC8vIERldGVybWluZSBgbWluWWAgLyBgbWF4WWAgYW5kIGBhdmdYYCB3aGlsZSB3ZSBzdGF5IHdpdGhpbiBzYW1lIHgtcG9zaXRpb25cbiAgICAgIGlmICh5IDwgbWluWSkge1xuICAgICAgICBtaW5ZID0geTtcbiAgICAgIH0gZWxzZSBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgbWF4WSA9IHk7XG4gICAgICB9XG4gICAgICAvLyBGb3IgZmlyc3QgcG9pbnQgaW4gZ3JvdXAsIGNvdW50WCBpcyBgMGAsIHNvIGF2ZXJhZ2Ugd2lsbCBiZSBgeGAgLyAxLlxuICAgICAgYXZnWCA9IChjb3VudFggKiBhdmdYICsgeCkgLyArK2NvdW50WDtcbiAgICB9IGVsc2Uge1xuICAgICAgZHJhd1goKTtcbiAgICAgIC8vIERyYXcgbGluZSB0byBuZXh0IHgtcG9zaXRpb24sIHVzaW5nIHRoZSBmaXJzdCAob3Igb25seSlcbiAgICAgIC8vIHktdmFsdWUgaW4gdGhhdCBncm91cFxuICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcblxuICAgICAgcHJldlggPSB0cnVuY1g7XG4gICAgICBjb3VudFggPSAwO1xuICAgICAgbWluWSA9IG1heFkgPSB5O1xuICAgIH1cbiAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBsYXN0IHktdmFsdWUgaW4gZ3JvdXBcbiAgICBsYXN0WSA9IHk7XG4gIH1cbiAgZHJhd1goKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lIC0gdGhlIGxpbmVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9nZXRTZWdtZW50TWV0aG9kKGxpbmUpIHtcbiAgY29uc3Qgb3B0cyA9IGxpbmUub3B0aW9ucztcbiAgY29uc3QgYm9yZGVyRGFzaCA9IG9wdHMuYm9yZGVyRGFzaCAmJiBvcHRzLmJvcmRlckRhc2gubGVuZ3RoO1xuICBjb25zdCB1c2VGYXN0UGF0aCA9ICFsaW5lLl9kZWNpbWF0ZWQgJiYgIWxpbmUuX2xvb3AgJiYgIW9wdHMudGVuc2lvbiAmJiBvcHRzLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgIT09ICdtb25vdG9uZScgJiYgIW9wdHMuc3RlcHBlZCAmJiAhYm9yZGVyRGFzaDtcbiAgcmV0dXJuIHVzZUZhc3RQYXRoID8gZmFzdFBhdGhTZWdtZW50IDogcGF0aFNlZ21lbnQ7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2dldEludGVycG9sYXRpb25NZXRob2Qob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5zdGVwcGVkKSB7XG4gICAgcmV0dXJuIF9zdGVwcGVkSW50ZXJwb2xhdGlvbjtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnRlbnNpb24gfHwgb3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSB7XG4gICAgcmV0dXJuIF9iZXppZXJJbnRlcnBvbGF0aW9uO1xuICB9XG5cbiAgcmV0dXJuIF9wb2ludEluTGluZTtcbn1cblxuZnVuY3Rpb24gc3Ryb2tlUGF0aFdpdGhDYWNoZShjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCkge1xuICBsZXQgcGF0aCA9IGxpbmUuX3BhdGg7XG4gIGlmICghcGF0aCkge1xuICAgIHBhdGggPSBsaW5lLl9wYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgIGlmIChsaW5lLnBhdGgocGF0aCwgc3RhcnQsIGNvdW50KSkge1xuICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH1cbiAgc2V0U3R5bGUoY3R4LCBsaW5lLm9wdGlvbnMpO1xuICBjdHguc3Ryb2tlKHBhdGgpO1xufVxuXG5mdW5jdGlvbiBzdHJva2VQYXRoRGlyZWN0KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XG4gIGNvbnN0IHtzZWdtZW50cywgb3B0aW9uc30gPSBsaW5lO1xuICBjb25zdCBzZWdtZW50TWV0aG9kID0gX2dldFNlZ21lbnRNZXRob2QobGluZSk7XG5cbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgc2V0U3R5bGUoY3R4LCBvcHRpb25zLCBzZWdtZW50LnN0eWxlKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgaWYgKHNlZ21lbnRNZXRob2QoY3R4LCBsaW5lLCBzZWdtZW50LCB7c3RhcnQsIGVuZDogc3RhcnQgKyBjb3VudCAtIDF9KSkge1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cblxuY29uc3QgdXNlUGF0aDJEID0gdHlwZW9mIFBhdGgyRCA9PT0gJ2Z1bmN0aW9uJztcblxuZnVuY3Rpb24gZHJhdyhjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCkge1xuICBpZiAodXNlUGF0aDJEICYmICFsaW5lLm9wdGlvbnMuc2VnbWVudCkge1xuICAgIHN0cm9rZVBhdGhXaXRoQ2FjaGUoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpO1xuICB9IGVsc2Uge1xuICAgIHN0cm9rZVBhdGhEaXJlY3QoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG5cbiAgc3RhdGljIGlkID0gJ2xpbmUnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGJvcmRlckNhcFN0eWxlOiAnYnV0dCcsXG4gICAgYm9yZGVyRGFzaDogW10sXG4gICAgYm9yZGVyRGFzaE9mZnNldDogMCxcbiAgICBib3JkZXJKb2luU3R5bGU6ICdtaXRlcicsXG4gICAgYm9yZGVyV2lkdGg6IDMsXG4gICAgY2FwQmV6aWVyUG9pbnRzOiB0cnVlLFxuICAgIGN1YmljSW50ZXJwb2xhdGlvbk1vZGU6ICdkZWZhdWx0JyxcbiAgICBmaWxsOiBmYWxzZSxcbiAgICBzcGFuR2FwczogZmFsc2UsXG4gICAgc3RlcHBlZDogZmFsc2UsXG4gICAgdGVuc2lvbjogMCxcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0Um91dGVzID0ge1xuICAgIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gICAgYm9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcidcbiAgfTtcblxuXG4gIHN0YXRpYyBkZXNjcmlwdG9ycyA9IHtcbiAgICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnICYmIG5hbWUgIT09ICdmaWxsJyxcbiAgfTtcblxuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmFuaW1hdGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fY2hhcnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbG9vcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mdWxsTG9vcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wYXRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3BvaW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zZWdtZW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kZWNpbWF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fZGF0YXNldEluZGV4ID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUNvbnRyb2xQb2ludHMoY2hhcnRBcmVhLCBpbmRleEF4aXMpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICgob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykgJiYgIW9wdGlvbnMuc3RlcHBlZCAmJiAhdGhpcy5fcG9pbnRzVXBkYXRlZCkge1xuICAgICAgY29uc3QgbG9vcCA9IG9wdGlvbnMuc3BhbkdhcHMgPyB0aGlzLl9sb29wIDogdGhpcy5fZnVsbExvb3A7XG4gICAgICBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyh0aGlzLl9wb2ludHMsIG9wdGlvbnMsIGNoYXJ0QXJlYSwgbG9vcCwgaW5kZXhBeGlzKTtcbiAgICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHNldCBwb2ludHMocG9pbnRzKSB7XG4gICAgdGhpcy5fcG9pbnRzID0gcG9pbnRzO1xuICAgIGRlbGV0ZSB0aGlzLl9zZWdtZW50cztcbiAgICBkZWxldGUgdGhpcy5fcGF0aDtcbiAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XG4gIH1cblxuICBnZXQgcG9pbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9wb2ludHM7XG4gIH1cblxuICBnZXQgc2VnbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlZ21lbnRzIHx8ICh0aGlzLl9zZWdtZW50cyA9IF9jb21wdXRlU2VnbWVudHModGhpcywgdGhpcy5vcHRpb25zLnNlZ21lbnQpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBGaXJzdCBub24tc2tpcHBlZCBwb2ludCBvbiB0aGlzIGxpbmVcblx0ICogQHJldHVybnMge1BvaW50RWxlbWVudHx1bmRlZmluZWR9XG5cdCAqL1xuICBmaXJzdCgpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCAmJiBwb2ludHNbc2VnbWVudHNbMF0uc3RhcnRdO1xuICB9XG5cbiAgLyoqXG5cdCAqIExhc3Qgbm9uLXNraXBwZWQgcG9pbnQgb24gdGhpcyBsaW5lXG5cdCAqIEByZXR1cm5zIHtQb2ludEVsZW1lbnR8dW5kZWZpbmVkfVxuXHQgKi9cbiAgbGFzdCgpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgY29uc3QgY291bnQgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGNvdW50ICYmIHBvaW50c1tzZWdtZW50c1tjb3VudCAtIDFdLmVuZF07XG4gIH1cblxuICAvKipcblx0ICogSW50ZXJwb2xhdGUgYSBwb2ludCBpbiB0aGlzIGxpbmUgYXQgdGhlIHNhbWUgdmFsdWUgb24gYHByb3BlcnR5YCBhc1xuXHQgKiB0aGUgcmVmZXJlbmNlIGBwb2ludGAgcHJvdmlkZWRcblx0ICogQHBhcmFtIHtQb2ludEVsZW1lbnR9IHBvaW50IC0gdGhlIHJlZmVyZW5jZSBwb2ludFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSB0aGUgcHJvcGVydHkgdG8gbWF0Y2ggb25cblx0ICogQHJldHVybnMge1BvaW50RWxlbWVudHx1bmRlZmluZWR9XG5cdCAqL1xuICBpbnRlcnBvbGF0ZShwb2ludCwgcHJvcGVydHkpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHZhbHVlID0gcG9pbnRbcHJvcGVydHldO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIGNvbnN0IHNlZ21lbnRzID0gX2JvdW5kU2VnbWVudHModGhpcywge3Byb3BlcnR5LCBzdGFydDogdmFsdWUsIGVuZDogdmFsdWV9KTtcblxuICAgIGlmICghc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgX2ludGVycG9sYXRlID0gX2dldEludGVycG9sYXRpb25NZXRob2Qob3B0aW9ucyk7XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3Qge3N0YXJ0LCBlbmR9ID0gc2VnbWVudHNbaV07XG4gICAgICBjb25zdCBwMSA9IHBvaW50c1tzdGFydF07XG4gICAgICBjb25zdCBwMiA9IHBvaW50c1tlbmRdO1xuICAgICAgaWYgKHAxID09PSBwMikge1xuICAgICAgICByZXN1bHQucHVzaChwMSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdCA9IE1hdGguYWJzKCh2YWx1ZSAtIHAxW3Byb3BlcnR5XSkgLyAocDJbcHJvcGVydHldIC0gcDFbcHJvcGVydHldKSk7XG4gICAgICBjb25zdCBpbnRlcnBvbGF0ZWQgPSBfaW50ZXJwb2xhdGUocDEsIHAyLCB0LCBvcHRpb25zLnN0ZXBwZWQpO1xuICAgICAgaW50ZXJwb2xhdGVkW3Byb3BlcnR5XSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgICAgIHJlc3VsdC5wdXNoKGludGVycG9sYXRlZCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQubGVuZ3RoID09PSAxID8gcmVzdWx0WzBdIDogcmVzdWx0O1xuICB9XG5cbiAgLyoqXG5cdCAqIEFwcGVuZCBhIHNlZ21lbnQgb2YgdGhpcyBsaW5lIHRvIGN1cnJlbnQgcGF0aC5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKiBAcGFyYW0ge29iamVjdH0gc2VnbWVudFxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5zdGFydCAtIHN0YXJ0IGluZGV4IG9mIHRoZSBzZWdtZW50LCByZWZlcnJpbmcgdGhlIHBvaW50cyBhcnJheVxuIFx0ICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQuZW5kIC0gZW5kIGluZGV4IG9mIHRoZSBzZWdtZW50LCByZWZlcnJpbmcgdGhlIHBvaW50cyBhcnJheVxuIFx0ICogQHBhcmFtIHtib29sZWFufSBzZWdtZW50Lmxvb3AgLSBpbmRpY2F0ZXMgdGhhdCB0aGUgc2VnbWVudCBpcyBhIGxvb3Bcblx0ICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5tb3ZlIC0gbW92ZSB0byBzdGFydGluZyBwb2ludCAodnMgbGluZSB0byBpdClcblx0ICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMucmV2ZXJzZSAtIHBhdGggdGhlIHNlZ21lbnQgZnJvbSBlbmQgdG8gc3RhcnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5zdGFydCAtIGxpbWl0IHNlZ21lbnQgdG8gcG9pbnRzIHN0YXJ0aW5nIGZyb20gYHN0YXJ0YCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmVuZCAtIGxpbWl0IHNlZ21lbnQgdG8gcG9pbnRzIGVuZGluZyBhdCBgc3RhcnRgICsgYGNvdW50YCBpbmRleFxuXHQgKiBAcmV0dXJucyB7dW5kZWZpbmVkfGJvb2xlYW59IC0gdHJ1ZSBpZiB0aGUgc2VnbWVudCBpcyBhIGZ1bGwgbG9vcCAocGF0aCBzaG91bGQgYmUgY2xvc2VkKVxuXHQgKi9cbiAgcGF0aFNlZ21lbnQoY3R4LCBzZWdtZW50LCBwYXJhbXMpIHtcbiAgICBjb25zdCBzZWdtZW50TWV0aG9kID0gX2dldFNlZ21lbnRNZXRob2QodGhpcyk7XG4gICAgcmV0dXJuIHNlZ21lbnRNZXRob2QoY3R4LCB0aGlzLCBzZWdtZW50LCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFwcGVuZCBhbGwgc2VnbWVudHMgb2YgdGhpcyBsaW5lIHRvIGN1cnJlbnQgcGF0aC5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR8UGF0aDJEfSBjdHhcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydF1cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtjb3VudF1cblx0ICogQHJldHVybnMge3VuZGVmaW5lZHxib29sZWFufSAtIHRydWUgaWYgbGluZSBpcyBhIGZ1bGwgbG9vcCAocGF0aCBzaG91bGQgYmUgY2xvc2VkKVxuXHQgKi9cbiAgcGF0aChjdHgsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBzZWdtZW50TWV0aG9kID0gX2dldFNlZ21lbnRNZXRob2QodGhpcyk7XG4gICAgbGV0IGxvb3AgPSB0aGlzLl9sb29wO1xuXG4gICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgIGNvdW50ID0gY291bnQgfHwgKHRoaXMucG9pbnRzLmxlbmd0aCAtIHN0YXJ0KTtcblxuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgICAgbG9vcCAmPSBzZWdtZW50TWV0aG9kKGN0eCwgdGhpcywgc2VnbWVudCwge3N0YXJ0LCBlbmQ6IHN0YXJ0ICsgY291bnQgLSAxfSk7XG4gICAgfVxuICAgIHJldHVybiAhIWxvb3A7XG4gIH1cblxuICAvKipcblx0ICogRHJhd1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBjaGFydEFyZWFcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydF1cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtjb3VudF1cblx0ICovXG4gIGRyYXcoY3R4LCBjaGFydEFyZWEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHMgfHwgW107XG5cbiAgICBpZiAocG9pbnRzLmxlbmd0aCAmJiBvcHRpb25zLmJvcmRlcldpZHRoKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICBkcmF3KGN0eCwgdGhpcywgc3RhcnQsIGNvdW50KTtcblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hbmltYXRlZCkge1xuICAgICAgLy8gV2hlbiBsaW5lIGlzIGFuaW1hdGVkLCB0aGUgY29udHJvbCBwb2ludHMgYW5kIHBhdGggYXJlIG5vdCBjYWNoZWQuXG4gICAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9wYXRoID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCB7ZHJhd1BvaW50LCBfaXNQb2ludEluQXJlYX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQgdHlwZSB7XG4gIENhcnRlc2lhblBhcnNlZERhdGEsXG4gIENoYXJ0QXJlYSxcbiAgUG9pbnQsXG4gIFBvaW50SG92ZXJPcHRpb25zLFxuICBQb2ludE9wdGlvbnMsXG59IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcblxuZnVuY3Rpb24gaW5SYW5nZShlbDogUG9pbnRFbGVtZW50LCBwb3M6IG51bWJlciwgYXhpczogJ3gnIHwgJ3knLCB1c2VGaW5hbFBvc2l0aW9uPzogYm9vbGVhbikge1xuICBjb25zdCBvcHRpb25zID0gZWwub3B0aW9ucztcbiAgY29uc3Qge1theGlzXTogdmFsdWV9ID0gZWwuZ2V0UHJvcHMoW2F4aXNdLCB1c2VGaW5hbFBvc2l0aW9uKTtcblxuICByZXR1cm4gKE1hdGguYWJzKHBvcyAtIHZhbHVlKSA8IG9wdGlvbnMucmFkaXVzICsgb3B0aW9ucy5oaXRSYWRpdXMpO1xufVxuXG5leHBvcnQgdHlwZSBQb2ludFByb3BzID0gUG9pbnRcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9pbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudDxQb2ludFByb3BzLCBQb2ludE9wdGlvbnMgJiBQb2ludEhvdmVyT3B0aW9ucz4ge1xuXG4gIHN0YXRpYyBpZCA9ICdwb2ludCc7XG5cbiAgcGFyc2VkOiBDYXJ0ZXNpYW5QYXJzZWREYXRhO1xuICBza2lwPzogYm9vbGVhbjtcbiAgc3RvcD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgaGl0UmFkaXVzOiAxLFxuICAgIGhvdmVyQm9yZGVyV2lkdGg6IDEsXG4gICAgaG92ZXJSYWRpdXM6IDQsXG4gICAgcG9pbnRTdHlsZTogJ2NpcmNsZScsXG4gICAgcmFkaXVzOiAzLFxuICAgIHJvdGF0aW9uOiAwXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFJvdXRlcyA9IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxuICAgIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXG4gIH07XG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhcnNlZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNraXAgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdG9wID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuXG4gIGluUmFuZ2UobW91c2VYOiBudW1iZXIsIG1vdXNlWTogbnVtYmVyLCB1c2VGaW5hbFBvc2l0aW9uPzogYm9vbGVhbikge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge3gsIHl9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICByZXR1cm4gKChNYXRoLnBvdyhtb3VzZVggLSB4LCAyKSArIE1hdGgucG93KG1vdXNlWSAtIHksIDIpKSA8IE1hdGgucG93KG9wdGlvbnMuaGl0UmFkaXVzICsgb3B0aW9ucy5yYWRpdXMsIDIpKTtcbiAgfVxuXG4gIGluWFJhbmdlKG1vdXNlWDogbnVtYmVyLCB1c2VGaW5hbFBvc2l0aW9uPzogYm9vbGVhbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG1vdXNlWCwgJ3gnLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuXG4gIGluWVJhbmdlKG1vdXNlWTogbnVtYmVyLCB1c2VGaW5hbFBvc2l0aW9uPzogYm9vbGVhbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG1vdXNlWSwgJ3knLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuXG4gIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24/OiBib29sZWFuKSB7XG4gICAgY29uc3Qge3gsIHl9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICByZXR1cm4ge3gsIHl9O1xuICB9XG5cbiAgc2l6ZShvcHRpb25zPzogUGFydGlhbDxQb2ludE9wdGlvbnMgJiBQb2ludEhvdmVyT3B0aW9ucz4pIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgbGV0IHJhZGl1cyA9IG9wdGlvbnMucmFkaXVzIHx8IDA7XG4gICAgcmFkaXVzID0gTWF0aC5tYXgocmFkaXVzLCByYWRpdXMgJiYgb3B0aW9ucy5ob3ZlclJhZGl1cyB8fCAwKTtcbiAgICBjb25zdCBib3JkZXJXaWR0aCA9IHJhZGl1cyAmJiBvcHRpb25zLmJvcmRlcldpZHRoIHx8IDA7XG4gICAgcmV0dXJuIChyYWRpdXMgKyBib3JkZXJXaWR0aCkgKiAyO1xuICB9XG5cbiAgZHJhdyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgYXJlYTogQ2hhcnRBcmVhKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgIGlmICh0aGlzLnNraXAgfHwgb3B0aW9ucy5yYWRpdXMgPCAwLjEgfHwgIV9pc1BvaW50SW5BcmVhKHRoaXMsIGFyZWEsIHRoaXMuc2l6ZShvcHRpb25zKSAvIDIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcbiAgICBjdHgubGluZVdpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgZHJhd1BvaW50KGN0eCwgb3B0aW9ucywgdGhpcy54LCB0aGlzLnkpO1xuICB9XG5cbiAgZ2V0UmFuZ2UoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEZhbGxiYWNrcyBzaG91bGQgbmV2ZXIgYmUgaGl0IGluIHByYWN0aWNlXG4gICAgcmV0dXJuIG9wdGlvbnMucmFkaXVzICsgb3B0aW9ucy5oaXRSYWRpdXM7XG4gIH1cbn1cbiIsICJpbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQge2lzT2JqZWN0LCBfaXNCZXR3ZWVuLCBfbGltaXRWYWx1ZX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge2FkZFJvdW5kZWRSZWN0UGF0aH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQge3RvVFJCTCwgdG9UUkJMQ29ybmVyc30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuXG4vKiogQHR5cGVkZWYge3sgeDogbnVtYmVyLCB5OiBudW1iZXIsIGJhc2U6IG51bWJlciwgaG9yaXpvbnRhbDogYm9vbGVhbiwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfX0gQmFyUHJvcHMgKi9cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBib3VuZHMgb2YgdGhlIGJhciByZWdhcmRsZXNzIG9mIHRoZSBvcmllbnRhdGlvblxuICogQHBhcmFtIHtCYXJFbGVtZW50fSBiYXIgdGhlIGJhclxuICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl1cbiAqIEByZXR1cm4ge29iamVjdH0gYm91bmRzIG9mIHRoZSBiYXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldEJhckJvdW5kcyhiYXIsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3Qge3gsIHksIGJhc2UsIHdpZHRoLCBoZWlnaHR9ID0gLyoqIEB0eXBlIHtCYXJQcm9wc30gKi8gKGJhci5nZXRQcm9wcyhbJ3gnLCAneScsICdiYXNlJywgJ3dpZHRoJywgJ2hlaWdodCddLCB1c2VGaW5hbFBvc2l0aW9uKSk7XG5cbiAgbGV0IGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgaGFsZjtcblxuICBpZiAoYmFyLmhvcml6b250YWwpIHtcbiAgICBoYWxmID0gaGVpZ2h0IC8gMjtcbiAgICBsZWZ0ID0gTWF0aC5taW4oeCwgYmFzZSk7XG4gICAgcmlnaHQgPSBNYXRoLm1heCh4LCBiYXNlKTtcbiAgICB0b3AgPSB5IC0gaGFsZjtcbiAgICBib3R0b20gPSB5ICsgaGFsZjtcbiAgfSBlbHNlIHtcbiAgICBoYWxmID0gd2lkdGggLyAyO1xuICAgIGxlZnQgPSB4IC0gaGFsZjtcbiAgICByaWdodCA9IHggKyBoYWxmO1xuICAgIHRvcCA9IE1hdGgubWluKHksIGJhc2UpO1xuICAgIGJvdHRvbSA9IE1hdGgubWF4KHksIGJhc2UpO1xuICB9XG5cbiAgcmV0dXJuIHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219O1xufVxuXG5mdW5jdGlvbiBza2lwT3JMaW1pdChza2lwLCB2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIHNraXAgPyAwIDogX2xpbWl0VmFsdWUodmFsdWUsIG1pbiwgbWF4KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VCb3JkZXJXaWR0aChiYXIsIG1heFcsIG1heEgpIHtcbiAgY29uc3QgdmFsdWUgPSBiYXIub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgY29uc3Qgc2tpcCA9IGJhci5ib3JkZXJTa2lwcGVkO1xuICBjb25zdCBvID0gdG9UUkJMKHZhbHVlKTtcblxuICByZXR1cm4ge1xuICAgIHQ6IHNraXBPckxpbWl0KHNraXAudG9wLCBvLnRvcCwgMCwgbWF4SCksXG4gICAgcjogc2tpcE9yTGltaXQoc2tpcC5yaWdodCwgby5yaWdodCwgMCwgbWF4VyksXG4gICAgYjogc2tpcE9yTGltaXQoc2tpcC5ib3R0b20sIG8uYm90dG9tLCAwLCBtYXhIKSxcbiAgICBsOiBza2lwT3JMaW1pdChza2lwLmxlZnQsIG8ubGVmdCwgMCwgbWF4VylcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VCb3JkZXJSYWRpdXMoYmFyLCBtYXhXLCBtYXhIKSB7XG4gIGNvbnN0IHtlbmFibGVCb3JkZXJSYWRpdXN9ID0gYmFyLmdldFByb3BzKFsnZW5hYmxlQm9yZGVyUmFkaXVzJ10pO1xuICBjb25zdCB2YWx1ZSA9IGJhci5vcHRpb25zLmJvcmRlclJhZGl1cztcbiAgY29uc3QgbyA9IHRvVFJCTENvcm5lcnModmFsdWUpO1xuICBjb25zdCBtYXhSID0gTWF0aC5taW4obWF4VywgbWF4SCk7XG4gIGNvbnN0IHNraXAgPSBiYXIuYm9yZGVyU2tpcHBlZDtcblxuICAvLyBJZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0LCBhc3N1bWUgdGhlIHVzZXIga25vd3Mgd2hhdCB0aGV5IGFyZSBkb2luZ1xuICAvLyBhbmQgYXBwbHkgYXMgZGlyZWN0ZWQuXG4gIGNvbnN0IGVuYWJsZUJvcmRlciA9IGVuYWJsZUJvcmRlclJhZGl1cyB8fCBpc09iamVjdCh2YWx1ZSk7XG5cbiAgcmV0dXJuIHtcbiAgICB0b3BMZWZ0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAudG9wIHx8IHNraXAubGVmdCwgby50b3BMZWZ0LCAwLCBtYXhSKSxcbiAgICB0b3BSaWdodDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLnRvcCB8fCBza2lwLnJpZ2h0LCBvLnRvcFJpZ2h0LCAwLCBtYXhSKSxcbiAgICBib3R0b21MZWZ0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAuYm90dG9tIHx8IHNraXAubGVmdCwgby5ib3R0b21MZWZ0LCAwLCBtYXhSKSxcbiAgICBib3R0b21SaWdodDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLmJvdHRvbSB8fCBza2lwLnJpZ2h0LCBvLmJvdHRvbVJpZ2h0LCAwLCBtYXhSKVxuICB9O1xufVxuXG5mdW5jdGlvbiBib3VuZGluZ1JlY3RzKGJhcikge1xuICBjb25zdCBib3VuZHMgPSBnZXRCYXJCb3VuZHMoYmFyKTtcbiAgY29uc3Qgd2lkdGggPSBib3VuZHMucmlnaHQgLSBib3VuZHMubGVmdDtcbiAgY29uc3QgaGVpZ2h0ID0gYm91bmRzLmJvdHRvbSAtIGJvdW5kcy50b3A7XG4gIGNvbnN0IGJvcmRlciA9IHBhcnNlQm9yZGVyV2lkdGgoYmFyLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICBjb25zdCByYWRpdXMgPSBwYXJzZUJvcmRlclJhZGl1cyhiYXIsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG5cbiAgcmV0dXJuIHtcbiAgICBvdXRlcjoge1xuICAgICAgeDogYm91bmRzLmxlZnQsXG4gICAgICB5OiBib3VuZHMudG9wLFxuICAgICAgdzogd2lkdGgsXG4gICAgICBoOiBoZWlnaHQsXG4gICAgICByYWRpdXNcbiAgICB9LFxuICAgIGlubmVyOiB7XG4gICAgICB4OiBib3VuZHMubGVmdCArIGJvcmRlci5sLFxuICAgICAgeTogYm91bmRzLnRvcCArIGJvcmRlci50LFxuICAgICAgdzogd2lkdGggLSBib3JkZXIubCAtIGJvcmRlci5yLFxuICAgICAgaDogaGVpZ2h0IC0gYm9yZGVyLnQgLSBib3JkZXIuYixcbiAgICAgIHJhZGl1czoge1xuICAgICAgICB0b3BMZWZ0OiBNYXRoLm1heCgwLCByYWRpdXMudG9wTGVmdCAtIE1hdGgubWF4KGJvcmRlci50LCBib3JkZXIubCkpLFxuICAgICAgICB0b3BSaWdodDogTWF0aC5tYXgoMCwgcmFkaXVzLnRvcFJpZ2h0IC0gTWF0aC5tYXgoYm9yZGVyLnQsIGJvcmRlci5yKSksXG4gICAgICAgIGJvdHRvbUxlZnQ6IE1hdGgubWF4KDAsIHJhZGl1cy5ib3R0b21MZWZ0IC0gTWF0aC5tYXgoYm9yZGVyLmIsIGJvcmRlci5sKSksXG4gICAgICAgIGJvdHRvbVJpZ2h0OiBNYXRoLm1heCgwLCByYWRpdXMuYm90dG9tUmlnaHQgLSBNYXRoLm1heChib3JkZXIuYiwgYm9yZGVyLnIpKSxcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluUmFuZ2UoYmFyLCB4LCB5LCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IHNraXBYID0geCA9PT0gbnVsbDtcbiAgY29uc3Qgc2tpcFkgPSB5ID09PSBudWxsO1xuICBjb25zdCBza2lwQm90aCA9IHNraXBYICYmIHNraXBZO1xuICBjb25zdCBib3VuZHMgPSBiYXIgJiYgIXNraXBCb3RoICYmIGdldEJhckJvdW5kcyhiYXIsIHVzZUZpbmFsUG9zaXRpb24pO1xuXG4gIHJldHVybiBib3VuZHNcblx0XHQmJiAoc2tpcFggfHwgX2lzQmV0d2Vlbih4LCBib3VuZHMubGVmdCwgYm91bmRzLnJpZ2h0KSlcblx0XHQmJiAoc2tpcFkgfHwgX2lzQmV0d2Vlbih5LCBib3VuZHMudG9wLCBib3VuZHMuYm90dG9tKSk7XG59XG5cbmZ1bmN0aW9uIGhhc1JhZGl1cyhyYWRpdXMpIHtcbiAgcmV0dXJuIHJhZGl1cy50b3BMZWZ0IHx8IHJhZGl1cy50b3BSaWdodCB8fCByYWRpdXMuYm90dG9tTGVmdCB8fCByYWRpdXMuYm90dG9tUmlnaHQ7XG59XG5cbi8qKlxuICogQWRkIGEgcGF0aCBvZiBhIHJlY3RhbmdsZSB0byB0aGUgY3VycmVudCBzdWItcGF0aFxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0XG4gKiBAcGFyYW0geyp9IHJlY3QgQm91bmRpbmcgcmVjdFxuICovXG5mdW5jdGlvbiBhZGROb3JtYWxSZWN0UGF0aChjdHgsIHJlY3QpIHtcbiAgY3R4LnJlY3QocmVjdC54LCByZWN0LnksIHJlY3QudywgcmVjdC5oKTtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlY3QocmVjdCwgYW1vdW50LCByZWZSZWN0ID0ge30pIHtcbiAgY29uc3QgeCA9IHJlY3QueCAhPT0gcmVmUmVjdC54ID8gLWFtb3VudCA6IDA7XG4gIGNvbnN0IHkgPSByZWN0LnkgIT09IHJlZlJlY3QueSA/IC1hbW91bnQgOiAwO1xuICBjb25zdCB3ID0gKHJlY3QueCArIHJlY3QudyAhPT0gcmVmUmVjdC54ICsgcmVmUmVjdC53ID8gYW1vdW50IDogMCkgLSB4O1xuICBjb25zdCBoID0gKHJlY3QueSArIHJlY3QuaCAhPT0gcmVmUmVjdC55ICsgcmVmUmVjdC5oID8gYW1vdW50IDogMCkgLSB5O1xuICByZXR1cm4ge1xuICAgIHg6IHJlY3QueCArIHgsXG4gICAgeTogcmVjdC55ICsgeSxcbiAgICB3OiByZWN0LncgKyB3LFxuICAgIGg6IHJlY3QuaCArIGgsXG4gICAgcmFkaXVzOiByZWN0LnJhZGl1c1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG5cbiAgc3RhdGljIGlkID0gJ2Jhcic7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgYm9yZGVyU2tpcHBlZDogJ3N0YXJ0JyxcbiAgICBib3JkZXJXaWR0aDogMCxcbiAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgaW5mbGF0ZUFtb3VudDogJ2F1dG8nLFxuICAgIHBvaW50U3R5bGU6IHVuZGVmaW5lZFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ob3Jpem9udGFsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmFzZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW5mbGF0ZUFtb3VudCA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cblxuICBkcmF3KGN0eCkge1xuICAgIGNvbnN0IHtpbmZsYXRlQW1vdW50LCBvcHRpb25zOiB7Ym9yZGVyQ29sb3IsIGJhY2tncm91bmRDb2xvcn19ID0gdGhpcztcbiAgICBjb25zdCB7aW5uZXIsIG91dGVyfSA9IGJvdW5kaW5nUmVjdHModGhpcyk7XG4gICAgY29uc3QgYWRkUmVjdFBhdGggPSBoYXNSYWRpdXMob3V0ZXIucmFkaXVzKSA/IGFkZFJvdW5kZWRSZWN0UGF0aCA6IGFkZE5vcm1hbFJlY3RQYXRoO1xuXG4gICAgY3R4LnNhdmUoKTtcblxuICAgIGlmIChvdXRlci53ICE9PSBpbm5lci53IHx8IG91dGVyLmggIT09IGlubmVyLmgpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3Qob3V0ZXIsIGluZmxhdGVBbW91bnQsIGlubmVyKSk7XG4gICAgICBjdHguY2xpcCgpO1xuICAgICAgYWRkUmVjdFBhdGgoY3R4LCBpbmZsYXRlUmVjdChpbm5lciwgLWluZmxhdGVBbW91bnQsIG91dGVyKSk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYm9yZGVyQ29sb3I7XG4gICAgICBjdHguZmlsbCgnZXZlbm9kZCcpO1xuICAgIH1cblxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KGlubmVyLCBpbmZsYXRlQW1vdW50KSk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICBjdHguZmlsbCgpO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIGluUmFuZ2UobW91c2VYLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVgsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBpblhSYW5nZShtb3VzZVgsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVgsIG51bGwsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgaW5ZUmFuZ2UobW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbnVsbCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuXG4gIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCB7eCwgeSwgYmFzZSwgaG9yaXpvbnRhbH0gPSAvKiogQHR5cGUge0JhclByb3BzfSAqLyAodGhpcy5nZXRQcm9wcyhbJ3gnLCAneScsICdiYXNlJywgJ2hvcml6b250YWwnXSwgdXNlRmluYWxQb3NpdGlvbikpO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBob3Jpem9udGFsID8gKHggKyBiYXNlKSAvIDIgOiB4LFxuICAgICAgeTogaG9yaXpvbnRhbCA/IHkgOiAoeSArIGJhc2UpIC8gMlxuICAgIH07XG4gIH1cblxuICBnZXRSYW5nZShheGlzKSB7XG4gICAgcmV0dXJuIGF4aXMgPT09ICd4JyA/IHRoaXMud2lkdGggLyAyIDogdGhpcy5oZWlnaHQgLyAyO1xuICB9XG59XG4iLCAiaW1wb3J0IHtEb3VnaG51dENvbnRyb2xsZXIsIFBvbGFyQXJlYUNvbnRyb2xsZXIsIGRlZmF1bHRzfSBmcm9tICcuLi9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnQsIENoYXJ0RGF0YXNldH0gZnJvbSAnLi4vdHlwZXMuanMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbG9yc1BsdWdpbk9wdGlvbnMge1xuICBlbmFibGVkPzogYm9vbGVhbjtcbiAgZm9yY2VPdmVycmlkZT86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBDb2xvcnNEZXNjcmlwdG9yIHtcbiAgYmFja2dyb3VuZENvbG9yPzogdW5rbm93bjtcbiAgYm9yZGVyQ29sb3I/OiB1bmtub3duO1xufVxuXG5jb25zdCBCT1JERVJfQ09MT1JTID0gW1xuICAncmdiKDU0LCAxNjIsIDIzNSknLCAvLyBibHVlXG4gICdyZ2IoMjU1LCA5OSwgMTMyKScsIC8vIHJlZFxuICAncmdiKDI1NSwgMTU5LCA2NCknLCAvLyBvcmFuZ2VcbiAgJ3JnYigyNTUsIDIwNSwgODYpJywgLy8geWVsbG93XG4gICdyZ2IoNzUsIDE5MiwgMTkyKScsIC8vIGdyZWVuXG4gICdyZ2IoMTUzLCAxMDIsIDI1NSknLCAvLyBwdXJwbGVcbiAgJ3JnYigyMDEsIDIwMywgMjA3KScgLy8gZ3JleVxuXTtcblxuLy8gQm9yZGVyIGNvbG9ycyB3aXRoIDUwJSB0cmFuc3BhcmVuY3lcbmNvbnN0IEJBQ0tHUk9VTkRfQ09MT1JTID0gLyogI19fUFVSRV9fICovIEJPUkRFUl9DT0xPUlMubWFwKGNvbG9yID0+IGNvbG9yLnJlcGxhY2UoJ3JnYignLCAncmdiYSgnKS5yZXBsYWNlKCcpJywgJywgMC41KScpKTtcblxuZnVuY3Rpb24gZ2V0Qm9yZGVyQ29sb3IoaTogbnVtYmVyKSB7XG4gIHJldHVybiBCT1JERVJfQ09MT1JTW2kgJSBCT1JERVJfQ09MT1JTLmxlbmd0aF07XG59XG5cbmZ1bmN0aW9uIGdldEJhY2tncm91bmRDb2xvcihpOiBudW1iZXIpIHtcbiAgcmV0dXJuIEJBQ0tHUk9VTkRfQ09MT1JTW2kgJSBCQUNLR1JPVU5EX0NPTE9SUy5sZW5ndGhdO1xufVxuXG5mdW5jdGlvbiBjb2xvcml6ZURlZmF1bHREYXRhc2V0KGRhdGFzZXQ6IENoYXJ0RGF0YXNldCwgaTogbnVtYmVyKSB7XG4gIGRhdGFzZXQuYm9yZGVyQ29sb3IgPSBnZXRCb3JkZXJDb2xvcihpKTtcbiAgZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IgPSBnZXRCYWNrZ3JvdW5kQ29sb3IoaSk7XG5cbiAgcmV0dXJuICsraTtcbn1cblxuZnVuY3Rpb24gY29sb3JpemVEb3VnaG51dERhdGFzZXQoZGF0YXNldDogQ2hhcnREYXRhc2V0LCBpOiBudW1iZXIpIHtcbiAgZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IgPSBkYXRhc2V0LmRhdGEubWFwKCgpID0+IGdldEJvcmRlckNvbG9yKGkrKykpO1xuXG4gIHJldHVybiBpO1xufVxuXG5mdW5jdGlvbiBjb2xvcml6ZVBvbGFyQXJlYURhdGFzZXQoZGF0YXNldDogQ2hhcnREYXRhc2V0LCBpOiBudW1iZXIpIHtcbiAgZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IgPSBkYXRhc2V0LmRhdGEubWFwKCgpID0+IGdldEJhY2tncm91bmRDb2xvcihpKyspKTtcblxuICByZXR1cm4gaTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29sb3JpemVyKGNoYXJ0OiBDaGFydCkge1xuICBsZXQgaSA9IDA7XG5cbiAgcmV0dXJuIChkYXRhc2V0OiBDaGFydERhdGFzZXQsIGRhdGFzZXRJbmRleDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcblxuICAgIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgRG91Z2hudXRDb250cm9sbGVyKSB7XG4gICAgICBpID0gY29sb3JpemVEb3VnaG51dERhdGFzZXQoZGF0YXNldCwgaSk7XG4gICAgfSBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgUG9sYXJBcmVhQ29udHJvbGxlcikge1xuICAgICAgaSA9IGNvbG9yaXplUG9sYXJBcmVhRGF0YXNldChkYXRhc2V0LCBpKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgIGkgPSBjb2xvcml6ZURlZmF1bHREYXRhc2V0KGRhdGFzZXQsIGkpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNDb2xvcnNEZWZpbml0aW9ucyhcbiAgZGVzY3JpcHRvcnM6IENvbG9yc0Rlc2NyaXB0b3JbXSB8IFJlY29yZDxzdHJpbmcsIENvbG9yc0Rlc2NyaXB0b3I+XG4pIHtcbiAgbGV0IGs6IG51bWJlciB8IHN0cmluZztcblxuICBmb3IgKGsgaW4gZGVzY3JpcHRvcnMpIHtcbiAgICBpZiAoZGVzY3JpcHRvcnNba10uYm9yZGVyQ29sb3IgfHwgZGVzY3JpcHRvcnNba10uYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zQ29sb3JzRGVmaW5pdGlvbihcbiAgZGVzY3JpcHRvcjogQ29sb3JzRGVzY3JpcHRvclxuKSB7XG4gIHJldHVybiBkZXNjcmlwdG9yICYmIChkZXNjcmlwdG9yLmJvcmRlckNvbG9yIHx8IGRlc2NyaXB0b3IuYmFja2dyb3VuZENvbG9yKTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNEZWZhdWx0Q29sb3JzRGVmZW5pdGlvbnMoKSB7XG4gIHJldHVybiBkZWZhdWx0cy5ib3JkZXJDb2xvciAhPT0gJ3JnYmEoMCwwLDAsMC4xKScgfHwgZGVmYXVsdHMuYmFja2dyb3VuZENvbG9yICE9PSAncmdiYSgwLDAsMCwwLjEpJztcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ2NvbG9ycycsXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZvcmNlT3ZlcnJpZGU6IGZhbHNlXG4gIH0gYXMgQ29sb3JzUGx1Z2luT3B0aW9ucyxcblxuICBiZWZvcmVMYXlvdXQoY2hhcnQ6IENoYXJ0LCBfYXJncywgb3B0aW9uczogQ29sb3JzUGx1Z2luT3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgZGF0YToge2RhdGFzZXRzfSxcbiAgICAgIG9wdGlvbnM6IGNoYXJ0T3B0aW9uc1xuICAgIH0gPSBjaGFydC5jb25maWc7XG4gICAgY29uc3Qge2VsZW1lbnRzfSA9IGNoYXJ0T3B0aW9ucztcblxuICAgIGNvbnN0IGNvbnRhaW5zQ29sb3JEZWZlbml0aW9uID0gKFxuICAgICAgY29udGFpbnNDb2xvcnNEZWZpbml0aW9ucyhkYXRhc2V0cykgfHxcbiAgICAgIGNvbnRhaW5zQ29sb3JzRGVmaW5pdGlvbihjaGFydE9wdGlvbnMpIHx8XG4gICAgICAoZWxlbWVudHMgJiYgY29udGFpbnNDb2xvcnNEZWZpbml0aW9ucyhlbGVtZW50cykpIHx8XG4gICAgICBjb250YWluc0RlZmF1bHRDb2xvcnNEZWZlbml0aW9ucygpKTtcblxuICAgIGlmICghb3B0aW9ucy5mb3JjZU92ZXJyaWRlICYmIGNvbnRhaW5zQ29sb3JEZWZlbml0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY29sb3JpemVyID0gZ2V0Q29sb3JpemVyKGNoYXJ0KTtcblxuICAgIGRhdGFzZXRzLmZvckVhY2goY29sb3JpemVyKTtcbiAgfVxufTtcbiIsICJpbXBvcnQge19saW1pdFZhbHVlLCBfbG9va3VwQnlLZXksIGlzTnVsbE9yVW5kZWYsIHJlc29sdmV9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5mdW5jdGlvbiBsdHRiRGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoLCBvcHRpb25zKSB7XG4gIC8qKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgTGFyZ2VzdCBUcmlhbmdsZSBUaHJlZSBCdWNrZXRzIGFsZ29yaXRobS5cbiAgICpcbiAgICogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB0aGUgb3JpZ2luYWwgaW1wbGVtZW50YXRpb24gYnkgU3ZlaW5uIFN0ZWluYXJzc29uXG4gICAqIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVpbm4tc3RlaW5hcnNzb24vZmxvdC1kb3duc2FtcGxlL2Jsb2IvbWFzdGVyL2pxdWVyeS5mbG90LmRvd25zYW1wbGUuanNcbiAgICpcbiAgICogVGhlIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uIGlzIE1JVCBsaWNlbnNlZC5cbiAgICovXG4gIGNvbnN0IHNhbXBsZXMgPSBvcHRpb25zLnNhbXBsZXMgfHwgYXZhaWxhYmxlV2lkdGg7XG4gIC8vIFRoZXJlIGFyZSBsZXNzIHBvaW50cyB0aGFuIHRoZSB0aHJlc2hvbGQsIHJldHVybmluZyB0aGUgd2hvbGUgYXJyYXlcbiAgaWYgKHNhbXBsZXMgPj0gY291bnQpIHtcbiAgICByZXR1cm4gZGF0YS5zbGljZShzdGFydCwgc3RhcnQgKyBjb3VudCk7XG4gIH1cblxuICBjb25zdCBkZWNpbWF0ZWQgPSBbXTtcblxuICBjb25zdCBidWNrZXRXaWR0aCA9IChjb3VudCAtIDIpIC8gKHNhbXBsZXMgLSAyKTtcbiAgbGV0IHNhbXBsZWRJbmRleCA9IDA7XG4gIGNvbnN0IGVuZEluZGV4ID0gc3RhcnQgKyBjb3VudCAtIDE7XG4gIC8vIFN0YXJ0aW5nIGZyb20gb2Zmc2V0XG4gIGxldCBhID0gc3RhcnQ7XG4gIGxldCBpLCBtYXhBcmVhUG9pbnQsIG1heEFyZWEsIGFyZWEsIG5leHRBO1xuXG4gIGRlY2ltYXRlZFtzYW1wbGVkSW5kZXgrK10gPSBkYXRhW2FdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzYW1wbGVzIC0gMjsgaSsrKSB7XG4gICAgbGV0IGF2Z1ggPSAwO1xuICAgIGxldCBhdmdZID0gMDtcbiAgICBsZXQgajtcblxuICAgIC8vIEFkZGluZyBvZmZzZXRcbiAgICBjb25zdCBhdmdSYW5nZVN0YXJ0ID0gTWF0aC5mbG9vcigoaSArIDEpICogYnVja2V0V2lkdGgpICsgMSArIHN0YXJ0O1xuICAgIGNvbnN0IGF2Z1JhbmdlRW5kID0gTWF0aC5taW4oTWF0aC5mbG9vcigoaSArIDIpICogYnVja2V0V2lkdGgpICsgMSwgY291bnQpICsgc3RhcnQ7XG4gICAgY29uc3QgYXZnUmFuZ2VMZW5ndGggPSBhdmdSYW5nZUVuZCAtIGF2Z1JhbmdlU3RhcnQ7XG5cbiAgICBmb3IgKGogPSBhdmdSYW5nZVN0YXJ0OyBqIDwgYXZnUmFuZ2VFbmQ7IGorKykge1xuICAgICAgYXZnWCArPSBkYXRhW2pdLng7XG4gICAgICBhdmdZICs9IGRhdGFbal0ueTtcbiAgICB9XG5cbiAgICBhdmdYIC89IGF2Z1JhbmdlTGVuZ3RoO1xuICAgIGF2Z1kgLz0gYXZnUmFuZ2VMZW5ndGg7XG5cbiAgICAvLyBBZGRpbmcgb2Zmc2V0XG4gICAgY29uc3QgcmFuZ2VPZmZzID0gTWF0aC5mbG9vcihpICogYnVja2V0V2lkdGgpICsgMSArIHN0YXJ0O1xuICAgIGNvbnN0IHJhbmdlVG8gPSBNYXRoLm1pbihNYXRoLmZsb29yKChpICsgMSkgKiBidWNrZXRXaWR0aCkgKyAxLCBjb3VudCkgKyBzdGFydDtcbiAgICBjb25zdCB7eDogcG9pbnRBeCwgeTogcG9pbnRBeX0gPSBkYXRhW2FdO1xuXG4gICAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgY2hhbmdlZCBmcm9tIHRoZSBvcmlnaW5hbCBhbGdvcml0aG0gd2hpY2ggaW5pdGlhbGl6ZXMgdGhlc2VcbiAgICAvLyB2YWx1ZXMgdG8gMS4gVGhlIHJlYXNvbiBmb3IgdGhpcyBjaGFuZ2UgaXMgdGhhdCBpZiB0aGUgYXJlYSBpcyBzbWFsbCwgbmV4dEFcbiAgICAvLyB3b3VsZCBuZXZlciBiZSBzZXQgYW5kIHRodXMgYSBjcmFzaCB3b3VsZCBvY2N1ciBpbiB0aGUgbmV4dCBsb29wIGFzIGBhYCB3b3VsZCBiZWNvbWVcbiAgICAvLyBgdW5kZWZpbmVkYC4gU2luY2UgdGhlIGFyZWEgaXMgYWx3YXlzIHBvc2l0aXZlLCBidXQgY291bGQgYmUgMCBpbiB0aGUgY2FzZSBvZiBhIGZsYXQgdHJhY2UsXG4gICAgLy8gaW5pdGlhbGl6aW5nIHdpdGggYSBuZWdhdGl2ZSBudW1iZXIgaXMgdGhlIGNvcnJlY3Qgc29sdXRpb24uXG4gICAgbWF4QXJlYSA9IGFyZWEgPSAtMTtcblxuICAgIGZvciAoaiA9IHJhbmdlT2ZmczsgaiA8IHJhbmdlVG87IGorKykge1xuICAgICAgYXJlYSA9IDAuNSAqIE1hdGguYWJzKFxuICAgICAgICAocG9pbnRBeCAtIGF2Z1gpICogKGRhdGFbal0ueSAtIHBvaW50QXkpIC1cbiAgICAgICAgKHBvaW50QXggLSBkYXRhW2pdLngpICogKGF2Z1kgLSBwb2ludEF5KVxuICAgICAgKTtcblxuICAgICAgaWYgKGFyZWEgPiBtYXhBcmVhKSB7XG4gICAgICAgIG1heEFyZWEgPSBhcmVhO1xuICAgICAgICBtYXhBcmVhUG9pbnQgPSBkYXRhW2pdO1xuICAgICAgICBuZXh0QSA9IGo7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IG1heEFyZWFQb2ludDtcbiAgICBhID0gbmV4dEE7XG4gIH1cblxuICAvLyBJbmNsdWRlIHRoZSBsYXN0IHBvaW50XG4gIGRlY2ltYXRlZFtzYW1wbGVkSW5kZXgrK10gPSBkYXRhW2VuZEluZGV4XTtcblxuICByZXR1cm4gZGVjaW1hdGVkO1xufVxuXG5mdW5jdGlvbiBtaW5NYXhEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgpIHtcbiAgbGV0IGF2Z1ggPSAwO1xuICBsZXQgY291bnRYID0gMDtcbiAgbGV0IGksIHBvaW50LCB4LCB5LCBwcmV2WCwgbWluSW5kZXgsIG1heEluZGV4LCBzdGFydEluZGV4LCBtaW5ZLCBtYXhZO1xuICBjb25zdCBkZWNpbWF0ZWQgPSBbXTtcbiAgY29uc3QgZW5kSW5kZXggPSBzdGFydCArIGNvdW50IC0gMTtcblxuICBjb25zdCB4TWluID0gZGF0YVtzdGFydF0ueDtcbiAgY29uc3QgeE1heCA9IGRhdGFbZW5kSW5kZXhdLng7XG4gIGNvbnN0IGR4ID0geE1heCAtIHhNaW47XG5cbiAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICBwb2ludCA9IGRhdGFbaV07XG4gICAgeCA9IChwb2ludC54IC0geE1pbikgLyBkeCAqIGF2YWlsYWJsZVdpZHRoO1xuICAgIHkgPSBwb2ludC55O1xuICAgIGNvbnN0IHRydW5jWCA9IHggfCAwO1xuXG4gICAgaWYgKHRydW5jWCA9PT0gcHJldlgpIHtcbiAgICAgIC8vIERldGVybWluZSBgbWluWWAgLyBgbWF4WWAgYW5kIGBhdmdYYCB3aGlsZSB3ZSBzdGF5IHdpdGhpbiBzYW1lIHgtcG9zaXRpb25cbiAgICAgIGlmICh5IDwgbWluWSkge1xuICAgICAgICBtaW5ZID0geTtcbiAgICAgICAgbWluSW5kZXggPSBpO1xuICAgICAgfSBlbHNlIGlmICh5ID4gbWF4WSkge1xuICAgICAgICBtYXhZID0geTtcbiAgICAgICAgbWF4SW5kZXggPSBpO1xuICAgICAgfVxuICAgICAgLy8gRm9yIGZpcnN0IHBvaW50IGluIGdyb3VwLCBjb3VudFggaXMgYDBgLCBzbyBhdmVyYWdlIHdpbGwgYmUgYHhgIC8gMS5cbiAgICAgIC8vIFVzZSBwb2ludC54IGhlcmUgYmVjYXVzZSB3ZSdyZSBjb21wdXRpbmcgdGhlIGF2ZXJhZ2UgZGF0YSBgeGAgdmFsdWVcbiAgICAgIGF2Z1ggPSAoY291bnRYICogYXZnWCArIHBvaW50LngpIC8gKytjb3VudFg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFB1c2ggdXAgdG8gNCBwb2ludHMsIDMgZm9yIHRoZSBsYXN0IGludGVydmFsIGFuZCB0aGUgZmlyc3QgcG9pbnQgZm9yIHRoaXMgaW50ZXJ2YWxcbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGkgLSAxO1xuXG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobWluSW5kZXgpICYmICFpc051bGxPclVuZGVmKG1heEluZGV4KSkge1xuICAgICAgICAvLyBUaGUgaW50ZXJ2YWwgaXMgZGVmaW5lZCBieSA0IHBvaW50czogc3RhcnQsIG1pbiwgbWF4LCBlbmQuXG4gICAgICAgIC8vIFRoZSBzdGFydGluZyBwb2ludCBpcyBhbHJlYWR5IGNvbnNpZGVyZWQgYXQgdGhpcyBwb2ludCwgc28gd2UgbmVlZCB0byBkZXRlcm1pbmUgd2hpY2hcbiAgICAgICAgLy8gb2YgdGhlIG90aGVyIHBvaW50cyB0byBhZGQuIFdlIG5lZWQgdG8gc29ydCB0aGVzZSBwb2ludHMgdG8gZW5zdXJlIHRoZSBkZWNpbWF0ZWQgZGF0YVxuICAgICAgICAvLyBpcyBzdGlsbCBzb3J0ZWQgYW5kIHRoZW4gZW5zdXJlIHRoZXJlIGFyZSBubyBkdXBsaWNhdGVzLlxuICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGVJbmRleDEgPSBNYXRoLm1pbihtaW5JbmRleCwgbWF4SW5kZXgpO1xuICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGVJbmRleDIgPSBNYXRoLm1heChtaW5JbmRleCwgbWF4SW5kZXgpO1xuXG4gICAgICAgIGlmIChpbnRlcm1lZGlhdGVJbmRleDEgIT09IHN0YXJ0SW5kZXggJiYgaW50ZXJtZWRpYXRlSW5kZXgxICE9PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICBkZWNpbWF0ZWQucHVzaCh7XG4gICAgICAgICAgICAuLi5kYXRhW2ludGVybWVkaWF0ZUluZGV4MV0sXG4gICAgICAgICAgICB4OiBhdmdYLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcm1lZGlhdGVJbmRleDIgIT09IHN0YXJ0SW5kZXggJiYgaW50ZXJtZWRpYXRlSW5kZXgyICE9PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICBkZWNpbWF0ZWQucHVzaCh7XG4gICAgICAgICAgICAuLi5kYXRhW2ludGVybWVkaWF0ZUluZGV4Ml0sXG4gICAgICAgICAgICB4OiBhdmdYXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbGFzdEluZGV4ID09PSBzdGFydEluZGV4IHdpbGwgb2NjdXIgd2hlbiBhIHJhbmdlIGhhcyBvbmx5IDEgcG9pbnQgd2hpY2ggY291bGRcbiAgICAgIC8vIGhhcHBlbiB3aXRoIHZlcnkgdW5ldmVuIGRhdGFcbiAgICAgIGlmIChpID4gMCAmJiBsYXN0SW5kZXggIT09IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgLy8gTGFzdCBwb2ludCBpbiB0aGUgcHJldmlvdXMgaW50ZXJ2YWxcbiAgICAgICAgZGVjaW1hdGVkLnB1c2goZGF0YVtsYXN0SW5kZXhdKTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RhcnQgb2YgdGhlIG5ldyBpbnRlcnZhbFxuICAgICAgZGVjaW1hdGVkLnB1c2gocG9pbnQpO1xuICAgICAgcHJldlggPSB0cnVuY1g7XG4gICAgICBjb3VudFggPSAwO1xuICAgICAgbWluWSA9IG1heFkgPSB5O1xuICAgICAgbWluSW5kZXggPSBtYXhJbmRleCA9IHN0YXJ0SW5kZXggPSBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZWNpbWF0ZWQ7XG59XG5cbmZ1bmN0aW9uIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KSB7XG4gIGlmIChkYXRhc2V0Ll9kZWNpbWF0ZWQpIHtcbiAgICBjb25zdCBkYXRhID0gZGF0YXNldC5fZGF0YTtcbiAgICBkZWxldGUgZGF0YXNldC5fZGVjaW1hdGVkO1xuICAgIGRlbGV0ZSBkYXRhc2V0Ll9kYXRhO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhc2V0LCAnZGF0YScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBkYXRhLFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCkge1xuICBjaGFydC5kYXRhLmRhdGFzZXRzLmZvckVhY2goKGRhdGFzZXQpID0+IHtcbiAgICBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzU2ltcGxpZmllZChtZXRhLCBwb2ludHMpIHtcbiAgY29uc3QgcG9pbnRDb3VudCA9IHBvaW50cy5sZW5ndGg7XG5cbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGNvdW50O1xuXG4gIGNvbnN0IHtpU2NhbGV9ID0gbWV0YTtcbiAgY29uc3Qge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IGlTY2FsZS5nZXRVc2VyQm91bmRzKCk7XG5cbiAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICBzdGFydCA9IF9saW1pdFZhbHVlKF9sb29rdXBCeUtleShwb2ludHMsIGlTY2FsZS5heGlzLCBtaW4pLmxvLCAwLCBwb2ludENvdW50IC0gMSk7XG4gIH1cbiAgaWYgKG1heERlZmluZWQpIHtcbiAgICBjb3VudCA9IF9saW1pdFZhbHVlKF9sb29rdXBCeUtleShwb2ludHMsIGlTY2FsZS5heGlzLCBtYXgpLmhpICsgMSwgc3RhcnQsIHBvaW50Q291bnQpIC0gc3RhcnQ7XG4gIH0gZWxzZSB7XG4gICAgY291bnQgPSBwb2ludENvdW50IC0gc3RhcnQ7XG4gIH1cblxuICByZXR1cm4ge3N0YXJ0LCBjb3VudH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaWQ6ICdkZWNpbWF0aW9uJyxcblxuICBkZWZhdWx0czoge1xuICAgIGFsZ29yaXRobTogJ21pbi1tYXgnLFxuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICB9LFxuXG4gIGJlZm9yZUVsZW1lbnRzVXBkYXRlOiAoY2hhcnQsIGFyZ3MsIG9wdGlvbnMpID0+IHtcbiAgICBpZiAoIW9wdGlvbnMuZW5hYmxlZCkge1xuICAgICAgLy8gVGhlIGRlY2ltYXRpb24gcGx1Z2luIG1heSBoYXZlIGJlZW4gcHJldmlvdXNseSBlbmFibGVkLiBOZWVkIHRvIHJlbW92ZSBvbGQgYGRhdGFzZXQuX2RhdGFgIGhhbmRsZXJzXG4gICAgICBjbGVhbkRlY2ltYXRlZERhdGEoY2hhcnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEFzc3VtZSB0aGUgZW50aXJlIGNoYXJ0IGlzIGF2YWlsYWJsZSB0byBzaG93IGEgZmV3IG1vcmUgcG9pbnRzIHRoYW4gbmVlZGVkXG4gICAgY29uc3QgYXZhaWxhYmxlV2lkdGggPSBjaGFydC53aWR0aDtcblxuICAgIGNoYXJ0LmRhdGEuZGF0YXNldHMuZm9yRWFjaCgoZGF0YXNldCwgZGF0YXNldEluZGV4KSA9PiB7XG4gICAgICBjb25zdCB7X2RhdGEsIGluZGV4QXhpc30gPSBkYXRhc2V0O1xuICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgICBjb25zdCBkYXRhID0gX2RhdGEgfHwgZGF0YXNldC5kYXRhO1xuXG4gICAgICBpZiAocmVzb2x2ZShbaW5kZXhBeGlzLCBjaGFydC5vcHRpb25zLmluZGV4QXhpc10pID09PSAneScpIHtcbiAgICAgICAgLy8gRGVjaW1hdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgbGluZXMgdGhhdCBoYXZlIGFuIFggaW5kZXhBeGlzXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFtZXRhLmNvbnRyb2xsZXIuc3VwcG9ydHNEZWNpbWF0aW9uKSB7XG4gICAgICAgIC8vIE9ubHkgbGluZSBkYXRhc2V0cyBhcmUgc3VwcG9ydGVkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgeEF4aXMgPSBjaGFydC5zY2FsZXNbbWV0YS54QXhpc0lEXTtcbiAgICAgIGlmICh4QXhpcy50eXBlICE9PSAnbGluZWFyJyAmJiB4QXhpcy50eXBlICE9PSAndGltZScpIHtcbiAgICAgICAgLy8gT25seSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBpcyBzdXBwb3J0ZWRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hhcnQub3B0aW9ucy5wYXJzaW5nKSB7XG4gICAgICAgIC8vIFBsdWdpbiBvbmx5IHN1cHBvcnRzIGRhdGEgdGhhdCBkb2VzIG5vdCBuZWVkIHBhcnNpbmdcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQge3N0YXJ0LCBjb3VudH0gPSBnZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzU2ltcGxpZmllZChtZXRhLCBkYXRhKTtcbiAgICAgIGNvbnN0IHRocmVzaG9sZCA9IG9wdGlvbnMudGhyZXNob2xkIHx8IDQgKiBhdmFpbGFibGVXaWR0aDtcbiAgICAgIGlmIChjb3VudCA8PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgLy8gTm8gZGVjaW1hdGlvbiBpcyByZXF1aXJlZCB1bnRpbCB3ZSBhcmUgYWJvdmUgdGhpcyB0aHJlc2hvbGRcbiAgICAgICAgY2xlYW5EZWNpbWF0ZWREYXRhc2V0KGRhdGFzZXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpc051bGxPclVuZGVmKF9kYXRhKSkge1xuICAgICAgICAvLyBGaXJzdCB0aW1lIHdlIGFyZSBzZWVpbmcgdGhpcyBkYXRhc2V0XG4gICAgICAgIC8vIFdlIG92ZXJyaWRlIHRoZSAnZGF0YScgcHJvcGVydHkgd2l0aCBhIHNldHRlciB0aGF0IHN0b3JlcyB0aGVcbiAgICAgICAgLy8gcmF3IGRhdGEgaW4gX2RhdGEsIGJ1dCByZWFkcyB0aGUgZGVjaW1hdGVkIGRhdGEgZnJvbSBfZGVjaW1hdGVkXG4gICAgICAgIGRhdGFzZXQuX2RhdGEgPSBkYXRhO1xuICAgICAgICBkZWxldGUgZGF0YXNldC5kYXRhO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YXNldCwgJ2RhdGEnLCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWNpbWF0ZWQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFBvaW50IHRoZSBjaGFydCB0byB0aGUgZGVjaW1hdGVkIGRhdGFcbiAgICAgIGxldCBkZWNpbWF0ZWQ7XG4gICAgICBzd2l0Y2ggKG9wdGlvbnMuYWxnb3JpdGhtKSB7XG4gICAgICBjYXNlICdsdHRiJzpcbiAgICAgICAgZGVjaW1hdGVkID0gbHR0YkRlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCwgb3B0aW9ucyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWluLW1heCc6XG4gICAgICAgIGRlY2ltYXRlZCA9IG1pbk1heERlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkZWNpbWF0aW9uIGFsZ29yaXRobSAnJHtvcHRpb25zLmFsZ29yaXRobX0nYCk7XG4gICAgICB9XG5cbiAgICAgIGRhdGFzZXQuX2RlY2ltYXRlZCA9IGRlY2ltYXRlZDtcbiAgICB9KTtcbiAgfSxcblxuICBkZXN0cm95KGNoYXJ0KSB7XG4gICAgY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KTtcbiAgfVxufTtcbiIsICJpbXBvcnQge19ib3VuZFNlZ21lbnQsIF9ib3VuZFNlZ21lbnRzLCBfbm9ybWFsaXplQW5nbGV9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gX3NlZ21lbnRzKGxpbmUsIHRhcmdldCwgcHJvcGVydHkpIHtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBjb25zdCBwb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgdHBvaW50cyA9IHRhcmdldC5wb2ludHM7XG4gIGNvbnN0IHBhcnRzID0gW107XG5cbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgbGV0IHtzdGFydCwgZW5kfSA9IHNlZ21lbnQ7XG4gICAgZW5kID0gX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cyk7XG5cbiAgICBjb25zdCBib3VuZHMgPSBfZ2V0Qm91bmRzKHByb3BlcnR5LCBwb2ludHNbc3RhcnRdLCBwb2ludHNbZW5kXSwgc2VnbWVudC5sb29wKTtcblxuICAgIGlmICghdGFyZ2V0LnNlZ21lbnRzKSB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGJvdW5kYXJ5IG5vdCBzdXBwb3J0aW5nIGBzZWdtZW50c2AgKHNpbXBsZUFyYylcbiAgICAgIC8vIEJvdW5kcyBhcmUgcHJvdmlkZWQgYXMgYHRhcmdldGAgZm9yIHBhcnRpYWwgY2lyY2xlLCBvciB1bmRlZmluZWQgZm9yIGZ1bGwgY2lyY2xlXG4gICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgc291cmNlOiBzZWdtZW50LFxuICAgICAgICB0YXJnZXQ6IGJvdW5kcyxcbiAgICAgICAgc3RhcnQ6IHBvaW50c1tzdGFydF0sXG4gICAgICAgIGVuZDogcG9pbnRzW2VuZF1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gR2V0IGFsbCBzZWdtZW50cyBmcm9tIGB0YXJnZXRgIHRoYXQgaW50ZXJzZWN0IHRoZSBib3VuZHMgb2YgY3VycmVudCBzZWdtZW50IG9mIGBsaW5lYFxuICAgIGNvbnN0IHRhcmdldFNlZ21lbnRzID0gX2JvdW5kU2VnbWVudHModGFyZ2V0LCBib3VuZHMpO1xuXG4gICAgZm9yIChjb25zdCB0Z3Qgb2YgdGFyZ2V0U2VnbWVudHMpIHtcbiAgICAgIGNvbnN0IHN1YkJvdW5kcyA9IF9nZXRCb3VuZHMocHJvcGVydHksIHRwb2ludHNbdGd0LnN0YXJ0XSwgdHBvaW50c1t0Z3QuZW5kXSwgdGd0Lmxvb3ApO1xuICAgICAgY29uc3QgZmlsbFNvdXJjZXMgPSBfYm91bmRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgc3ViQm91bmRzKTtcblxuICAgICAgZm9yIChjb25zdCBmaWxsU291cmNlIG9mIGZpbGxTb3VyY2VzKSB7XG4gICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgIHNvdXJjZTogZmlsbFNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQ6IHRndCxcbiAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgW3Byb3BlcnR5XTogX2dldEVkZ2UoYm91bmRzLCBzdWJCb3VuZHMsICdzdGFydCcsIE1hdGgubWF4KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICBbcHJvcGVydHldOiBfZ2V0RWRnZShib3VuZHMsIHN1YkJvdW5kcywgJ2VuZCcsIE1hdGgubWluKVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJ0cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRCb3VuZHMocHJvcGVydHksIGZpcnN0LCBsYXN0LCBsb29wKSB7XG4gIGlmIChsb29wKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBzdGFydCA9IGZpcnN0W3Byb3BlcnR5XTtcbiAgbGV0IGVuZCA9IGxhc3RbcHJvcGVydHldO1xuXG4gIGlmIChwcm9wZXJ0eSA9PT0gJ2FuZ2xlJykge1xuICAgIHN0YXJ0ID0gX25vcm1hbGl6ZUFuZ2xlKHN0YXJ0KTtcbiAgICBlbmQgPSBfbm9ybWFsaXplQW5nbGUoZW5kKTtcbiAgfVxuICByZXR1cm4ge3Byb3BlcnR5LCBzdGFydCwgZW5kfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9wb2ludHNGcm9tU2VnbWVudHMoYm91bmRhcnksIGxpbmUpIHtcbiAgY29uc3Qge3ggPSBudWxsLCB5ID0gbnVsbH0gPSBib3VuZGFyeSB8fCB7fTtcbiAgY29uc3QgbGluZVBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCBwb2ludHMgPSBbXTtcbiAgbGluZS5zZWdtZW50cy5mb3JFYWNoKCh7c3RhcnQsIGVuZH0pID0+IHtcbiAgICBlbmQgPSBfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgbGluZVBvaW50cyk7XG4gICAgY29uc3QgZmlyc3QgPSBsaW5lUG9pbnRzW3N0YXJ0XTtcbiAgICBjb25zdCBsYXN0ID0gbGluZVBvaW50c1tlbmRdO1xuICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICBwb2ludHMucHVzaCh7eDogZmlyc3QueCwgeX0pO1xuICAgICAgcG9pbnRzLnB1c2goe3g6IGxhc3QueCwgeX0pO1xuICAgIH0gZWxzZSBpZiAoeCAhPT0gbnVsbCkge1xuICAgICAgcG9pbnRzLnB1c2goe3gsIHk6IGZpcnN0Lnl9KTtcbiAgICAgIHBvaW50cy5wdXNoKHt4LCB5OiBsYXN0Lnl9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcG9pbnRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cykge1xuICBmb3IgKDtlbmQgPiBzdGFydDsgZW5kLS0pIHtcbiAgICBjb25zdCBwb2ludCA9IHBvaW50c1tlbmRdO1xuICAgIGlmICghaXNOYU4ocG9pbnQueCkgJiYgIWlzTmFOKHBvaW50LnkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVuZDtcbn1cblxuZnVuY3Rpb24gX2dldEVkZ2UoYSwgYiwgcHJvcCwgZm4pIHtcbiAgaWYgKGEgJiYgYikge1xuICAgIHJldHVybiBmbihhW3Byb3BdLCBiW3Byb3BdKTtcbiAgfVxuICByZXR1cm4gYSA/IGFbcHJvcF0gOiBiID8gYltwcm9wXSA6IDA7XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuc2NhbGUuanMnKS5kZWZhdWx0IH0gU2NhbGVcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9lbGVtZW50cy9lbGVtZW50LnBvaW50LmpzJykuZGVmYXVsdCB9IFBvaW50RWxlbWVudFxuICovXG5cbmltcG9ydCB7TGluZUVsZW1lbnR9IGZyb20gJy4uLy4uL2VsZW1lbnRzL2luZGV4LmpzJztcbmltcG9ydCB7aXNBcnJheX0gZnJvbSAnLi4vLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge19wb2ludHNGcm9tU2VnbWVudHN9IGZyb20gJy4vZmlsbGVyLnNlZ21lbnQuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50W10gfCB7IHg6IG51bWJlcjsgeTogbnVtYmVyOyB9fSBib3VuZGFyeVxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHJldHVybiB7TGluZUVsZW1lbnQ/fVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NyZWF0ZUJvdW5kYXJ5TGluZShib3VuZGFyeSwgbGluZSkge1xuICBsZXQgcG9pbnRzID0gW107XG4gIGxldCBfbG9vcCA9IGZhbHNlO1xuXG4gIGlmIChpc0FycmF5KGJvdW5kYXJ5KSkge1xuICAgIF9sb29wID0gdHJ1ZTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcG9pbnRzID0gYm91bmRhcnk7XG4gIH0gZWxzZSB7XG4gICAgcG9pbnRzID0gX3BvaW50c0Zyb21TZWdtZW50cyhib3VuZGFyeSwgbGluZSk7XG4gIH1cblxuICByZXR1cm4gcG9pbnRzLmxlbmd0aCA/IG5ldyBMaW5lRWxlbWVudCh7XG4gICAgcG9pbnRzLFxuICAgIG9wdGlvbnM6IHt0ZW5zaW9uOiAwfSxcbiAgICBfbG9vcCxcbiAgICBfZnVsbExvb3A6IF9sb29wXG4gIH0pIDogbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9zaG91bGRBcHBseUZpbGwoc291cmNlKSB7XG4gIHJldHVybiBzb3VyY2UgJiYgc291cmNlLmZpbGwgIT09IGZhbHNlO1xufVxuIiwgImltcG9ydCB7aXNPYmplY3QsIGlzRmluaXRlLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuc2NhbGUuanMnKS5kZWZhdWx0IH0gU2NhbGVcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9lbGVtZW50cy9lbGVtZW50LmxpbmUuanMnKS5kZWZhdWx0IH0gTGluZUVsZW1lbnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi90eXBlcy9pbmRleC5qcycpLkZpbGxUYXJnZXQgfSBGaWxsVGFyZ2V0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vdHlwZXMvaW5kZXguanMnKS5Db21wbGV4RmlsbFRhcmdldCB9IENvbXBsZXhGaWxsVGFyZ2V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIF9yZXNvbHZlVGFyZ2V0KHNvdXJjZXMsIGluZGV4LCBwcm9wYWdhdGUpIHtcbiAgY29uc3Qgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gIGxldCBmaWxsID0gc291cmNlLmZpbGw7XG4gIGNvbnN0IHZpc2l0ZWQgPSBbaW5kZXhdO1xuICBsZXQgdGFyZ2V0O1xuXG4gIGlmICghcHJvcGFnYXRlKSB7XG4gICAgcmV0dXJuIGZpbGw7XG4gIH1cblxuICB3aGlsZSAoZmlsbCAhPT0gZmFsc2UgJiYgdmlzaXRlZC5pbmRleE9mKGZpbGwpID09PSAtMSkge1xuICAgIGlmICghaXNGaW5pdGUoZmlsbCkpIHtcbiAgICAgIHJldHVybiBmaWxsO1xuICAgIH1cblxuICAgIHRhcmdldCA9IHNvdXJjZXNbZmlsbF07XG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0LnZpc2libGUpIHtcbiAgICAgIHJldHVybiBmaWxsO1xuICAgIH1cblxuICAgIHZpc2l0ZWQucHVzaChmaWxsKTtcbiAgICBmaWxsID0gdGFyZ2V0LmZpbGw7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9kZWNvZGVGaWxsKGxpbmUsIGluZGV4LCBjb3VudCkge1xuICAvKiogQHR5cGUge3N0cmluZyB8IHt2YWx1ZTogbnVtYmVyfX0gKi9cbiAgY29uc3QgZmlsbCA9IHBhcnNlRmlsbE9wdGlvbihsaW5lKTtcblxuICBpZiAoaXNPYmplY3QoZmlsbCkpIHtcbiAgICByZXR1cm4gaXNOYU4oZmlsbC52YWx1ZSkgPyBmYWxzZSA6IGZpbGw7XG4gIH1cblxuICBsZXQgdGFyZ2V0ID0gcGFyc2VGbG9hdChmaWxsKTtcblxuICBpZiAoaXNGaW5pdGUodGFyZ2V0KSAmJiBNYXRoLmZsb29yKHRhcmdldCkgPT09IHRhcmdldCkge1xuICAgIHJldHVybiBkZWNvZGVUYXJnZXRJbmRleChmaWxsWzBdLCBpbmRleCwgdGFyZ2V0LCBjb3VudCk7XG4gIH1cblxuICByZXR1cm4gWydvcmlnaW4nLCAnc3RhcnQnLCAnZW5kJywgJ3N0YWNrJywgJ3NoYXBlJ10uaW5kZXhPZihmaWxsKSA+PSAwICYmIGZpbGw7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVRhcmdldEluZGV4KGZpcnN0Q2gsIGluZGV4LCB0YXJnZXQsIGNvdW50KSB7XG4gIGlmIChmaXJzdENoID09PSAnLScgfHwgZmlyc3RDaCA9PT0gJysnKSB7XG4gICAgdGFyZ2V0ID0gaW5kZXggKyB0YXJnZXQ7XG4gIH1cblxuICBpZiAodGFyZ2V0ID09PSBpbmRleCB8fCB0YXJnZXQgPCAwIHx8IHRhcmdldCA+PSBjb3VudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtGaWxsVGFyZ2V0IHwgQ29tcGxleEZpbGxUYXJnZXR9IGZpbGxcbiAqIEBwYXJhbSB7U2NhbGV9IHNjYWxlXG4gKiBAcmV0dXJucyB7bnVtYmVyIHwgbnVsbH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9nZXRUYXJnZXRQaXhlbChmaWxsLCBzY2FsZSkge1xuICBsZXQgcGl4ZWwgPSBudWxsO1xuICBpZiAoZmlsbCA9PT0gJ3N0YXJ0Jykge1xuICAgIHBpeGVsID0gc2NhbGUuYm90dG9tO1xuICB9IGVsc2UgaWYgKGZpbGwgPT09ICdlbmQnKSB7XG4gICAgcGl4ZWwgPSBzY2FsZS50b3A7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoZmlsbCkpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcGl4ZWwgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKGZpbGwudmFsdWUpO1xuICB9IGVsc2UgaWYgKHNjYWxlLmdldEJhc2VQaXhlbCkge1xuICAgIHBpeGVsID0gc2NhbGUuZ2V0QmFzZVBpeGVsKCk7XG4gIH1cbiAgcmV0dXJuIHBpeGVsO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmlsbFRhcmdldCB8IENvbXBsZXhGaWxsVGFyZ2V0fSBmaWxsXG4gKiBAcGFyYW0ge1NjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0VmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0VGFyZ2V0VmFsdWUoZmlsbCwgc2NhbGUsIHN0YXJ0VmFsdWUpIHtcbiAgbGV0IHZhbHVlO1xuXG4gIGlmIChmaWxsID09PSAnc3RhcnQnKSB7XG4gICAgdmFsdWUgPSBzdGFydFZhbHVlO1xuICB9IGVsc2UgaWYgKGZpbGwgPT09ICdlbmQnKSB7XG4gICAgdmFsdWUgPSBzY2FsZS5vcHRpb25zLnJldmVyc2UgPyBzY2FsZS5taW4gOiBzY2FsZS5tYXg7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoZmlsbCkpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdmFsdWUgPSBmaWxsLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gc2NhbGUuZ2V0QmFzZVZhbHVlKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqL1xuZnVuY3Rpb24gcGFyc2VGaWxsT3B0aW9uKGxpbmUpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGxpbmUub3B0aW9ucztcbiAgY29uc3QgZmlsbE9wdGlvbiA9IG9wdGlvbnMuZmlsbDtcbiAgbGV0IGZpbGwgPSB2YWx1ZU9yRGVmYXVsdChmaWxsT3B0aW9uICYmIGZpbGxPcHRpb24udGFyZ2V0LCBmaWxsT3B0aW9uKTtcblxuICBpZiAoZmlsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZmlsbCA9ICEhb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gIH1cblxuICBpZiAoZmlsbCA9PT0gZmFsc2UgfHwgZmlsbCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChmaWxsID09PSB0cnVlKSB7XG4gICAgcmV0dXJuICdvcmlnaW4nO1xuICB9XG4gIHJldHVybiBmaWxsO1xufVxuIiwgIi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vY29yZS9jb3JlLnNjYWxlLmpzJykuZGVmYXVsdCB9IFNjYWxlXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vZWxlbWVudHMvZWxlbWVudC5wb2ludC5qcycpLmRlZmF1bHQgfSBQb2ludEVsZW1lbnRcbiAqL1xuXG5pbXBvcnQge0xpbmVFbGVtZW50fSBmcm9tICcuLi8uLi9lbGVtZW50cy9pbmRleC5qcyc7XG5pbXBvcnQge19pc0JldHdlZW59IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfY3JlYXRlQm91bmRhcnlMaW5lfSBmcm9tICcuL2ZpbGxlci5oZWxwZXIuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7eyBjaGFydDogQ2hhcnQ7IHNjYWxlOiBTY2FsZTsgaW5kZXg6IG51bWJlcjsgbGluZTogTGluZUVsZW1lbnQ7IH19IHNvdXJjZVxuICogQHJldHVybiB7TGluZUVsZW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYnVpbGRTdGFja0xpbmUoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSwgaW5kZXgsIGxpbmV9ID0gc291cmNlO1xuICBjb25zdCBwb2ludHMgPSBbXTtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBjb25zdCBzb3VyY2VQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgbGluZXNCZWxvdyA9IGdldExpbmVzQmVsb3coc2NhbGUsIGluZGV4KTtcbiAgbGluZXNCZWxvdy5wdXNoKF9jcmVhdGVCb3VuZGFyeUxpbmUoe3g6IG51bGwsIHk6IHNjYWxlLmJvdHRvbX0sIGxpbmUpKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGZvciAobGV0IGogPSBzZWdtZW50LnN0YXJ0OyBqIDw9IHNlZ21lbnQuZW5kOyBqKyspIHtcbiAgICAgIGFkZFBvaW50c0JlbG93KHBvaW50cywgc291cmNlUG9pbnRzW2pdLCBsaW5lc0JlbG93KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBMaW5lRWxlbWVudCh7cG9pbnRzLCBvcHRpb25zOiB7fX0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm4ge0xpbmVFbGVtZW50W119XG4gKi9cbmZ1bmN0aW9uIGdldExpbmVzQmVsb3coc2NhbGUsIGluZGV4KSB7XG4gIGNvbnN0IGJlbG93ID0gW107XG4gIGNvbnN0IG1ldGFzID0gc2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoJ2xpbmUnKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1ldGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbWV0YSA9IG1ldGFzW2ldO1xuICAgIGlmIChtZXRhLmluZGV4ID09PSBpbmRleCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICghbWV0YS5oaWRkZW4pIHtcbiAgICAgIGJlbG93LnVuc2hpZnQobWV0YS5kYXRhc2V0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJlbG93O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50W119IHBvaW50c1xuICogQHBhcmFtIHtQb2ludEVsZW1lbnR9IHNvdXJjZVBvaW50XG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50W119IGxpbmVzQmVsb3dcbiAqL1xuZnVuY3Rpb24gYWRkUG9pbnRzQmVsb3cocG9pbnRzLCBzb3VyY2VQb2ludCwgbGluZXNCZWxvdykge1xuICBjb25zdCBwb3N0cG9uZWQgPSBbXTtcbiAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lc0JlbG93Lmxlbmd0aDsgaisrKSB7XG4gICAgY29uc3QgbGluZSA9IGxpbmVzQmVsb3dbal07XG4gICAgY29uc3Qge2ZpcnN0LCBsYXN0LCBwb2ludH0gPSBmaW5kUG9pbnQobGluZSwgc291cmNlUG9pbnQsICd4Jyk7XG5cbiAgICBpZiAoIXBvaW50IHx8IChmaXJzdCAmJiBsYXN0KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChmaXJzdCkge1xuICAgICAgLy8gRmlyc3QgcG9pbnQgb2YgYW4gc2VnbWVudCAtPiBuZWVkIHRvIGFkZCBhbm90aGVyIHBvaW50IGJlZm9yZSB0aGlzLFxuICAgICAgLy8gZnJvbSBuZXh0IGxpbmUgYmVsb3cuXG4gICAgICBwb3N0cG9uZWQudW5zaGlmdChwb2ludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgIGlmICghbGFzdCkge1xuICAgICAgICAvLyBJbiB0aGUgbWlkZGxlIG9mIGFuIHNlZ21lbnQsIG5vIG5lZWQgdG8gYWRkIG1vcmUgcG9pbnRzLlxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcG9pbnRzLnB1c2goLi4ucG9zdHBvbmVkKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudH0gc291cmNlUG9pbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICogQHJldHVybnMge3twb2ludD86IFBvaW50RWxlbWVudCwgZmlyc3Q/OiBib29sZWFuLCBsYXN0PzogYm9vbGVhbn19XG4gKi9cbmZ1bmN0aW9uIGZpbmRQb2ludChsaW5lLCBzb3VyY2VQb2ludCwgcHJvcGVydHkpIHtcbiAgY29uc3QgcG9pbnQgPSBsaW5lLmludGVycG9sYXRlKHNvdXJjZVBvaW50LCBwcm9wZXJ0eSk7XG4gIGlmICghcG9pbnQpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBjb25zdCBwb2ludFZhbHVlID0gcG9pbnRbcHJvcGVydHldO1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gIGNvbnN0IGxpbmVQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgbGV0IGZpcnN0ID0gZmFsc2U7XG4gIGxldCBsYXN0ID0gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgY29uc3QgZmlyc3RWYWx1ZSA9IGxpbmVQb2ludHNbc2VnbWVudC5zdGFydF1bcHJvcGVydHldO1xuICAgIGNvbnN0IGxhc3RWYWx1ZSA9IGxpbmVQb2ludHNbc2VnbWVudC5lbmRdW3Byb3BlcnR5XTtcbiAgICBpZiAoX2lzQmV0d2Vlbihwb2ludFZhbHVlLCBmaXJzdFZhbHVlLCBsYXN0VmFsdWUpKSB7XG4gICAgICBmaXJzdCA9IHBvaW50VmFsdWUgPT09IGZpcnN0VmFsdWU7XG4gICAgICBsYXN0ID0gcG9pbnRWYWx1ZSA9PT0gbGFzdFZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB7Zmlyc3QsIGxhc3QsIHBvaW50fTtcbn1cbiIsICJpbXBvcnQge1RBVX0gZnJvbSAnLi4vLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbi8vIFRPRE86IHVzZSBlbGVtZW50cy5BcmNFbGVtZW50IGluc3RlYWRcbmV4cG9ydCBjbGFzcyBzaW1wbGVBcmMge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdGhpcy54ID0gb3B0cy54O1xuICAgIHRoaXMueSA9IG9wdHMueTtcbiAgICB0aGlzLnJhZGl1cyA9IG9wdHMucmFkaXVzO1xuICB9XG5cbiAgcGF0aFNlZ21lbnQoY3R4LCBib3VuZHMsIG9wdHMpIHtcbiAgICBjb25zdCB7eCwgeSwgcmFkaXVzfSA9IHRoaXM7XG4gICAgYm91bmRzID0gYm91bmRzIHx8IHtzdGFydDogMCwgZW5kOiBUQVV9O1xuICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCBib3VuZHMuZW5kLCBib3VuZHMuc3RhcnQsIHRydWUpO1xuICAgIHJldHVybiAhb3B0cy5ib3VuZHM7XG4gIH1cblxuICBpbnRlcnBvbGF0ZShwb2ludCkge1xuICAgIGNvbnN0IHt4LCB5LCByYWRpdXN9ID0gdGhpcztcbiAgICBjb25zdCBhbmdsZSA9IHBvaW50LmFuZ2xlO1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4ICsgTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzLFxuICAgICAgeTogeSArIE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1cyxcbiAgICAgIGFuZ2xlXG4gICAgfTtcbiAgfVxufVxuIiwgImltcG9ydCB7aXNGaW5pdGV9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfY3JlYXRlQm91bmRhcnlMaW5lfSBmcm9tICcuL2ZpbGxlci5oZWxwZXIuanMnO1xuaW1wb3J0IHtfZ2V0VGFyZ2V0UGl4ZWwsIF9nZXRUYXJnZXRWYWx1ZX0gZnJvbSAnLi9maWxsZXIub3B0aW9ucy5qcyc7XG5pbXBvcnQge19idWlsZFN0YWNrTGluZX0gZnJvbSAnLi9maWxsZXIudGFyZ2V0LnN0YWNrLmpzJztcbmltcG9ydCB7c2ltcGxlQXJjfSBmcm9tICcuL3NpbXBsZUFyYy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vY29yZS9jb3JlLnNjYWxlLmpzJykuZGVmYXVsdCB9IFNjYWxlXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vZWxlbWVudHMvZWxlbWVudC5wb2ludC5qcycpLmRlZmF1bHQgfSBQb2ludEVsZW1lbnRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gX2dldFRhcmdldChzb3VyY2UpIHtcbiAgY29uc3Qge2NoYXJ0LCBmaWxsLCBsaW5lfSA9IHNvdXJjZTtcblxuICBpZiAoaXNGaW5pdGUoZmlsbCkpIHtcbiAgICByZXR1cm4gZ2V0TGluZUJ5SW5kZXgoY2hhcnQsIGZpbGwpO1xuICB9XG5cbiAgaWYgKGZpbGwgPT09ICdzdGFjaycpIHtcbiAgICByZXR1cm4gX2J1aWxkU3RhY2tMaW5lKHNvdXJjZSk7XG4gIH1cblxuICBpZiAoZmlsbCA9PT0gJ3NoYXBlJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgYm91bmRhcnkgPSBjb21wdXRlQm91bmRhcnkoc291cmNlKTtcblxuICBpZiAoYm91bmRhcnkgaW5zdGFuY2VvZiBzaW1wbGVBcmMpIHtcbiAgICByZXR1cm4gYm91bmRhcnk7XG4gIH1cblxuICByZXR1cm4gX2NyZWF0ZUJvdW5kYXJ5TGluZShib3VuZGFyeSwgbGluZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGFydH0gY2hhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICovXG5mdW5jdGlvbiBnZXRMaW5lQnlJbmRleChjaGFydCwgaW5kZXgpIHtcbiAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGluZGV4KTtcbiAgY29uc3QgdmlzaWJsZSA9IG1ldGEgJiYgY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpbmRleCk7XG4gIHJldHVybiB2aXNpYmxlID8gbWV0YS5kYXRhc2V0IDogbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUJvdW5kYXJ5KHNvdXJjZSkge1xuICBjb25zdCBzY2FsZSA9IHNvdXJjZS5zY2FsZSB8fCB7fTtcblxuICBpZiAoc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5KHNvdXJjZSk7XG4gIH1cbiAgcmV0dXJuIGNvbXB1dGVMaW5lYXJCb3VuZGFyeShzb3VyY2UpO1xufVxuXG5cbmZ1bmN0aW9uIGNvbXB1dGVMaW5lYXJCb3VuZGFyeShzb3VyY2UpIHtcbiAgY29uc3Qge3NjYWxlID0ge30sIGZpbGx9ID0gc291cmNlO1xuICBjb25zdCBwaXhlbCA9IF9nZXRUYXJnZXRQaXhlbChmaWxsLCBzY2FsZSk7XG5cbiAgaWYgKGlzRmluaXRlKHBpeGVsKSkge1xuICAgIGNvbnN0IGhvcml6b250YWwgPSBzY2FsZS5pc0hvcml6b250YWwoKTtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiBob3Jpem9udGFsID8gcGl4ZWwgOiBudWxsLFxuICAgICAgeTogaG9yaXpvbnRhbCA/IG51bGwgOiBwaXhlbFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUNpcmN1bGFyQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSwgZmlsbH0gPSBzb3VyY2U7XG4gIGNvbnN0IG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zO1xuICBjb25zdCBsZW5ndGggPSBzY2FsZS5nZXRMYWJlbHMoKS5sZW5ndGg7XG4gIGNvbnN0IHN0YXJ0ID0gb3B0aW9ucy5yZXZlcnNlID8gc2NhbGUubWF4IDogc2NhbGUubWluO1xuICBjb25zdCB2YWx1ZSA9IF9nZXRUYXJnZXRWYWx1ZShmaWxsLCBzY2FsZSwgc3RhcnQpO1xuICBjb25zdCB0YXJnZXQgPSBbXTtcblxuICBpZiAob3B0aW9ucy5ncmlkLmNpcmN1bGFyKSB7XG4gICAgY29uc3QgY2VudGVyID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKDAsIHN0YXJ0KTtcbiAgICByZXR1cm4gbmV3IHNpbXBsZUFyYyh7XG4gICAgICB4OiBjZW50ZXIueCxcbiAgICAgIHk6IGNlbnRlci55LFxuICAgICAgcmFkaXVzOiBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSlcbiAgICB9KTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB0YXJnZXQucHVzaChzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaSwgdmFsdWUpKTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4iLCAiaW1wb3J0IHtjbGlwQXJlYSwgdW5jbGlwQXJlYX0gZnJvbSAnLi4vLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge19maW5kU2VnbWVudEVuZCwgX2dldEJvdW5kcywgX3NlZ21lbnRzfSBmcm9tICcuL2ZpbGxlci5zZWdtZW50LmpzJztcbmltcG9ydCB7X2dldFRhcmdldH0gZnJvbSAnLi9maWxsZXIudGFyZ2V0LmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIF9kcmF3ZmlsbChjdHgsIHNvdXJjZSwgYXJlYSkge1xuICBjb25zdCB0YXJnZXQgPSBfZ2V0VGFyZ2V0KHNvdXJjZSk7XG4gIGNvbnN0IHtsaW5lLCBzY2FsZSwgYXhpc30gPSBzb3VyY2U7XG4gIGNvbnN0IGxpbmVPcHRzID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBmaWxsT3B0aW9uID0gbGluZU9wdHMuZmlsbDtcbiAgY29uc3QgY29sb3IgPSBsaW5lT3B0cy5iYWNrZ3JvdW5kQ29sb3I7XG4gIGNvbnN0IHthYm92ZSA9IGNvbG9yLCBiZWxvdyA9IGNvbG9yfSA9IGZpbGxPcHRpb24gfHwge307XG4gIGlmICh0YXJnZXQgJiYgbGluZS5wb2ludHMubGVuZ3RoKSB7XG4gICAgY2xpcEFyZWEoY3R4LCBhcmVhKTtcbiAgICBkb0ZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBhYm92ZSwgYmVsb3csIGFyZWEsIHNjYWxlLCBheGlzfSk7XG4gICAgdW5jbGlwQXJlYShjdHgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRvRmlsbChjdHgsIGNmZykge1xuICBjb25zdCB7bGluZSwgdGFyZ2V0LCBhYm92ZSwgYmVsb3csIGFyZWEsIHNjYWxlfSA9IGNmZztcbiAgY29uc3QgcHJvcGVydHkgPSBsaW5lLl9sb29wID8gJ2FuZ2xlJyA6IGNmZy5heGlzO1xuXG4gIGN0eC5zYXZlKCk7XG5cbiAgaWYgKHByb3BlcnR5ID09PSAneCcgJiYgYmVsb3cgIT09IGFib3ZlKSB7XG4gICAgY2xpcFZlcnRpY2FsKGN0eCwgdGFyZ2V0LCBhcmVhLnRvcCk7XG4gICAgZmlsbChjdHgsIHtsaW5lLCB0YXJnZXQsIGNvbG9yOiBhYm92ZSwgc2NhbGUsIHByb3BlcnR5fSk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGNsaXBWZXJ0aWNhbChjdHgsIHRhcmdldCwgYXJlYS5ib3R0b20pO1xuICB9XG4gIGZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBjb2xvcjogYmVsb3csIHNjYWxlLCBwcm9wZXJ0eX0pO1xuXG4gIGN0eC5yZXN0b3JlKCk7XG59XG5cbmZ1bmN0aW9uIGNsaXBWZXJ0aWNhbChjdHgsIHRhcmdldCwgY2xpcFkpIHtcbiAgY29uc3Qge3NlZ21lbnRzLCBwb2ludHN9ID0gdGFyZ2V0O1xuICBsZXQgZmlyc3QgPSB0cnVlO1xuICBsZXQgbGluZUxvb3AgPSBmYWxzZTtcblxuICBjdHguYmVnaW5QYXRoKCk7XG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIGNvbnN0IHtzdGFydCwgZW5kfSA9IHNlZ21lbnQ7XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IHBvaW50c1tzdGFydF07XG4gICAgY29uc3QgbGFzdFBvaW50ID0gcG9pbnRzW19maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBwb2ludHMpXTtcbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIGN0eC5tb3ZlVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xuICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmxpbmVUbyhmaXJzdFBvaW50LngsIGNsaXBZKTtcbiAgICAgIGN0eC5saW5lVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xuICAgIH1cbiAgICBsaW5lTG9vcCA9ICEhdGFyZ2V0LnBhdGhTZWdtZW50KGN0eCwgc2VnbWVudCwge21vdmU6IGxpbmVMb29wfSk7XG4gICAgaWYgKGxpbmVMb29wKSB7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5saW5lVG8obGFzdFBvaW50LngsIGNsaXBZKTtcbiAgICB9XG4gIH1cblxuICBjdHgubGluZVRvKHRhcmdldC5maXJzdCgpLngsIGNsaXBZKTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguY2xpcCgpO1xufVxuXG5mdW5jdGlvbiBmaWxsKGN0eCwgY2ZnKSB7XG4gIGNvbnN0IHtsaW5lLCB0YXJnZXQsIHByb3BlcnR5LCBjb2xvciwgc2NhbGV9ID0gY2ZnO1xuICBjb25zdCBzZWdtZW50cyA9IF9zZWdtZW50cyhsaW5lLCB0YXJnZXQsIHByb3BlcnR5KTtcblxuICBmb3IgKGNvbnN0IHtzb3VyY2U6IHNyYywgdGFyZ2V0OiB0Z3QsIHN0YXJ0LCBlbmR9IG9mIHNlZ21lbnRzKSB7XG4gICAgY29uc3Qge3N0eWxlOiB7YmFja2dyb3VuZENvbG9yID0gY29sb3J9ID0ge319ID0gc3JjO1xuICAgIGNvbnN0IG5vdFNoYXBlID0gdGFyZ2V0ICE9PSB0cnVlO1xuXG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuXG4gICAgY2xpcEJvdW5kcyhjdHgsIHNjYWxlLCBub3RTaGFwZSAmJiBfZ2V0Qm91bmRzKHByb3BlcnR5LCBzdGFydCwgZW5kKSk7XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICBjb25zdCBsaW5lTG9vcCA9ICEhbGluZS5wYXRoU2VnbWVudChjdHgsIHNyYyk7XG5cbiAgICBsZXQgbG9vcDtcbiAgICBpZiAobm90U2hhcGUpIHtcbiAgICAgIGlmIChsaW5lTG9vcCkge1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcnBvbGF0ZWRMaW5lVG8oY3R4LCB0YXJnZXQsIGVuZCwgcHJvcGVydHkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0YXJnZXRMb29wID0gISF0YXJnZXQucGF0aFNlZ21lbnQoY3R4LCB0Z3QsIHttb3ZlOiBsaW5lTG9vcCwgcmV2ZXJzZTogdHJ1ZX0pO1xuICAgICAgbG9vcCA9IGxpbmVMb29wICYmIHRhcmdldExvb3A7XG4gICAgICBpZiAoIWxvb3ApIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBzdGFydCwgcHJvcGVydHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguZmlsbChsb29wID8gJ2V2ZW5vZGQnIDogJ25vbnplcm8nKTtcblxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xpcEJvdW5kcyhjdHgsIHNjYWxlLCBib3VuZHMpIHtcbiAgY29uc3Qge3RvcCwgYm90dG9tfSA9IHNjYWxlLmNoYXJ0LmNoYXJ0QXJlYTtcbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydCwgZW5kfSA9IGJvdW5kcyB8fCB7fTtcbiAgaWYgKHByb3BlcnR5ID09PSAneCcpIHtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LnJlY3Qoc3RhcnQsIHRvcCwgZW5kIC0gc3RhcnQsIGJvdHRvbSAtIHRvcCk7XG4gICAgY3R4LmNsaXAoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZWRMaW5lVG8oY3R4LCB0YXJnZXQsIHBvaW50LCBwcm9wZXJ0eSkge1xuICBjb25zdCBpbnRlcnBvbGF0ZWRQb2ludCA9IHRhcmdldC5pbnRlcnBvbGF0ZShwb2ludCwgcHJvcGVydHkpO1xuICBpZiAoaW50ZXJwb2xhdGVkUG9pbnQpIHtcbiAgICBjdHgubGluZVRvKGludGVycG9sYXRlZFBvaW50LngsIGludGVycG9sYXRlZFBvaW50LnkpO1xuICB9XG59XG5cbiIsICIvKipcbiAqIFBsdWdpbiBiYXNlZCBvbiBkaXNjdXNzaW9uIGZyb20gdGhlIGZvbGxvd2luZyBDaGFydC5qcyBpc3N1ZXM6XG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yMzgwI2lzc3VlY29tbWVudC0yNzk5NjE1NjlcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI0NDAjaXNzdWVjb21tZW50LTI1NjQ2MTg5N1xuICovXG5cbmltcG9ydCBMaW5lRWxlbWVudCBmcm9tICcuLi8uLi9lbGVtZW50cy9lbGVtZW50LmxpbmUuanMnO1xuaW1wb3J0IHtfZHJhd2ZpbGx9IGZyb20gJy4vZmlsbGVyLmRyYXdpbmcuanMnO1xuaW1wb3J0IHtfc2hvdWxkQXBwbHlGaWxsfSBmcm9tICcuL2ZpbGxlci5oZWxwZXIuanMnO1xuaW1wb3J0IHtfZGVjb2RlRmlsbCwgX3Jlc29sdmVUYXJnZXR9IGZyb20gJy4vZmlsbGVyLm9wdGlvbnMuanMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAnZmlsbGVyJyxcblxuICBhZnRlckRhdGFzZXRzVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGNvdW50ID0gKGNoYXJ0LmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDtcbiAgICBjb25zdCBzb3VyY2VzID0gW107XG4gICAgbGV0IG1ldGEsIGksIGxpbmUsIHNvdXJjZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICBsaW5lID0gbWV0YS5kYXRhc2V0O1xuICAgICAgc291cmNlID0gbnVsbDtcblxuICAgICAgaWYgKGxpbmUgJiYgbGluZS5vcHRpb25zICYmIGxpbmUgaW5zdGFuY2VvZiBMaW5lRWxlbWVudCkge1xuICAgICAgICBzb3VyY2UgPSB7XG4gICAgICAgICAgdmlzaWJsZTogY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSxcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICBmaWxsOiBfZGVjb2RlRmlsbChsaW5lLCBpLCBjb3VudCksXG4gICAgICAgICAgY2hhcnQsXG4gICAgICAgICAgYXhpczogbWV0YS5jb250cm9sbGVyLm9wdGlvbnMuaW5kZXhBeGlzLFxuICAgICAgICAgIHNjYWxlOiBtZXRhLnZTY2FsZSxcbiAgICAgICAgICBsaW5lLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBtZXRhLiRmaWxsZXIgPSBzb3VyY2U7XG4gICAgICBzb3VyY2VzLnB1c2goc291cmNlKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgc291cmNlID0gc291cmNlc1tpXTtcbiAgICAgIGlmICghc291cmNlIHx8IHNvdXJjZS5maWxsID09PSBmYWxzZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc291cmNlLmZpbGwgPSBfcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpLCBvcHRpb25zLnByb3BhZ2F0ZSk7XG4gICAgfVxuICB9LFxuXG4gIGJlZm9yZURyYXcoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZHJhdyA9IG9wdGlvbnMuZHJhd1RpbWUgPT09ICdiZWZvcmVEcmF3JztcbiAgICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBjb25zdCBhcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGZvciAobGV0IGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3Qgc291cmNlID0gbWV0YXNldHNbaV0uJGZpbGxlcjtcbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzb3VyY2UubGluZS51cGRhdGVDb250cm9sUG9pbnRzKGFyZWEsIHNvdXJjZS5heGlzKTtcbiAgICAgIGlmIChkcmF3ICYmIHNvdXJjZS5maWxsKSB7XG4gICAgICAgIF9kcmF3ZmlsbChjaGFydC5jdHgsIHNvdXJjZSwgYXJlYSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGJlZm9yZURhdGFzZXRzRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5kcmF3VGltZSAhPT0gJ2JlZm9yZURhdGFzZXRzRHJhdycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IG1ldGFzZXRzW2ldLiRmaWxsZXI7XG5cbiAgICAgIGlmIChfc2hvdWxkQXBwbHlGaWxsKHNvdXJjZSkpIHtcbiAgICAgICAgX2RyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBjaGFydC5jaGFydEFyZWEpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBiZWZvcmVEYXRhc2V0RHJhdyhjaGFydCwgYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHNvdXJjZSA9IGFyZ3MubWV0YS4kZmlsbGVyO1xuXG4gICAgaWYgKCFfc2hvdWxkQXBwbHlGaWxsKHNvdXJjZSkgfHwgb3B0aW9ucy5kcmF3VGltZSAhPT0gJ2JlZm9yZURhdGFzZXREcmF3Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF9kcmF3ZmlsbChjaGFydC5jdHgsIHNvdXJjZSwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgfSxcblxuICBkZWZhdWx0czoge1xuICAgIHByb3BhZ2F0ZTogdHJ1ZSxcbiAgICBkcmF3VGltZTogJ2JlZm9yZURhdGFzZXREcmF3J1xuICB9XG59O1xuIiwgImltcG9ydCBkZWZhdWx0cyBmcm9tICcuLi9jb3JlL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vY29yZS9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IGxheW91dHMgZnJvbSAnLi4vY29yZS9jb3JlLmxheW91dHMuanMnO1xuaW1wb3J0IHthZGRSb3VuZGVkUmVjdFBhdGgsIGRyYXdQb2ludExlZ2VuZCwgcmVuZGVyVGV4dH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQge1xuICBfaXNCZXR3ZWVuLFxuICBjYWxsYmFjayBhcyBjYWxsLFxuICBjbGlwQXJlYSxcbiAgZ2V0UnRsQWRhcHRlcixcbiAgb3ZlcnJpZGVUZXh0RGlyZWN0aW9uLFxuICByZXN0b3JlVGV4dERpcmVjdGlvbixcbiAgdG9Gb250LFxuICB0b1BhZGRpbmcsXG4gIHVuY2xpcEFyZWEsXG4gIHZhbHVlT3JEZWZhdWx0LFxufSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7X2FsaWduU3RhcnRFbmQsIF90ZXh0WCwgX3RvTGVmdFJpZ2h0Q2VudGVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcbmltcG9ydCB7dG9UUkJMQ29ybmVyc30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkNoYXJ0RXZlbnQgfSBDaGFydEV2ZW50XG4gKi9cblxuY29uc3QgZ2V0Qm94U2l6ZSA9IChsYWJlbE9wdHMsIGZvbnRTaXplKSA9PiB7XG4gIGxldCB7Ym94SGVpZ2h0ID0gZm9udFNpemUsIGJveFdpZHRoID0gZm9udFNpemV9ID0gbGFiZWxPcHRzO1xuXG4gIGlmIChsYWJlbE9wdHMudXNlUG9pbnRTdHlsZSkge1xuICAgIGJveEhlaWdodCA9IE1hdGgubWluKGJveEhlaWdodCwgZm9udFNpemUpO1xuICAgIGJveFdpZHRoID0gbGFiZWxPcHRzLnBvaW50U3R5bGVXaWR0aCB8fCBNYXRoLm1pbihib3hXaWR0aCwgZm9udFNpemUpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBib3hXaWR0aCxcbiAgICBib3hIZWlnaHQsXG4gICAgaXRlbUhlaWdodDogTWF0aC5tYXgoZm9udFNpemUsIGJveEhlaWdodClcbiAgfTtcbn07XG5cbmNvbnN0IGl0ZW1zRXF1YWwgPSAoYSwgYikgPT4gYSAhPT0gbnVsbCAmJiBiICE9PSBudWxsICYmIGEuZGF0YXNldEluZGV4ID09PSBiLmRhdGFzZXRJbmRleCAmJiBhLmluZGV4ID09PSBiLmluZGV4O1xuXG5leHBvcnQgY2xhc3MgTGVnZW5kIGV4dGVuZHMgRWxlbWVudCB7XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7eyBjdHg6IGFueTsgb3B0aW9uczogYW55OyBjaGFydDogYW55OyB9fSBjb25maWdcblx0ICovXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9hZGRlZCA9IGZhbHNlO1xuXG4gICAgLy8gQ29udGFpbnMgaGl0IGJveGVzIGZvciBlYWNoIGRhdGFzZXQgKGluIGRhdGFzZXQgb3JkZXIpXG4gICAgdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuXG4gICAgLyoqXG4gXHRcdCAqIEBwcml2YXRlXG4gXHRcdCAqL1xuICAgIHRoaXMuX2hvdmVyZWRJdGVtID0gbnVsbDtcblxuICAgIC8vIEFyZSB3ZSBpbiBkb3VnaG51dCBtb2RlIHdoaWNoIGhhcyBhIGRpZmZlcmVudCBkYXRhIHR5cGVcbiAgICB0aGlzLmRvdWdobnV0TW9kZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5jaGFydCA9IGNvbmZpZy5jaGFydDtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcbiAgICB0aGlzLmN0eCA9IGNvbmZpZy5jdHg7XG4gICAgdGhpcy5sZWdlbmRJdGVtcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNvbHVtblNpemVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGluZVdpZHRocyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1heEhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1heFdpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm90dG9tID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2VpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZnVsbFNpemUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB1cGRhdGUobWF4V2lkdGgsIG1heEhlaWdodCwgbWFyZ2lucykge1xuICAgIHRoaXMubWF4V2lkdGggPSBtYXhXaWR0aDtcbiAgICB0aGlzLm1heEhlaWdodCA9IG1heEhlaWdodDtcbiAgICB0aGlzLl9tYXJnaW5zID0gbWFyZ2lucztcblxuICAgIHRoaXMuc2V0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuYnVpbGRMYWJlbHMoKTtcbiAgICB0aGlzLmZpdCgpO1xuICB9XG5cbiAgc2V0RGltZW5zaW9ucygpIHtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICB0aGlzLmxlZnQgPSB0aGlzLl9tYXJnaW5zLmxlZnQ7XG4gICAgICB0aGlzLnJpZ2h0ID0gdGhpcy53aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLm1heEhlaWdodDtcbiAgICAgIHRoaXMudG9wID0gdGhpcy5fbWFyZ2lucy50b3A7XG4gICAgICB0aGlzLmJvdHRvbSA9IHRoaXMuaGVpZ2h0O1xuICAgIH1cbiAgfVxuXG4gIGJ1aWxkTGFiZWxzKCkge1xuICAgIGNvbnN0IGxhYmVsT3B0cyA9IHRoaXMub3B0aW9ucy5sYWJlbHMgfHwge307XG4gICAgbGV0IGxlZ2VuZEl0ZW1zID0gY2FsbChsYWJlbE9wdHMuZ2VuZXJhdGVMYWJlbHMsIFt0aGlzLmNoYXJ0XSwgdGhpcykgfHwgW107XG5cbiAgICBpZiAobGFiZWxPcHRzLmZpbHRlcikge1xuICAgICAgbGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcy5maWx0ZXIoKGl0ZW0pID0+IGxhYmVsT3B0cy5maWx0ZXIoaXRlbSwgdGhpcy5jaGFydC5kYXRhKSk7XG4gICAgfVxuXG4gICAgaWYgKGxhYmVsT3B0cy5zb3J0KSB7XG4gICAgICBsZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zLnNvcnQoKGEsIGIpID0+IGxhYmVsT3B0cy5zb3J0KGEsIGIsIHRoaXMuY2hhcnQuZGF0YSkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgbGVnZW5kSXRlbXMucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIHRoaXMubGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcztcbiAgfVxuXG4gIGZpdCgpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgY3R4fSA9IHRoaXM7XG5cbiAgICAvLyBUaGUgbGVnZW5kIG1heSBub3QgYmUgZGlzcGxheWVkIGZvciBhIHZhcmlldHkgb2YgcmVhc29ucyBpbmNsdWRpbmdcbiAgICAvLyB0aGUgZmFjdCB0aGF0IHRoZSBkZWZhdWx0cyBnb3Qgc2V0IHRvIGBmYWxzZWAuXG4gICAgLy8gV2hlbiB0aGUgbGVnZW5kIGlzIG5vdCBkaXNwbGF5ZWQsIHRoZXJlIGFyZSBubyBndWFyYW50ZWVzIHRoYXQgdGhlIG9wdGlvbnNcbiAgICAvLyBhcmUgY29ycmVjdGx5IGZvcm1hdHRlZCBzbyB3ZSBuZWVkIHRvIGJhaWwgb3V0IGFzIGVhcmx5IGFzIHBvc3NpYmxlLlxuICAgIGlmICghb3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGxhYmVsT3B0cyA9IG9wdGlvbnMubGFiZWxzO1xuICAgIGNvbnN0IGxhYmVsRm9udCA9IHRvRm9udChsYWJlbE9wdHMuZm9udCk7XG4gICAgY29uc3QgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcbiAgICBjb25zdCB0aXRsZUhlaWdodCA9IHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpO1xuICAgIGNvbnN0IHtib3hXaWR0aCwgaXRlbUhlaWdodH0gPSBnZXRCb3hTaXplKGxhYmVsT3B0cywgZm9udFNpemUpO1xuXG4gICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG5cbiAgICBjdHguZm9udCA9IGxhYmVsRm9udC5zdHJpbmc7XG5cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgd2lkdGggPSB0aGlzLm1heFdpZHRoOyAvLyBmaWxsIGFsbCB0aGUgd2lkdGhcbiAgICAgIGhlaWdodCA9IHRoaXMuX2ZpdFJvd3ModGl0bGVIZWlnaHQsIGZvbnRTaXplLCBib3hXaWR0aCwgaXRlbUhlaWdodCkgKyAxMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7IC8vIGZpbGwgYWxsIHRoZSBoZWlnaHRcbiAgICAgIHdpZHRoID0gdGhpcy5fZml0Q29scyh0aXRsZUhlaWdodCwgbGFiZWxGb250LCBib3hXaWR0aCwgaXRlbUhlaWdodCkgKyAxMDtcbiAgICB9XG5cbiAgICB0aGlzLndpZHRoID0gTWF0aC5taW4od2lkdGgsIG9wdGlvbnMubWF4V2lkdGggfHwgdGhpcy5tYXhXaWR0aCk7XG4gICAgdGhpcy5oZWlnaHQgPSBNYXRoLm1pbihoZWlnaHQsIG9wdGlvbnMubWF4SGVpZ2h0IHx8IHRoaXMubWF4SGVpZ2h0KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2ZpdFJvd3ModGl0bGVIZWlnaHQsIGZvbnRTaXplLCBib3hXaWR0aCwgaXRlbUhlaWdodCkge1xuICAgIGNvbnN0IHtjdHgsIG1heFdpZHRoLCBvcHRpb25zOiB7bGFiZWxzOiB7cGFkZGluZ319fSA9IHRoaXM7XG4gICAgY29uc3QgaGl0Ym94ZXMgPSB0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XG4gICAgLy8gV2lkdGggb2YgZWFjaCBsaW5lIG9mIGxlZ2VuZCBib3hlcy4gTGFiZWxzIHdyYXAgb250byBtdWx0aXBsZSBsaW5lcyB3aGVuIHRoZXJlIGFyZSB0b28gbWFueSB0byBmaXQgb24gb25lXG4gICAgY29uc3QgbGluZVdpZHRocyA9IHRoaXMubGluZVdpZHRocyA9IFswXTtcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gaXRlbUhlaWdodCArIHBhZGRpbmc7XG4gICAgbGV0IHRvdGFsSGVpZ2h0ID0gdGl0bGVIZWlnaHQ7XG5cbiAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuICAgIGxldCByb3cgPSAtMTtcbiAgICBsZXQgdG9wID0gLWxpbmVIZWlnaHQ7XG4gICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKSA9PiB7XG4gICAgICBjb25zdCBpdGVtV2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG5cbiAgICAgIGlmIChpID09PSAwIHx8IGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAxXSArIGl0ZW1XaWR0aCArIDIgKiBwYWRkaW5nID4gbWF4V2lkdGgpIHtcbiAgICAgICAgdG90YWxIZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgICAgICAgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIChpID4gMCA/IDAgOiAxKV0gPSAwO1xuICAgICAgICB0b3AgKz0gbGluZUhlaWdodDtcbiAgICAgICAgcm93Kys7XG4gICAgICB9XG5cbiAgICAgIGhpdGJveGVzW2ldID0ge2xlZnQ6IDAsIHRvcCwgcm93LCB3aWR0aDogaXRlbVdpZHRoLCBoZWlnaHQ6IGl0ZW1IZWlnaHR9O1xuXG4gICAgICBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKz0gaXRlbVdpZHRoICsgcGFkZGluZztcbiAgICB9KTtcblxuICAgIHJldHVybiB0b3RhbEhlaWdodDtcbiAgfVxuXG4gIF9maXRDb2xzKHRpdGxlSGVpZ2h0LCBsYWJlbEZvbnQsIGJveFdpZHRoLCBfaXRlbUhlaWdodCkge1xuICAgIGNvbnN0IHtjdHgsIG1heEhlaWdodCwgb3B0aW9uczoge2xhYmVsczoge3BhZGRpbmd9fX0gPSB0aGlzO1xuICAgIGNvbnN0IGhpdGJveGVzID0gdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuICAgIGNvbnN0IGNvbHVtblNpemVzID0gdGhpcy5jb2x1bW5TaXplcyA9IFtdO1xuICAgIGNvbnN0IGhlaWdodExpbWl0ID0gbWF4SGVpZ2h0IC0gdGl0bGVIZWlnaHQ7XG5cbiAgICBsZXQgdG90YWxXaWR0aCA9IHBhZGRpbmc7XG4gICAgbGV0IGN1cnJlbnRDb2xXaWR0aCA9IDA7XG4gICAgbGV0IGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xuXG4gICAgbGV0IGxlZnQgPSAwO1xuICAgIGxldCBjb2wgPSAwO1xuXG4gICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKSA9PiB7XG4gICAgICBjb25zdCB7aXRlbVdpZHRoLCBpdGVtSGVpZ2h0fSA9IGNhbGN1bGF0ZUl0ZW1TaXplKGJveFdpZHRoLCBsYWJlbEZvbnQsIGN0eCwgbGVnZW5kSXRlbSwgX2l0ZW1IZWlnaHQpO1xuXG4gICAgICAvLyBJZiB0b28gdGFsbCwgZ28gdG8gbmV3IGNvbHVtblxuICAgICAgaWYgKGkgPiAwICYmIGN1cnJlbnRDb2xIZWlnaHQgKyBpdGVtSGVpZ2h0ICsgMiAqIHBhZGRpbmcgPiBoZWlnaHRMaW1pdCkge1xuICAgICAgICB0b3RhbFdpZHRoICs9IGN1cnJlbnRDb2xXaWR0aCArIHBhZGRpbmc7XG4gICAgICAgIGNvbHVtblNpemVzLnB1c2goe3dpZHRoOiBjdXJyZW50Q29sV2lkdGgsIGhlaWdodDogY3VycmVudENvbEhlaWdodH0pOyAvLyBwcmV2aW91cyBjb2x1bW4gc2l6ZVxuICAgICAgICBsZWZ0ICs9IGN1cnJlbnRDb2xXaWR0aCArIHBhZGRpbmc7XG4gICAgICAgIGNvbCsrO1xuICAgICAgICBjdXJyZW50Q29sV2lkdGggPSBjdXJyZW50Q29sSGVpZ2h0ID0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gU3RvcmUgdGhlIGhpdGJveCB3aWR0aCBhbmQgaGVpZ2h0IGhlcmUuIEZpbmFsIHBvc2l0aW9uIHdpbGwgYmUgdXBkYXRlZCBpbiBgZHJhd2BcbiAgICAgIGhpdGJveGVzW2ldID0ge2xlZnQsIHRvcDogY3VycmVudENvbEhlaWdodCwgY29sLCB3aWR0aDogaXRlbVdpZHRoLCBoZWlnaHQ6IGl0ZW1IZWlnaHR9O1xuXG4gICAgICAvLyBHZXQgbWF4IHdpZHRoXG4gICAgICBjdXJyZW50Q29sV2lkdGggPSBNYXRoLm1heChjdXJyZW50Q29sV2lkdGgsIGl0ZW1XaWR0aCk7XG4gICAgICBjdXJyZW50Q29sSGVpZ2h0ICs9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgIH0pO1xuXG4gICAgdG90YWxXaWR0aCArPSBjdXJyZW50Q29sV2lkdGg7XG4gICAgY29sdW1uU2l6ZXMucHVzaCh7d2lkdGg6IGN1cnJlbnRDb2xXaWR0aCwgaGVpZ2h0OiBjdXJyZW50Q29sSGVpZ2h0fSk7IC8vIHByZXZpb3VzIGNvbHVtbiBzaXplXG5cbiAgICByZXR1cm4gdG90YWxXaWR0aDtcbiAgfVxuXG4gIGFkanVzdEhpdEJveGVzKCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICBjb25zdCB7bGVnZW5kSGl0Qm94ZXM6IGhpdGJveGVzLCBvcHRpb25zOiB7YWxpZ24sIGxhYmVsczoge3BhZGRpbmd9LCBydGx9fSA9IHRoaXM7XG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIGxldCByb3cgPSAwO1xuICAgICAgbGV0IGxlZnQgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIHRoaXMubGluZVdpZHRoc1tyb3ddKTtcbiAgICAgIGZvciAoY29uc3QgaGl0Ym94IG9mIGhpdGJveGVzKSB7XG4gICAgICAgIGlmIChyb3cgIT09IGhpdGJveC5yb3cpIHtcbiAgICAgICAgICByb3cgPSBoaXRib3gucm93O1xuICAgICAgICAgIGxlZnQgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIHRoaXMubGluZVdpZHRoc1tyb3ddKTtcbiAgICAgICAgfVxuICAgICAgICBoaXRib3gudG9wICs9IHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nO1xuICAgICAgICBoaXRib3gubGVmdCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54KGxlZnQpLCBoaXRib3gud2lkdGgpO1xuICAgICAgICBsZWZ0ICs9IGhpdGJveC53aWR0aCArIHBhZGRpbmc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjb2wgPSAwO1xuICAgICAgbGV0IHRvcCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSB0aGlzLmNvbHVtblNpemVzW2NvbF0uaGVpZ2h0KTtcbiAgICAgIGZvciAoY29uc3QgaGl0Ym94IG9mIGhpdGJveGVzKSB7XG4gICAgICAgIGlmIChoaXRib3guY29sICE9PSBjb2wpIHtcbiAgICAgICAgICBjb2wgPSBoaXRib3guY29sO1xuICAgICAgICAgIHRvcCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSB0aGlzLmNvbHVtblNpemVzW2NvbF0uaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBoaXRib3gudG9wID0gdG9wO1xuICAgICAgICBoaXRib3gubGVmdCArPSB0aGlzLmxlZnQgKyBwYWRkaW5nO1xuICAgICAgICBoaXRib3gubGVmdCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54KGhpdGJveC5sZWZ0KSwgaGl0Ym94LndpZHRoKTtcbiAgICAgICAgdG9wICs9IGhpdGJveC5oZWlnaHQgKyBwYWRkaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlzSG9yaXpvbnRhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAndG9wJyB8fCB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nO1xuICB9XG5cbiAgZHJhdygpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmRpc3BsYXkpIHtcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgICAgY2xpcEFyZWEoY3R4LCB0aGlzKTtcblxuICAgICAgdGhpcy5fZHJhdygpO1xuXG4gICAgICB1bmNsaXBBcmVhKGN0eCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZHJhdygpIHtcbiAgICBjb25zdCB7b3B0aW9uczogb3B0cywgY29sdW1uU2l6ZXMsIGxpbmVXaWR0aHMsIGN0eH0gPSB0aGlzO1xuICAgIGNvbnN0IHthbGlnbiwgbGFiZWxzOiBsYWJlbE9wdHN9ID0gb3B0cztcbiAgICBjb25zdCBkZWZhdWx0Q29sb3IgPSBkZWZhdWx0cy5jb2xvcjtcbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdHMucnRsLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpO1xuICAgIGNvbnN0IGxhYmVsRm9udCA9IHRvRm9udChsYWJlbE9wdHMuZm9udCk7XG4gICAgY29uc3Qge3BhZGRpbmd9ID0gbGFiZWxPcHRzO1xuICAgIGNvbnN0IGZvbnRTaXplID0gbGFiZWxGb250LnNpemU7XG4gICAgY29uc3QgaGFsZkZvbnRTaXplID0gZm9udFNpemUgLyAyO1xuICAgIGxldCBjdXJzb3I7XG5cbiAgICB0aGlzLmRyYXdUaXRsZSgpO1xuXG4gICAgLy8gQ2FudmFzIHNldHVwXG4gICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oJ2xlZnQnKTtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDAuNTtcbiAgICBjdHguZm9udCA9IGxhYmVsRm9udC5zdHJpbmc7XG5cbiAgICBjb25zdCB7Ym94V2lkdGgsIGJveEhlaWdodCwgaXRlbUhlaWdodH0gPSBnZXRCb3hTaXplKGxhYmVsT3B0cywgZm9udFNpemUpO1xuXG4gICAgLy8gY3VycmVudCBwb3NpdGlvblxuICAgIGNvbnN0IGRyYXdMZWdlbmRCb3ggPSBmdW5jdGlvbih4LCB5LCBsZWdlbmRJdGVtKSB7XG4gICAgICBpZiAoaXNOYU4oYm94V2lkdGgpIHx8IGJveFdpZHRoIDw9IDAgfHwgaXNOYU4oYm94SGVpZ2h0KSB8fCBib3hIZWlnaHQgPCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHRoZSBjdHggZm9yIHRoZSBib3hcbiAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgIGNvbnN0IGxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZVdpZHRoLCAxKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmZpbGxTdHlsZSwgZGVmYXVsdENvbG9yKTtcbiAgICAgIGN0eC5saW5lQ2FwID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lQ2FwLCAnYnV0dCcpO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lRGFzaE9mZnNldCwgMCk7XG4gICAgICBjdHgubGluZUpvaW4gPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVKb2luLCAnbWl0ZXInKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLnN0cm9rZVN0eWxlLCBkZWZhdWx0Q29sb3IpO1xuXG4gICAgICBjdHguc2V0TGluZURhc2godmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lRGFzaCwgW10pKTtcblxuICAgICAgaWYgKGxhYmVsT3B0cy51c2VQb2ludFN0eWxlKSB7XG4gICAgICAgIC8vIFJlY2FsY3VsYXRlIHggYW5kIHkgZm9yIGRyYXdQb2ludCgpIGJlY2F1c2UgaXRzIGV4cGVjdGluZ1xuICAgICAgICAvLyB4IGFuZCB5IHRvIGJlIGNlbnRlciBvZiBmaWd1cmUgKGluc3RlYWQgb2YgdG9wIGxlZnQpXG4gICAgICAgIGNvbnN0IGRyYXdPcHRpb25zID0ge1xuICAgICAgICAgIHJhZGl1czogYm94SGVpZ2h0ICogTWF0aC5TUVJUMiAvIDIsXG4gICAgICAgICAgcG9pbnRTdHlsZTogbGVnZW5kSXRlbS5wb2ludFN0eWxlLFxuICAgICAgICAgIHJvdGF0aW9uOiBsZWdlbmRJdGVtLnJvdGF0aW9uLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiBsaW5lV2lkdGhcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2VudGVyWCA9IHJ0bEhlbHBlci54UGx1cyh4LCBib3hXaWR0aCAvIDIpO1xuICAgICAgICBjb25zdCBjZW50ZXJZID0geSArIGhhbGZGb250U2l6ZTtcblxuICAgICAgICAvLyBEcmF3IHBvaW50U3R5bGUgYXMgbGVnZW5kIHN5bWJvbFxuICAgICAgICBkcmF3UG9pbnRMZWdlbmQoY3R4LCBkcmF3T3B0aW9ucywgY2VudGVyWCwgY2VudGVyWSwgbGFiZWxPcHRzLnBvaW50U3R5bGVXaWR0aCAmJiBib3hXaWR0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEcmF3IGJveCBhcyBsZWdlbmQgc3ltYm9sXG4gICAgICAgIC8vIEFkanVzdCBwb3NpdGlvbiB3aGVuIGJveEhlaWdodCA8IGZvbnRTaXplICh3YW50IGl0IGNlbnRlcmVkKVxuICAgICAgICBjb25zdCB5Qm94VG9wID0geSArIE1hdGgubWF4KChmb250U2l6ZSAtIGJveEhlaWdodCkgLyAyLCAwKTtcbiAgICAgICAgY29uc3QgeEJveExlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cih4LCBib3hXaWR0aCk7XG4gICAgICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMobGVnZW5kSXRlbS5ib3JkZXJSYWRpdXMpO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUodiA9PiB2ICE9PSAwKSkge1xuICAgICAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgICAgIHg6IHhCb3hMZWZ0LFxuICAgICAgICAgICAgeTogeUJveFRvcCxcbiAgICAgICAgICAgIHc6IGJveFdpZHRoLFxuICAgICAgICAgICAgaDogYm94SGVpZ2h0LFxuICAgICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LnJlY3QoeEJveExlZnQsIHlCb3hUb3AsIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgaWYgKGxpbmVXaWR0aCAhPT0gMCkge1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH07XG5cbiAgICBjb25zdCBmaWxsVGV4dCA9IGZ1bmN0aW9uKHgsIHksIGxlZ2VuZEl0ZW0pIHtcbiAgICAgIHJlbmRlclRleHQoY3R4LCBsZWdlbmRJdGVtLnRleHQsIHgsIHkgKyAoaXRlbUhlaWdodCAvIDIpLCBsYWJlbEZvbnQsIHtcbiAgICAgICAgc3RyaWtldGhyb3VnaDogbGVnZW5kSXRlbS5oaWRkZW4sXG4gICAgICAgIHRleHRBbGlnbjogcnRsSGVscGVyLnRleHRBbGlnbihsZWdlbmRJdGVtLnRleHRBbGlnbilcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBIb3Jpem9udGFsXG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCB0aXRsZUhlaWdodCA9IHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpO1xuICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgIGN1cnNvciA9IHtcbiAgICAgICAgeDogX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSBsaW5lV2lkdGhzWzBdKSxcbiAgICAgICAgeTogdGhpcy50b3AgKyBwYWRkaW5nICsgdGl0bGVIZWlnaHQsXG4gICAgICAgIGxpbmU6IDBcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnNvciA9IHtcbiAgICAgICAgeDogdGhpcy5sZWZ0ICsgcGFkZGluZyxcbiAgICAgICAgeTogX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIGNvbHVtblNpemVzWzBdLmhlaWdodCksXG4gICAgICAgIGxpbmU6IDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgb3ZlcnJpZGVUZXh0RGlyZWN0aW9uKHRoaXMuY3R4LCBvcHRzLnRleHREaXJlY3Rpb24pO1xuXG4gICAgY29uc3QgbGluZUhlaWdodCA9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSkgPT4ge1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGVnZW5kSXRlbS5mb250Q29sb3I7IC8vIGZvciBzdHJpa2V0aHJvdWdoIGVmZmVjdFxuICAgICAgY3R4LmZpbGxTdHlsZSA9IGxlZ2VuZEl0ZW0uZm9udENvbG9yOyAvLyByZW5kZXIgaW4gY29ycmVjdCBjb2xvdXJcblxuICAgICAgY29uc3QgdGV4dFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG4gICAgICBjb25zdCB0ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKGxlZ2VuZEl0ZW0udGV4dEFsaWduIHx8IChsZWdlbmRJdGVtLnRleHRBbGlnbiA9IGxhYmVsT3B0cy50ZXh0QWxpZ24pKTtcbiAgICAgIGNvbnN0IHdpZHRoID0gYm94V2lkdGggKyBoYWxmRm9udFNpemUgKyB0ZXh0V2lkdGg7XG4gICAgICBsZXQgeCA9IGN1cnNvci54O1xuICAgICAgbGV0IHkgPSBjdXJzb3IueTtcblxuICAgICAgcnRsSGVscGVyLnNldFdpZHRoKHRoaXMud2lkdGgpO1xuXG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIGlmIChpID4gMCAmJiB4ICsgd2lkdGggKyBwYWRkaW5nID4gdGhpcy5yaWdodCkge1xuICAgICAgICAgIHkgPSBjdXJzb3IueSArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgIGN1cnNvci5saW5lKys7XG4gICAgICAgICAgeCA9IGN1cnNvci54ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSBsaW5lV2lkdGhzW2N1cnNvci5saW5lXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaSA+IDAgJiYgeSArIGxpbmVIZWlnaHQgPiB0aGlzLmJvdHRvbSkge1xuICAgICAgICB4ID0gY3Vyc29yLnggPSB4ICsgY29sdW1uU2l6ZXNbY3Vyc29yLmxpbmVdLndpZHRoICsgcGFkZGluZztcbiAgICAgICAgY3Vyc29yLmxpbmUrKztcbiAgICAgICAgeSA9IGN1cnNvci55ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIGNvbHVtblNpemVzW2N1cnNvci5saW5lXS5oZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZWFsWCA9IHJ0bEhlbHBlci54KHgpO1xuXG4gICAgICBkcmF3TGVnZW5kQm94KHJlYWxYLCB5LCBsZWdlbmRJdGVtKTtcblxuICAgICAgeCA9IF90ZXh0WCh0ZXh0QWxpZ24sIHggKyBib3hXaWR0aCArIGhhbGZGb250U2l6ZSwgaXNIb3Jpem9udGFsID8geCArIHdpZHRoIDogdGhpcy5yaWdodCwgb3B0cy5ydGwpO1xuXG4gICAgICAvLyBGaWxsIHRoZSBhY3R1YWwgbGFiZWxcbiAgICAgIGZpbGxUZXh0KHJ0bEhlbHBlci54KHgpLCB5LCBsZWdlbmRJdGVtKTtcblxuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBjdXJzb3IueCArPSB3aWR0aCArIHBhZGRpbmc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsZWdlbmRJdGVtLnRleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IGZvbnRMaW5lSGVpZ2h0ID0gbGFiZWxGb250LmxpbmVIZWlnaHQ7XG4gICAgICAgIGN1cnNvci55ICs9IGNhbGN1bGF0ZUxlZ2VuZEl0ZW1IZWlnaHQobGVnZW5kSXRlbSwgZm9udExpbmVIZWlnaHQpICsgcGFkZGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnNvci55ICs9IGxpbmVIZWlnaHQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXN0b3JlVGV4dERpcmVjdGlvbih0aGlzLmN0eCwgb3B0cy50ZXh0RGlyZWN0aW9uKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3VGl0bGUoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aXRsZU9wdHMgPSBvcHRzLnRpdGxlO1xuICAgIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udCh0aXRsZU9wdHMuZm9udCk7XG4gICAgY29uc3QgdGl0bGVQYWRkaW5nID0gdG9QYWRkaW5nKHRpdGxlT3B0cy5wYWRkaW5nKTtcblxuICAgIGlmICghdGl0bGVPcHRzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdHMucnRsLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGl0bGVPcHRzLnBvc2l0aW9uO1xuICAgIGNvbnN0IGhhbGZGb250U2l6ZSA9IHRpdGxlRm9udC5zaXplIC8gMjtcbiAgICBjb25zdCB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZSA9IHRpdGxlUGFkZGluZy50b3AgKyBoYWxmRm9udFNpemU7XG4gICAgbGV0IHk7XG5cbiAgICAvLyBUaGVzZSBkZWZhdWx0cyBhcmUgdXNlZCB3aGVuIHRoZSBsZWdlbmQgaXMgdmVydGljYWwuXG4gICAgLy8gV2hlbiBob3Jpem9udGFsLCB0aGV5IGFyZSBjb21wdXRlZCBiZWxvdy5cbiAgICBsZXQgbGVmdCA9IHRoaXMubGVmdDtcbiAgICBsZXQgbWF4V2lkdGggPSB0aGlzLndpZHRoO1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIC8vIE1vdmUgbGVmdCAvIHJpZ2h0IHNvIHRoYXQgdGhlIHRpdGxlIGlzIGFib3ZlIHRoZSBsZWdlbmQgbGluZXNcbiAgICAgIG1heFdpZHRoID0gTWF0aC5tYXgoLi4udGhpcy5saW5lV2lkdGhzKTtcbiAgICAgIHkgPSB0aGlzLnRvcCArIHRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplO1xuICAgICAgbGVmdCA9IF9hbGlnblN0YXJ0RW5kKG9wdHMuYWxpZ24sIGxlZnQsIHRoaXMucmlnaHQgLSBtYXhXaWR0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1vdmUgZG93biBzbyB0aGF0IHRoZSB0aXRsZSBpcyBhYm92ZSB0aGUgbGVnZW5kIHN0YWNrIGluIGV2ZXJ5IGFsaWdubWVudFxuICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gdGhpcy5jb2x1bW5TaXplcy5yZWR1Y2UoKGFjYywgc2l6ZSkgPT4gTWF0aC5tYXgoYWNjLCBzaXplLmhlaWdodCksIDApO1xuICAgICAgeSA9IHRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplICsgX2FsaWduU3RhcnRFbmQob3B0cy5hbGlnbiwgdGhpcy50b3AsIHRoaXMuYm90dG9tIC0gbWF4SGVpZ2h0IC0gb3B0cy5sYWJlbHMucGFkZGluZyAtIHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgdGhhdCB3ZSBrbm93IHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIGlubmVyIGxlZ2VuZCBib3gsIGNvbXB1dGUgdGhlIGNvcnJlY3RcbiAgICAvLyBYIGNvb3JkaW5hdGUgZnJvbSB0aGUgdGl0bGUgYWxpZ25tZW50XG4gICAgY29uc3QgeCA9IF9hbGlnblN0YXJ0RW5kKHBvc2l0aW9uLCBsZWZ0LCBsZWZ0ICsgbWF4V2lkdGgpO1xuXG4gICAgLy8gQ2FudmFzIHNldHVwXG4gICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oX3RvTGVmdFJpZ2h0Q2VudGVyKHBvc2l0aW9uKSk7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHRpdGxlT3B0cy5jb2xvcjtcbiAgICBjdHguZmlsbFN0eWxlID0gdGl0bGVPcHRzLmNvbG9yO1xuICAgIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcblxuICAgIHJlbmRlclRleHQoY3R4LCB0aXRsZU9wdHMudGV4dCwgeCwgeSwgdGl0bGVGb250KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NvbXB1dGVUaXRsZUhlaWdodCgpIHtcbiAgICBjb25zdCB0aXRsZU9wdHMgPSB0aGlzLm9wdGlvbnMudGl0bGU7XG4gICAgY29uc3QgdGl0bGVGb250ID0gdG9Gb250KHRpdGxlT3B0cy5mb250KTtcbiAgICBjb25zdCB0aXRsZVBhZGRpbmcgPSB0b1BhZGRpbmcodGl0bGVPcHRzLnBhZGRpbmcpO1xuICAgIHJldHVybiB0aXRsZU9wdHMuZGlzcGxheSA/IHRpdGxlRm9udC5saW5lSGVpZ2h0ICsgdGl0bGVQYWRkaW5nLmhlaWdodCA6IDA7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRMZWdlbmRJdGVtQXQoeCwgeSkge1xuICAgIGxldCBpLCBoaXRCb3gsIGxoO1xuXG4gICAgaWYgKF9pc0JldHdlZW4oeCwgdGhpcy5sZWZ0LCB0aGlzLnJpZ2h0KVxuICAgICAgJiYgX2lzQmV0d2Vlbih5LCB0aGlzLnRvcCwgdGhpcy5ib3R0b20pKSB7XG4gICAgICAvLyBTZWUgaWYgd2UgYXJlIHRvdWNoaW5nIG9uZSBvZiB0aGUgZGF0YXNldCBib3hlc1xuICAgICAgbGggPSB0aGlzLmxlZ2VuZEhpdEJveGVzO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxoLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGhpdEJveCA9IGxoW2ldO1xuXG4gICAgICAgIGlmIChfaXNCZXR3ZWVuKHgsIGhpdEJveC5sZWZ0LCBoaXRCb3gubGVmdCArIGhpdEJveC53aWR0aClcbiAgICAgICAgICAmJiBfaXNCZXR3ZWVuKHksIGhpdEJveC50b3AsIGhpdEJveC50b3AgKyBoaXRCb3guaGVpZ2h0KSkge1xuICAgICAgICAgIC8vIFRvdWNoaW5nIGFuIGVsZW1lbnRcbiAgICAgICAgICByZXR1cm4gdGhpcy5sZWdlbmRJdGVtc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG5cdCAqIEhhbmRsZSBhbiBldmVudFxuXHQgKiBAcGFyYW0ge0NoYXJ0RXZlbnR9IGUgLSBUaGUgZXZlbnQgdG8gaGFuZGxlXG5cdCAqL1xuICBoYW5kbGVFdmVudChlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoIWlzTGlzdGVuZWQoZS50eXBlLCBvcHRzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoYXJ0IGV2ZW50IGFscmVhZHkgaGFzIHJlbGF0aXZlIHBvc2l0aW9uIGluIGl0XG4gICAgY29uc3QgaG92ZXJlZEl0ZW0gPSB0aGlzLl9nZXRMZWdlbmRJdGVtQXQoZS54LCBlLnkpO1xuXG4gICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlbW92ZScgfHwgZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgICBjb25zdCBwcmV2aW91cyA9IHRoaXMuX2hvdmVyZWRJdGVtO1xuICAgICAgY29uc3Qgc2FtZUl0ZW0gPSBpdGVtc0VxdWFsKHByZXZpb3VzLCBob3ZlcmVkSXRlbSk7XG4gICAgICBpZiAocHJldmlvdXMgJiYgIXNhbWVJdGVtKSB7XG4gICAgICAgIGNhbGwob3B0cy5vbkxlYXZlLCBbZSwgcHJldmlvdXMsIHRoaXNdLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faG92ZXJlZEl0ZW0gPSBob3ZlcmVkSXRlbTtcblxuICAgICAgaWYgKGhvdmVyZWRJdGVtICYmICFzYW1lSXRlbSkge1xuICAgICAgICBjYWxsKG9wdHMub25Ib3ZlciwgW2UsIGhvdmVyZWRJdGVtLCB0aGlzXSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChob3ZlcmVkSXRlbSkge1xuICAgICAgY2FsbChvcHRzLm9uQ2xpY2ssIFtlLCBob3ZlcmVkSXRlbSwgdGhpc10sIHRoaXMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVJdGVtU2l6ZShib3hXaWR0aCwgbGFiZWxGb250LCBjdHgsIGxlZ2VuZEl0ZW0sIF9pdGVtSGVpZ2h0KSB7XG4gIGNvbnN0IGl0ZW1XaWR0aCA9IGNhbGN1bGF0ZUl0ZW1XaWR0aChsZWdlbmRJdGVtLCBib3hXaWR0aCwgbGFiZWxGb250LCBjdHgpO1xuICBjb25zdCBpdGVtSGVpZ2h0ID0gY2FsY3VsYXRlSXRlbUhlaWdodChfaXRlbUhlaWdodCwgbGVnZW5kSXRlbSwgbGFiZWxGb250LmxpbmVIZWlnaHQpO1xuICByZXR1cm4ge2l0ZW1XaWR0aCwgaXRlbUhlaWdodH07XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUl0ZW1XaWR0aChsZWdlbmRJdGVtLCBib3hXaWR0aCwgbGFiZWxGb250LCBjdHgpIHtcbiAgbGV0IGxlZ2VuZEl0ZW1UZXh0ID0gbGVnZW5kSXRlbS50ZXh0O1xuICBpZiAobGVnZW5kSXRlbVRleHQgJiYgdHlwZW9mIGxlZ2VuZEl0ZW1UZXh0ICE9PSAnc3RyaW5nJykge1xuICAgIGxlZ2VuZEl0ZW1UZXh0ID0gbGVnZW5kSXRlbVRleHQucmVkdWNlKChhLCBiKSA9PiBhLmxlbmd0aCA+IGIubGVuZ3RoID8gYSA6IGIpO1xuICB9XG4gIHJldHVybiBib3hXaWR0aCArIChsYWJlbEZvbnQuc2l6ZSAvIDIpICsgY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW1UZXh0KS53aWR0aDtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlSXRlbUhlaWdodChfaXRlbUhlaWdodCwgbGVnZW5kSXRlbSwgZm9udExpbmVIZWlnaHQpIHtcbiAgbGV0IGl0ZW1IZWlnaHQgPSBfaXRlbUhlaWdodDtcbiAgaWYgKHR5cGVvZiBsZWdlbmRJdGVtLnRleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgaXRlbUhlaWdodCA9IGNhbGN1bGF0ZUxlZ2VuZEl0ZW1IZWlnaHQobGVnZW5kSXRlbSwgZm9udExpbmVIZWlnaHQpO1xuICB9XG4gIHJldHVybiBpdGVtSGVpZ2h0O1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVMZWdlbmRJdGVtSGVpZ2h0KGxlZ2VuZEl0ZW0sIGZvbnRMaW5lSGVpZ2h0KSB7XG4gIGNvbnN0IGxhYmVsSGVpZ2h0ID0gbGVnZW5kSXRlbS50ZXh0ID8gbGVnZW5kSXRlbS50ZXh0Lmxlbmd0aCA6IDA7XG4gIHJldHVybiBmb250TGluZUhlaWdodCAqIGxhYmVsSGVpZ2h0O1xufVxuXG5mdW5jdGlvbiBpc0xpc3RlbmVkKHR5cGUsIG9wdHMpIHtcbiAgaWYgKCh0eXBlID09PSAnbW91c2Vtb3ZlJyB8fCB0eXBlID09PSAnbW91c2VvdXQnKSAmJiAob3B0cy5vbkhvdmVyIHx8IG9wdHMub25MZWF2ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAob3B0cy5vbkNsaWNrICYmICh0eXBlID09PSAnY2xpY2snIHx8IHR5cGUgPT09ICdtb3VzZXVwJykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaWQ6ICdsZWdlbmQnLFxuXG4gIC8qKlxuXHQgKiBGb3IgdGVzdHNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9lbGVtZW50OiBMZWdlbmQsXG5cbiAgc3RhcnQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGVnZW5kID0gY2hhcnQubGVnZW5kID0gbmV3IExlZ2VuZCh7Y3R4OiBjaGFydC5jdHgsIG9wdGlvbnMsIGNoYXJ0fSk7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIGxlZ2VuZCwgb3B0aW9ucyk7XG4gICAgbGF5b3V0cy5hZGRCb3goY2hhcnQsIGxlZ2VuZCk7XG4gIH0sXG5cbiAgc3RvcChjaGFydCkge1xuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBjaGFydC5sZWdlbmQpO1xuICAgIGRlbGV0ZSBjaGFydC5sZWdlbmQ7XG4gIH0sXG5cbiAgLy8gRHVyaW5nIHRoZSBiZWZvcmVVcGRhdGUgc3RlcCwgdGhlIGxheW91dCBjb25maWd1cmF0aW9uIG5lZWRzIHRvIHJ1blxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdCBpZiB0aGUgbGVnZW5kIHBvc2l0aW9uIGNoYW5nZXMgKHZpYSBhbiBvcHRpb24gdXBkYXRlKVxuICAvLyB0aGUgbGF5b3V0IHN5c3RlbSByZXNwZWN0cyB0aGUgY2hhbmdlLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzc1MjdcbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZDtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBvcHRpb25zKTtcbiAgICBsZWdlbmQub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG5cbiAgLy8gVGhlIGxhYmVscyBuZWVkIHRvIGJlIGJ1aWx0IGFmdGVyIGRhdGFzZXRzIGFyZSB1cGRhdGVkIHRvIGVuc3VyZSB0aGF0IGNvbG9yc1xuICAvLyBhbmQgb3RoZXIgc3R5bGluZyBhcmUgY29ycmVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy82OTY4XG4gIGFmdGVyVXBkYXRlKGNoYXJ0KSB7XG4gICAgY29uc3QgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xuICAgIGxlZ2VuZC5idWlsZExhYmVscygpO1xuICAgIGxlZ2VuZC5hZGp1c3RIaXRCb3hlcygpO1xuICB9LFxuXG5cbiAgYWZ0ZXJFdmVudChjaGFydCwgYXJncykge1xuICAgIGlmICghYXJncy5yZXBsYXkpIHtcbiAgICAgIGNoYXJ0LmxlZ2VuZC5oYW5kbGVFdmVudChhcmdzLmV2ZW50KTtcbiAgICB9XG4gIH0sXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBkaXNwbGF5OiB0cnVlLFxuICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgZnVsbFNpemU6IHRydWUsXG4gICAgcmV2ZXJzZTogZmFsc2UsXG4gICAgd2VpZ2h0OiAxMDAwLFxuXG4gICAgLy8gYSBjYWxsYmFjayB0aGF0IHdpbGwgaGFuZGxlXG4gICAgb25DbGljayhlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gbGVnZW5kSXRlbS5kYXRhc2V0SW5kZXg7XG4gICAgICBjb25zdCBjaSA9IGxlZ2VuZC5jaGFydDtcbiAgICAgIGlmIChjaS5pc0RhdGFzZXRWaXNpYmxlKGluZGV4KSkge1xuICAgICAgICBjaS5oaWRlKGluZGV4KTtcbiAgICAgICAgbGVnZW5kSXRlbS5oaWRkZW4gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2kuc2hvdyhpbmRleCk7XG4gICAgICAgIGxlZ2VuZEl0ZW0uaGlkZGVuID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcblxuICAgIG9uSG92ZXI6IG51bGwsXG4gICAgb25MZWF2ZTogbnVsbCxcblxuICAgIGxhYmVsczoge1xuICAgICAgY29sb3I6IChjdHgpID0+IGN0eC5jaGFydC5vcHRpb25zLmNvbG9yLFxuICAgICAgYm94V2lkdGg6IDQwLFxuICAgICAgcGFkZGluZzogMTAsXG4gICAgICAvLyBHZW5lcmF0ZXMgbGFiZWxzIHNob3duIGluIHRoZSBsZWdlbmRcbiAgICAgIC8vIFZhbGlkIHByb3BlcnRpZXMgdG8gcmV0dXJuOlxuICAgICAgLy8gdGV4dCA6IHRleHQgdG8gZGlzcGxheVxuICAgICAgLy8gZmlsbFN0eWxlIDogZmlsbCBvZiBjb2xvdXJlZCBib3hcbiAgICAgIC8vIHN0cm9rZVN0eWxlOiBzdHJva2Ugb2YgY29sb3VyZWQgYm94XG4gICAgICAvLyBoaWRkZW4gOiBpZiB0aGlzIGxlZ2VuZCBpdGVtIHJlZmVycyB0byBhIGhpZGRlbiBpdGVtXG4gICAgICAvLyBsaW5lQ2FwIDogY2FwIHN0eWxlIGZvciBsaW5lXG4gICAgICAvLyBsaW5lRGFzaFxuICAgICAgLy8gbGluZURhc2hPZmZzZXQgOlxuICAgICAgLy8gbGluZUpvaW4gOlxuICAgICAgLy8gbGluZVdpZHRoIDpcbiAgICAgIGdlbmVyYXRlTGFiZWxzKGNoYXJ0KSB7XG4gICAgICAgIGNvbnN0IGRhdGFzZXRzID0gY2hhcnQuZGF0YS5kYXRhc2V0cztcbiAgICAgICAgY29uc3Qge2xhYmVsczoge3VzZVBvaW50U3R5bGUsIHBvaW50U3R5bGUsIHRleHRBbGlnbiwgY29sb3IsIHVzZUJvcmRlclJhZGl1cywgYm9yZGVyUmFkaXVzfX0gPSBjaGFydC5sZWdlbmQub3B0aW9ucztcblxuICAgICAgICByZXR1cm4gY2hhcnQuX2dldFNvcnRlZERhdGFzZXRNZXRhcygpLm1hcCgobWV0YSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHVzZVBvaW50U3R5bGUgPyAwIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICBjb25zdCBib3JkZXJXaWR0aCA9IHRvUGFkZGluZyhzdHlsZS5ib3JkZXJXaWR0aCk7XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogZGF0YXNldHNbbWV0YS5pbmRleF0ubGFiZWwsXG4gICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIGZvbnRDb2xvcjogY29sb3IsXG4gICAgICAgICAgICBoaWRkZW46ICFtZXRhLnZpc2libGUsXG4gICAgICAgICAgICBsaW5lQ2FwOiBzdHlsZS5ib3JkZXJDYXBTdHlsZSxcbiAgICAgICAgICAgIGxpbmVEYXNoOiBzdHlsZS5ib3JkZXJEYXNoLFxuICAgICAgICAgICAgbGluZURhc2hPZmZzZXQ6IHN0eWxlLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgICAgICBsaW5lSm9pbjogc3R5bGUuYm9yZGVySm9pblN0eWxlLFxuICAgICAgICAgICAgbGluZVdpZHRoOiAoYm9yZGVyV2lkdGgud2lkdGggKyBib3JkZXJXaWR0aC5oZWlnaHQpIC8gNCxcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUgfHwgc3R5bGUucG9pbnRTdHlsZSxcbiAgICAgICAgICAgIHJvdGF0aW9uOiBzdHlsZS5yb3RhdGlvbixcbiAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduIHx8IHN0eWxlLnRleHRBbGlnbixcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogdXNlQm9yZGVyUmFkaXVzICYmIChib3JkZXJSYWRpdXMgfHwgc3R5bGUuYm9yZGVyUmFkaXVzKSxcblxuICAgICAgICAgICAgLy8gQmVsb3cgaXMgZXh0cmEgZGF0YSB1c2VkIGZvciB0b2dnbGluZyB0aGUgZGF0YXNldHNcbiAgICAgICAgICAgIGRhdGFzZXRJbmRleDogbWV0YS5pbmRleFxuICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB0aXRsZToge1xuICAgICAgY29sb3I6IChjdHgpID0+IGN0eC5jaGFydC5vcHRpb25zLmNvbG9yLFxuICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICBwb3NpdGlvbjogJ2NlbnRlcicsXG4gICAgICB0ZXh0OiAnJyxcbiAgICB9XG4gIH0sXG5cbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ29uJyksXG4gICAgbGFiZWxzOiB7XG4gICAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFbJ2dlbmVyYXRlTGFiZWxzJywgJ2ZpbHRlcicsICdzb3J0J10uaW5jbHVkZXMobmFtZSksXG4gICAgfVxuICB9LFxufTtcbiIsICJpbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQgbGF5b3V0cyBmcm9tICcuLi9jb3JlL2NvcmUubGF5b3V0cy5qcyc7XG5pbXBvcnQge1BJLCBpc0FycmF5LCB0b1BhZGRpbmcsIHRvRm9udH0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge190b0xlZnRSaWdodENlbnRlciwgX2FsaWduU3RhcnRFbmR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuaW1wb3J0IHtyZW5kZXJUZXh0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcblxuZXhwb3J0IGNsYXNzIFRpdGxlIGV4dGVuZHMgRWxlbWVudCB7XG4gIC8qKlxuXHQgKiBAcGFyYW0ge3sgY3R4OiBhbnk7IG9wdGlvbnM6IGFueTsgY2hhcnQ6IGFueTsgfX0gY29uZmlnXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5jaGFydCA9IGNvbmZpZy5jaGFydDtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcbiAgICB0aGlzLmN0eCA9IGNvbmZpZy5jdHg7XG4gICAgdGhpcy5fcGFkZGluZyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53ZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mdWxsU2l6ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0KSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcblxuICAgIHRoaXMubGVmdCA9IDA7XG4gICAgdGhpcy50b3AgPSAwO1xuXG4gICAgaWYgKCFvcHRzLmRpc3BsYXkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IHRoaXMucmlnaHQgPSB0aGlzLmJvdHRvbSA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy53aWR0aCA9IHRoaXMucmlnaHQgPSBtYXhXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMuYm90dG9tID0gbWF4SGVpZ2h0O1xuXG4gICAgY29uc3QgbGluZUNvdW50ID0gaXNBcnJheShvcHRzLnRleHQpID8gb3B0cy50ZXh0Lmxlbmd0aCA6IDE7XG4gICAgdGhpcy5fcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzLnBhZGRpbmcpO1xuICAgIGNvbnN0IHRleHRTaXplID0gbGluZUNvdW50ICogdG9Gb250KG9wdHMuZm9udCkubGluZUhlaWdodCArIHRoaXMuX3BhZGRpbmcuaGVpZ2h0O1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGV4dFNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2lkdGggPSB0ZXh0U2l6ZTtcbiAgICB9XG4gIH1cblxuICBpc0hvcml6b250YWwoKSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuICAgIHJldHVybiBwb3MgPT09ICd0b3AnIHx8IHBvcyA9PT0gJ2JvdHRvbSc7XG4gIH1cblxuICBfZHJhd0FyZ3Mob2Zmc2V0KSB7XG4gICAgY29uc3Qge3RvcCwgbGVmdCwgYm90dG9tLCByaWdodCwgb3B0aW9uc30gPSB0aGlzO1xuICAgIGNvbnN0IGFsaWduID0gb3B0aW9ucy5hbGlnbjtcbiAgICBsZXQgcm90YXRpb24gPSAwO1xuICAgIGxldCBtYXhXaWR0aCwgdGl0bGVYLCB0aXRsZVk7XG5cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGl0bGVYID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGxlZnQsIHJpZ2h0KTtcbiAgICAgIHRpdGxlWSA9IHRvcCArIG9mZnNldDtcbiAgICAgIG1heFdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHRpdGxlWCA9IGxlZnQgKyBvZmZzZXQ7XG4gICAgICAgIHRpdGxlWSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBib3R0b20sIHRvcCk7XG4gICAgICAgIHJvdGF0aW9uID0gUEkgKiAtMC41O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGl0bGVYID0gcmlnaHQgLSBvZmZzZXQ7XG4gICAgICAgIHRpdGxlWSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0b3AsIGJvdHRvbSk7XG4gICAgICAgIHJvdGF0aW9uID0gUEkgKiAwLjU7XG4gICAgICB9XG4gICAgICBtYXhXaWR0aCA9IGJvdHRvbSAtIHRvcDtcbiAgICB9XG4gICAgcmV0dXJuIHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufTtcbiAgfVxuXG4gIGRyYXcoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcblxuICAgIGlmICghb3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZm9udE9wdHMgPSB0b0ZvbnQob3B0cy5mb250KTtcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gZm9udE9wdHMubGluZUhlaWdodDtcbiAgICBjb25zdCBvZmZzZXQgPSBsaW5lSGVpZ2h0IC8gMiArIHRoaXMuX3BhZGRpbmcudG9wO1xuICAgIGNvbnN0IHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufSA9IHRoaXMuX2RyYXdBcmdzKG9mZnNldCk7XG5cbiAgICByZW5kZXJUZXh0KGN0eCwgb3B0cy50ZXh0LCAwLCAwLCBmb250T3B0cywge1xuICAgICAgY29sb3I6IG9wdHMuY29sb3IsXG4gICAgICBtYXhXaWR0aCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgdGV4dEFsaWduOiBfdG9MZWZ0UmlnaHRDZW50ZXIob3B0cy5hbGlnbiksXG4gICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgdHJhbnNsYXRpb246IFt0aXRsZVgsIHRpdGxlWV0sXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlVGl0bGUoY2hhcnQsIHRpdGxlT3B0cykge1xuICBjb25zdCB0aXRsZSA9IG5ldyBUaXRsZSh7XG4gICAgY3R4OiBjaGFydC5jdHgsXG4gICAgb3B0aW9uczogdGl0bGVPcHRzLFxuICAgIGNoYXJ0XG4gIH0pO1xuXG4gIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgdGl0bGVPcHRzKTtcbiAgbGF5b3V0cy5hZGRCb3goY2hhcnQsIHRpdGxlKTtcbiAgY2hhcnQudGl0bGVCbG9jayA9IHRpdGxlO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAndGl0bGUnLFxuXG4gIC8qKlxuXHQgKiBGb3IgdGVzdHNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9lbGVtZW50OiBUaXRsZSxcblxuICBzdGFydChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjcmVhdGVUaXRsZShjaGFydCwgb3B0aW9ucyk7XG4gIH0sXG5cbiAgc3RvcChjaGFydCkge1xuICAgIGNvbnN0IHRpdGxlQmxvY2sgPSBjaGFydC50aXRsZUJsb2NrO1xuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCB0aXRsZUJsb2NrKTtcbiAgICBkZWxldGUgY2hhcnQudGl0bGVCbG9jaztcbiAgfSxcblxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSBjaGFydC50aXRsZUJsb2NrO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgdGl0bGUub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgZGlzcGxheTogZmFsc2UsXG4gICAgZm9udDoge1xuICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgfSxcbiAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICBwYWRkaW5nOiAxMCxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgdGV4dDogJycsXG4gICAgd2VpZ2h0OiAyMDAwICAgICAgICAgLy8gYnkgZGVmYXVsdCBncmVhdGVyIHRoYW4gbGVnZW5kICgxMDAwKSB0byBiZSBhYm92ZVxuICB9LFxuXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBjb2xvcjogJ2NvbG9yJ1xuICB9LFxuXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IHRydWUsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH0sXG59O1xuIiwgImltcG9ydCB7VGl0bGV9IGZyb20gJy4vcGx1Z2luLnRpdGxlLmpzJztcbmltcG9ydCBsYXlvdXRzIGZyb20gJy4uL2NvcmUvY29yZS5sYXlvdXRzLmpzJztcblxuY29uc3QgbWFwID0gbmV3IFdlYWtNYXAoKTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ3N1YnRpdGxlJyxcblxuICBzdGFydChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IG5ldyBUaXRsZSh7XG4gICAgICBjdHg6IGNoYXJ0LmN0eCxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBjaGFydFxuICAgIH0pO1xuXG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCBvcHRpb25zKTtcbiAgICBsYXlvdXRzLmFkZEJveChjaGFydCwgdGl0bGUpO1xuICAgIG1hcC5zZXQoY2hhcnQsIHRpdGxlKTtcbiAgfSxcblxuICBzdG9wKGNoYXJ0KSB7XG4gICAgbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIG1hcC5nZXQoY2hhcnQpKTtcbiAgICBtYXAuZGVsZXRlKGNoYXJ0KTtcbiAgfSxcblxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSBtYXAuZ2V0KGNoYXJ0KTtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgIHRpdGxlLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgIGZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ25vcm1hbCcsXG4gICAgfSxcbiAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICBwYWRkaW5nOiAwLFxuICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICB0ZXh0OiAnJyxcbiAgICB3ZWlnaHQ6IDE1MDAgICAgICAgICAvLyBieSBkZWZhdWx0IGdyZWF0ZXIgdGhhbiBsZWdlbmQgKDEwMDApIGFuZCBzbWFsbGVyIHRoYW4gdGl0bGUgKDIwMDApXG4gIH0sXG5cbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGNvbG9yOiAnY29sb3InXG4gIH0sXG5cbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgfSxcbn07XG4iLCAiaW1wb3J0IEFuaW1hdGlvbnMgZnJvbSAnLi4vY29yZS9jb3JlLmFuaW1hdGlvbnMuanMnO1xuaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vY29yZS9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IHthZGRSb3VuZGVkUmVjdFBhdGh9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHtlYWNoLCBub29wLCBpc051bGxPclVuZGVmLCBpc0FycmF5LCBfZWxlbWVudHNFcXVhbCwgaXNPYmplY3R9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7dG9Gb250LCB0b1BhZGRpbmcsIHRvVFJCTENvcm5lcnN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcbmltcG9ydCB7Z2V0UnRsQWRhcHRlciwgb3ZlcnJpZGVUZXh0RGlyZWN0aW9uLCByZXN0b3JlVGV4dERpcmVjdGlvbn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLnJ0bC5qcyc7XG5pbXBvcnQge2Rpc3RhbmNlQmV0d2VlblBvaW50cywgX2xpbWl0VmFsdWV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7Y3JlYXRlQ29udGV4dCwgZHJhd1BvaW50fSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vcGxhdGZvcm0vcGxhdGZvcm0uYmFzZS5qcycpLkNoYXJ0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkNoYXJ0RXZlbnQgfSBDaGFydEV2ZW50XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5BY3RpdmVFbGVtZW50IH0gQWN0aXZlRWxlbWVudFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL2NvcmUvY29yZS5pbnRlcmFjdGlvbi5qcycpLkludGVyYWN0aW9uSXRlbSB9IEludGVyYWN0aW9uSXRlbVxuICovXG5cbmNvbnN0IHBvc2l0aW9uZXJzID0ge1xuICAvKipcblx0ICogQXZlcmFnZSBtb2RlIHBsYWNlcyB0aGUgdG9vbHRpcCBhdCB0aGUgYXZlcmFnZSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudHMgc2hvd25cblx0ICovXG4gIGF2ZXJhZ2UoaXRlbXMpIHtcbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBpLCBsZW47XG4gICAgbGV0IHhTZXQgPSBuZXcgU2V0KCk7XG4gICAgbGV0IHkgPSAwO1xuICAgIGxldCBjb3VudCA9IDA7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29uc3QgZWwgPSBpdGVtc1tpXS5lbGVtZW50O1xuICAgICAgaWYgKGVsICYmIGVsLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY29uc3QgcG9zID0gZWwudG9vbHRpcFBvc2l0aW9uKCk7XG4gICAgICAgIHhTZXQuYWRkKHBvcy54KTtcbiAgICAgICAgeSArPSBwb3MueTtcbiAgICAgICAgKytjb3VudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBObyB2aXNpYmxlIGl0ZW1zIHdoZXJlIGZvdW5kLCByZXR1cm4gZmFsc2Ugc28gd2UgZG9uJ3QgaGF2ZSB0byBkaXZpZGUgYnkgMCB3aGljaCByZWR1Y2VzIGluIE5hTlxuICAgIGlmIChjb3VudCA9PT0gMCB8fCB4U2V0LnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCB4QXZlcmFnZSA9IFsuLi54U2V0XS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiKSAvIHhTZXQuc2l6ZTtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiB4QXZlcmFnZSxcbiAgICAgIHk6IHkgLyBjb3VudFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG5cdCAqIEdldHMgdGhlIHRvb2x0aXAgcG9zaXRpb24gbmVhcmVzdCBvZiB0aGUgaXRlbSBuZWFyZXN0IHRvIHRoZSBldmVudCBwb3NpdGlvblxuXHQgKi9cbiAgbmVhcmVzdChpdGVtcywgZXZlbnRQb3NpdGlvbikge1xuICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHggPSBldmVudFBvc2l0aW9uLng7XG4gICAgbGV0IHkgPSBldmVudFBvc2l0aW9uLnk7XG4gICAgbGV0IG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBpLCBsZW4sIG5lYXJlc3RFbGVtZW50O1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IGVsID0gaXRlbXNbaV0uZWxlbWVudDtcbiAgICAgIGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IGVsLmdldENlbnRlclBvaW50KCk7XG4gICAgICAgIGNvbnN0IGQgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMoZXZlbnRQb3NpdGlvbiwgY2VudGVyKTtcblxuICAgICAgICBpZiAoZCA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgbWluRGlzdGFuY2UgPSBkO1xuICAgICAgICAgIG5lYXJlc3RFbGVtZW50ID0gZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmVhcmVzdEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHRwID0gbmVhcmVzdEVsZW1lbnQudG9vbHRpcFBvc2l0aW9uKCk7XG4gICAgICB4ID0gdHAueDtcbiAgICAgIHkgPSB0cC55O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH07XG4gIH1cbn07XG5cbi8vIEhlbHBlciB0byBwdXNoIG9yIGNvbmNhdCBiYXNlZCBvbiBpZiB0aGUgMm5kIHBhcmFtZXRlciBpcyBhbiBhcnJheSBvciBub3RcbmZ1bmN0aW9uIHB1c2hPckNvbmNhdChiYXNlLCB0b1B1c2gpIHtcbiAgaWYgKHRvUHVzaCkge1xuICAgIGlmIChpc0FycmF5KHRvUHVzaCkpIHtcbiAgICAgIC8vIGJhc2UgPSBiYXNlLmNvbmNhdCh0b1B1c2gpO1xuICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYmFzZSwgdG9QdXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZS5wdXNoKHRvUHVzaCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJhc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyBhcnJheSBvZiBzdHJpbmdzIHNwbGl0IGJ5IG5ld2xpbmVcbiAqIEBwYXJhbSB7Kn0gc3RyIC0gVGhlIHZhbHVlIHRvIHNwbGl0IGJ5IG5ld2xpbmUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN0cmluZ1tdfSB2YWx1ZSBpZiBuZXdsaW5lIHByZXNlbnQgLSBSZXR1cm5lZCBmcm9tIFN0cmluZyBzcGxpdCgpIG1ldGhvZFxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIHNwbGl0TmV3bGluZXMoc3RyKSB7XG4gIGlmICgodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgfHwgc3RyIGluc3RhbmNlb2YgU3RyaW5nKSAmJiBzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgIHJldHVybiBzdHIuc3BsaXQoJ1xcbicpO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5cblxuLyoqXG4gKiBQcml2YXRlIGhlbHBlciB0byBjcmVhdGUgYSB0b29sdGlwIGl0ZW0gbW9kZWxcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG4gKiBAcGFyYW0ge0FjdGl2ZUVsZW1lbnR9IGl0ZW0gLSB7ZWxlbWVudCwgaW5kZXgsIGRhdGFzZXRJbmRleH0gdG8gY3JlYXRlIHRoZSB0b29sdGlwIGl0ZW0gZm9yXG4gKiBAcmV0dXJuIG5ldyB0b29sdGlwIGl0ZW1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVG9vbHRpcEl0ZW0oY2hhcnQsIGl0ZW0pIHtcbiAgY29uc3Qge2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9ID0gaXRlbTtcbiAgY29uc3QgY29udHJvbGxlciA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcbiAgY29uc3Qge2xhYmVsLCB2YWx1ZX0gPSBjb250cm9sbGVyLmdldExhYmVsQW5kVmFsdWUoaW5kZXgpO1xuXG4gIHJldHVybiB7XG4gICAgY2hhcnQsXG4gICAgbGFiZWwsXG4gICAgcGFyc2VkOiBjb250cm9sbGVyLmdldFBhcnNlZChpbmRleCksXG4gICAgcmF3OiBjaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF0sXG4gICAgZm9ybWF0dGVkVmFsdWU6IHZhbHVlLFxuICAgIGRhdGFzZXQ6IGNvbnRyb2xsZXIuZ2V0RGF0YXNldCgpLFxuICAgIGRhdGFJbmRleDogaW5kZXgsXG4gICAgZGF0YXNldEluZGV4LFxuICAgIGVsZW1lbnRcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNpemUgb2YgdGhlIHRvb2x0aXBcbiAqL1xuZnVuY3Rpb24gZ2V0VG9vbHRpcFNpemUodG9vbHRpcCwgb3B0aW9ucykge1xuICBjb25zdCBjdHggPSB0b29sdGlwLmNoYXJ0LmN0eDtcbiAgY29uc3Qge2JvZHksIGZvb3RlciwgdGl0bGV9ID0gdG9vbHRpcDtcbiAgY29uc3Qge2JveFdpZHRoLCBib3hIZWlnaHR9ID0gb3B0aW9ucztcbiAgY29uc3QgYm9keUZvbnQgPSB0b0ZvbnQob3B0aW9ucy5ib2R5Rm9udCk7XG4gIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udChvcHRpb25zLnRpdGxlRm9udCk7XG4gIGNvbnN0IGZvb3RlckZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb290ZXJGb250KTtcbiAgY29uc3QgdGl0bGVMaW5lQ291bnQgPSB0aXRsZS5sZW5ndGg7XG4gIGNvbnN0IGZvb3RlckxpbmVDb3VudCA9IGZvb3Rlci5sZW5ndGg7XG4gIGNvbnN0IGJvZHlMaW5lSXRlbUNvdW50ID0gYm9keS5sZW5ndGg7XG5cbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICBsZXQgaGVpZ2h0ID0gcGFkZGluZy5oZWlnaHQ7XG4gIGxldCB3aWR0aCA9IDA7XG5cbiAgLy8gQ291bnQgb2YgYWxsIGxpbmVzIGluIHRoZSBib2R5XG4gIGxldCBjb21iaW5lZEJvZHlMZW5ndGggPSBib2R5LnJlZHVjZSgoY291bnQsIGJvZHlJdGVtKSA9PiBjb3VudCArIGJvZHlJdGVtLmJlZm9yZS5sZW5ndGggKyBib2R5SXRlbS5saW5lcy5sZW5ndGggKyBib2R5SXRlbS5hZnRlci5sZW5ndGgsIDApO1xuICBjb21iaW5lZEJvZHlMZW5ndGggKz0gdG9vbHRpcC5iZWZvcmVCb2R5Lmxlbmd0aCArIHRvb2x0aXAuYWZ0ZXJCb2R5Lmxlbmd0aDtcblxuICBpZiAodGl0bGVMaW5lQ291bnQpIHtcbiAgICBoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgKiB0aXRsZUZvbnQubGluZUhlaWdodFxuXHRcdFx0KyAodGl0bGVMaW5lQ291bnQgLSAxKSAqIG9wdGlvbnMudGl0bGVTcGFjaW5nXG5cdFx0XHQrIG9wdGlvbnMudGl0bGVNYXJnaW5Cb3R0b207XG4gIH1cbiAgaWYgKGNvbWJpbmVkQm9keUxlbmd0aCkge1xuICAgIC8vIEJvZHkgbGluZXMgbWF5IGluY2x1ZGUgc29tZSBleHRyYSBoZWlnaHQgZGVwZW5kaW5nIG9uIGJveEhlaWdodFxuICAgIGNvbnN0IGJvZHlMaW5lSGVpZ2h0ID0gb3B0aW9ucy5kaXNwbGF5Q29sb3JzID8gTWF0aC5tYXgoYm94SGVpZ2h0LCBib2R5Rm9udC5saW5lSGVpZ2h0KSA6IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgaGVpZ2h0ICs9IGJvZHlMaW5lSXRlbUNvdW50ICogYm9keUxpbmVIZWlnaHRcblx0XHRcdCsgKGNvbWJpbmVkQm9keUxlbmd0aCAtIGJvZHlMaW5lSXRlbUNvdW50KSAqIGJvZHlGb250LmxpbmVIZWlnaHRcblx0XHRcdCsgKGNvbWJpbmVkQm9keUxlbmd0aCAtIDEpICogb3B0aW9ucy5ib2R5U3BhY2luZztcbiAgfVxuICBpZiAoZm9vdGVyTGluZUNvdW50KSB7XG4gICAgaGVpZ2h0ICs9IG9wdGlvbnMuZm9vdGVyTWFyZ2luVG9wXG5cdFx0XHQrIGZvb3RlckxpbmVDb3VudCAqIGZvb3RlckZvbnQubGluZUhlaWdodFxuXHRcdFx0KyAoZm9vdGVyTGluZUNvdW50IC0gMSkgKiBvcHRpb25zLmZvb3RlclNwYWNpbmc7XG4gIH1cblxuICAvLyBUaXRsZSB3aWR0aFxuICBsZXQgd2lkdGhQYWRkaW5nID0gMDtcbiAgY29uc3QgbWF4TGluZVdpZHRoID0gZnVuY3Rpb24obGluZSkge1xuICAgIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIGN0eC5tZWFzdXJlVGV4dChsaW5lKS53aWR0aCArIHdpZHRoUGFkZGluZyk7XG4gIH07XG5cbiAgY3R4LnNhdmUoKTtcblxuICBjdHguZm9udCA9IHRpdGxlRm9udC5zdHJpbmc7XG4gIGVhY2godG9vbHRpcC50aXRsZSwgbWF4TGluZVdpZHRoKTtcblxuICAvLyBCb2R5IHdpZHRoXG4gIGN0eC5mb250ID0gYm9keUZvbnQuc3RyaW5nO1xuICBlYWNoKHRvb2x0aXAuYmVmb3JlQm9keS5jb25jYXQodG9vbHRpcC5hZnRlckJvZHkpLCBtYXhMaW5lV2lkdGgpO1xuXG4gIC8vIEJvZHkgbGluZXMgbWF5IGluY2x1ZGUgc29tZSBleHRyYSB3aWR0aCBkdWUgdG8gdGhlIGNvbG9yIGJveFxuICB3aWR0aFBhZGRpbmcgPSBvcHRpb25zLmRpc3BsYXlDb2xvcnMgPyAoYm94V2lkdGggKyAyICsgb3B0aW9ucy5ib3hQYWRkaW5nKSA6IDA7XG4gIGVhY2goYm9keSwgKGJvZHlJdGVtKSA9PiB7XG4gICAgZWFjaChib2R5SXRlbS5iZWZvcmUsIG1heExpbmVXaWR0aCk7XG4gICAgZWFjaChib2R5SXRlbS5saW5lcywgbWF4TGluZVdpZHRoKTtcbiAgICBlYWNoKGJvZHlJdGVtLmFmdGVyLCBtYXhMaW5lV2lkdGgpO1xuICB9KTtcblxuICAvLyBSZXNldCBiYWNrIHRvIDBcbiAgd2lkdGhQYWRkaW5nID0gMDtcblxuICAvLyBGb290ZXIgd2lkdGhcbiAgY3R4LmZvbnQgPSBmb290ZXJGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLmZvb3RlciwgbWF4TGluZVdpZHRoKTtcblxuICBjdHgucmVzdG9yZSgpO1xuXG4gIC8vIEFkZCBwYWRkaW5nXG4gIHdpZHRoICs9IHBhZGRpbmcud2lkdGg7XG5cbiAgcmV0dXJuIHt3aWR0aCwgaGVpZ2h0fTtcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lWUFsaWduKGNoYXJ0LCBzaXplKSB7XG4gIGNvbnN0IHt5LCBoZWlnaHR9ID0gc2l6ZTtcblxuICBpZiAoeSA8IGhlaWdodCAvIDIpIHtcbiAgICByZXR1cm4gJ3RvcCc7XG4gIH0gZWxzZSBpZiAoeSA+IChjaGFydC5oZWlnaHQgLSBoZWlnaHQgLyAyKSkge1xuICAgIHJldHVybiAnYm90dG9tJztcbiAgfVxuICByZXR1cm4gJ2NlbnRlcic7XG59XG5cbmZ1bmN0aW9uIGRvZXNOb3RGaXRXaXRoQWxpZ24oeEFsaWduLCBjaGFydCwgb3B0aW9ucywgc2l6ZSkge1xuICBjb25zdCB7eCwgd2lkdGh9ID0gc2l6ZTtcbiAgY29uc3QgY2FyZXQgPSBvcHRpb25zLmNhcmV0U2l6ZSArIG9wdGlvbnMuY2FyZXRQYWRkaW5nO1xuICBpZiAoeEFsaWduID09PSAnbGVmdCcgJiYgeCArIHdpZHRoICsgY2FyZXQgPiBjaGFydC53aWR0aCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0JyAmJiB4IC0gd2lkdGggLSBjYXJldCA8IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVYQWxpZ24oY2hhcnQsIG9wdGlvbnMsIHNpemUsIHlBbGlnbikge1xuICBjb25zdCB7eCwgd2lkdGh9ID0gc2l6ZTtcbiAgY29uc3Qge3dpZHRoOiBjaGFydFdpZHRoLCBjaGFydEFyZWE6IHtsZWZ0LCByaWdodH19ID0gY2hhcnQ7XG4gIGxldCB4QWxpZ24gPSAnY2VudGVyJztcblxuICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgIHhBbGlnbiA9IHggPD0gKGxlZnQgKyByaWdodCkgLyAyID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgfSBlbHNlIGlmICh4IDw9IHdpZHRoIC8gMikge1xuICAgIHhBbGlnbiA9ICdsZWZ0JztcbiAgfSBlbHNlIGlmICh4ID49IGNoYXJ0V2lkdGggLSB3aWR0aCAvIDIpIHtcbiAgICB4QWxpZ24gPSAncmlnaHQnO1xuICB9XG5cbiAgaWYgKGRvZXNOb3RGaXRXaXRoQWxpZ24oeEFsaWduLCBjaGFydCwgb3B0aW9ucywgc2l6ZSkpIHtcbiAgICB4QWxpZ24gPSAnY2VudGVyJztcbiAgfVxuXG4gIHJldHVybiB4QWxpZ247XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGdldCB0aGUgYWxpZ25tZW50IG9mIGEgdG9vbHRpcCBnaXZlbiB0aGUgc2l6ZVxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVBbGlnbm1lbnQoY2hhcnQsIG9wdGlvbnMsIHNpemUpIHtcbiAgY29uc3QgeUFsaWduID0gc2l6ZS55QWxpZ24gfHwgb3B0aW9ucy55QWxpZ24gfHwgZGV0ZXJtaW5lWUFsaWduKGNoYXJ0LCBzaXplKTtcblxuICByZXR1cm4ge1xuICAgIHhBbGlnbjogc2l6ZS54QWxpZ24gfHwgb3B0aW9ucy54QWxpZ24gfHwgZGV0ZXJtaW5lWEFsaWduKGNoYXJ0LCBvcHRpb25zLCBzaXplLCB5QWxpZ24pLFxuICAgIHlBbGlnblxuICB9O1xufVxuXG5mdW5jdGlvbiBhbGlnblgoc2l6ZSwgeEFsaWduKSB7XG4gIGxldCB7eCwgd2lkdGh9ID0gc2l6ZTtcbiAgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggLT0gd2lkdGg7XG4gIH0gZWxzZSBpZiAoeEFsaWduID09PSAnY2VudGVyJykge1xuICAgIHggLT0gKHdpZHRoIC8gMik7XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5cbmZ1bmN0aW9uIGFsaWduWShzaXplLCB5QWxpZ24sIHBhZGRpbmdBbmRTaXplKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgbGV0IHt5LCBoZWlnaHR9ID0gc2l6ZTtcbiAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICB5ICs9IHBhZGRpbmdBbmRTaXplO1xuICB9IGVsc2UgaWYgKHlBbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICB5IC09IGhlaWdodCArIHBhZGRpbmdBbmRTaXplO1xuICB9IGVsc2Uge1xuICAgIHkgLT0gKGhlaWdodCAvIDIpO1xuICB9XG4gIHJldHVybiB5O1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBnZXQgdGhlIGxvY2F0aW9uIGEgdG9vbHRpcCBuZWVkcyB0byBiZSBwbGFjZWQgYXQgZ2l2ZW4gdGhlIGluaXRpYWwgcG9zaXRpb24gKHZpYSB0aGUgdm0pIGFuZCB0aGUgc2l6ZSBhbmQgYWxpZ25tZW50XG4gKi9cbmZ1bmN0aW9uIGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBzaXplLCBhbGlnbm1lbnQsIGNoYXJ0KSB7XG4gIGNvbnN0IHtjYXJldFNpemUsIGNhcmV0UGFkZGluZywgY29ybmVyUmFkaXVzfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHt4QWxpZ24sIHlBbGlnbn0gPSBhbGlnbm1lbnQ7XG4gIGNvbnN0IHBhZGRpbmdBbmRTaXplID0gY2FyZXRTaXplICsgY2FyZXRQYWRkaW5nO1xuICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMoY29ybmVyUmFkaXVzKTtcblxuICBsZXQgeCA9IGFsaWduWChzaXplLCB4QWxpZ24pO1xuICBjb25zdCB5ID0gYWxpZ25ZKHNpemUsIHlBbGlnbiwgcGFkZGluZ0FuZFNpemUpO1xuXG4gIGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICB4ICs9IHBhZGRpbmdBbmRTaXplO1xuICAgIH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICB4IC09IHBhZGRpbmdBbmRTaXplO1xuICAgIH1cbiAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgIHggLT0gTWF0aC5tYXgodG9wTGVmdCwgYm90dG9tTGVmdCkgKyBjYXJldFNpemU7XG4gIH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCArPSBNYXRoLm1heCh0b3BSaWdodCwgYm90dG9tUmlnaHQpICsgY2FyZXRTaXplO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBfbGltaXRWYWx1ZSh4LCAwLCBjaGFydC53aWR0aCAtIHNpemUud2lkdGgpLFxuICAgIHk6IF9saW1pdFZhbHVlKHksIDAsIGNoYXJ0LmhlaWdodCAtIHNpemUuaGVpZ2h0KVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRBbGlnbmVkWCh0b29sdGlwLCBhbGlnbiwgb3B0aW9ucykge1xuICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG5cbiAgcmV0dXJuIGFsaWduID09PSAnY2VudGVyJ1xuICAgID8gdG9vbHRpcC54ICsgdG9vbHRpcC53aWR0aCAvIDJcbiAgICA6IGFsaWduID09PSAncmlnaHQnXG4gICAgICA/IHRvb2x0aXAueCArIHRvb2x0aXAud2lkdGggLSBwYWRkaW5nLnJpZ2h0XG4gICAgICA6IHRvb2x0aXAueCArIHBhZGRpbmcubGVmdDtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gYnVpbGQgYmVmb3JlIGFuZCBhZnRlciBib2R5IGxpbmVzXG4gKi9cbmZ1bmN0aW9uIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKGNhbGxiYWNrKSB7XG4gIHJldHVybiBwdXNoT3JDb25jYXQoW10sIHNwbGl0TmV3bGluZXMoY2FsbGJhY2spKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVG9vbHRpcENvbnRleHQocGFyZW50LCB0b29sdGlwLCB0b29sdGlwSXRlbXMpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgdG9vbHRpcCxcbiAgICB0b29sdGlwSXRlbXMsXG4gICAgdHlwZTogJ3Rvb2x0aXAnXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvdmVycmlkZUNhbGxiYWNrcyhjYWxsYmFja3MsIGNvbnRleHQpIHtcbiAgY29uc3Qgb3ZlcnJpZGUgPSBjb250ZXh0ICYmIGNvbnRleHQuZGF0YXNldCAmJiBjb250ZXh0LmRhdGFzZXQudG9vbHRpcCAmJiBjb250ZXh0LmRhdGFzZXQudG9vbHRpcC5jYWxsYmFja3M7XG4gIHJldHVybiBvdmVycmlkZSA/IGNhbGxiYWNrcy5vdmVycmlkZShvdmVycmlkZSkgOiBjYWxsYmFja3M7XG59XG5cbmNvbnN0IGRlZmF1bHRDYWxsYmFja3MgPSB7XG4gIC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxuICBiZWZvcmVUaXRsZTogbm9vcCxcbiAgdGl0bGUodG9vbHRpcEl0ZW1zKSB7XG4gICAgaWYgKHRvb2x0aXBJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBpdGVtID0gdG9vbHRpcEl0ZW1zWzBdO1xuICAgICAgY29uc3QgbGFiZWxzID0gaXRlbS5jaGFydC5kYXRhLmxhYmVscztcbiAgICAgIGNvbnN0IGxhYmVsQ291bnQgPSBsYWJlbHMgPyBsYWJlbHMubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHRoaXMgJiYgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5tb2RlID09PSAnZGF0YXNldCcpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0uZGF0YXNldC5sYWJlbCB8fCAnJztcbiAgICAgIH0gZWxzZSBpZiAoaXRlbS5sYWJlbCkge1xuICAgICAgICByZXR1cm4gaXRlbS5sYWJlbDtcbiAgICAgIH0gZWxzZSBpZiAobGFiZWxDb3VudCA+IDAgJiYgaXRlbS5kYXRhSW5kZXggPCBsYWJlbENvdW50KSB7XG4gICAgICAgIHJldHVybiBsYWJlbHNbaXRlbS5kYXRhSW5kZXhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfSxcbiAgYWZ0ZXJUaXRsZTogbm9vcCxcblxuICAvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcbiAgYmVmb3JlQm9keTogbm9vcCxcblxuICAvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtLCBkYXRhKVxuICBiZWZvcmVMYWJlbDogbm9vcCxcbiAgbGFiZWwodG9vbHRpcEl0ZW0pIHtcbiAgICBpZiAodGhpcyAmJiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm1vZGUgPT09ICdkYXRhc2V0Jykge1xuICAgICAgcmV0dXJuIHRvb2x0aXBJdGVtLmxhYmVsICsgJzogJyArIHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlIHx8IHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlO1xuICAgIH1cblxuICAgIGxldCBsYWJlbCA9IHRvb2x0aXBJdGVtLmRhdGFzZXQubGFiZWwgfHwgJyc7XG5cbiAgICBpZiAobGFiZWwpIHtcbiAgICAgIGxhYmVsICs9ICc6ICc7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWU7XG4gICAgaWYgKCFpc051bGxPclVuZGVmKHZhbHVlKSkge1xuICAgICAgbGFiZWwgKz0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBsYWJlbDtcbiAgfSxcbiAgbGFiZWxDb2xvcih0b29sdGlwSXRlbSkge1xuICAgIGNvbnN0IG1ldGEgPSB0b29sdGlwSXRlbS5jaGFydC5nZXREYXRhc2V0TWV0YSh0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXgpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUodG9vbHRpcEl0ZW0uZGF0YUluZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgYm9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgYm9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG4gICAgICBib3JkZXJEYXNoOiBvcHRpb25zLmJvcmRlckRhc2gsXG4gICAgICBib3JkZXJEYXNoT2Zmc2V0OiBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgfTtcbiAgfSxcbiAgbGFiZWxUZXh0Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5ib2R5Q29sb3I7XG4gIH0sXG4gIGxhYmVsUG9pbnRTdHlsZSh0b29sdGlwSXRlbSkge1xuICAgIGNvbnN0IG1ldGEgPSB0b29sdGlwSXRlbS5jaGFydC5nZXREYXRhc2V0TWV0YSh0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXgpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUodG9vbHRpcEl0ZW0uZGF0YUluZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9pbnRTdHlsZTogb3B0aW9ucy5wb2ludFN0eWxlLFxuICAgICAgcm90YXRpb246IG9wdGlvbnMucm90YXRpb24sXG4gICAgfTtcbiAgfSxcbiAgYWZ0ZXJMYWJlbDogbm9vcCxcblxuICAvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcbiAgYWZ0ZXJCb2R5OiBub29wLFxuXG4gIC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxuICBiZWZvcmVGb290ZXI6IG5vb3AsXG4gIGZvb3Rlcjogbm9vcCxcbiAgYWZ0ZXJGb290ZXI6IG5vb3Bcbn07XG5cbi8qKlxuICogSW52b2tlIGNhbGxiYWNrIGZyb20gb2JqZWN0IHdpdGggY29udGV4dCBhbmQgYXJndW1lbnRzLlxuICogSWYgY2FsbGJhY2sgcmV0dXJucyBgdW5kZWZpbmVkYCwgdGhlbiB3aWxsIGJlIGludm9rZWQgZGVmYXVsdCBjYWxsYmFjay5cbiAqIEBwYXJhbSB7UmVjb3JkPGtleW9mIHR5cGVvZiBkZWZhdWx0Q2FsbGJhY2tzLCBGdW5jdGlvbj59IGNhbGxiYWNrc1xuICogQHBhcmFtIHtrZXlvZiB0eXBlb2YgZGVmYXVsdENhbGxiYWNrc30gbmFtZVxuICogQHBhcmFtIHsqfSBjdHhcbiAqIEBwYXJhbSB7Kn0gYXJnXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsIG5hbWUsIGN0eCwgYXJnKSB7XG4gIGNvbnN0IHJlc3VsdCA9IGNhbGxiYWNrc1tuYW1lXS5jYWxsKGN0eCwgYXJnKTtcblxuICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZGVmYXVsdENhbGxiYWNrc1tuYW1lXS5jYWxsKGN0eCwgYXJnKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBjbGFzcyBUb29sdGlwIGV4dGVuZHMgRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBuYW1lc3BhY2UgQ2hhcnQuVG9vbHRpcC5wb3NpdGlvbmVyc1xuICAgKi9cbiAgc3RhdGljIHBvc2l0aW9uZXJzID0gcG9zaXRpb25lcnM7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMub3BhY2l0eSA9IDA7XG4gICAgdGhpcy5fYWN0aXZlID0gW107XG4gICAgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zaXplID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdG9vbHRpcEl0ZW1zID0gW107XG4gICAgdGhpcy4kYW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5kYXRhUG9pbnRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudGl0bGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iZWZvcmVCb2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm9keSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmFmdGVyQm9keSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZvb3RlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnhBbGlnbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnlBbGlnbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jYXJldFggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jYXJldFkgPSB1bmRlZmluZWQ7XG4gICAgLy8gVE9ETzogVjQsIG1ha2UgdGhpcyBwcml2YXRlLCByZW5hbWUgdG8gYF9sYWJlbFN0eWxlc2AsIGFuZCBjb21iaW5lIHdpdGggYGxhYmVsUG9pbnRTdHlsZXNgXG4gICAgLy8gYW5kIGBsYWJlbFRleHRDb2xvcnNgIHRvIGNyZWF0ZSBhIHNpbmdsZSB2YXJpYWJsZVxuICAgIHRoaXMubGFiZWxDb2xvcnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbFBvaW50U3R5bGVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWxUZXh0Q29sb3JzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaW5pdGlhbGl6ZShvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZXNvbHZlQW5pbWF0aW9ucygpIHtcbiAgICBjb25zdCBjYWNoZWQgPSB0aGlzLl9jYWNoZWRBbmltYXRpb25zO1xuXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG5cbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBvcHRzID0gb3B0aW9ucy5lbmFibGVkICYmIGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uICYmIG9wdGlvbnMuYW5pbWF0aW9ucztcbiAgICBjb25zdCBhbmltYXRpb25zID0gbmV3IEFuaW1hdGlvbnModGhpcy5jaGFydCwgb3B0cyk7XG4gICAgaWYgKG9wdHMuX2NhY2hlYWJsZSkge1xuICAgICAgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IE9iamVjdC5mcmVlemUoYW5pbWF0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4kY29udGV4dCB8fFxuXHRcdFx0KHRoaXMuJGNvbnRleHQgPSBjcmVhdGVUb29sdGlwQ29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcywgdGhpcy5fdG9vbHRpcEl0ZW1zKSk7XG4gIH1cblxuICBnZXRUaXRsZShjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2NhbGxiYWNrc30gPSBvcHRpb25zO1xuXG4gICAgY29uc3QgYmVmb3JlVGl0bGUgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICdiZWZvcmVUaXRsZScsIHRoaXMsIGNvbnRleHQpO1xuICAgIGNvbnN0IHRpdGxlID0gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCAndGl0bGUnLCB0aGlzLCBjb250ZXh0KTtcbiAgICBjb25zdCBhZnRlclRpdGxlID0gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCAnYWZ0ZXJUaXRsZScsIHRoaXMsIGNvbnRleHQpO1xuXG4gICAgbGV0IGxpbmVzID0gW107XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYmVmb3JlVGl0bGUpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyh0aXRsZSkpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGFmdGVyVGl0bGUpKTtcblxuICAgIHJldHVybiBsaW5lcztcbiAgfVxuXG4gIGdldEJlZm9yZUJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKFxuICAgICAgaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2sob3B0aW9ucy5jYWxsYmFja3MsICdiZWZvcmVCb2R5JywgdGhpcywgdG9vbHRpcEl0ZW1zKVxuICAgICk7XG4gIH1cblxuICBnZXRCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHtjYWxsYmFja3N9ID0gb3B0aW9ucztcbiAgICBjb25zdCBib2R5SXRlbXMgPSBbXTtcblxuICAgIGVhY2godG9vbHRpcEl0ZW1zLCAoY29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgYm9keUl0ZW0gPSB7XG4gICAgICAgIGJlZm9yZTogW10sXG4gICAgICAgIGxpbmVzOiBbXSxcbiAgICAgICAgYWZ0ZXI6IFtdXG4gICAgICB9O1xuICAgICAgY29uc3Qgc2NvcGVkID0gb3ZlcnJpZGVDYWxsYmFja3MoY2FsbGJhY2tzLCBjb250ZXh0KTtcbiAgICAgIHB1c2hPckNvbmNhdChib2R5SXRlbS5iZWZvcmUsIHNwbGl0TmV3bGluZXMoaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnYmVmb3JlTGFiZWwnLCB0aGlzLCBjb250ZXh0KSkpO1xuICAgICAgcHVzaE9yQ29uY2F0KGJvZHlJdGVtLmxpbmVzLCBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhzY29wZWQsICdsYWJlbCcsIHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIHB1c2hPckNvbmNhdChib2R5SXRlbS5hZnRlciwgc3BsaXROZXdsaW5lcyhpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhzY29wZWQsICdhZnRlckxhYmVsJywgdGhpcywgY29udGV4dCkpKTtcblxuICAgICAgYm9keUl0ZW1zLnB1c2goYm9keUl0ZW0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGJvZHlJdGVtcztcbiAgfVxuXG4gIGdldEFmdGVyQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMoXG4gICAgICBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhvcHRpb25zLmNhbGxiYWNrcywgJ2FmdGVyQm9keScsIHRoaXMsIHRvb2x0aXBJdGVtcylcbiAgICApO1xuICB9XG5cbiAgLy8gR2V0IHRoZSBmb290ZXIgYW5kIGJlZm9yZUZvb3RlciBhbmQgYWZ0ZXJGb290ZXIgbGluZXNcbiAgZ2V0Rm9vdGVyKHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHtjYWxsYmFja3N9ID0gb3B0aW9ucztcblxuICAgIGNvbnN0IGJlZm9yZUZvb3RlciA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ2JlZm9yZUZvb3RlcicsIHRoaXMsIHRvb2x0aXBJdGVtcyk7XG4gICAgY29uc3QgZm9vdGVyID0gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCAnZm9vdGVyJywgdGhpcywgdG9vbHRpcEl0ZW1zKTtcbiAgICBjb25zdCBhZnRlckZvb3RlciA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ2FmdGVyRm9vdGVyJywgdGhpcywgdG9vbHRpcEl0ZW1zKTtcblxuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZUZvb3RlcikpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGZvb3RlcikpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGFmdGVyRm9vdGVyKSk7XG5cbiAgICByZXR1cm4gbGluZXM7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jcmVhdGVJdGVtcyhvcHRpb25zKSB7XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmNoYXJ0LmRhdGE7XG4gICAgY29uc3QgbGFiZWxDb2xvcnMgPSBbXTtcbiAgICBjb25zdCBsYWJlbFBvaW50U3R5bGVzID0gW107XG4gICAgY29uc3QgbGFiZWxUZXh0Q29sb3JzID0gW107XG4gICAgbGV0IHRvb2x0aXBJdGVtcyA9IFtdO1xuICAgIGxldCBpLCBsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBhY3RpdmUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRvb2x0aXBJdGVtcy5wdXNoKGNyZWF0ZVRvb2x0aXBJdGVtKHRoaXMuY2hhcnQsIGFjdGl2ZVtpXSkpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSB1c2VyIHByb3ZpZGVkIGEgZmlsdGVyIGZ1bmN0aW9uLCB1c2UgaXQgdG8gbW9kaWZ5IHRoZSB0b29sdGlwIGl0ZW1zXG4gICAgaWYgKG9wdGlvbnMuZmlsdGVyKSB7XG4gICAgICB0b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXMuZmlsdGVyKChlbGVtZW50LCBpbmRleCwgYXJyYXkpID0+IG9wdGlvbnMuZmlsdGVyKGVsZW1lbnQsIGluZGV4LCBhcnJheSwgZGF0YSkpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSB1c2VyIHByb3ZpZGVkIGEgc29ydGluZyBmdW5jdGlvbiwgdXNlIGl0IHRvIG1vZGlmeSB0aGUgdG9vbHRpcCBpdGVtc1xuICAgIGlmIChvcHRpb25zLml0ZW1Tb3J0KSB7XG4gICAgICB0b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXMuc29ydCgoYSwgYikgPT4gb3B0aW9ucy5pdGVtU29ydChhLCBiLCBkYXRhKSk7XG4gICAgfVxuXG4gICAgLy8gRGV0ZXJtaW5lIGNvbG9ycyBmb3IgYm94ZXNcbiAgICBlYWNoKHRvb2x0aXBJdGVtcywgKGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IHNjb3BlZCA9IG92ZXJyaWRlQ2FsbGJhY2tzKG9wdGlvbnMuY2FsbGJhY2tzLCBjb250ZXh0KTtcbiAgICAgIGxhYmVsQ29sb3JzLnB1c2goaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnbGFiZWxDb2xvcicsIHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIGxhYmVsUG9pbnRTdHlsZXMucHVzaChpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhzY29wZWQsICdsYWJlbFBvaW50U3R5bGUnLCB0aGlzLCBjb250ZXh0KSk7XG4gICAgICBsYWJlbFRleHRDb2xvcnMucHVzaChpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhzY29wZWQsICdsYWJlbFRleHRDb2xvcicsIHRoaXMsIGNvbnRleHQpKTtcbiAgICB9KTtcblxuICAgIHRoaXMubGFiZWxDb2xvcnMgPSBsYWJlbENvbG9ycztcbiAgICB0aGlzLmxhYmVsUG9pbnRTdHlsZXMgPSBsYWJlbFBvaW50U3R5bGVzO1xuICAgIHRoaXMubGFiZWxUZXh0Q29sb3JzID0gbGFiZWxUZXh0Q29sb3JzO1xuICAgIHRoaXMuZGF0YVBvaW50cyA9IHRvb2x0aXBJdGVtcztcbiAgICByZXR1cm4gdG9vbHRpcEl0ZW1zO1xuICB9XG5cbiAgdXBkYXRlKGNoYW5nZWQsIHJlcGxheSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuICAgIGxldCBwcm9wZXJ0aWVzO1xuICAgIGxldCB0b29sdGlwSXRlbXMgPSBbXTtcblxuICAgIGlmICghYWN0aXZlLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMub3BhY2l0eSAhPT0gMCkge1xuICAgICAgICBwcm9wZXJ0aWVzID0ge1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIGFjdGl2ZSwgdGhpcy5fZXZlbnRQb3NpdGlvbik7XG4gICAgICB0b29sdGlwSXRlbXMgPSB0aGlzLl9jcmVhdGVJdGVtcyhvcHRpb25zKTtcblxuICAgICAgdGhpcy50aXRsZSA9IHRoaXMuZ2V0VGl0bGUodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuYmVmb3JlQm9keSA9IHRoaXMuZ2V0QmVmb3JlQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5ib2R5ID0gdGhpcy5nZXRCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmFmdGVyQm9keSA9IHRoaXMuZ2V0QWZ0ZXJCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmZvb3RlciA9IHRoaXMuZ2V0Rm9vdGVyKHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG5cbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9zaXplID0gZ2V0VG9vbHRpcFNpemUodGhpcywgb3B0aW9ucyk7XG4gICAgICBjb25zdCBwb3NpdGlvbkFuZFNpemUgPSBPYmplY3QuYXNzaWduKHt9LCBwb3NpdGlvbiwgc2l6ZSk7XG4gICAgICBjb25zdCBhbGlnbm1lbnQgPSBkZXRlcm1pbmVBbGlnbm1lbnQodGhpcy5jaGFydCwgb3B0aW9ucywgcG9zaXRpb25BbmRTaXplKTtcbiAgICAgIGNvbnN0IGJhY2tncm91bmRQb2ludCA9IGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUsIGFsaWdubWVudCwgdGhpcy5jaGFydCk7XG5cbiAgICAgIHRoaXMueEFsaWduID0gYWxpZ25tZW50LnhBbGlnbjtcbiAgICAgIHRoaXMueUFsaWduID0gYWxpZ25tZW50LnlBbGlnbjtcblxuICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgeDogYmFja2dyb3VuZFBvaW50LngsXG4gICAgICAgIHk6IGJhY2tncm91bmRQb2ludC55LFxuICAgICAgICB3aWR0aDogc2l6ZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBzaXplLmhlaWdodCxcbiAgICAgICAgY2FyZXRYOiBwb3NpdGlvbi54LFxuICAgICAgICBjYXJldFk6IHBvc2l0aW9uLnlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5fdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoKS51cGRhdGUodGhpcywgcHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgaWYgKGNoYW5nZWQgJiYgb3B0aW9ucy5leHRlcm5hbCkge1xuICAgICAgb3B0aW9ucy5leHRlcm5hbC5jYWxsKHRoaXMsIHtjaGFydDogdGhpcy5jaGFydCwgdG9vbHRpcDogdGhpcywgcmVwbGF5fSk7XG4gICAgfVxuICB9XG5cbiAgZHJhd0NhcmV0KHRvb2x0aXBQb2ludCwgY3R4LCBzaXplLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY2FyZXRQb3NpdGlvbiA9IHRoaXMuZ2V0Q2FyZXRQb3NpdGlvbih0b29sdGlwUG9pbnQsIHNpemUsIG9wdGlvbnMpO1xuXG4gICAgY3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngxLCBjYXJldFBvc2l0aW9uLnkxKTtcbiAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDIsIGNhcmV0UG9zaXRpb24ueTIpO1xuICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MywgY2FyZXRQb3NpdGlvbi55Myk7XG4gIH1cblxuICBnZXRDYXJldFBvc2l0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHt4QWxpZ24sIHlBbGlnbn0gPSB0aGlzO1xuICAgIGNvbnN0IHtjYXJldFNpemUsIGNvcm5lclJhZGl1c30gPSBvcHRpb25zO1xuICAgIGNvbnN0IHt0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHR9ID0gdG9UUkJMQ29ybmVycyhjb3JuZXJSYWRpdXMpO1xuICAgIGNvbnN0IHt4OiBwdFgsIHk6IHB0WX0gPSB0b29sdGlwUG9pbnQ7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gc2l6ZTtcbiAgICBsZXQgeDEsIHgyLCB4MywgeTEsIHkyLCB5MztcblxuICAgIGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICB5MiA9IHB0WSArIChoZWlnaHQgLyAyKTtcblxuICAgICAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHgxID0gcHRYO1xuICAgICAgICB4MiA9IHgxIC0gY2FyZXRTaXplO1xuXG4gICAgICAgIC8vIExlZnQgZHJhd3MgYm90dG9tIC0+IHRvcCwgdGhpcyB5MSBpcyBvbiB0aGUgYm90dG9tXG4gICAgICAgIHkxID0geTIgKyBjYXJldFNpemU7XG4gICAgICAgIHkzID0geTIgLSBjYXJldFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MSA9IHB0WCArIHdpZHRoO1xuICAgICAgICB4MiA9IHgxICsgY2FyZXRTaXplO1xuXG4gICAgICAgIC8vIFJpZ2h0IGRyYXdzIHRvcCAtPiBib3R0b20sIHRodXMgeTEgaXMgb24gdGhlIHRvcFxuICAgICAgICB5MSA9IHkyIC0gY2FyZXRTaXplO1xuICAgICAgICB5MyA9IHkyICsgY2FyZXRTaXplO1xuICAgICAgfVxuXG4gICAgICB4MyA9IHgxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgeDIgPSBwdFggKyBNYXRoLm1heCh0b3BMZWZ0LCBib3R0b21MZWZ0KSArIChjYXJldFNpemUpO1xuICAgICAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgeDIgPSBwdFggKyB3aWR0aCAtIE1hdGgubWF4KHRvcFJpZ2h0LCBib3R0b21SaWdodCkgLSBjYXJldFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MiA9IHRoaXMuY2FyZXRYO1xuICAgICAgfVxuXG4gICAgICBpZiAoeUFsaWduID09PSAndG9wJykge1xuICAgICAgICB5MSA9IHB0WTtcbiAgICAgICAgeTIgPSB5MSAtIGNhcmV0U2l6ZTtcblxuICAgICAgICAvLyBUb3AgZHJhd3MgbGVmdCAtPiByaWdodCwgdGh1cyB4MSBpcyBvbiB0aGUgbGVmdFxuICAgICAgICB4MSA9IHgyIC0gY2FyZXRTaXplO1xuICAgICAgICB4MyA9IHgyICsgY2FyZXRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeTEgPSBwdFkgKyBoZWlnaHQ7XG4gICAgICAgIHkyID0geTEgKyBjYXJldFNpemU7XG5cbiAgICAgICAgLy8gQm90dG9tIGRyYXdzIHJpZ2h0IC0+IGxlZnQsIHRodXMgeDEgaXMgb24gdGhlIHJpZ2h0XG4gICAgICAgIHgxID0geDIgKyBjYXJldFNpemU7XG4gICAgICAgIHgzID0geDIgLSBjYXJldFNpemU7XG4gICAgICB9XG4gICAgICB5MyA9IHkxO1xuICAgIH1cbiAgICByZXR1cm4ge3gxLCB4MiwgeDMsIHkxLCB5MiwgeTN9O1xuICB9XG5cbiAgZHJhd1RpdGxlKHB0LCBjdHgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IHRoaXMudGl0bGU7XG4gICAgY29uc3QgbGVuZ3RoID0gdGl0bGUubGVuZ3RoO1xuICAgIGxldCB0aXRsZUZvbnQsIHRpdGxlU3BhY2luZywgaTtcblxuICAgIGlmIChsZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0aW9ucy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCk7XG5cbiAgICAgIHB0LnggPSBnZXRBbGlnbmVkWCh0aGlzLCBvcHRpb25zLnRpdGxlQWxpZ24sIG9wdGlvbnMpO1xuXG4gICAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihvcHRpb25zLnRpdGxlQWxpZ24pO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG4gICAgICB0aXRsZUZvbnQgPSB0b0ZvbnQob3B0aW9ucy50aXRsZUZvbnQpO1xuICAgICAgdGl0bGVTcGFjaW5nID0gb3B0aW9ucy50aXRsZVNwYWNpbmc7XG5cbiAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLnRpdGxlQ29sb3I7XG4gICAgICBjdHguZm9udCA9IHRpdGxlRm9udC5zdHJpbmc7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBjdHguZmlsbFRleHQodGl0bGVbaV0sIHJ0bEhlbHBlci54KHB0LngpLCBwdC55ICsgdGl0bGVGb250LmxpbmVIZWlnaHQgLyAyKTtcbiAgICAgICAgcHQueSArPSB0aXRsZUZvbnQubGluZUhlaWdodCArIHRpdGxlU3BhY2luZzsgLy8gTGluZSBIZWlnaHQgYW5kIHNwYWNpbmdcblxuICAgICAgICBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIHB0LnkgKz0gb3B0aW9ucy50aXRsZU1hcmdpbkJvdHRvbSAtIHRpdGxlU3BhY2luZzsgLy8gSWYgTGFzdCwgYWRkIG1hcmdpbiwgcmVtb3ZlIHNwYWNpbmdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2RyYXdDb2xvckJveChjdHgsIHB0LCBpLCBydGxIZWxwZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsYWJlbENvbG9yID0gdGhpcy5sYWJlbENvbG9yc1tpXTtcbiAgICBjb25zdCBsYWJlbFBvaW50U3R5bGUgPSB0aGlzLmxhYmVsUG9pbnRTdHlsZXNbaV07XG4gICAgY29uc3Qge2JveEhlaWdodCwgYm94V2lkdGh9ID0gb3B0aW9ucztcbiAgICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcbiAgICBjb25zdCBjb2xvclggPSBnZXRBbGlnbmVkWCh0aGlzLCAnbGVmdCcsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHJ0bENvbG9yWCA9IHJ0bEhlbHBlci54KGNvbG9yWCk7XG4gICAgY29uc3QgeU9mZlNldCA9IGJveEhlaWdodCA8IGJvZHlGb250LmxpbmVIZWlnaHQgPyAoYm9keUZvbnQubGluZUhlaWdodCAtIGJveEhlaWdodCkgLyAyIDogMDtcbiAgICBjb25zdCBjb2xvclkgPSBwdC55ICsgeU9mZlNldDtcblxuICAgIGlmIChvcHRpb25zLnVzZVBvaW50U3R5bGUpIHtcbiAgICAgIGNvbnN0IGRyYXdPcHRpb25zID0ge1xuICAgICAgICByYWRpdXM6IE1hdGgubWluKGJveFdpZHRoLCBib3hIZWlnaHQpIC8gMiwgLy8gZml0IHRoZSBjaXJjbGUgaW4gdGhlIGJveFxuICAgICAgICBwb2ludFN0eWxlOiBsYWJlbFBvaW50U3R5bGUucG9pbnRTdHlsZSxcbiAgICAgICAgcm90YXRpb246IGxhYmVsUG9pbnRTdHlsZS5yb3RhdGlvbixcbiAgICAgICAgYm9yZGVyV2lkdGg6IDFcbiAgICAgIH07XG4gICAgICAvLyBSZWNhbGN1bGF0ZSB4IGFuZCB5IGZvciBkcmF3UG9pbnQoKSBiZWNhdXNlIGl0cyBleHBlY3RpbmdcbiAgICAgIC8vIHggYW5kIHkgdG8gYmUgY2VudGVyIG9mIGZpZ3VyZSAoaW5zdGVhZCBvZiB0b3AgbGVmdClcbiAgICAgIGNvbnN0IGNlbnRlclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxDb2xvclgsIGJveFdpZHRoKSArIGJveFdpZHRoIC8gMjtcbiAgICAgIGNvbnN0IGNlbnRlclkgPSBjb2xvclkgKyBib3hIZWlnaHQgLyAyO1xuXG4gICAgICAvLyBGaWxsIHRoZSBwb2ludCB3aXRoIHdoaXRlIHNvIHRoYXQgY29sb3VycyBtZXJnZSBuaWNlbHkgaWYgdGhlIG9wYWNpdHkgaXMgPCAxXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgIGRyYXdQb2ludChjdHgsIGRyYXdPcHRpb25zLCBjZW50ZXJYLCBjZW50ZXJZKTtcblxuICAgICAgLy8gRHJhdyB0aGUgcG9pbnRcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxhYmVsQ29sb3IuYm9yZGVyQ29sb3I7XG4gICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvci5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBkcmF3UG9pbnQoY3R4LCBkcmF3T3B0aW9ucywgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJvcmRlclxuICAgICAgY3R4LmxpbmVXaWR0aCA9IGlzT2JqZWN0KGxhYmVsQ29sb3IuYm9yZGVyV2lkdGgpID8gTWF0aC5tYXgoLi4uT2JqZWN0LnZhbHVlcyhsYWJlbENvbG9yLmJvcmRlcldpZHRoKSkgOiAobGFiZWxDb2xvci5ib3JkZXJXaWR0aCB8fCAxKTsgLy8gVE9ETywgdjQgcmVtb3ZlIGZhbGxiYWNrXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsYWJlbENvbG9yLmJvcmRlckNvbG9yO1xuICAgICAgY3R4LnNldExpbmVEYXNoKGxhYmVsQ29sb3IuYm9yZGVyRGFzaCB8fCBbXSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBsYWJlbENvbG9yLmJvcmRlckRhc2hPZmZzZXQgfHwgMDtcblxuICAgICAgLy8gRmlsbCBhIHdoaXRlIHJlY3Qgc28gdGhhdCBjb2xvdXJzIG1lcmdlIG5pY2VseSBpZiB0aGUgb3BhY2l0eSBpcyA8IDFcbiAgICAgIGNvbnN0IG91dGVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bENvbG9yWCwgYm94V2lkdGgpO1xuICAgICAgY29uc3QgaW5uZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsSGVscGVyLnhQbHVzKHJ0bENvbG9yWCwgMSksIGJveFdpZHRoIC0gMik7XG4gICAgICBjb25zdCBib3JkZXJSYWRpdXMgPSB0b1RSQkxDb3JuZXJzKGxhYmVsQ29sb3IuYm9yZGVyUmFkaXVzKTtcblxuICAgICAgaWYgKE9iamVjdC52YWx1ZXMoYm9yZGVyUmFkaXVzKS5zb21lKHYgPT4gdiAhPT0gMCkpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgICB4OiBvdXRlclgsXG4gICAgICAgICAgeTogY29sb3JZLFxuICAgICAgICAgIHc6IGJveFdpZHRoLFxuICAgICAgICAgIGg6IGJveEhlaWdodCxcbiAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICAvLyBJbm5lciBzcXVhcmVcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3IuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgICB4OiBpbm5lclgsXG4gICAgICAgICAgeTogY29sb3JZICsgMSxcbiAgICAgICAgICB3OiBib3hXaWR0aCAtIDIsXG4gICAgICAgICAgaDogYm94SGVpZ2h0IC0gMixcbiAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3JtYWwgcmVjdFxuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICAgIGN0eC5maWxsUmVjdChvdXRlclgsIGNvbG9yWSwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIGN0eC5zdHJva2VSZWN0KG91dGVyWCwgY29sb3JZLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcbiAgICAgICAgLy8gSW5uZXIgc3F1YXJlXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9yLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KGlubmVyWCwgY29sb3JZICsgMSwgYm94V2lkdGggLSAyLCBib3hIZWlnaHQgLSAyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXN0b3JlIGZpbGxTdHlsZVxuICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmxhYmVsVGV4dENvbG9yc1tpXTtcbiAgfVxuXG4gIGRyYXdCb2R5KHB0LCBjdHgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Ym9keX0gPSB0aGlzO1xuICAgIGNvbnN0IHtib2R5U3BhY2luZywgYm9keUFsaWduLCBkaXNwbGF5Q29sb3JzLCBib3hIZWlnaHQsIGJveFdpZHRoLCBib3hQYWRkaW5nfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUZvbnQgPSB0b0ZvbnQob3B0aW9ucy5ib2R5Rm9udCk7XG4gICAgbGV0IGJvZHlMaW5lSGVpZ2h0ID0gYm9keUZvbnQubGluZUhlaWdodDtcbiAgICBsZXQgeExpbmVQYWRkaW5nID0gMDtcblxuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0aW9ucy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCk7XG5cbiAgICBjb25zdCBmaWxsTGluZU9mVGV4dCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIGN0eC5maWxsVGV4dChsaW5lLCBydGxIZWxwZXIueChwdC54ICsgeExpbmVQYWRkaW5nKSwgcHQueSArIGJvZHlMaW5lSGVpZ2h0IC8gMik7XG4gICAgICBwdC55ICs9IGJvZHlMaW5lSGVpZ2h0ICsgYm9keVNwYWNpbmc7XG4gICAgfTtcblxuICAgIGNvbnN0IGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uID0gcnRsSGVscGVyLnRleHRBbGlnbihib2R5QWxpZ24pO1xuICAgIGxldCBib2R5SXRlbSwgdGV4dENvbG9yLCBsaW5lcywgaSwgaiwgaWxlbiwgamxlbjtcblxuICAgIGN0eC50ZXh0QWxpZ24gPSBib2R5QWxpZ247XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGN0eC5mb250ID0gYm9keUZvbnQuc3RyaW5nO1xuXG4gICAgcHQueCA9IGdldEFsaWduZWRYKHRoaXMsIGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uLCBvcHRpb25zKTtcblxuICAgIC8vIEJlZm9yZSBib2R5IGxpbmVzXG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYm9keUNvbG9yO1xuICAgIGVhY2godGhpcy5iZWZvcmVCb2R5LCBmaWxsTGluZU9mVGV4dCk7XG5cbiAgICB4TGluZVBhZGRpbmcgPSBkaXNwbGF5Q29sb3JzICYmIGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uICE9PSAncmlnaHQnXG4gICAgICA/IGJvZHlBbGlnbiA9PT0gJ2NlbnRlcicgPyAoYm94V2lkdGggLyAyICsgYm94UGFkZGluZykgOiAoYm94V2lkdGggKyAyICsgYm94UGFkZGluZylcbiAgICAgIDogMDtcblxuICAgIC8vIERyYXcgYm9keSBsaW5lcyBub3dcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gYm9keS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGJvZHlJdGVtID0gYm9keVtpXTtcbiAgICAgIHRleHRDb2xvciA9IHRoaXMubGFiZWxUZXh0Q29sb3JzW2ldO1xuXG4gICAgICBjdHguZmlsbFN0eWxlID0gdGV4dENvbG9yO1xuICAgICAgZWFjaChib2R5SXRlbS5iZWZvcmUsIGZpbGxMaW5lT2ZUZXh0KTtcblxuICAgICAgbGluZXMgPSBib2R5SXRlbS5saW5lcztcbiAgICAgIC8vIERyYXcgTGVnZW5kLWxpa2UgYm94ZXMgaWYgbmVlZGVkXG4gICAgICBpZiAoZGlzcGxheUNvbG9ycyAmJiBsaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fZHJhd0NvbG9yQm94KGN0eCwgcHQsIGksIHJ0bEhlbHBlciwgb3B0aW9ucyk7XG4gICAgICAgIGJvZHlMaW5lSGVpZ2h0ID0gTWF0aC5tYXgoYm9keUZvbnQubGluZUhlaWdodCwgYm94SGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgZm9yIChqID0gMCwgamxlbiA9IGxpbmVzLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgICBmaWxsTGluZU9mVGV4dChsaW5lc1tqXSk7XG4gICAgICAgIC8vIFJlc2V0IGZvciBhbnkgbGluZXMgdGhhdCBkb24ndCBpbmNsdWRlIGNvbG9yYm94XG4gICAgICAgIGJvZHlMaW5lSGVpZ2h0ID0gYm9keUZvbnQubGluZUhlaWdodDtcbiAgICAgIH1cblxuICAgICAgZWFjaChib2R5SXRlbS5hZnRlciwgZmlsbExpbmVPZlRleHQpO1xuICAgIH1cblxuICAgIC8vIFJlc2V0IGJhY2sgdG8gMCBmb3IgYWZ0ZXIgYm9keVxuICAgIHhMaW5lUGFkZGluZyA9IDA7XG4gICAgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xuXG4gICAgLy8gQWZ0ZXIgYm9keSBsaW5lc1xuICAgIGVhY2godGhpcy5hZnRlckJvZHksIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICBwdC55IC09IGJvZHlTcGFjaW5nOyAvLyBSZW1vdmUgbGFzdCBib2R5IHNwYWNpbmdcbiAgfVxuXG4gIGRyYXdGb290ZXIocHQsIGN0eCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZvb3RlciA9IHRoaXMuZm9vdGVyO1xuICAgIGNvbnN0IGxlbmd0aCA9IGZvb3Rlci5sZW5ndGg7XG4gICAgbGV0IGZvb3RlckZvbnQsIGk7XG5cbiAgICBpZiAobGVuZ3RoKSB7XG4gICAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xuXG4gICAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgb3B0aW9ucy5mb290ZXJBbGlnbiwgb3B0aW9ucyk7XG4gICAgICBwdC55ICs9IG9wdGlvbnMuZm9vdGVyTWFyZ2luVG9wO1xuXG4gICAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihvcHRpb25zLmZvb3RlckFsaWduKTtcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuICAgICAgZm9vdGVyRm9udCA9IHRvRm9udChvcHRpb25zLmZvb3RlckZvbnQpO1xuXG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5mb290ZXJDb2xvcjtcbiAgICAgIGN0eC5mb250ID0gZm9vdGVyRm9udC5zdHJpbmc7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBjdHguZmlsbFRleHQoZm9vdGVyW2ldLCBydGxIZWxwZXIueChwdC54KSwgcHQueSArIGZvb3RlckZvbnQubGluZUhlaWdodCAvIDIpO1xuICAgICAgICBwdC55ICs9IGZvb3RlckZvbnQubGluZUhlaWdodCArIG9wdGlvbnMuZm9vdGVyU3BhY2luZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkcmF3QmFja2dyb3VuZChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHt4QWxpZ24sIHlBbGlnbn0gPSB0aGlzO1xuICAgIGNvbnN0IHt4LCB5fSA9IHB0O1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRvb2x0aXBTaXplO1xuICAgIGNvbnN0IHt0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHR9ID0gdG9UUkJMQ29ybmVycyhvcHRpb25zLmNvcm5lclJhZGl1cyk7XG5cbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcbiAgICBjdHgubGluZVdpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aDtcblxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHggKyB0b3BMZWZ0LCB5KTtcbiAgICBpZiAoeUFsaWduID09PSAndG9wJykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHRvcFJpZ2h0LCB5KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHRvcFJpZ2h0KTtcbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSBib3R0b21SaWdodCk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSBib3R0b21SaWdodCwgeSArIGhlaWdodCk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4ICsgYm90dG9tTGVmdCwgeSArIGhlaWdodCk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIGJvdHRvbUxlZnQpO1xuICAgIGlmICh5QWxpZ24gPT09ICdjZW50ZXInICYmIHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCwgeSArIHRvcExlZnQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyB0b3BMZWZ0LCB5KTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICBjdHguZmlsbCgpO1xuXG4gICAgaWYgKG9wdGlvbnMuYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFVwZGF0ZSB4L3kgYW5pbWF0aW9uIHRhcmdldHMgd2hlbiBfYWN0aXZlIGVsZW1lbnRzIGFyZSBhbmltYXRpbmcgdG9vXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlQW5pbWF0aW9uVGFyZ2V0KG9wdGlvbnMpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLiRhbmltYXRpb25zO1xuICAgIGNvbnN0IGFuaW1YID0gYW5pbXMgJiYgYW5pbXMueDtcbiAgICBjb25zdCBhbmltWSA9IGFuaW1zICYmIGFuaW1zLnk7XG4gICAgaWYgKGFuaW1YIHx8IGFuaW1ZKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uZXJzW29wdGlvbnMucG9zaXRpb25dLmNhbGwodGhpcywgdGhpcy5fYWN0aXZlLCB0aGlzLl9ldmVudFBvc2l0aW9uKTtcbiAgICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX3NpemUgPSBnZXRUb29sdGlwU2l6ZSh0aGlzLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQW5kU2l6ZSA9IE9iamVjdC5hc3NpZ24oe30sIHBvc2l0aW9uLCB0aGlzLl9zaXplKTtcbiAgICAgIGNvbnN0IGFsaWdubWVudCA9IGRldGVybWluZUFsaWdubWVudChjaGFydCwgb3B0aW9ucywgcG9zaXRpb25BbmRTaXplKTtcbiAgICAgIGNvbnN0IHBvaW50ID0gZ2V0QmFja2dyb3VuZFBvaW50KG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSwgYWxpZ25tZW50LCBjaGFydCk7XG4gICAgICBpZiAoYW5pbVguX3RvICE9PSBwb2ludC54IHx8IGFuaW1ZLl90byAhPT0gcG9pbnQueSkge1xuICAgICAgICB0aGlzLnhBbGlnbiA9IGFsaWdubWVudC54QWxpZ247XG4gICAgICAgIHRoaXMueUFsaWduID0gYWxpZ25tZW50LnlBbGlnbjtcbiAgICAgICAgdGhpcy53aWR0aCA9IHNpemUud2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMuY2FyZXRYID0gcG9zaXRpb24ueDtcbiAgICAgICAgdGhpcy5jYXJldFkgPSBwb3NpdGlvbi55O1xuICAgICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucygpLnVwZGF0ZSh0aGlzLCBwb2ludCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiB0aGUgdG9vbHRpcCB3aWxsIGRyYXcgYW55dGhpbmdcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHRvb2x0aXAgd2lsbCByZW5kZXJcbiAgICovXG4gIF93aWxsUmVuZGVyKCkge1xuICAgIHJldHVybiAhIXRoaXMub3BhY2l0eTtcbiAgfVxuXG4gIGRyYXcoY3R4KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBsZXQgb3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcblxuICAgIGlmICghb3BhY2l0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUFuaW1hdGlvblRhcmdldChvcHRpb25zKTtcblxuICAgIGNvbnN0IHRvb2x0aXBTaXplID0ge1xuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgfTtcbiAgICBjb25zdCBwdCA9IHtcbiAgICAgIHg6IHRoaXMueCxcbiAgICAgIHk6IHRoaXMueVxuICAgIH07XG5cbiAgICAvLyBJRTExL0VkZ2UgZG9lcyBub3QgbGlrZSB2ZXJ5IHNtYWxsIG9wYWNpdGllcywgc28gc25hcCB0byAwXG4gICAgb3BhY2l0eSA9IE1hdGguYWJzKG9wYWNpdHkpIDwgMWUtMyA/IDAgOiBvcGFjaXR5O1xuXG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuXG4gICAgLy8gVHJ1dGh5L2ZhbHNleSB2YWx1ZSBmb3IgZW1wdHkgdG9vbHRpcFxuICAgIGNvbnN0IGhhc1Rvb2x0aXBDb250ZW50ID0gdGhpcy50aXRsZS5sZW5ndGggfHwgdGhpcy5iZWZvcmVCb2R5Lmxlbmd0aCB8fCB0aGlzLmJvZHkubGVuZ3RoIHx8IHRoaXMuYWZ0ZXJCb2R5Lmxlbmd0aCB8fCB0aGlzLmZvb3Rlci5sZW5ndGg7XG5cbiAgICBpZiAob3B0aW9ucy5lbmFibGVkICYmIGhhc1Rvb2x0aXBDb250ZW50KSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcblxuICAgICAgLy8gRHJhdyBCYWNrZ3JvdW5kXG4gICAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcblxuICAgICAgb3ZlcnJpZGVUZXh0RGlyZWN0aW9uKGN0eCwgb3B0aW9ucy50ZXh0RGlyZWN0aW9uKTtcblxuICAgICAgcHQueSArPSBwYWRkaW5nLnRvcDtcblxuICAgICAgLy8gVGl0bGVzXG4gICAgICB0aGlzLmRyYXdUaXRsZShwdCwgY3R4LCBvcHRpb25zKTtcblxuICAgICAgLy8gQm9keVxuICAgICAgdGhpcy5kcmF3Qm9keShwdCwgY3R4LCBvcHRpb25zKTtcblxuICAgICAgLy8gRm9vdGVyXG4gICAgICB0aGlzLmRyYXdGb290ZXIocHQsIGN0eCwgb3B0aW9ucyk7XG5cbiAgICAgIHJlc3RvcmVUZXh0RGlyZWN0aW9uKGN0eCwgb3B0aW9ucy50ZXh0RGlyZWN0aW9uKTtcblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogR2V0IGFjdGl2ZSBlbGVtZW50cyBpbiB0aGUgdG9vbHRpcFxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIGFjdGl2ZSBpbiB0aGUgdG9vbHRpcFxuXHQgKi9cbiAgZ2V0QWN0aXZlRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBTZXQgYWN0aXZlIGVsZW1lbnRzIGluIHRoZSB0b29sdGlwXG5cdCAqIEBwYXJhbSB7YXJyYXl9IGFjdGl2ZUVsZW1lbnRzIEFycmF5IG9mIGFjdGl2ZSBkYXRhc2V0SW5kZXgvaW5kZXggcGFpcnMuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFBvc2l0aW9uIFN5bnRoZXRpYyBldmVudCBwb3NpdGlvbiB1c2VkIGluIHBvc2l0aW9uaW5nXG5cdCAqL1xuICBzZXRBY3RpdmVFbGVtZW50cyhhY3RpdmVFbGVtZW50cywgZXZlbnRQb3NpdGlvbikge1xuICAgIGNvbnN0IGxhc3RBY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG4gICAgY29uc3QgYWN0aXZlID0gYWN0aXZlRWxlbWVudHMubWFwKCh7ZGF0YXNldEluZGV4LCBpbmRleH0pID0+IHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cbiAgICAgIGlmICghbWV0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGEgZGF0YXNldCBhdCBpbmRleCAnICsgZGF0YXNldEluZGV4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YXNldEluZGV4LFxuICAgICAgICBlbGVtZW50OiBtZXRhLmRhdGFbaW5kZXhdLFxuICAgICAgICBpbmRleCxcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgY2hhbmdlZCA9ICFfZWxlbWVudHNFcXVhbChsYXN0QWN0aXZlLCBhY3RpdmUpO1xuICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlZCA9IHRoaXMuX3Bvc2l0aW9uQ2hhbmdlZChhY3RpdmUsIGV2ZW50UG9zaXRpb24pO1xuXG4gICAgaWYgKGNoYW5nZWQgfHwgcG9zaXRpb25DaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0gZXZlbnRQb3NpdGlvbjtcbiAgICAgIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cyA9IHRydWU7XG4gICAgICB0aGlzLnVwZGF0ZSh0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogSGFuZGxlIGFuIGV2ZW50XG5cdCAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZSAtIFRoZSBldmVudCB0byBoYW5kbGVcblx0ICogQHBhcmFtIHtib29sZWFufSBbcmVwbGF5XSAtIFRoaXMgaXMgYSByZXBsYXllZCBldmVudCAoZnJvbSB1cGRhdGUpXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luQ2hhcnRBcmVhXSAtIFRoZSBldmVudCBpcyBpbnNpZGUgY2hhcnRBcmVhXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSB0b29sdGlwIGNoYW5nZWRcblx0ICovXG4gIGhhbmRsZUV2ZW50KGUsIHJlcGxheSwgaW5DaGFydEFyZWEgPSB0cnVlKSB7XG4gICAgaWYgKHJlcGxheSAmJiB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzID0gZmFsc2U7XG5cbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGxhc3RBY3RpdmUgPSB0aGlzLl9hY3RpdmUgfHwgW107XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSk7XG5cbiAgICAvLyBXaGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBpdGVtcyBzaG93biwgYnV0IHRoZSB0b29sdGlwIHBvc2l0aW9uIGlzIG5lYXJlc3QgbW9kZVxuICAgIC8vIGFuIHVwZGF0ZSBtYXkgbmVlZCB0byBiZSBtYWRlIGJlY2F1c2Ugb3VyIHBvc2l0aW9uIG1heSBoYXZlIGNoYW5nZWQgZXZlbiB0aG91Z2hcbiAgICAvLyB0aGUgaXRlbXMgYXJlIHRoZSBzYW1lIGFzIGJlZm9yZS5cbiAgICBjb25zdCBwb3NpdGlvbkNoYW5nZWQgPSB0aGlzLl9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBlKTtcblxuICAgIC8vIFJlbWVtYmVyIExhc3QgQWN0aXZlc1xuICAgIGNvbnN0IGNoYW5nZWQgPSByZXBsYXkgfHwgIV9lbGVtZW50c0VxdWFsKGFjdGl2ZSwgbGFzdEFjdGl2ZSkgfHwgcG9zaXRpb25DaGFuZ2VkO1xuXG4gICAgLy8gT25seSBoYW5kbGUgdGFyZ2V0IGV2ZW50IG9uIHRvb2x0aXAgY2hhbmdlXG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcblxuICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlZCB8fCBvcHRpb25zLmV4dGVybmFsKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSB7XG4gICAgICAgICAgeDogZS54LFxuICAgICAgICAgIHk6IGUueVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMudXBkYXRlKHRydWUsIHJlcGxheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH1cblxuICAvKipcblx0ICogSGVscGVyIGZvciBkZXRlcm1pbmluZyB0aGUgYWN0aXZlIGVsZW1lbnRzIGZvciBldmVudFxuXHQgKiBAcGFyYW0ge0NoYXJ0RXZlbnR9IGUgLSBUaGUgZXZlbnQgdG8gaGFuZGxlXG5cdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25JdGVtW119IGxhc3RBY3RpdmUgLSBQcmV2aW91c2x5IGFjdGl2ZSBlbGVtZW50c1xuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXBsYXldIC0gVGhpcyBpcyBhIHJlcGxheWVkIGV2ZW50IChmcm9tIHVwZGF0ZSlcblx0ICogQHBhcmFtIHtib29sZWFufSBbaW5DaGFydEFyZWFdIC0gVGhlIGV2ZW50IGlzIGluc2lkZSBjaGFydEFyZWFcblx0ICogQHJldHVybnMge0ludGVyYWN0aW9uSXRlbVtdfSAtIEFjdGl2ZSBlbGVtZW50c1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIHJlcGxheSwgaW5DaGFydEFyZWEpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmICghaW5DaGFydEFyZWEpIHtcbiAgICAgIC8vIExldCB1c2VyIGNvbnRyb2wgdGhlIGFjdGl2ZSBlbGVtZW50cyBvdXRzaWRlIGNoYXJ0QXJlYS4gRWcuIHVzaW5nIExlZ2VuZC5cbiAgICAgIC8vIEJ1dCBtYWtlIHN1cmUgdGhhdCBhY3RpdmUgZWxlbWVudHMgYXJlIHN0aWxsIHZhbGlkLlxuICAgICAgcmV0dXJuIGxhc3RBY3RpdmUuZmlsdGVyKGkgPT5cbiAgICAgICAgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2kuZGF0YXNldEluZGV4XSAmJlxuICAgICAgICB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKGkuZGF0YXNldEluZGV4KS5jb250cm9sbGVyLmdldFBhcnNlZChpLmluZGV4KSAhPT0gdW5kZWZpbmVkXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEZpbmQgQWN0aXZlIEVsZW1lbnRzIGZvciB0b29sdGlwc1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuY2hhcnQuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBvcHRpb25zLm1vZGUsIG9wdGlvbnMsIHJlcGxheSk7XG5cbiAgICBpZiAob3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICBhY3RpdmUucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBhY3RpdmU7XG4gIH1cblxuICAvKipcblx0ICogRGV0ZXJtaW5lIGlmIHRoZSBhY3RpdmUgZWxlbWVudHMgKyBldmVudCBjb21iaW5hdGlvbiBjaGFuZ2VzIHRoZVxuXHQgKiB0b29sdGlwIHBvc2l0aW9uXG5cdCAqIEBwYXJhbSB7YXJyYXl9IGFjdGl2ZSAtIEFjdGl2ZSBlbGVtZW50c1xuXHQgKiBAcGFyYW0ge0NoYXJ0RXZlbnR9IGUgLSBFdmVudCB0aGF0IHRyaWdnZXJlZCB0aGUgcG9zaXRpb24gY2hhbmdlXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwb3NpdGlvbiBoYXMgY2hhbmdlZFxuXHQgKi9cbiAgX3Bvc2l0aW9uQ2hhbmdlZChhY3RpdmUsIGUpIHtcbiAgICBjb25zdCB7Y2FyZXRYLCBjYXJldFksIG9wdGlvbnN9ID0gdGhpcztcbiAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uZXJzW29wdGlvbnMucG9zaXRpb25dLmNhbGwodGhpcywgYWN0aXZlLCBlKTtcbiAgICByZXR1cm4gcG9zaXRpb24gIT09IGZhbHNlICYmIChjYXJldFggIT09IHBvc2l0aW9uLnggfHwgY2FyZXRZICE9PSBwb3NpdGlvbi55KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAndG9vbHRpcCcsXG4gIF9lbGVtZW50OiBUb29sdGlwLFxuICBwb3NpdGlvbmVycyxcblxuICBhZnRlckluaXQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGNoYXJ0LnRvb2x0aXAgPSBuZXcgVG9vbHRpcCh7Y2hhcnQsIG9wdGlvbnN9KTtcbiAgICB9XG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChjaGFydC50b29sdGlwKSB7XG4gICAgICBjaGFydC50b29sdGlwLmluaXRpYWxpemUob3B0aW9ucyk7XG4gICAgfVxuICB9LFxuXG4gIHJlc2V0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChjaGFydC50b29sdGlwKSB7XG4gICAgICBjaGFydC50b29sdGlwLmluaXRpYWxpemUob3B0aW9ucyk7XG4gICAgfVxuICB9LFxuXG4gIGFmdGVyRHJhdyhjaGFydCkge1xuICAgIGNvbnN0IHRvb2x0aXAgPSBjaGFydC50b29sdGlwO1xuXG4gICAgaWYgKHRvb2x0aXAgJiYgdG9vbHRpcC5fd2lsbFJlbmRlcigpKSB7XG4gICAgICBjb25zdCBhcmdzID0ge1xuICAgICAgICB0b29sdGlwXG4gICAgICB9O1xuXG4gICAgICBpZiAoY2hhcnQubm90aWZ5UGx1Z2lucygnYmVmb3JlVG9vbHRpcERyYXcnLCB7Li4uYXJncywgY2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRvb2x0aXAuZHJhdyhjaGFydC5jdHgpO1xuXG4gICAgICBjaGFydC5ub3RpZnlQbHVnaW5zKCdhZnRlclRvb2x0aXBEcmF3JywgYXJncyk7XG4gICAgfVxuICB9LFxuXG4gIGFmdGVyRXZlbnQoY2hhcnQsIGFyZ3MpIHtcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgLy8gSWYgdGhlIGV2ZW50IGlzIHJlcGxheWVkIGZyb20gYHVwZGF0ZWAsIHdlIHNob3VsZCBldmFsdWF0ZSB3aXRoIHRoZSBmaW5hbCBwb3NpdGlvbnMuXG4gICAgICBjb25zdCB1c2VGaW5hbFBvc2l0aW9uID0gYXJncy5yZXBsYXk7XG4gICAgICBpZiAoY2hhcnQudG9vbHRpcC5oYW5kbGVFdmVudChhcmdzLmV2ZW50LCB1c2VGaW5hbFBvc2l0aW9uLCBhcmdzLmluQ2hhcnRBcmVhKSkge1xuICAgICAgICAvLyBub3RpZnkgY2hhcnQgYWJvdXQgdGhlIGNoYW5nZSwgc28gaXQgd2lsbCByZW5kZXJcbiAgICAgICAgYXJncy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGV4dGVybmFsOiBudWxsLFxuICAgIHBvc2l0aW9uOiAnYXZlcmFnZScsXG4gICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwLjgpJyxcbiAgICB0aXRsZUNvbG9yOiAnI2ZmZicsXG4gICAgdGl0bGVGb250OiB7XG4gICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICB9LFxuICAgIHRpdGxlU3BhY2luZzogMixcbiAgICB0aXRsZU1hcmdpbkJvdHRvbTogNixcbiAgICB0aXRsZUFsaWduOiAnbGVmdCcsXG4gICAgYm9keUNvbG9yOiAnI2ZmZicsXG4gICAgYm9keVNwYWNpbmc6IDIsXG4gICAgYm9keUZvbnQ6IHtcbiAgICB9LFxuICAgIGJvZHlBbGlnbjogJ2xlZnQnLFxuICAgIGZvb3RlckNvbG9yOiAnI2ZmZicsXG4gICAgZm9vdGVyU3BhY2luZzogMixcbiAgICBmb290ZXJNYXJnaW5Ub3A6IDYsXG4gICAgZm9vdGVyRm9udDoge1xuICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgfSxcbiAgICBmb290ZXJBbGlnbjogJ2xlZnQnLFxuICAgIHBhZGRpbmc6IDYsXG4gICAgY2FyZXRQYWRkaW5nOiAyLFxuICAgIGNhcmV0U2l6ZTogNSxcbiAgICBjb3JuZXJSYWRpdXM6IDYsXG4gICAgYm94SGVpZ2h0OiAoY3R4LCBvcHRzKSA9PiBvcHRzLmJvZHlGb250LnNpemUsXG4gICAgYm94V2lkdGg6IChjdHgsIG9wdHMpID0+IG9wdHMuYm9keUZvbnQuc2l6ZSxcbiAgICBtdWx0aUtleUJhY2tncm91bmQ6ICcjZmZmJyxcbiAgICBkaXNwbGF5Q29sb3JzOiB0cnVlLFxuICAgIGJveFBhZGRpbmc6IDAsXG4gICAgYm9yZGVyQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcbiAgICBib3JkZXJXaWR0aDogMCxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIGR1cmF0aW9uOiA0MDAsXG4gICAgICBlYXNpbmc6ICdlYXNlT3V0UXVhcnQnLFxuICAgIH0sXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgbnVtYmVyczoge1xuICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ2NhcmV0WCcsICdjYXJldFknXSxcbiAgICAgIH0sXG4gICAgICBvcGFjaXR5OiB7XG4gICAgICAgIGVhc2luZzogJ2xpbmVhcicsXG4gICAgICAgIGR1cmF0aW9uOiAyMDBcbiAgICAgIH1cbiAgICB9LFxuICAgIGNhbGxiYWNrczogZGVmYXVsdENhbGxiYWNrc1xuICB9LFxuXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBib2R5Rm9udDogJ2ZvbnQnLFxuICAgIGZvb3RlckZvbnQ6ICdmb250JyxcbiAgICB0aXRsZUZvbnQ6ICdmb250J1xuICB9LFxuXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnZmlsdGVyJyAmJiBuYW1lICE9PSAnaXRlbVNvcnQnICYmIG5hbWUgIT09ICdleHRlcm5hbCcsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gICAgY2FsbGJhY2tzOiB7XG4gICAgICBfc2NyaXB0YWJsZTogZmFsc2UsXG4gICAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgICB9LFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgX2ZhbGxiYWNrOiBmYWxzZVxuICAgIH0sXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgX2ZhbGxiYWNrOiAnYW5pbWF0aW9uJ1xuICAgIH1cbiAgfSxcblxuICAvLyBSZXNvbHZlIGFkZGl0aW9uYWxseSBmcm9tIGBpbnRlcmFjdGlvbmAgb3B0aW9ucyBhbmQgZGVmYXVsdHMuXG4gIGFkZGl0aW9uYWxPcHRpb25TY29wZXM6IFsnaW50ZXJhY3Rpb24nXVxufTtcbiIsICJpbXBvcnQgU2NhbGUgZnJvbSAnLi4vY29yZS9jb3JlLnNjYWxlLmpzJztcbmltcG9ydCB7aXNOdWxsT3JVbmRlZiwgdmFsdWVPckRlZmF1bHQsIF9saW1pdFZhbHVlfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuY29uc3QgYWRkSWZTdHJpbmcgPSAobGFiZWxzLCByYXcsIGluZGV4LCBhZGRlZExhYmVscykgPT4ge1xuICBpZiAodHlwZW9mIHJhdyA9PT0gJ3N0cmluZycpIHtcbiAgICBpbmRleCA9IGxhYmVscy5wdXNoKHJhdykgLSAxO1xuICAgIGFkZGVkTGFiZWxzLnVuc2hpZnQoe2luZGV4LCBsYWJlbDogcmF3fSk7XG4gIH0gZWxzZSBpZiAoaXNOYU4ocmF3KSkge1xuICAgIGluZGV4ID0gbnVsbDtcbiAgfVxuICByZXR1cm4gaW5kZXg7XG59O1xuXG5mdW5jdGlvbiBmaW5kT3JBZGRMYWJlbChsYWJlbHMsIHJhdywgaW5kZXgsIGFkZGVkTGFiZWxzKSB7XG4gIGNvbnN0IGZpcnN0ID0gbGFiZWxzLmluZGV4T2YocmF3KTtcbiAgaWYgKGZpcnN0ID09PSAtMSkge1xuICAgIHJldHVybiBhZGRJZlN0cmluZyhsYWJlbHMsIHJhdywgaW5kZXgsIGFkZGVkTGFiZWxzKTtcbiAgfVxuICBjb25zdCBsYXN0ID0gbGFiZWxzLmxhc3RJbmRleE9mKHJhdyk7XG4gIHJldHVybiBmaXJzdCAhPT0gbGFzdCA/IGluZGV4IDogZmlyc3Q7XG59XG5cbmNvbnN0IHZhbGlkSW5kZXggPSAoaW5kZXgsIG1heCkgPT4gaW5kZXggPT09IG51bGwgPyBudWxsIDogX2xpbWl0VmFsdWUoTWF0aC5yb3VuZChpbmRleCksIDAsIG1heCk7XG5cbmZ1bmN0aW9uIF9nZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG5cbiAgaWYgKHZhbHVlID49IDAgJiYgdmFsdWUgPCBsYWJlbHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGxhYmVsc1t2YWx1ZV07XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYXRlZ29yeVNjYWxlIGV4dGVuZHMgU2NhbGUge1xuXG4gIHN0YXRpYyBpZCA9ICdjYXRlZ29yeSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgdGlja3M6IHtcbiAgICAgIGNhbGxiYWNrOiBfZ2V0TGFiZWxGb3JWYWx1ZVxuICAgIH1cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgICB0aGlzLl9hZGRlZExhYmVscyA9IFtdO1xuICB9XG5cbiAgaW5pdChzY2FsZU9wdGlvbnMpIHtcbiAgICBjb25zdCBhZGRlZCA9IHRoaXMuX2FkZGVkTGFiZWxzO1xuICAgIGlmIChhZGRlZC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgICBmb3IgKGNvbnN0IHtpbmRleCwgbGFiZWx9IG9mIGFkZGVkKSB7XG4gICAgICAgIGlmIChsYWJlbHNbaW5kZXhdID09PSBsYWJlbCkge1xuICAgICAgICAgIGxhYmVscy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9hZGRlZExhYmVscyA9IFtdO1xuICAgIH1cbiAgICBzdXBlci5pbml0KHNjYWxlT3B0aW9ucyk7XG4gIH1cblxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYocmF3KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgaW5kZXggPSBpc0Zpbml0ZShpbmRleCkgJiYgbGFiZWxzW2luZGV4XSA9PT0gcmF3ID8gaW5kZXhcbiAgICAgIDogZmluZE9yQWRkTGFiZWwobGFiZWxzLCByYXcsIHZhbHVlT3JEZWZhdWx0KGluZGV4LCByYXcpLCB0aGlzLl9hZGRlZExhYmVscyk7XG4gICAgcmV0dXJuIHZhbGlkSW5kZXgoaW5kZXgsIGxhYmVscy5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heCh0cnVlKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICBpZiAoIW1pbkRlZmluZWQpIHtcbiAgICAgICAgbWluID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCkge1xuICAgICAgICBtYXggPSB0aGlzLmdldExhYmVscygpLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gIH1cblxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub3B0aW9ucy5vZmZzZXQ7XG4gICAgY29uc3QgdGlja3MgPSBbXTtcbiAgICBsZXQgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcblxuICAgIC8vIElmIHdlIGFyZSB2aWV3aW5nIHNvbWUgc3Vic2V0IG9mIGxhYmVscywgc2xpY2UgdGhlIG9yaWdpbmFsIGFycmF5XG4gICAgbGFiZWxzID0gKG1pbiA9PT0gMCAmJiBtYXggPT09IGxhYmVscy5sZW5ndGggLSAxKSA/IGxhYmVscyA6IGxhYmVscy5zbGljZShtaW4sIG1heCArIDEpO1xuXG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IE1hdGgubWF4KGxhYmVscy5sZW5ndGggLSAob2Zmc2V0ID8gMCA6IDEpLCAxKTtcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdGhpcy5taW4gLSAob2Zmc2V0ID8gMC41IDogMCk7XG5cbiAgICBmb3IgKGxldCB2YWx1ZSA9IG1pbjsgdmFsdWUgPD0gbWF4OyB2YWx1ZSsrKSB7XG4gICAgICB0aWNrcy5wdXNoKHt2YWx1ZX0pO1xuICAgIH1cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cblxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIF9nZXRMYWJlbEZvclZhbHVlLmNhbGwodGhpcywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBzdXBlci5jb25maWd1cmUoKTtcblxuICAgIGlmICghdGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHZlcnRpY2FsIGNhdGVnb3J5IHNjYWxlIHJldmVyc2UgaXMgaW52ZXJ0ZWQuXG4gICAgICB0aGlzLl9yZXZlcnNlUGl4ZWxzID0gIXRoaXMuX3JldmVyc2VQaXhlbHM7XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlZCB0byBnZXQgZGF0YSB2YWx1ZSBsb2NhdGlvbnMuIFZhbHVlIGNhbiBlaXRoZXIgYmUgYW4gaW5kZXggb3IgYSBudW1lcmljYWwgdmFsdWVcbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucGFyc2UodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6IHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKCh2YWx1ZSAtIHRoaXMuX3N0YXJ0VmFsdWUpIC8gdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cblxuICAvLyBNdXN0IG92ZXJyaWRlIGJhc2UgaW1wbGVtZW50YXRpb24gYmVjYXVzZSBpdCBjYWxscyBnZXRQaXhlbEZvclZhbHVlXG4gIC8vIGFuZCBjYXRlZ29yeSBzY2FsZSBjYW4gaGF2ZSBkdXBsaWNhdGUgdmFsdWVzXG4gIGdldFBpeGVsRm9yVGljayhpbmRleCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGlja3MubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGlja3NbaW5kZXhdLnZhbHVlKTtcbiAgfVxuXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh0aGlzLl9zdGFydFZhbHVlICsgdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpICogdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cblxuICBnZXRCYXNlUGl4ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm90dG9tO1xuICB9XG59XG4iLCAiaW1wb3J0IHtpc051bGxPclVuZGVmfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2FsbW9zdEVxdWFscywgYWxtb3N0V2hvbGUsIG5pY2VOdW0sIF9kZWNpbWFsUGxhY2VzLCBfc2V0TWluQW5kTWF4QnlLZXksIHNpZ24sIHRvUmFkaWFuc30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IFNjYWxlIGZyb20gJy4uL2NvcmUvY29yZS5zY2FsZS5qcyc7XG5pbXBvcnQge2Zvcm1hdE51bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmludGwuanMnO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc2V0IG9mIGxpbmVhciB0aWNrcyBmb3IgYW4gYXhpc1xuICogMS4gSWYgZ2VuZXJhdGlvbk9wdGlvbnMubWluLCBnZW5lcmF0aW9uT3B0aW9ucy5tYXgsIGFuZCBnZW5lcmF0aW9uT3B0aW9ucy5zdGVwIGFyZSBkZWZpbmVkOlxuICogICAgaWYgKG1heCAtIG1pbikgLyBzdGVwIGlzIGFuIGludGVnZXIsIHRpY2tzIGFyZSBnZW5lcmF0ZWQgYXMgW21pbiwgbWluICsgc3RlcCwgLi4uLCBtYXhdXG4gKiAgICBOb3RlIHRoYXQgdGhlIGdlbmVyYXRpb25PcHRpb25zLm1heENvdW50IHNldHRpbmcgaXMgcmVzcGVjdGVkIGluIHRoaXMgc2NlbmFyaW9cbiAqXG4gKiAyLiBJZiBnZW5lcmF0aW9uT3B0aW9ucy5taW4sIGdlbmVyYXRpb25PcHRpb25zLm1heCwgYW5kIGdlbmVyYXRpb25PcHRpb25zLmNvdW50IGlzIGRlZmluZWRcbiAqICAgIHNwYWNpbmcgPSAobWF4IC0gbWluKSAvIGNvdW50XG4gKiAgICBUaWNrcyBhcmUgZ2VuZXJhdGVkIGFzIFttaW4sIG1pbiArIHNwYWNpbmcsIC4uLiwgbWF4XVxuICpcbiAqIDMuIElmIGdlbmVyYXRpb25PcHRpb25zLmNvdW50IGlzIGRlZmluZWRcbiAqICAgIHNwYWNpbmcgPSAobmljZU1heCAtIG5pY2VNaW4pIC8gY291bnRcbiAqXG4gKiA0LiBDb21wdXRlIG9wdGltYWwgc3BhY2luZyBvZiB0aWNrcyB1c2luZyBuaWNlTnVtIGFsZ29yaXRobVxuICpcbiAqIEBwYXJhbSBnZW5lcmF0aW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aWNrc1xuICogQHBhcmFtIGRhdGFSYW5nZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGFcbiAqIEByZXR1cm5zIHtvYmplY3RbXX0gYXJyYXkgb2YgdGljayBvYmplY3RzXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlVGlja3MoZ2VuZXJhdGlvbk9wdGlvbnMsIGRhdGFSYW5nZSkge1xuICBjb25zdCB0aWNrcyA9IFtdO1xuICAvLyBUbyBnZXQgYSBcIm5pY2VcIiB2YWx1ZSBmb3IgdGhlIHRpY2sgc3BhY2luZywgd2Ugd2lsbCB1c2UgdGhlIGFwcHJvcHJpYXRlbHkgbmFtZWRcbiAgLy8gXCJuaWNlIG51bWJlclwiIGFsZ29yaXRobS4gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg1MDY4ODEvbmljZS1sYWJlbC1hbGdvcml0aG0tZm9yLWNoYXJ0cy13aXRoLW1pbmltdW0tdGlja3NcbiAgLy8gZm9yIGRldGFpbHMuXG5cbiAgY29uc3QgTUlOX1NQQUNJTkcgPSAxZS0xNDtcbiAgY29uc3Qge2JvdW5kcywgc3RlcCwgbWluLCBtYXgsIHByZWNpc2lvbiwgY291bnQsIG1heFRpY2tzLCBtYXhEaWdpdHMsIGluY2x1ZGVCb3VuZHN9ID0gZ2VuZXJhdGlvbk9wdGlvbnM7XG4gIGNvbnN0IHVuaXQgPSBzdGVwIHx8IDE7XG4gIGNvbnN0IG1heFNwYWNlcyA9IG1heFRpY2tzIC0gMTtcbiAgY29uc3Qge21pbjogcm1pbiwgbWF4OiBybWF4fSA9IGRhdGFSYW5nZTtcbiAgY29uc3QgbWluRGVmaW5lZCA9ICFpc051bGxPclVuZGVmKG1pbik7XG4gIGNvbnN0IG1heERlZmluZWQgPSAhaXNOdWxsT3JVbmRlZihtYXgpO1xuICBjb25zdCBjb3VudERlZmluZWQgPSAhaXNOdWxsT3JVbmRlZihjb3VudCk7XG4gIGNvbnN0IG1pblNwYWNpbmcgPSAocm1heCAtIHJtaW4pIC8gKG1heERpZ2l0cyArIDEpO1xuICBsZXQgc3BhY2luZyA9IG5pY2VOdW0oKHJtYXggLSBybWluKSAvIG1heFNwYWNlcyAvIHVuaXQpICogdW5pdDtcbiAgbGV0IGZhY3RvciwgbmljZU1pbiwgbmljZU1heCwgbnVtU3BhY2VzO1xuXG4gIC8vIEJleW9uZCBNSU5fU1BBQ0lORyBmbG9hdGluZyBwb2ludCBudW1iZXJzIGJlaW5nIHRvIGxvc2UgcHJlY2lzaW9uXG4gIC8vIHN1Y2ggdGhhdCB3ZSBjYW4ndCBkbyB0aGUgbWF0aCBuZWNlc3NhcnkgdG8gZ2VuZXJhdGUgdGlja3NcbiAgaWYgKHNwYWNpbmcgPCBNSU5fU1BBQ0lORyAmJiAhbWluRGVmaW5lZCAmJiAhbWF4RGVmaW5lZCkge1xuICAgIHJldHVybiBbe3ZhbHVlOiBybWlufSwge3ZhbHVlOiBybWF4fV07XG4gIH1cblxuICBudW1TcGFjZXMgPSBNYXRoLmNlaWwocm1heCAvIHNwYWNpbmcpIC0gTWF0aC5mbG9vcihybWluIC8gc3BhY2luZyk7XG4gIGlmIChudW1TcGFjZXMgPiBtYXhTcGFjZXMpIHtcbiAgICAvLyBJZiB0aGUgY2FsY3VsYXRlZCBudW0gb2Ygc3BhY2VzIGV4Y2VlZHMgbWF4TnVtU3BhY2VzLCByZWNhbGN1bGF0ZSBpdFxuICAgIHNwYWNpbmcgPSBuaWNlTnVtKG51bVNwYWNlcyAqIHNwYWNpbmcgLyBtYXhTcGFjZXMgLyB1bml0KSAqIHVuaXQ7XG4gIH1cblxuICBpZiAoIWlzTnVsbE9yVW5kZWYocHJlY2lzaW9uKSkge1xuICAgIC8vIElmIHRoZSB1c2VyIHNwZWNpZmllZCBhIHByZWNpc2lvbiwgcm91bmQgdG8gdGhhdCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXNcbiAgICBmYWN0b3IgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcbiAgICBzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcgKiBmYWN0b3IpIC8gZmFjdG9yO1xuICB9XG5cbiAgaWYgKGJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgIG5pY2VNaW4gPSBNYXRoLmZsb29yKHJtaW4gLyBzcGFjaW5nKSAqIHNwYWNpbmc7XG4gICAgbmljZU1heCA9IE1hdGguY2VpbChybWF4IC8gc3BhY2luZykgKiBzcGFjaW5nO1xuICB9IGVsc2Uge1xuICAgIG5pY2VNaW4gPSBybWluO1xuICAgIG5pY2VNYXggPSBybWF4O1xuICB9XG5cbiAgaWYgKG1pbkRlZmluZWQgJiYgbWF4RGVmaW5lZCAmJiBzdGVwICYmIGFsbW9zdFdob2xlKChtYXggLSBtaW4pIC8gc3RlcCwgc3BhY2luZyAvIDEwMDApKSB7XG4gICAgLy8gQ2FzZSAxOiBJZiBtaW4sIG1heCBhbmQgc3RlcFNpemUgYXJlIHNldCBhbmQgdGhleSBtYWtlIGFuIGV2ZW5seSBzcGFjZWQgc2NhbGUgdXNlIGl0LlxuICAgIC8vIHNwYWNpbmcgPSBzdGVwO1xuICAgIC8vIG51bVNwYWNlcyA9IChtYXggLSBtaW4pIC8gc3BhY2luZztcbiAgICAvLyBOb3RlIHRoYXQgd2Ugcm91bmQgaGVyZSB0byBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgYWxtb3N0V2hvbGUgdHJhbnNsYXRlZCBhbiBGUCBlcnJvclxuICAgIG51bVNwYWNlcyA9IE1hdGgucm91bmQoTWF0aC5taW4oKG1heCAtIG1pbikgLyBzcGFjaW5nLCBtYXhUaWNrcykpO1xuICAgIHNwYWNpbmcgPSAobWF4IC0gbWluKSAvIG51bVNwYWNlcztcbiAgICBuaWNlTWluID0gbWluO1xuICAgIG5pY2VNYXggPSBtYXg7XG4gIH0gZWxzZSBpZiAoY291bnREZWZpbmVkKSB7XG4gICAgLy8gQ2FzZXMgMiAmIDMsIHdlIGhhdmUgYSBjb3VudCBzcGVjaWZpZWQuIEhhbmRsZSBvcHRpb25hbCB1c2VyIGRlZmluZWQgZWRnZXMgdG8gdGhlIHJhbmdlLlxuICAgIC8vIFNvbWV0aW1lcyB0aGVzZSBhcmUgbm8tb3BzLCBidXQgaXQgbWFrZXMgdGhlIGNvZGUgYSBsb3QgY2xlYXJlclxuICAgIC8vIGFuZCB3aGVuIGEgdXNlciBkZWZpbmVkIHJhbmdlIGlzIHNwZWNpZmllZCwgd2Ugd2FudCB0aGUgY29ycmVjdCB0aWNrc1xuICAgIG5pY2VNaW4gPSBtaW5EZWZpbmVkID8gbWluIDogbmljZU1pbjtcbiAgICBuaWNlTWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IG5pY2VNYXg7XG4gICAgbnVtU3BhY2VzID0gY291bnQgLSAxO1xuICAgIHNwYWNpbmcgPSAobmljZU1heCAtIG5pY2VNaW4pIC8gbnVtU3BhY2VzO1xuICB9IGVsc2Uge1xuICAgIC8vIENhc2UgNFxuICAgIG51bVNwYWNlcyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBzcGFjaW5nO1xuXG4gICAgLy8gSWYgdmVyeSBjbG9zZSB0byBvdXIgcm91bmRlZCB2YWx1ZSwgdXNlIGl0LlxuICAgIGlmIChhbG1vc3RFcXVhbHMobnVtU3BhY2VzLCBNYXRoLnJvdW5kKG51bVNwYWNlcyksIHNwYWNpbmcgLyAxMDAwKSkge1xuICAgICAgbnVtU3BhY2VzID0gTWF0aC5yb3VuZChudW1TcGFjZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBudW1TcGFjZXMgPSBNYXRoLmNlaWwobnVtU3BhY2VzKTtcbiAgICB9XG4gIH1cblxuICAvLyBUaGUgc3BhY2luZyB3aWxsIGhhdmUgY2hhbmdlZCBpbiBjYXNlcyAxLCAyLCBhbmQgMyBzbyB0aGUgZmFjdG9yIGNhbm5vdCBiZSBjb21wdXRlZFxuICAvLyB1bnRpbCB0aGlzIHBvaW50XG4gIGNvbnN0IGRlY2ltYWxQbGFjZXMgPSBNYXRoLm1heChcbiAgICBfZGVjaW1hbFBsYWNlcyhzcGFjaW5nKSxcbiAgICBfZGVjaW1hbFBsYWNlcyhuaWNlTWluKVxuICApO1xuICBmYWN0b3IgPSBNYXRoLnBvdygxMCwgaXNOdWxsT3JVbmRlZihwcmVjaXNpb24pID8gZGVjaW1hbFBsYWNlcyA6IHByZWNpc2lvbik7XG4gIG5pY2VNaW4gPSBNYXRoLnJvdW5kKG5pY2VNaW4gKiBmYWN0b3IpIC8gZmFjdG9yO1xuICBuaWNlTWF4ID0gTWF0aC5yb3VuZChuaWNlTWF4ICogZmFjdG9yKSAvIGZhY3RvcjtcblxuICBsZXQgaiA9IDA7XG4gIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgaWYgKGluY2x1ZGVCb3VuZHMgJiYgbmljZU1pbiAhPT0gbWluKSB7XG4gICAgICB0aWNrcy5wdXNoKHt2YWx1ZTogbWlufSk7XG5cbiAgICAgIGlmIChuaWNlTWluIDwgbWluKSB7XG4gICAgICAgIGorKzsgLy8gU2tpcCBuaWNlTWluXG4gICAgICB9XG4gICAgICAvLyBJZiB0aGUgbmV4dCBuaWNlIHRpY2sgaXMgY2xvc2UgdG8gbWluLCBza2lwIGl0XG4gICAgICBpZiAoYWxtb3N0RXF1YWxzKE1hdGgucm91bmQoKG5pY2VNaW4gKyBqICogc3BhY2luZykgKiBmYWN0b3IpIC8gZmFjdG9yLCBtaW4sIHJlbGF0aXZlTGFiZWxTaXplKG1pbiwgbWluU3BhY2luZywgZ2VuZXJhdGlvbk9wdGlvbnMpKSkge1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuaWNlTWluIDwgbWluKSB7XG4gICAgICBqKys7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IGogPCBudW1TcGFjZXM7ICsraikge1xuICAgIGNvbnN0IHRpY2tWYWx1ZSA9IE1hdGgucm91bmQoKG5pY2VNaW4gKyBqICogc3BhY2luZykgKiBmYWN0b3IpIC8gZmFjdG9yO1xuICAgIGlmIChtYXhEZWZpbmVkICYmIHRpY2tWYWx1ZSA+IG1heCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRpY2tzLnB1c2goe3ZhbHVlOiB0aWNrVmFsdWV9KTtcbiAgfVxuXG4gIGlmIChtYXhEZWZpbmVkICYmIGluY2x1ZGVCb3VuZHMgJiYgbmljZU1heCAhPT0gbWF4KSB7XG4gICAgLy8gSWYgdGhlIHByZXZpb3VzIHRpY2sgaXMgdG9vIGNsb3NlIHRvIG1heCwgcmVwbGFjZSBpdCB3aXRoIG1heCwgZWxzZSBhZGQgbWF4XG4gICAgaWYgKHRpY2tzLmxlbmd0aCAmJiBhbG1vc3RFcXVhbHModGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWUsIG1heCwgcmVsYXRpdmVMYWJlbFNpemUobWF4LCBtaW5TcGFjaW5nLCBnZW5lcmF0aW9uT3B0aW9ucykpKSB7XG4gICAgICB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSA9IG1heDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGlja3MucHVzaCh7dmFsdWU6IG1heH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmICghbWF4RGVmaW5lZCB8fCBuaWNlTWF4ID09PSBtYXgpIHtcbiAgICB0aWNrcy5wdXNoKHt2YWx1ZTogbmljZU1heH0pO1xuICB9XG5cbiAgcmV0dXJuIHRpY2tzO1xufVxuXG5mdW5jdGlvbiByZWxhdGl2ZUxhYmVsU2l6ZSh2YWx1ZSwgbWluU3BhY2luZywge2hvcml6b250YWwsIG1pblJvdGF0aW9ufSkge1xuICBjb25zdCByYWQgPSB0b1JhZGlhbnMobWluUm90YXRpb24pO1xuICBjb25zdCByYXRpbyA9IChob3Jpem9udGFsID8gTWF0aC5zaW4ocmFkKSA6IE1hdGguY29zKHJhZCkpIHx8IDAuMDAxO1xuICBjb25zdCBsZW5ndGggPSAwLjc1ICogbWluU3BhY2luZyAqICgnJyArIHZhbHVlKS5sZW5ndGg7XG4gIHJldHVybiBNYXRoLm1pbihtaW5TcGFjaW5nIC8gcmF0aW8sIGxlbmd0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmVhclNjYWxlQmFzZSBleHRlbmRzIFNjYWxlIHtcblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5zdGFydCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLmVuZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX2VuZFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwO1xuICB9XG5cbiAgcGFyc2UocmF3LCBpbmRleCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgaWYgKGlzTnVsbE9yVW5kZWYocmF3KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICgodHlwZW9mIHJhdyA9PT0gJ251bWJlcicgfHwgcmF3IGluc3RhbmNlb2YgTnVtYmVyKSAmJiAhaXNGaW5pdGUoK3JhdykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiArcmF3O1xuICB9XG5cbiAgaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpIHtcbiAgICBjb25zdCB7YmVnaW5BdFplcm99ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHttaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCB7bWluLCBtYXh9ID0gdGhpcztcblxuICAgIGNvbnN0IHNldE1pbiA9IHYgPT4gKG1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiB2KTtcbiAgICBjb25zdCBzZXRNYXggPSB2ID0+IChtYXggPSBtYXhEZWZpbmVkID8gbWF4IDogdik7XG5cbiAgICBpZiAoYmVnaW5BdFplcm8pIHtcbiAgICAgIGNvbnN0IG1pblNpZ24gPSBzaWduKG1pbik7XG4gICAgICBjb25zdCBtYXhTaWduID0gc2lnbihtYXgpO1xuXG4gICAgICBpZiAobWluU2lnbiA8IDAgJiYgbWF4U2lnbiA8IDApIHtcbiAgICAgICAgc2V0TWF4KDApO1xuICAgICAgfSBlbHNlIGlmIChtaW5TaWduID4gMCAmJiBtYXhTaWduID4gMCkge1xuICAgICAgICBzZXRNaW4oMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1pbiA9PT0gbWF4KSB7XG4gICAgICBsZXQgb2Zmc2V0ID0gbWF4ID09PSAwID8gMSA6IE1hdGguYWJzKG1heCAqIDAuMDUpO1xuXG4gICAgICBzZXRNYXgobWF4ICsgb2Zmc2V0KTtcblxuICAgICAgaWYgKCFiZWdpbkF0WmVybykge1xuICAgICAgICBzZXRNaW4obWluIC0gb2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gIH1cblxuICBnZXRUaWNrTGltaXQoKSB7XG4gICAgY29uc3QgdGlja09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgIGxldCB7bWF4VGlja3NMaW1pdCwgc3RlcFNpemV9ID0gdGlja09wdHM7XG4gICAgbGV0IG1heFRpY2tzO1xuXG4gICAgaWYgKHN0ZXBTaXplKSB7XG4gICAgICBtYXhUaWNrcyA9IE1hdGguY2VpbCh0aGlzLm1heCAvIHN0ZXBTaXplKSAtIE1hdGguZmxvb3IodGhpcy5taW4gLyBzdGVwU2l6ZSkgKyAxO1xuICAgICAgaWYgKG1heFRpY2tzID4gMTAwMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYHNjYWxlcy4ke3RoaXMuaWR9LnRpY2tzLnN0ZXBTaXplOiAke3N0ZXBTaXplfSB3b3VsZCByZXN1bHQgZ2VuZXJhdGluZyB1cCB0byAke21heFRpY2tzfSB0aWNrcy4gTGltaXRpbmcgdG8gMTAwMC5gKTtcbiAgICAgICAgbWF4VGlja3MgPSAxMDAwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhUaWNrcyA9IHRoaXMuY29tcHV0ZVRpY2tMaW1pdCgpO1xuICAgICAgbWF4VGlja3NMaW1pdCA9IG1heFRpY2tzTGltaXQgfHwgMTE7XG4gICAgfVxuXG4gICAgaWYgKG1heFRpY2tzTGltaXQpIHtcbiAgICAgIG1heFRpY2tzID0gTWF0aC5taW4obWF4VGlja3NMaW1pdCwgbWF4VGlja3MpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXhUaWNrcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIH1cblxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXG4gICAgLy8gRmlndXJlIG91dCB3aGF0IHRoZSBtYXggbnVtYmVyIG9mIHRpY2tzIHdlIGNhbiBzdXBwb3J0IGl0IGlzIGJhc2VkIG9uIHRoZSBzaXplIG9mXG4gICAgLy8gdGhlIGF4aXMgYXJlYS4gRm9yIG5vdywgd2Ugc2F5IHRoYXQgdGhlIG1pbmltdW0gdGljayBzcGFjaW5nIGluIHBpeGVscyBtdXN0IGJlIDQwXG4gICAgLy8gV2UgYWxzbyBsaW1pdCB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGlja3MgdG8gMTEgd2hpY2ggZ2l2ZXMgYSBuaWNlIDEwIHNxdWFyZXMgb25cbiAgICAvLyB0aGUgZ3JhcGguIE1ha2Ugc3VyZSB3ZSBhbHdheXMgaGF2ZSBhdCBsZWFzdCAyIHRpY2tzXG4gICAgbGV0IG1heFRpY2tzID0gdGhpcy5nZXRUaWNrTGltaXQoKTtcbiAgICBtYXhUaWNrcyA9IE1hdGgubWF4KDIsIG1heFRpY2tzKTtcblxuICAgIGNvbnN0IG51bWVyaWNHZW5lcmF0b3JPcHRpb25zID0ge1xuICAgICAgbWF4VGlja3MsXG4gICAgICBib3VuZHM6IG9wdHMuYm91bmRzLFxuICAgICAgbWluOiBvcHRzLm1pbixcbiAgICAgIG1heDogb3B0cy5tYXgsXG4gICAgICBwcmVjaXNpb246IHRpY2tPcHRzLnByZWNpc2lvbixcbiAgICAgIHN0ZXA6IHRpY2tPcHRzLnN0ZXBTaXplLFxuICAgICAgY291bnQ6IHRpY2tPcHRzLmNvdW50LFxuICAgICAgbWF4RGlnaXRzOiB0aGlzLl9tYXhEaWdpdHMoKSxcbiAgICAgIGhvcml6b250YWw6IHRoaXMuaXNIb3Jpem9udGFsKCksXG4gICAgICBtaW5Sb3RhdGlvbjogdGlja09wdHMubWluUm90YXRpb24gfHwgMCxcbiAgICAgIGluY2x1ZGVCb3VuZHM6IHRpY2tPcHRzLmluY2x1ZGVCb3VuZHMgIT09IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBkYXRhUmFuZ2UgPSB0aGlzLl9yYW5nZSB8fCB0aGlzO1xuICAgIGNvbnN0IHRpY2tzID0gZ2VuZXJhdGVUaWNrcyhudW1lcmljR2VuZXJhdG9yT3B0aW9ucywgZGF0YVJhbmdlKTtcblxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIG5lZWQgdG8gdXBkYXRlIG91ciBtYXggYW5kIG1pbiBnaXZlbiB0aGUgdGljayB2YWx1ZXMsXG4gICAgLy8gc2luY2Ugd2UgcHJvYmFibHkgaGF2ZSBleHBhbmRlZCB0aGUgcmFuZ2Ugb2YgdGhlIHNjYWxlXG4gICAgaWYgKG9wdHMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICBfc2V0TWluQW5kTWF4QnlLZXkodGlja3MsIHRoaXMsICd2YWx1ZScpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLnJldmVyc2UpIHtcbiAgICAgIHRpY2tzLnJldmVyc2UoKTtcblxuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWF4O1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1pbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWluO1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1heDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgY29uZmlndXJlKCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBsZXQgc3RhcnQgPSB0aGlzLm1pbjtcbiAgICBsZXQgZW5kID0gdGhpcy5tYXg7XG5cbiAgICBzdXBlci5jb25maWd1cmUoKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMub2Zmc2V0ICYmIHRpY2tzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gKGVuZCAtIHN0YXJ0KSAvIE1hdGgubWF4KHRpY2tzLmxlbmd0aCAtIDEsIDEpIC8gMjtcbiAgICAgIHN0YXJ0IC09IG9mZnNldDtcbiAgICAgIGVuZCArPSBvZmZzZXQ7XG4gICAgfVxuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSBzdGFydDtcbiAgICB0aGlzLl9lbmRWYWx1ZSA9IGVuZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gZW5kIC0gc3RhcnQ7XG4gIH1cblxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZvcm1hdE51bWJlcih2YWx1ZSwgdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZSwgdGhpcy5vcHRpb25zLnRpY2tzLmZvcm1hdCk7XG4gIH1cbn1cbiIsICJpbXBvcnQge2lzRmluaXRlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQgTGluZWFyU2NhbGVCYXNlIGZyb20gJy4vc2NhbGUubGluZWFyYmFzZS5qcyc7XG5pbXBvcnQgVGlja3MgZnJvbSAnLi4vY29yZS9jb3JlLnRpY2tzLmpzJztcbmltcG9ydCB7dG9SYWRpYW5zfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZWFyU2NhbGUgZXh0ZW5kcyBMaW5lYXJTY2FsZUJhc2Uge1xuXG4gIHN0YXRpYyBpZCA9ICdsaW5lYXInO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIHRpY2tzOiB7XG4gICAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5udW1lcmljXG4gICAgfVxuICB9O1xuXG5cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgodHJ1ZSk7XG5cbiAgICB0aGlzLm1pbiA9IGlzRmluaXRlKG1pbikgPyBtaW4gOiAwO1xuICAgIHRoaXMubWF4ID0gaXNGaW5pdGUobWF4KSA/IG1heCA6IDE7XG5cbiAgICAvLyBDb21tb24gYmFzZSBpbXBsZW1lbnRhdGlvbiB0byBoYW5kbGUgbWluLCBtYXgsIGJlZ2luQXRaZXJvXG4gICAgdGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGlja3MgYmFzZWQgb24gdGhlIHNjYWxlIGRpbWVuc2lvblxuXHQgKiBAcHJvdGVjdGVkXG4gXHQgKi9cbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICBjb25zdCBob3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCBsZW5ndGggPSBob3Jpem9udGFsID8gdGhpcy53aWR0aCA6IHRoaXMuaGVpZ2h0O1xuICAgIGNvbnN0IG1pblJvdGF0aW9uID0gdG9SYWRpYW5zKHRoaXMub3B0aW9ucy50aWNrcy5taW5Sb3RhdGlvbik7XG4gICAgY29uc3QgcmF0aW8gPSAoaG9yaXpvbnRhbCA/IE1hdGguc2luKG1pblJvdGF0aW9uKSA6IE1hdGguY29zKG1pblJvdGF0aW9uKSkgfHwgMC4wMDE7XG4gICAgY29uc3QgdGlja0ZvbnQgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApO1xuICAgIHJldHVybiBNYXRoLmNlaWwobGVuZ3RoIC8gTWF0aC5taW4oNDAsIHRpY2tGb250LmxpbmVIZWlnaHQgLyByYXRpbykpO1xuICB9XG5cbiAgLy8gVXRpbHNcbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6IHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKCh2YWx1ZSAtIHRoaXMuX3N0YXJ0VmFsdWUpIC8gdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cblxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0VmFsdWUgKyB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgKiB0aGlzLl92YWx1ZVJhbmdlO1xuICB9XG59XG4iLCAiaW1wb3J0IHtmaW5pdGVPckRlZmF1bHQsIGlzRmluaXRlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2Zvcm1hdE51bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmludGwuanMnO1xuaW1wb3J0IHtfc2V0TWluQW5kTWF4QnlLZXksIGxvZzEwfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQgU2NhbGUgZnJvbSAnLi4vY29yZS9jb3JlLnNjYWxlLmpzJztcbmltcG9ydCBMaW5lYXJTY2FsZUJhc2UgZnJvbSAnLi9zY2FsZS5saW5lYXJiYXNlLmpzJztcbmltcG9ydCBUaWNrcyBmcm9tICcuLi9jb3JlL2NvcmUudGlja3MuanMnO1xuXG5jb25zdCBsb2cxMEZsb29yID0gdiA9PiBNYXRoLmZsb29yKGxvZzEwKHYpKTtcbmNvbnN0IGNoYW5nZUV4cG9uZW50ID0gKHYsIG0pID0+IE1hdGgucG93KDEwLCBsb2cxMEZsb29yKHYpICsgbSk7XG5cbmZ1bmN0aW9uIGlzTWFqb3IodGlja1ZhbCkge1xuICBjb25zdCByZW1haW4gPSB0aWNrVmFsIC8gKE1hdGgucG93KDEwLCBsb2cxMEZsb29yKHRpY2tWYWwpKSk7XG4gIHJldHVybiByZW1haW4gPT09IDE7XG59XG5cbmZ1bmN0aW9uIHN0ZXBzKG1pbiwgbWF4LCByYW5nZUV4cCkge1xuICBjb25zdCByYW5nZVN0ZXAgPSBNYXRoLnBvdygxMCwgcmFuZ2VFeHApO1xuICBjb25zdCBzdGFydCA9IE1hdGguZmxvb3IobWluIC8gcmFuZ2VTdGVwKTtcbiAgY29uc3QgZW5kID0gTWF0aC5jZWlsKG1heCAvIHJhbmdlU3RlcCk7XG4gIHJldHVybiBlbmQgLSBzdGFydDtcbn1cblxuZnVuY3Rpb24gc3RhcnRFeHAobWluLCBtYXgpIHtcbiAgY29uc3QgcmFuZ2UgPSBtYXggLSBtaW47XG4gIGxldCByYW5nZUV4cCA9IGxvZzEwRmxvb3IocmFuZ2UpO1xuICB3aGlsZSAoc3RlcHMobWluLCBtYXgsIHJhbmdlRXhwKSA+IDEwKSB7XG4gICAgcmFuZ2VFeHArKztcbiAgfVxuICB3aGlsZSAoc3RlcHMobWluLCBtYXgsIHJhbmdlRXhwKSA8IDEwKSB7XG4gICAgcmFuZ2VFeHAtLTtcbiAgfVxuICByZXR1cm4gTWF0aC5taW4ocmFuZ2VFeHAsIGxvZzEwRmxvb3IobWluKSk7XG59XG5cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHNldCBvZiBsb2dhcml0aG1pYyB0aWNrc1xuICogQHBhcmFtIGdlbmVyYXRpb25PcHRpb25zIHRoZSBvcHRpb25zIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpY2tzXG4gKiBAcGFyYW0gZGF0YVJhbmdlIHRoZSByYW5nZSBvZiB0aGUgZGF0YVxuICogQHJldHVybnMge29iamVjdFtdfSBhcnJheSBvZiB0aWNrIG9iamVjdHNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywge21pbiwgbWF4fSkge1xuICBtaW4gPSBmaW5pdGVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWluLCBtaW4pO1xuICBjb25zdCB0aWNrcyA9IFtdO1xuICBjb25zdCBtaW5FeHAgPSBsb2cxMEZsb29yKG1pbik7XG4gIGxldCBleHAgPSBzdGFydEV4cChtaW4sIG1heCk7XG4gIGxldCBwcmVjaXNpb24gPSBleHAgPCAwID8gTWF0aC5wb3coMTAsIE1hdGguYWJzKGV4cCkpIDogMTtcbiAgY29uc3Qgc3RlcFNpemUgPSBNYXRoLnBvdygxMCwgZXhwKTtcbiAgY29uc3QgYmFzZSA9IG1pbkV4cCA+IGV4cCA/IE1hdGgucG93KDEwLCBtaW5FeHApIDogMDtcbiAgY29uc3Qgc3RhcnQgPSBNYXRoLnJvdW5kKChtaW4gLSBiYXNlKSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gIGNvbnN0IG9mZnNldCA9IE1hdGguZmxvb3IoKG1pbiAtIGJhc2UpIC8gc3RlcFNpemUgLyAxMCkgKiBzdGVwU2l6ZSAqIDEwO1xuICBsZXQgc2lnbmlmaWNhbmQgPSBNYXRoLmZsb29yKChzdGFydCAtIG9mZnNldCkgLyBNYXRoLnBvdygxMCwgZXhwKSk7XG4gIGxldCB2YWx1ZSA9IGZpbml0ZU9yRGVmYXVsdChnZW5lcmF0aW9uT3B0aW9ucy5taW4sIE1hdGgucm91bmQoKGJhc2UgKyBvZmZzZXQgKyBzaWduaWZpY2FuZCAqIE1hdGgucG93KDEwLCBleHApKSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb24pO1xuICB3aGlsZSAodmFsdWUgPCBtYXgpIHtcbiAgICB0aWNrcy5wdXNoKHt2YWx1ZSwgbWFqb3I6IGlzTWFqb3IodmFsdWUpLCBzaWduaWZpY2FuZH0pO1xuICAgIGlmIChzaWduaWZpY2FuZCA+PSAxMCkge1xuICAgICAgc2lnbmlmaWNhbmQgPSBzaWduaWZpY2FuZCA8IDE1ID8gMTUgOiAyMDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2lnbmlmaWNhbmQrKztcbiAgICB9XG4gICAgaWYgKHNpZ25pZmljYW5kID49IDIwKSB7XG4gICAgICBleHArKztcbiAgICAgIHNpZ25pZmljYW5kID0gMjtcbiAgICAgIHByZWNpc2lvbiA9IGV4cCA+PSAwID8gMSA6IHByZWNpc2lvbjtcbiAgICB9XG4gICAgdmFsdWUgPSBNYXRoLnJvdW5kKChiYXNlICsgb2Zmc2V0ICsgc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKSkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICB9XG4gIGNvbnN0IGxhc3RUaWNrID0gZmluaXRlT3JEZWZhdWx0KGdlbmVyYXRpb25PcHRpb25zLm1heCwgdmFsdWUpO1xuICB0aWNrcy5wdXNoKHt2YWx1ZTogbGFzdFRpY2ssIG1ham9yOiBpc01ham9yKGxhc3RUaWNrKSwgc2lnbmlmaWNhbmR9KTtcblxuICByZXR1cm4gdGlja3M7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvZ2FyaXRobWljU2NhbGUgZXh0ZW5kcyBTY2FsZSB7XG5cbiAgc3RhdGljIGlkID0gJ2xvZ2FyaXRobWljJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICB0aWNrczoge1xuICAgICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubG9nYXJpdGhtaWMsXG4gICAgICBtYWpvcjoge1xuICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcblxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5lbmQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgfVxuXG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IExpbmVhclNjYWxlQmFzZS5wcm90b3R5cGUucGFyc2UuYXBwbHkodGhpcywgW3JhdywgaW5kZXhdKTtcbiAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgIHRoaXMuX3plcm8gPSB0cnVlO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKSAmJiB2YWx1ZSA+IDAgPyB2YWx1ZSA6IG51bGw7XG4gIH1cblxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heCh0cnVlKTtcblxuICAgIHRoaXMubWluID0gaXNGaW5pdGUobWluKSA/IE1hdGgubWF4KDAsIG1pbikgOiBudWxsO1xuICAgIHRoaXMubWF4ID0gaXNGaW5pdGUobWF4KSA/IE1hdGgubWF4KDAsIG1heCkgOiBudWxsO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5iZWdpbkF0WmVybykge1xuICAgICAgdGhpcy5femVybyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gaWYgZGF0YSBoYXMgYDBgIGluIGl0IG9yIGBiZWdpbkF0WmVyb2AgaXMgdHJ1ZSwgbWluIChub24gemVybykgdmFsdWUgaXMgYXQgYm90dG9tXG4gICAgLy8gb2Ygc2NhbGUsIGFuZCBpdCBkb2VzIG5vdCBlcXVhbCBzdWdnZXN0ZWRNaW4sIGxvd2VyIHRoZSBtaW4gYm91bmQgYnkgb25lIGV4cC5cbiAgICBpZiAodGhpcy5femVybyAmJiB0aGlzLm1pbiAhPT0gdGhpcy5fc3VnZ2VzdGVkTWluICYmICFpc0Zpbml0ZSh0aGlzLl91c2VyTWluKSkge1xuICAgICAgdGhpcy5taW4gPSBtaW4gPT09IGNoYW5nZUV4cG9uZW50KHRoaXMubWluLCAwKSA/IGNoYW5nZUV4cG9uZW50KHRoaXMubWluLCAtMSkgOiBjaGFuZ2VFeHBvbmVudCh0aGlzLm1pbiwgMCk7XG4gICAgfVxuXG4gICAgdGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gIH1cblxuICBoYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCkge1xuICAgIGNvbnN0IHttaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCBtaW4gPSB0aGlzLm1pbjtcbiAgICBsZXQgbWF4ID0gdGhpcy5tYXg7XG5cbiAgICBjb25zdCBzZXRNaW4gPSB2ID0+IChtaW4gPSBtaW5EZWZpbmVkID8gbWluIDogdik7XG4gICAgY29uc3Qgc2V0TWF4ID0gdiA9PiAobWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IHYpO1xuXG4gICAgaWYgKG1pbiA9PT0gbWF4KSB7XG4gICAgICBpZiAobWluIDw9IDApIHsgLy8gaW5jbHVkZXMgbnVsbFxuICAgICAgICBzZXRNaW4oMSk7XG4gICAgICAgIHNldE1heCgxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRNaW4oY2hhbmdlRXhwb25lbnQobWluLCAtMSkpO1xuICAgICAgICBzZXRNYXgoY2hhbmdlRXhwb25lbnQobWF4LCArMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWluIDw9IDApIHtcbiAgICAgIHNldE1pbihjaGFuZ2VFeHBvbmVudChtYXgsIC0xKSk7XG4gICAgfVxuICAgIGlmIChtYXggPD0gMCkge1xuXG4gICAgICBzZXRNYXgoY2hhbmdlRXhwb25lbnQobWluLCArMSkpO1xuICAgIH1cblxuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICB9XG5cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuXG4gICAgY29uc3QgZ2VuZXJhdGlvbk9wdGlvbnMgPSB7XG4gICAgICBtaW46IHRoaXMuX3VzZXJNaW4sXG4gICAgICBtYXg6IHRoaXMuX3VzZXJNYXhcbiAgICB9O1xuICAgIGNvbnN0IHRpY2tzID0gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywgdGhpcyk7XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBuZWVkIHRvIHVwZGF0ZSBvdXIgbWF4IGFuZCBtaW4gZ2l2ZW4gdGhlIHRpY2sgdmFsdWVzLFxuICAgIC8vIHNpbmNlIHdlIHByb2JhYmx5IGhhdmUgZXhwYW5kZWQgdGhlIHJhbmdlIG9mIHRoZSBzY2FsZVxuICAgIGlmIChvcHRzLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgICAgX3NldE1pbkFuZE1heEJ5S2V5KHRpY2tzLCB0aGlzLCAndmFsdWUnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG5cbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1heDtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5taW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1pbjtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5tYXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgID8gJzAnXG4gICAgICA6IGZvcm1hdE51bWJlcih2YWx1ZSwgdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZSwgdGhpcy5vcHRpb25zLnRpY2tzLmZvcm1hdCk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgY29uZmlndXJlKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5taW47XG5cbiAgICBzdXBlci5jb25maWd1cmUoKTtcblxuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSBsb2cxMChzdGFydCk7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IGxvZzEwKHRoaXMubWF4KSAtIGxvZzEwKHN0YXJ0KTtcbiAgfVxuXG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gMCkge1xuICAgICAgdmFsdWUgPSB0aGlzLm1pbjtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IGlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKHZhbHVlID09PSB0aGlzLm1pblxuICAgICAgPyAwXG4gICAgICA6IChsb2cxMCh2YWx1ZSkgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG5cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IGRlY2ltYWwgPSB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCk7XG4gICAgcmV0dXJuIE1hdGgucG93KDEwLCB0aGlzLl9zdGFydFZhbHVlICsgZGVjaW1hbCAqIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG59XG4iLCAiaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4uL2NvcmUvY29yZS5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge19sb25nZXN0VGV4dCwgYWRkUm91bmRlZFJlY3RQYXRoLCByZW5kZXJUZXh0LCBfaXNQb2ludEluQXJlYX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQge0hBTEZfUEksIFRBVSwgdG9EZWdyZWVzLCB0b1JhZGlhbnMsIF9ub3JtYWxpemVBbmdsZSwgUEl9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCBMaW5lYXJTY2FsZUJhc2UgZnJvbSAnLi9zY2FsZS5saW5lYXJiYXNlLmpzJztcbmltcG9ydCBUaWNrcyBmcm9tICcuLi9jb3JlL2NvcmUudGlja3MuanMnO1xuaW1wb3J0IHt2YWx1ZU9yRGVmYXVsdCwgaXNBcnJheSwgaXNGaW5pdGUsIGNhbGxiYWNrIGFzIGNhbGxDYWxsYmFjaywgaXNOdWxsT3JVbmRlZn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtjcmVhdGVDb250ZXh0LCB0b0ZvbnQsIHRvUGFkZGluZywgdG9UUkJMQ29ybmVyc30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuXG5mdW5jdGlvbiBnZXRUaWNrQmFja2Ryb3BIZWlnaHQob3B0cykge1xuICBjb25zdCB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cbiAgaWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgb3B0cy5kaXNwbGF5KSB7XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyh0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmcpO1xuICAgIHJldHVybiB2YWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5mb250ICYmIHRpY2tPcHRzLmZvbnQuc2l6ZSwgZGVmYXVsdHMuZm9udC5zaXplKSArIHBhZGRpbmcuaGVpZ2h0O1xuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBtZWFzdXJlTGFiZWxTaXplKGN0eCwgZm9udCwgbGFiZWwpIHtcbiAgbGFiZWwgPSBpc0FycmF5KGxhYmVsKSA/IGxhYmVsIDogW2xhYmVsXTtcbiAgcmV0dXJuIHtcbiAgICB3OiBfbG9uZ2VzdFRleHQoY3R4LCBmb250LnN0cmluZywgbGFiZWwpLFxuICAgIGg6IGxhYmVsLmxlbmd0aCAqIGZvbnQubGluZUhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvcywgc2l6ZSwgbWluLCBtYXgpIHtcbiAgaWYgKGFuZ2xlID09PSBtaW4gfHwgYW5nbGUgPT09IG1heCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogcG9zIC0gKHNpemUgLyAyKSxcbiAgICAgIGVuZDogcG9zICsgKHNpemUgLyAyKVxuICAgIH07XG4gIH0gZWxzZSBpZiAoYW5nbGUgPCBtaW4gfHwgYW5nbGUgPiBtYXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHBvcyAtIHNpemUsXG4gICAgICBlbmQ6IHBvc1xuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBwb3MsXG4gICAgZW5kOiBwb3MgKyBzaXplXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGZpdCBhIHJhZGlhbCBsaW5lYXIgc2NhbGUgd2l0aCBwb2ludCBsYWJlbHNcbiAqL1xuZnVuY3Rpb24gZml0V2l0aFBvaW50TGFiZWxzKHNjYWxlKSB7XG5cbiAgLy8gUmlnaHQsIHRoaXMgaXMgcmVhbGx5IGNvbmZ1c2luZyBhbmQgdGhlcmUgaXMgYSBsb3Qgb2YgbWF0aHMgZ29pbmcgb24gaGVyZVxuICAvLyBUaGUgZ2lzdCBvZiB0aGUgcHJvYmxlbSBpcyBoZXJlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9ubm5pY2svNjk2Y2M5YzU1ZjRiMGJlYjhmZTlcbiAgLy9cbiAgLy8gUmVhY3Rpb246IGh0dHBzOi8vZGwuZHJvcGJveHVzZXJjb250ZW50LmNvbS91LzM0NjAxMzYzL3Rvb211Y2hzY2llbmNlLmdpZlxuICAvL1xuICAvLyBTb2x1dGlvbjpcbiAgLy9cbiAgLy8gV2UgYXNzdW1lIHRoZSByYWRpdXMgb2YgdGhlIHBvbHlnb24gaXMgaGFsZiB0aGUgc2l6ZSBvZiB0aGUgY2FudmFzIGF0IGZpcnN0XG4gIC8vIGF0IGVhY2ggaW5kZXggd2UgY2hlY2sgaWYgdGhlIHRleHQgb3ZlcmxhcHMuXG4gIC8vXG4gIC8vIFdoZXJlIGl0IGRvZXMsIHdlIHN0b3JlIHRoYXQgYW5nbGUgYW5kIHRoYXQgaW5kZXguXG4gIC8vXG4gIC8vIEFmdGVyIGZpbmRpbmcgdGhlIGxhcmdlc3QgaW5kZXggYW5kIGFuZ2xlIHdlIGNhbGN1bGF0ZSBob3cgbXVjaCB3ZSBuZWVkIHRvIHJlbW92ZVxuICAvLyBmcm9tIHRoZSBzaGFwZSByYWRpdXMgdG8gbW92ZSB0aGUgcG9pbnQgaW53YXJkcyBieSB0aGF0IHguXG4gIC8vXG4gIC8vIFdlIGF2ZXJhZ2UgdGhlIGxlZnQgYW5kIHJpZ2h0IGRpc3RhbmNlcyB0byBnZXQgdGhlIG1heGltdW0gc2hhcGUgcmFkaXVzIHRoYXQgY2FuIGZpdCBpbiB0aGUgYm94XG4gIC8vIGFsb25nIHdpdGggbGFiZWxzLlxuICAvL1xuICAvLyBPbmNlIHdlIGhhdmUgdGhhdCwgd2UgY2FuIGZpbmQgdGhlIGNlbnRyZSBwb2ludCBmb3IgdGhlIGNoYXJ0LCBieSB0YWtpbmcgdGhlIHggdGV4dCBwcm90cnVzaW9uXG4gIC8vIG9uIGVhY2ggc2lkZSwgcmVtb3ZpbmcgdGhhdCBmcm9tIHRoZSBzaXplLCBoYWx2aW5nIGl0IGFuZCBhZGRpbmcgdGhlIGxlZnQgeCBwcm90cnVzaW9uIHdpZHRoLlxuICAvL1xuICAvLyBUaGlzIHdpbGwgbWVhbiB3ZSBoYXZlIGEgc2hhcGUgZml0dGVkIHRvIHRoZSBjYW52YXMsIGFzIGxhcmdlIGFzIGl0IGNhbiBiZSB3aXRoIHRoZSBsYWJlbHNcbiAgLy8gYW5kIHBvc2l0aW9uIGl0IGluIHRoZSBtb3N0IHNwYWNlIGVmZmljaWVudCBtYW5uZXJcbiAgLy9cbiAgLy8gaHR0cHM6Ly9kbC5kcm9wYm94dXNlcmNvbnRlbnQuY29tL3UvMzQ2MDEzNjMveWVhaHNjaWVuY2UuZ2lmXG5cbiAgLy8gR2V0IG1heGltdW0gcmFkaXVzIG9mIHRoZSBwb2x5Z29uLiBFaXRoZXIgaGFsZiB0aGUgaGVpZ2h0IChtaW51cyB0aGUgdGV4dCB3aWR0aCkgb3IgaGFsZiB0aGUgd2lkdGguXG4gIC8vIFVzZSB0aGlzIHRvIGNhbGN1bGF0ZSB0aGUgb2Zmc2V0ICsgY2hhbmdlLiAtIE1ha2Ugc3VyZSBML1IgcHJvdHJ1c2lvbiBpcyBhdCBsZWFzdCAwIHRvIHN0b3AgaXNzdWVzIHdpdGggY2VudHJlIHBvaW50c1xuICBjb25zdCBvcmlnID0ge1xuICAgIGw6IHNjYWxlLmxlZnQgKyBzY2FsZS5fcGFkZGluZy5sZWZ0LFxuICAgIHI6IHNjYWxlLnJpZ2h0IC0gc2NhbGUuX3BhZGRpbmcucmlnaHQsXG4gICAgdDogc2NhbGUudG9wICsgc2NhbGUuX3BhZGRpbmcudG9wLFxuICAgIGI6IHNjYWxlLmJvdHRvbSAtIHNjYWxlLl9wYWRkaW5nLmJvdHRvbVxuICB9O1xuICBjb25zdCBsaW1pdHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcmlnKTtcbiAgY29uc3QgbGFiZWxTaXplcyA9IFtdO1xuICBjb25zdCBwYWRkaW5nID0gW107XG4gIGNvbnN0IHZhbHVlQ291bnQgPSBzY2FsZS5fcG9pbnRMYWJlbHMubGVuZ3RoO1xuICBjb25zdCBwb2ludExhYmVsT3B0cyA9IHNjYWxlLm9wdGlvbnMucG9pbnRMYWJlbHM7XG4gIGNvbnN0IGFkZGl0aW9uYWxBbmdsZSA9IHBvaW50TGFiZWxPcHRzLmNlbnRlclBvaW50TGFiZWxzID8gUEkgLyB2YWx1ZUNvdW50IDogMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuICAgIGNvbnN0IG9wdHMgPSBwb2ludExhYmVsT3B0cy5zZXRDb250ZXh0KHNjYWxlLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcbiAgICBwYWRkaW5nW2ldID0gb3B0cy5wYWRkaW5nO1xuICAgIGNvbnN0IHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHNjYWxlLmRyYXdpbmdBcmVhICsgcGFkZGluZ1tpXSwgYWRkaXRpb25hbEFuZ2xlKTtcbiAgICBjb25zdCBwbEZvbnQgPSB0b0ZvbnQob3B0cy5mb250KTtcbiAgICBjb25zdCB0ZXh0U2l6ZSA9IG1lYXN1cmVMYWJlbFNpemUoc2NhbGUuY3R4LCBwbEZvbnQsIHNjYWxlLl9wb2ludExhYmVsc1tpXSk7XG4gICAgbGFiZWxTaXplc1tpXSA9IHRleHRTaXplO1xuXG4gICAgY29uc3QgYW5nbGVSYWRpYW5zID0gX25vcm1hbGl6ZUFuZ2xlKHNjYWxlLmdldEluZGV4QW5nbGUoaSkgKyBhZGRpdGlvbmFsQW5nbGUpO1xuICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5yb3VuZCh0b0RlZ3JlZXMoYW5nbGVSYWRpYW5zKSk7XG4gICAgY29uc3QgaExpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi54LCB0ZXh0U2l6ZS53LCAwLCAxODApO1xuICAgIGNvbnN0IHZMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueSwgdGV4dFNpemUuaCwgOTAsIDI3MCk7XG4gICAgdXBkYXRlTGltaXRzKGxpbWl0cywgb3JpZywgYW5nbGVSYWRpYW5zLCBoTGltaXRzLCB2TGltaXRzKTtcbiAgfVxuXG4gIHNjYWxlLnNldENlbnRlclBvaW50KFxuICAgIG9yaWcubCAtIGxpbWl0cy5sLFxuICAgIGxpbWl0cy5yIC0gb3JpZy5yLFxuICAgIG9yaWcudCAtIGxpbWl0cy50LFxuICAgIGxpbWl0cy5iIC0gb3JpZy5iXG4gICk7XG5cbiAgLy8gTm93IHRoYXQgdGV4dCBzaXplIGlzIGRldGVybWluZWQsIGNvbXB1dGUgdGhlIGZ1bGwgcG9zaXRpb25zXG4gIHNjYWxlLl9wb2ludExhYmVsSXRlbXMgPSBidWlsZFBvaW50TGFiZWxJdGVtcyhzY2FsZSwgbGFiZWxTaXplcywgcGFkZGluZyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbWl0cyhsaW1pdHMsIG9yaWcsIGFuZ2xlLCBoTGltaXRzLCB2TGltaXRzKSB7XG4gIGNvbnN0IHNpbiA9IE1hdGguYWJzKE1hdGguc2luKGFuZ2xlKSk7XG4gIGNvbnN0IGNvcyA9IE1hdGguYWJzKE1hdGguY29zKGFuZ2xlKSk7XG4gIGxldCB4ID0gMDtcbiAgbGV0IHkgPSAwO1xuICBpZiAoaExpbWl0cy5zdGFydCA8IG9yaWcubCkge1xuICAgIHggPSAob3JpZy5sIC0gaExpbWl0cy5zdGFydCkgLyBzaW47XG4gICAgbGltaXRzLmwgPSBNYXRoLm1pbihsaW1pdHMubCwgb3JpZy5sIC0geCk7XG4gIH0gZWxzZSBpZiAoaExpbWl0cy5lbmQgPiBvcmlnLnIpIHtcbiAgICB4ID0gKGhMaW1pdHMuZW5kIC0gb3JpZy5yKSAvIHNpbjtcbiAgICBsaW1pdHMuciA9IE1hdGgubWF4KGxpbWl0cy5yLCBvcmlnLnIgKyB4KTtcbiAgfVxuICBpZiAodkxpbWl0cy5zdGFydCA8IG9yaWcudCkge1xuICAgIHkgPSAob3JpZy50IC0gdkxpbWl0cy5zdGFydCkgLyBjb3M7XG4gICAgbGltaXRzLnQgPSBNYXRoLm1pbihsaW1pdHMudCwgb3JpZy50IC0geSk7XG4gIH0gZWxzZSBpZiAodkxpbWl0cy5lbmQgPiBvcmlnLmIpIHtcbiAgICB5ID0gKHZMaW1pdHMuZW5kIC0gb3JpZy5iKSAvIGNvcztcbiAgICBsaW1pdHMuYiA9IE1hdGgubWF4KGxpbWl0cy5iLCBvcmlnLmIgKyB5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQb2ludExhYmVsSXRlbShzY2FsZSwgaW5kZXgsIGl0ZW1PcHRzKSB7XG4gIGNvbnN0IG91dGVyRGlzdGFuY2UgPSBzY2FsZS5kcmF3aW5nQXJlYTtcbiAgY29uc3Qge2V4dHJhLCBhZGRpdGlvbmFsQW5nbGUsIHBhZGRpbmcsIHNpemV9ID0gaXRlbU9wdHM7XG4gIGNvbnN0IHBvaW50TGFiZWxQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaW5kZXgsIG91dGVyRGlzdGFuY2UgKyBleHRyYSArIHBhZGRpbmcsIGFkZGl0aW9uYWxBbmdsZSk7XG4gIGNvbnN0IGFuZ2xlID0gTWF0aC5yb3VuZCh0b0RlZ3JlZXMoX25vcm1hbGl6ZUFuZ2xlKHBvaW50TGFiZWxQb3NpdGlvbi5hbmdsZSArIEhBTEZfUEkpKSk7XG4gIGNvbnN0IHkgPSB5Rm9yQW5nbGUocG9pbnRMYWJlbFBvc2l0aW9uLnksIHNpemUuaCwgYW5nbGUpO1xuICBjb25zdCB0ZXh0QWxpZ24gPSBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSk7XG4gIGNvbnN0IGxlZnQgPSBsZWZ0Rm9yVGV4dEFsaWduKHBvaW50TGFiZWxQb3NpdGlvbi54LCBzaXplLncsIHRleHRBbGlnbik7XG4gIHJldHVybiB7XG4gICAgLy8gaWYgdG8gZHJhdyBvciBvdmVybGFwcGVkXG4gICAgdmlzaWJsZTogdHJ1ZSxcblxuICAgIC8vIFRleHQgcG9zaXRpb25cbiAgICB4OiBwb2ludExhYmVsUG9zaXRpb24ueCxcbiAgICB5LFxuXG4gICAgLy8gVGV4dCByZW5kZXJpbmcgZGF0YVxuICAgIHRleHRBbGlnbixcblxuICAgIC8vIEJvdW5kaW5nIGJveFxuICAgIGxlZnQsXG4gICAgdG9wOiB5LFxuICAgIHJpZ2h0OiBsZWZ0ICsgc2l6ZS53LFxuICAgIGJvdHRvbTogeSArIHNpemUuaFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc05vdE92ZXJsYXBwZWQoaXRlbSwgYXJlYSkge1xuICBpZiAoIWFyZWEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCB7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfSA9IGl0ZW07XG4gIGNvbnN0IGFwZXhlc0luQXJlYSA9IF9pc1BvaW50SW5BcmVhKHt4OiBsZWZ0LCB5OiB0b3B9LCBhcmVhKSB8fCBfaXNQb2ludEluQXJlYSh7eDogbGVmdCwgeTogYm90dG9tfSwgYXJlYSkgfHxcbiAgICBfaXNQb2ludEluQXJlYSh7eDogcmlnaHQsIHk6IHRvcH0sIGFyZWEpIHx8IF9pc1BvaW50SW5BcmVhKHt4OiByaWdodCwgeTogYm90dG9tfSwgYXJlYSk7XG4gIHJldHVybiAhYXBleGVzSW5BcmVhO1xufVxuXG5mdW5jdGlvbiBidWlsZFBvaW50TGFiZWxJdGVtcyhzY2FsZSwgbGFiZWxTaXplcywgcGFkZGluZykge1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBjb25zdCB2YWx1ZUNvdW50ID0gc2NhbGUuX3BvaW50TGFiZWxzLmxlbmd0aDtcbiAgY29uc3Qgb3B0cyA9IHNjYWxlLm9wdGlvbnM7XG4gIGNvbnN0IHtjZW50ZXJQb2ludExhYmVscywgZGlzcGxheX0gPSBvcHRzLnBvaW50TGFiZWxzO1xuICBjb25zdCBpdGVtT3B0cyA9IHtcbiAgICBleHRyYTogZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG9wdHMpIC8gMixcbiAgICBhZGRpdGlvbmFsQW5nbGU6IGNlbnRlclBvaW50TGFiZWxzID8gUEkgLyB2YWx1ZUNvdW50IDogMFxuICB9O1xuICBsZXQgYXJlYTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuICAgIGl0ZW1PcHRzLnBhZGRpbmcgPSBwYWRkaW5nW2ldO1xuICAgIGl0ZW1PcHRzLnNpemUgPSBsYWJlbFNpemVzW2ldO1xuXG4gICAgY29uc3QgaXRlbSA9IGNyZWF0ZVBvaW50TGFiZWxJdGVtKHNjYWxlLCBpLCBpdGVtT3B0cyk7XG4gICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICBpZiAoZGlzcGxheSA9PT0gJ2F1dG8nKSB7XG4gICAgICBpdGVtLnZpc2libGUgPSBpc05vdE92ZXJsYXBwZWQoaXRlbSwgYXJlYSk7XG4gICAgICBpZiAoaXRlbS52aXNpYmxlKSB7XG4gICAgICAgIGFyZWEgPSBpdGVtO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaXRlbXM7XG59XG5cbmZ1bmN0aW9uIGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKSB7XG4gIGlmIChhbmdsZSA9PT0gMCB8fCBhbmdsZSA9PT0gMTgwKSB7XG4gICAgcmV0dXJuICdjZW50ZXInO1xuICB9IGVsc2UgaWYgKGFuZ2xlIDwgMTgwKSB7XG4gICAgcmV0dXJuICdsZWZ0JztcbiAgfVxuXG4gIHJldHVybiAncmlnaHQnO1xufVxuXG5mdW5jdGlvbiBsZWZ0Rm9yVGV4dEFsaWduKHgsIHcsIGFsaWduKSB7XG4gIGlmIChhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggLT0gdztcbiAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4IC09ICh3IC8gMik7XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5cbmZ1bmN0aW9uIHlGb3JBbmdsZSh5LCBoLCBhbmdsZSkge1xuICBpZiAoYW5nbGUgPT09IDkwIHx8IGFuZ2xlID09PSAyNzApIHtcbiAgICB5IC09IChoIC8gMik7XG4gIH0gZWxzZSBpZiAoYW5nbGUgPiAyNzAgfHwgYW5nbGUgPCA5MCkge1xuICAgIHkgLT0gaDtcbiAgfVxuICByZXR1cm4geTtcbn1cblxuZnVuY3Rpb24gZHJhd1BvaW50TGFiZWxCb3goY3R4LCBvcHRzLCBpdGVtKSB7XG4gIGNvbnN0IHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219ID0gaXRlbTtcbiAgY29uc3Qge2JhY2tkcm9wQ29sb3J9ID0gb3B0cztcblxuICBpZiAoIWlzTnVsbE9yVW5kZWYoYmFja2Ryb3BDb2xvcikpIHtcbiAgICBjb25zdCBib3JkZXJSYWRpdXMgPSB0b1RSQkxDb3JuZXJzKG9wdHMuYm9yZGVyUmFkaXVzKTtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdHMuYmFja2Ryb3BQYWRkaW5nKTtcbiAgICBjdHguZmlsbFN0eWxlID0gYmFja2Ryb3BDb2xvcjtcblxuICAgIGNvbnN0IGJhY2tkcm9wTGVmdCA9IGxlZnQgLSBwYWRkaW5nLmxlZnQ7XG4gICAgY29uc3QgYmFja2Ryb3BUb3AgPSB0b3AgLSBwYWRkaW5nLnRvcDtcbiAgICBjb25zdCBiYWNrZHJvcFdpZHRoID0gcmlnaHQgLSBsZWZ0ICsgcGFkZGluZy53aWR0aDtcbiAgICBjb25zdCBiYWNrZHJvcEhlaWdodCA9IGJvdHRvbSAtIHRvcCArIHBhZGRpbmcuaGVpZ2h0O1xuXG4gICAgaWYgKE9iamVjdC52YWx1ZXMoYm9yZGVyUmFkaXVzKS5zb21lKHYgPT4gdiAhPT0gMCkpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgeDogYmFja2Ryb3BMZWZ0LFxuICAgICAgICB5OiBiYWNrZHJvcFRvcCxcbiAgICAgICAgdzogYmFja2Ryb3BXaWR0aCxcbiAgICAgICAgaDogYmFja2Ryb3BIZWlnaHQsXG4gICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgfSk7XG4gICAgICBjdHguZmlsbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHguZmlsbFJlY3QoYmFja2Ryb3BMZWZ0LCBiYWNrZHJvcFRvcCwgYmFja2Ryb3BXaWR0aCwgYmFja2Ryb3BIZWlnaHQpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3UG9pbnRMYWJlbHMoc2NhbGUsIGxhYmVsQ291bnQpIHtcbiAgY29uc3Qge2N0eCwgb3B0aW9uczoge3BvaW50TGFiZWxzfX0gPSBzY2FsZTtcblxuICBmb3IgKGxldCBpID0gbGFiZWxDb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgaXRlbSA9IHNjYWxlLl9wb2ludExhYmVsSXRlbXNbaV07XG4gICAgaWYgKCFpdGVtLnZpc2libGUpIHtcbiAgICAgIC8vIG92ZXJsYXBwaW5nXG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qgb3B0c0F0SW5kZXggPSBwb2ludExhYmVscy5zZXRDb250ZXh0KHNjYWxlLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcbiAgICBkcmF3UG9pbnRMYWJlbEJveChjdHgsIG9wdHNBdEluZGV4LCBpdGVtKTtcbiAgICBjb25zdCBwbEZvbnQgPSB0b0ZvbnQob3B0c0F0SW5kZXguZm9udCk7XG4gICAgY29uc3Qge3gsIHksIHRleHRBbGlnbn0gPSBpdGVtO1xuXG4gICAgcmVuZGVyVGV4dChcbiAgICAgIGN0eCxcbiAgICAgIHNjYWxlLl9wb2ludExhYmVsc1tpXSxcbiAgICAgIHgsXG4gICAgICB5ICsgKHBsRm9udC5saW5lSGVpZ2h0IC8gMiksXG4gICAgICBwbEZvbnQsXG4gICAgICB7XG4gICAgICAgIGNvbG9yOiBvcHRzQXRJbmRleC5jb2xvcixcbiAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZSdcbiAgICAgIH1cbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhdGhSYWRpdXNMaW5lKHNjYWxlLCByYWRpdXMsIGNpcmN1bGFyLCBsYWJlbENvdW50KSB7XG4gIGNvbnN0IHtjdHh9ID0gc2NhbGU7XG4gIGlmIChjaXJjdWxhcikge1xuICAgIC8vIERyYXcgY2lyY3VsYXIgYXJjcyBiZXR3ZWVuIHRoZSBwb2ludHNcbiAgICBjdHguYXJjKHNjYWxlLnhDZW50ZXIsIHNjYWxlLnlDZW50ZXIsIHJhZGl1cywgMCwgVEFVKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEcmF3IHN0cmFpZ2h0IGxpbmVzIGNvbm5lY3RpbmcgZWFjaCBpbmRleFxuICAgIGxldCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbigwLCByYWRpdXMpO1xuICAgIGN0eC5tb3ZlVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsYWJlbENvdW50OyBpKyspIHtcbiAgICAgIHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHJhZGl1cyk7XG4gICAgICBjdHgubGluZVRvKHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd1JhZGl1c0xpbmUoc2NhbGUsIGdyaWRMaW5lT3B0cywgcmFkaXVzLCBsYWJlbENvdW50LCBib3JkZXJPcHRzKSB7XG4gIGNvbnN0IGN0eCA9IHNjYWxlLmN0eDtcbiAgY29uc3QgY2lyY3VsYXIgPSBncmlkTGluZU9wdHMuY2lyY3VsYXI7XG5cbiAgY29uc3Qge2NvbG9yLCBsaW5lV2lkdGh9ID0gZ3JpZExpbmVPcHRzO1xuXG4gIGlmICgoIWNpcmN1bGFyICYmICFsYWJlbENvdW50KSB8fCAhY29sb3IgfHwgIWxpbmVXaWR0aCB8fCByYWRpdXMgPCAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY3R4LnNhdmUoKTtcbiAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gIGN0eC5zZXRMaW5lRGFzaChib3JkZXJPcHRzLmRhc2ggfHwgW10pO1xuICBjdHgubGluZURhc2hPZmZzZXQgPSBib3JkZXJPcHRzLmRhc2hPZmZzZXQ7XG5cbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBwYXRoUmFkaXVzTGluZShzY2FsZSwgcmFkaXVzLCBjaXJjdWxhciwgbGFiZWxDb3VudCk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LnN0cm9rZSgpO1xuICBjdHgucmVzdG9yZSgpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQb2ludExhYmVsQ29udGV4dChwYXJlbnQsIGluZGV4LCBsYWJlbCkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICBsYWJlbCxcbiAgICBpbmRleCxcbiAgICB0eXBlOiAncG9pbnRMYWJlbCdcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhZGlhbExpbmVhclNjYWxlIGV4dGVuZHMgTGluZWFyU2NhbGVCYXNlIHtcblxuICBzdGF0aWMgaWQgPSAncmFkaWFsTGluZWFyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkaXNwbGF5OiB0cnVlLFxuXG4gICAgLy8gQm9vbGVhbiAtIFdoZXRoZXIgdG8gYW5pbWF0ZSBzY2FsaW5nIHRoZSBjaGFydCBmcm9tIHRoZSBjZW50cmVcbiAgICBhbmltYXRlOiB0cnVlLFxuICAgIHBvc2l0aW9uOiAnY2hhcnRBcmVhJyxcblxuICAgIGFuZ2xlTGluZXM6IHtcbiAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICBib3JkZXJEYXNoOiBbXSxcbiAgICAgIGJvcmRlckRhc2hPZmZzZXQ6IDAuMFxuICAgIH0sXG5cbiAgICBncmlkOiB7XG4gICAgICBjaXJjdWxhcjogZmFsc2VcbiAgICB9LFxuXG4gICAgc3RhcnRBbmdsZTogMCxcblxuICAgIC8vIGxhYmVsIHNldHRpbmdzXG4gICAgdGlja3M6IHtcbiAgICAgIC8vIEJvb2xlYW4gLSBTaG93IGEgYmFja2Ryb3AgdG8gdGhlIHNjYWxlIGxhYmVsXG4gICAgICBzaG93TGFiZWxCYWNrZHJvcDogdHJ1ZSxcblxuICAgICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubnVtZXJpY1xuICAgIH0sXG5cbiAgICBwb2ludExhYmVsczoge1xuICAgICAgYmFja2Ryb3BDb2xvcjogdW5kZWZpbmVkLFxuXG4gICAgICAvLyBOdW1iZXIgLSBUaGUgYmFja2Ryb3AgcGFkZGluZyBhYm92ZSAmIGJlbG93IHRoZSBsYWJlbCBpbiBwaXhlbHNcbiAgICAgIGJhY2tkcm9wUGFkZGluZzogMixcblxuICAgICAgLy8gQm9vbGVhbiAtIGlmIHRydWUsIHNob3cgcG9pbnQgbGFiZWxzXG4gICAgICBkaXNwbGF5OiB0cnVlLFxuXG4gICAgICAvLyBOdW1iZXIgLSBQb2ludCBsYWJlbCBmb250IHNpemUgaW4gcGl4ZWxzXG4gICAgICBmb250OiB7XG4gICAgICAgIHNpemU6IDEwXG4gICAgICB9LFxuXG4gICAgICAvLyBGdW5jdGlvbiAtIFVzZWQgdG8gY29udmVydCBwb2ludCBsYWJlbHNcbiAgICAgIGNhbGxiYWNrKGxhYmVsKSB7XG4gICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgIH0sXG5cbiAgICAgIC8vIE51bWJlciAtIEFkZGl0aW9ubCBwYWRkaW5nIGJldHdlZW4gc2NhbGUgYW5kIHBvaW50TGFiZWxcbiAgICAgIHBhZGRpbmc6IDUsXG5cbiAgICAgIC8vIEJvb2xlYW4gLSBpZiB0cnVlLCBjZW50ZXIgcG9pbnQgbGFiZWxzIHRvIHNsaWNlcyBpbiBwb2xhciBjaGFydFxuICAgICAgY2VudGVyUG9pbnRMYWJlbHM6IGZhbHNlXG4gICAgfVxuICB9O1xuXG4gIHN0YXRpYyBkZWZhdWx0Um91dGVzID0ge1xuICAgICdhbmdsZUxpbmVzLmNvbG9yJzogJ2JvcmRlckNvbG9yJyxcbiAgICAncG9pbnRMYWJlbHMuY29sb3InOiAnY29sb3InLFxuICAgICd0aWNrcy5jb2xvcic6ICdjb2xvcidcbiAgfTtcblxuICBzdGF0aWMgZGVzY3JpcHRvcnMgPSB7XG4gICAgYW5nbGVMaW5lczoge1xuICAgICAgX2ZhbGxiYWNrOiAnZ3JpZCdcbiAgICB9XG4gIH07XG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcblxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMueENlbnRlciA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnlDZW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5kcmF3aW5nQXJlYSA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge3N0cmluZ1tdfSAqL1xuICAgIHRoaXMuX3BvaW50TGFiZWxzID0gW107XG4gICAgdGhpcy5fcG9pbnRMYWJlbEl0ZW1zID0gW107XG4gIH1cblxuICBzZXREaW1lbnNpb25zKCkge1xuICAgIC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXG4gICAgY29uc3QgcGFkZGluZyA9IHRoaXMuX3BhZGRpbmcgPSB0b1BhZGRpbmcoZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KHRoaXMub3B0aW9ucykgLyAyKTtcbiAgICBjb25zdCB3ID0gdGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGggLSBwYWRkaW5nLndpZHRoO1xuICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0IC0gcGFkZGluZy5oZWlnaHQ7XG4gICAgdGhpcy54Q2VudGVyID0gTWF0aC5mbG9vcih0aGlzLmxlZnQgKyB3IC8gMiArIHBhZGRpbmcubGVmdCk7XG4gICAgdGhpcy55Q2VudGVyID0gTWF0aC5mbG9vcih0aGlzLnRvcCArIGggLyAyICsgcGFkZGluZy50b3ApO1xuICAgIHRoaXMuZHJhd2luZ0FyZWEgPSBNYXRoLmZsb29yKE1hdGgubWluKHcsIGgpIC8gMik7XG4gIH1cblxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heChmYWxzZSk7XG5cbiAgICB0aGlzLm1pbiA9IGlzRmluaXRlKG1pbikgJiYgIWlzTmFOKG1pbikgPyBtaW4gOiAwO1xuICAgIHRoaXMubWF4ID0gaXNGaW5pdGUobWF4KSAmJiAhaXNOYU4obWF4KSA/IG1heCA6IDA7XG5cbiAgICAvLyBDb21tb24gYmFzZSBpbXBsZW1lbnRhdGlvbiB0byBoYW5kbGUgbWluLCBtYXgsIGJlZ2luQXRaZXJvXG4gICAgdGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGlja3MgYmFzZWQgb24gdGhlIHNjYWxlIGRpbWVuc2lvblxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5kcmF3aW5nQXJlYSAvIGdldFRpY2tCYWNrZHJvcEhlaWdodCh0aGlzLm9wdGlvbnMpKTtcbiAgfVxuXG4gIGdlbmVyYXRlVGlja0xhYmVscyh0aWNrcykge1xuICAgIExpbmVhclNjYWxlQmFzZS5wcm90b3R5cGUuZ2VuZXJhdGVUaWNrTGFiZWxzLmNhbGwodGhpcywgdGlja3MpO1xuXG4gICAgLy8gUG9pbnQgbGFiZWxzXG4gICAgdGhpcy5fcG9pbnRMYWJlbHMgPSB0aGlzLmdldExhYmVscygpXG4gICAgICAubWFwKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBjYWxsQ2FsbGJhY2sodGhpcy5vcHRpb25zLnBvaW50TGFiZWxzLmNhbGxiYWNrLCBbdmFsdWUsIGluZGV4XSwgdGhpcyk7XG4gICAgICAgIHJldHVybiBsYWJlbCB8fCBsYWJlbCA9PT0gMCA/IGxhYmVsIDogJyc7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcigodiwgaSkgPT4gdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSk7XG4gIH1cblxuICBmaXQoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcblxuICAgIGlmIChvcHRzLmRpc3BsYXkgJiYgb3B0cy5wb2ludExhYmVscy5kaXNwbGF5KSB7XG4gICAgICBmaXRXaXRoUG9pbnRMYWJlbHModGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Q2VudGVyUG9pbnQoMCwgMCwgMCwgMCk7XG4gICAgfVxuICB9XG5cbiAgc2V0Q2VudGVyUG9pbnQobGVmdE1vdmVtZW50LCByaWdodE1vdmVtZW50LCB0b3BNb3ZlbWVudCwgYm90dG9tTW92ZW1lbnQpIHtcbiAgICB0aGlzLnhDZW50ZXIgKz0gTWF0aC5mbG9vcigobGVmdE1vdmVtZW50IC0gcmlnaHRNb3ZlbWVudCkgLyAyKTtcbiAgICB0aGlzLnlDZW50ZXIgKz0gTWF0aC5mbG9vcigodG9wTW92ZW1lbnQgLSBib3R0b21Nb3ZlbWVudCkgLyAyKTtcbiAgICB0aGlzLmRyYXdpbmdBcmVhIC09IE1hdGgubWluKHRoaXMuZHJhd2luZ0FyZWEgLyAyLCBNYXRoLm1heChsZWZ0TW92ZW1lbnQsIHJpZ2h0TW92ZW1lbnQsIHRvcE1vdmVtZW50LCBib3R0b21Nb3ZlbWVudCkpO1xuICB9XG5cbiAgZ2V0SW5kZXhBbmdsZShpbmRleCkge1xuICAgIGNvbnN0IGFuZ2xlTXVsdGlwbGllciA9IFRBVSAvICh0aGlzLl9wb2ludExhYmVscy5sZW5ndGggfHwgMSk7XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHRoaXMub3B0aW9ucy5zdGFydEFuZ2xlIHx8IDA7XG5cbiAgICByZXR1cm4gX25vcm1hbGl6ZUFuZ2xlKGluZGV4ICogYW5nbGVNdWx0aXBsaWVyICsgdG9SYWRpYW5zKHN0YXJ0QW5nbGUpKTtcbiAgfVxuXG4gIGdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgIC8vIFRha2UgaW50byBhY2NvdW50IGhhbGYgZm9udCBzaXplICsgdGhlIHlQYWRkaW5nIG9mIHRoZSB0b3AgdmFsdWVcbiAgICBjb25zdCBzY2FsaW5nRmFjdG9yID0gdGhpcy5kcmF3aW5nQXJlYSAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIHJldHVybiAodGhpcy5tYXggLSB2YWx1ZSkgKiBzY2FsaW5nRmFjdG9yO1xuICAgIH1cbiAgICByZXR1cm4gKHZhbHVlIC0gdGhpcy5taW4pICogc2NhbGluZ0ZhY3RvcjtcbiAgfVxuXG4gIGdldFZhbHVlRm9yRGlzdGFuY2VGcm9tQ2VudGVyKGRpc3RhbmNlKSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYoZGlzdGFuY2UpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgIGNvbnN0IHNjYWxlZERpc3RhbmNlID0gZGlzdGFuY2UgLyAodGhpcy5kcmF3aW5nQXJlYSAvICh0aGlzLm1heCAtIHRoaXMubWluKSk7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5yZXZlcnNlID8gdGhpcy5tYXggLSBzY2FsZWREaXN0YW5jZSA6IHRoaXMubWluICsgc2NhbGVkRGlzdGFuY2U7XG4gIH1cblxuICBnZXRQb2ludExhYmVsQ29udGV4dChpbmRleCkge1xuICAgIGNvbnN0IHBvaW50TGFiZWxzID0gdGhpcy5fcG9pbnRMYWJlbHMgfHwgW107XG5cbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHBvaW50TGFiZWxzLmxlbmd0aCkge1xuICAgICAgY29uc3QgcG9pbnRMYWJlbCA9IHBvaW50TGFiZWxzW2luZGV4XTtcbiAgICAgIHJldHVybiBjcmVhdGVQb2ludExhYmVsQ29udGV4dCh0aGlzLmdldENvbnRleHQoKSwgaW5kZXgsIHBvaW50TGFiZWwpO1xuICAgIH1cbiAgfVxuXG4gIGdldFBvaW50UG9zaXRpb24oaW5kZXgsIGRpc3RhbmNlRnJvbUNlbnRlciwgYWRkaXRpb25hbEFuZ2xlID0gMCkge1xuICAgIGNvbnN0IGFuZ2xlID0gdGhpcy5nZXRJbmRleEFuZ2xlKGluZGV4KSAtIEhBTEZfUEkgKyBhZGRpdGlvbmFsQW5nbGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IE1hdGguY29zKGFuZ2xlKSAqIGRpc3RhbmNlRnJvbUNlbnRlciArIHRoaXMueENlbnRlcixcbiAgICAgIHk6IE1hdGguc2luKGFuZ2xlKSAqIGRpc3RhbmNlRnJvbUNlbnRlciArIHRoaXMueUNlbnRlcixcbiAgICAgIGFuZ2xlXG4gICAgfTtcbiAgfVxuXG4gIGdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpbmRleCwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQb2ludFBvc2l0aW9uKGluZGV4LCB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKSk7XG4gIH1cblxuICBnZXRCYXNlUG9zaXRpb24oaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaW5kZXggfHwgMCwgdGhpcy5nZXRCYXNlVmFsdWUoKSk7XG4gIH1cblxuICBnZXRQb2ludExhYmVsUG9zaXRpb24oaW5kZXgpIHtcbiAgICBjb25zdCB7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfSA9IHRoaXMuX3BvaW50TGFiZWxJdGVtc1tpbmRleF07XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQsXG4gICAgICB0b3AsXG4gICAgICByaWdodCxcbiAgICAgIGJvdHRvbSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdCYWNrZ3JvdW5kKCkge1xuICAgIGNvbnN0IHtiYWNrZ3JvdW5kQ29sb3IsIGdyaWQ6IHtjaXJjdWxhcn19ID0gdGhpcy5vcHRpb25zO1xuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHBhdGhSYWRpdXNMaW5lKHRoaXMsIHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGhpcy5fZW5kVmFsdWUpLCBjaXJjdWxhciwgdGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBjdHguZmlsbCgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd0dyaWQoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7YW5nbGVMaW5lcywgZ3JpZCwgYm9yZGVyfSA9IG9wdHM7XG4gICAgY29uc3QgbGFiZWxDb3VudCA9IHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aDtcblxuICAgIGxldCBpLCBvZmZzZXQsIHBvc2l0aW9uO1xuXG4gICAgaWYgKG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xuICAgICAgZHJhd1BvaW50TGFiZWxzKHRoaXMsIGxhYmVsQ291bnQpO1xuICAgIH1cblxuICAgIGlmIChncmlkLmRpc3BsYXkpIHtcbiAgICAgIHRoaXMudGlja3MuZm9yRWFjaCgodGljaywgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAwIHx8IChpbmRleCA9PT0gMCAmJiB0aGlzLm1pbiA8IDApKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aWNrLnZhbHVlKTtcbiAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KGluZGV4KTtcbiAgICAgICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGdyaWQuc2V0Q29udGV4dChjb250ZXh0KTtcbiAgICAgICAgICBjb25zdCBvcHRzQXRJbmRleEJvcmRlciA9IGJvcmRlci5zZXRDb250ZXh0KGNvbnRleHQpO1xuXG4gICAgICAgICAgZHJhd1JhZGl1c0xpbmUodGhpcywgb3B0c0F0SW5kZXgsIG9mZnNldCwgbGFiZWxDb3VudCwgb3B0c0F0SW5kZXhCb3JkZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYW5nbGVMaW5lcy5kaXNwbGF5KSB7XG4gICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICBmb3IgKGkgPSBsYWJlbENvdW50IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBhbmdsZUxpbmVzLnNldENvbnRleHQodGhpcy5nZXRQb2ludExhYmVsQ29udGV4dChpKSk7XG4gICAgICAgIGNvbnN0IHtjb2xvciwgbGluZVdpZHRofSA9IG9wdHNBdEluZGV4O1xuXG4gICAgICAgIGlmICghbGluZVdpZHRoIHx8ICFjb2xvcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG5cbiAgICAgICAgY3R4LnNldExpbmVEYXNoKG9wdHNBdEluZGV4LmJvcmRlckRhc2gpO1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBvcHRzQXRJbmRleC5ib3JkZXJEYXNoT2Zmc2V0O1xuXG4gICAgICAgIG9mZnNldCA9IHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUob3B0cy5yZXZlcnNlID8gdGhpcy5taW4gOiB0aGlzLm1heCk7XG4gICAgICAgIHBvc2l0aW9uID0gdGhpcy5nZXRQb2ludFBvc2l0aW9uKGksIG9mZnNldCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLnhDZW50ZXIsIHRoaXMueUNlbnRlcik7XG4gICAgICAgIGN0eC5saW5lVG8ocG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd0JvcmRlcigpIHt9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdMYWJlbHMoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cbiAgICBpZiAoIXRpY2tPcHRzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydEFuZ2xlID0gdGhpcy5nZXRJbmRleEFuZ2xlKDApO1xuICAgIGxldCBvZmZzZXQsIHdpZHRoO1xuXG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgudHJhbnNsYXRlKHRoaXMueENlbnRlciwgdGhpcy55Q2VudGVyKTtcbiAgICBjdHgucm90YXRlKHN0YXJ0QW5nbGUpO1xuICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICB0aGlzLnRpY2tzLmZvckVhY2goKHRpY2ssIGluZGV4KSA9PiB7XG4gICAgICBpZiAoKGluZGV4ID09PSAwICYmIHRoaXMubWluID49IDApICYmICFvcHRzLnJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvcHRzQXRJbmRleCA9IHRpY2tPcHRzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgICBjb25zdCB0aWNrRm9udCA9IHRvRm9udChvcHRzQXRJbmRleC5mb250KTtcbiAgICAgIG9mZnNldCA9IHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGhpcy50aWNrc1tpbmRleF0udmFsdWUpO1xuXG4gICAgICBpZiAob3B0c0F0SW5kZXguc2hvd0xhYmVsQmFja2Ryb3ApIHtcbiAgICAgICAgY3R4LmZvbnQgPSB0aWNrRm9udC5zdHJpbmc7XG4gICAgICAgIHdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KHRpY2subGFiZWwpLndpZHRoO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0c0F0SW5kZXguYmFja2Ryb3BDb2xvcjtcblxuICAgICAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdHNBdEluZGV4LmJhY2tkcm9wUGFkZGluZyk7XG4gICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAtd2lkdGggLyAyIC0gcGFkZGluZy5sZWZ0LFxuICAgICAgICAgIC1vZmZzZXQgLSB0aWNrRm9udC5zaXplIC8gMiAtIHBhZGRpbmcudG9wLFxuICAgICAgICAgIHdpZHRoICsgcGFkZGluZy53aWR0aCxcbiAgICAgICAgICB0aWNrRm9udC5zaXplICsgcGFkZGluZy5oZWlnaHRcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmVuZGVyVGV4dChjdHgsIHRpY2subGFiZWwsIDAsIC1vZmZzZXQsIHRpY2tGb250LCB7XG4gICAgICAgIGNvbG9yOiBvcHRzQXRJbmRleC5jb2xvcixcbiAgICAgICAgc3Ryb2tlQ29sb3I6IG9wdHNBdEluZGV4LnRleHRTdHJva2VDb2xvcixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IG9wdHNBdEluZGV4LnRleHRTdHJva2VXaWR0aCxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3VGl0bGUoKSB7fVxufVxuIiwgImltcG9ydCBhZGFwdGVycyBmcm9tICcuLi9jb3JlL2NvcmUuYWRhcHRlcnMuanMnO1xuaW1wb3J0IHtjYWxsYmFjayBhcyBjYWxsLCBpc0Zpbml0ZSwgaXNOdWxsT3JVbmRlZiwgbWVyZ2VJZiwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7dG9SYWRpYW5zLCBpc051bWJlciwgX2xpbWl0VmFsdWV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCBTY2FsZSBmcm9tICcuLi9jb3JlL2NvcmUuc2NhbGUuanMnO1xuaW1wb3J0IHtfYXJyYXlVbmlxdWUsIF9maWx0ZXJCZXR3ZWVuLCBfbG9va3VwfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29sbGVjdGlvbi5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL2NvcmUvY29yZS5hZGFwdGVycy5qcycpLlRpbWVVbml0IH0gVW5pdFxuICogQHR5cGVkZWYge3tjb21tb246IGJvb2xlYW4sIHNpemU6IG51bWJlciwgc3RlcHM/OiBudW1iZXJ9fSBJbnRlcnZhbFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL2NvcmUvY29yZS5hZGFwdGVycy5qcycpLkRhdGVBZGFwdGVyIH0gRGF0ZUFkYXB0ZXJcbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8VW5pdCwgSW50ZXJ2YWw+fVxuICovXG5jb25zdCBJTlRFUlZBTFMgPSB7XG4gIG1pbGxpc2Vjb25kOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAxLCBzdGVwczogMTAwMH0sXG4gIHNlY29uZDoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMTAwMCwgc3RlcHM6IDYwfSxcbiAgbWludXRlOiB7Y29tbW9uOiB0cnVlLCBzaXplOiA2MDAwMCwgc3RlcHM6IDYwfSxcbiAgaG91cjoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMzYwMDAwMCwgc3RlcHM6IDI0fSxcbiAgZGF5OiB7Y29tbW9uOiB0cnVlLCBzaXplOiA4NjQwMDAwMCwgc3RlcHM6IDMwfSxcbiAgd2Vlazoge2NvbW1vbjogZmFsc2UsIHNpemU6IDYwNDgwMDAwMCwgc3RlcHM6IDR9LFxuICBtb250aDoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMi42MjhlOSwgc3RlcHM6IDEyfSxcbiAgcXVhcnRlcjoge2NvbW1vbjogZmFsc2UsIHNpemU6IDcuODg0ZTksIHN0ZXBzOiA0fSxcbiAgeWVhcjoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMy4xNTRlMTB9XG59O1xuXG4vKipcbiAqIEB0eXBlIHtVbml0W119XG4gKi9cbmNvbnN0IFVOSVRTID0gLyoqIEB0eXBlIFVuaXRbXSAqLyAvKiAjX19QVVJFX18gKi8gKE9iamVjdC5rZXlzKElOVEVSVkFMUykpO1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcGFyYW0ge251bWJlcn0gYlxuICovXG5mdW5jdGlvbiBzb3J0ZXIoYSwgYikge1xuICByZXR1cm4gYSAtIGI7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaW1lU2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0geyp9IGlucHV0XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlKHNjYWxlLCBpbnB1dCkge1xuICBpZiAoaXNOdWxsT3JVbmRlZihpbnB1dCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcbiAgY29uc3Qge3BhcnNlciwgcm91bmQsIGlzb1dlZWtkYXl9ID0gc2NhbGUuX3BhcnNlT3B0cztcbiAgbGV0IHZhbHVlID0gaW5wdXQ7XG5cbiAgaWYgKHR5cGVvZiBwYXJzZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YWx1ZSA9IHBhcnNlcih2YWx1ZSk7XG4gIH1cblxuICAvLyBPbmx5IHBhcnNlIGlmIGl0J3Mgbm90IGEgdGltZXN0YW1wIGFscmVhZHlcbiAgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IHR5cGVvZiBwYXJzZXIgPT09ICdzdHJpbmcnXG4gICAgICA/IGFkYXB0ZXIucGFyc2UodmFsdWUsIC8qKiBAdHlwZSB7VW5pdH0gKi8gKHBhcnNlcikpXG4gICAgICA6IGFkYXB0ZXIucGFyc2UodmFsdWUpO1xuICB9XG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAocm91bmQpIHtcbiAgICB2YWx1ZSA9IHJvdW5kID09PSAnd2VlaycgJiYgKGlzTnVtYmVyKGlzb1dlZWtkYXkpIHx8IGlzb1dlZWtkYXkgPT09IHRydWUpXG4gICAgICA/IGFkYXB0ZXIuc3RhcnRPZih2YWx1ZSwgJ2lzb1dlZWsnLCBpc29XZWVrZGF5KVxuICAgICAgOiBhZGFwdGVyLnN0YXJ0T2YodmFsdWUsIHJvdW5kKTtcbiAgfVxuXG4gIHJldHVybiArdmFsdWU7XG59XG5cbi8qKlxuICogRmlndXJlcyBvdXQgd2hhdCB1bml0IHJlc3VsdHMgaW4gYW4gYXBwcm9wcmlhdGUgbnVtYmVyIG9mIGF1dG8tZ2VuZXJhdGVkIHRpY2tzXG4gKiBAcGFyYW0ge1VuaXR9IG1pblVuaXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBjYXBhY2l0eVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKG1pblVuaXQsIG1pbiwgbWF4LCBjYXBhY2l0eSkge1xuICBjb25zdCBpbGVuID0gVU5JVFMubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpIDwgaWxlbiAtIDE7ICsraSkge1xuICAgIGNvbnN0IGludGVydmFsID0gSU5URVJWQUxTW1VOSVRTW2ldXTtcbiAgICBjb25zdCBmYWN0b3IgPSBpbnRlcnZhbC5zdGVwcyA/IGludGVydmFsLnN0ZXBzIDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG5cbiAgICBpZiAoaW50ZXJ2YWwuY29tbW9uICYmIE1hdGguY2VpbCgobWF4IC0gbWluKSAvIChmYWN0b3IgKiBpbnRlcnZhbC5zaXplKSkgPD0gY2FwYWNpdHkpIHtcbiAgICAgIHJldHVybiBVTklUU1tpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gVU5JVFNbaWxlbiAtIDFdO1xufVxuXG4vKipcbiAqIEZpZ3VyZXMgb3V0IHdoYXQgdW5pdCB0byBmb3JtYXQgYSBzZXQgb2YgdGlja3Mgd2l0aFxuICogQHBhcmFtIHtUaW1lU2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtVGlja3NcbiAqIEBwYXJhbSB7VW5pdH0gbWluVW5pdFxuICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICogQHJldHVybiB7VW5pdH1cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcoc2NhbGUsIG51bVRpY2tzLCBtaW5Vbml0LCBtaW4sIG1heCkge1xuICBmb3IgKGxldCBpID0gVU5JVFMubGVuZ3RoIC0gMTsgaSA+PSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpLS0pIHtcbiAgICBjb25zdCB1bml0ID0gVU5JVFNbaV07XG4gICAgaWYgKElOVEVSVkFMU1t1bml0XS5jb21tb24gJiYgc2NhbGUuX2FkYXB0ZXIuZGlmZihtYXgsIG1pbiwgdW5pdCkgPj0gbnVtVGlja3MgLSAxKSB7XG4gICAgICByZXR1cm4gdW5pdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gVU5JVFNbbWluVW5pdCA/IFVOSVRTLmluZGV4T2YobWluVW5pdCkgOiAwXTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VuaXR9IHVuaXRcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lTWFqb3JVbml0KHVuaXQpIHtcbiAgZm9yIChsZXQgaSA9IFVOSVRTLmluZGV4T2YodW5pdCkgKyAxLCBpbGVuID0gVU5JVFMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgaWYgKElOVEVSVkFMU1tVTklUU1tpXV0uY29tbW9uKSB7XG4gICAgICByZXR1cm4gVU5JVFNbaV07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IHRpY2tzXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZVxuICogQHBhcmFtIHtudW1iZXJbXX0gW3RpbWVzdGFtcHNdIC0gaWYgZGVmaW5lZCwgc25hcCB0byB0aGVzZSB0aW1lc3RhbXBzXG4gKi9cbmZ1bmN0aW9uIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpIHtcbiAgaWYgKCF0aW1lc3RhbXBzKSB7XG4gICAgdGlja3NbdGltZV0gPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgY29uc3Qge2xvLCBoaX0gPSBfbG9va3VwKHRpbWVzdGFtcHMsIHRpbWUpO1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IHRpbWVzdGFtcHNbbG9dID49IHRpbWUgPyB0aW1lc3RhbXBzW2xvXSA6IHRpbWVzdGFtcHNbaGldO1xuICAgIHRpY2tzW3RpbWVzdGFtcF0gPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaW1lU2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge29iamVjdFtdfSB0aWNrc1xuICogQHBhcmFtIHtvYmplY3R9IG1hcFxuICogQHBhcmFtIHtVbml0fSBtYWpvclVuaXRcbiAqIEByZXR1cm4ge29iamVjdFtdfVxuICovXG5mdW5jdGlvbiBzZXRNYWpvclRpY2tzKHNjYWxlLCB0aWNrcywgbWFwLCBtYWpvclVuaXQpIHtcbiAgY29uc3QgYWRhcHRlciA9IHNjYWxlLl9hZGFwdGVyO1xuICBjb25zdCBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YodGlja3NbMF0udmFsdWUsIG1ham9yVW5pdCk7XG4gIGNvbnN0IGxhc3QgPSB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZTtcbiAgbGV0IG1ham9yLCBpbmRleDtcblxuICBmb3IgKG1ham9yID0gZmlyc3Q7IG1ham9yIDw9IGxhc3Q7IG1ham9yID0gK2FkYXB0ZXIuYWRkKG1ham9yLCAxLCBtYWpvclVuaXQpKSB7XG4gICAgaW5kZXggPSBtYXBbbWFqb3JdO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB0aWNrc1tpbmRleF0ubWFqb3IgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGlja3M7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaW1lU2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge251bWJlcltdfSB2YWx1ZXNcbiAqIEBwYXJhbSB7VW5pdHx1bmRlZmluZWR9IFttYWpvclVuaXRdXG4gKiBAcmV0dXJuIHtvYmplY3RbXX1cbiAqL1xuZnVuY3Rpb24gdGlja3NGcm9tVGltZXN0YW1wcyhzY2FsZSwgdmFsdWVzLCBtYWpvclVuaXQpIHtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgLyoqIEB0eXBlIHtPYmplY3Q8bnVtYmVyLG9iamVjdD59ICovXG4gIGNvbnN0IG1hcCA9IHt9O1xuICBjb25zdCBpbGVuID0gdmFsdWVzLmxlbmd0aDtcbiAgbGV0IGksIHZhbHVlO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICBtYXBbdmFsdWVdID0gaTtcblxuICAgIHRpY2tzLnB1c2goe1xuICAgICAgdmFsdWUsXG4gICAgICBtYWpvcjogZmFsc2VcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFdlIHNldCB0aGUgbWFqb3IgdGlja3Mgc2VwYXJhdGVseSBmcm9tIHRoZSBhYm92ZSBsb29wIGJlY2F1c2UgY2FsbGluZyBzdGFydE9mIGZvciBldmVyeSB0aWNrXG4gIC8vIGlzIGV4cGVuc2l2ZSB3aGVuIHRoZXJlIGlzIGEgbGFyZ2UgbnVtYmVyIG9mIHRpY2tzXG4gIHJldHVybiAoaWxlbiA9PT0gMCB8fCAhbWFqb3JVbml0KSA/IHRpY2tzIDogc2V0TWFqb3JUaWNrcyhzY2FsZSwgdGlja3MsIG1hcCwgbWFqb3JVbml0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZVNjYWxlIGV4dGVuZHMgU2NhbGUge1xuXG4gIHN0YXRpYyBpZCA9ICd0aW1lJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAvKipcbiAgICAgKiBTY2FsZSBib3VuZGFyeSBzdHJhdGVneSAoYnlwYXNzZWQgYnkgbWluL21heCB0aW1lIG9wdGlvbnMpXG4gICAgICogLSBgZGF0YWA6IG1ha2Ugc3VyZSBkYXRhIGFyZSBmdWxseSB2aXNpYmxlLCB0aWNrcyBvdXRzaWRlIGFyZSByZW1vdmVkXG4gICAgICogLSBgdGlja3NgOiBtYWtlIHN1cmUgdGlja3MgYXJlIGZ1bGx5IHZpc2libGUsIGRhdGEgb3V0c2lkZSBhcmUgdHJ1bmNhdGVkXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1NTZcbiAgICAgKiBAc2luY2UgMi43LjBcbiAgICAgKi9cbiAgICBib3VuZHM6ICdkYXRhJyxcblxuICAgIGFkYXB0ZXJzOiB7fSxcbiAgICB0aW1lOiB7XG4gICAgICBwYXJzZXI6IGZhbHNlLCAvLyBmYWxzZSA9PSBhIHBhdHRlcm4gc3RyaW5nIGZyb20gb3IgYSBjdXN0b20gY2FsbGJhY2sgdGhhdCBjb252ZXJ0cyBpdHMgYXJndW1lbnQgdG8gYSB0aW1lc3RhbXBcbiAgICAgIHVuaXQ6IGZhbHNlLCAvLyBmYWxzZSA9PSBhdXRvbWF0aWMgb3Igb3ZlcnJpZGUgd2l0aCB3ZWVrLCBtb250aCwgeWVhciwgZXRjLlxuICAgICAgcm91bmQ6IGZhbHNlLCAvLyBub25lLCBvciBvdmVycmlkZSB3aXRoIHdlZWssIG1vbnRoLCB5ZWFyLCBldGMuXG4gICAgICBpc29XZWVrZGF5OiBmYWxzZSwgLy8gb3ZlcnJpZGUgd2VlayBzdGFydCBkYXlcbiAgICAgIG1pblVuaXQ6ICdtaWxsaXNlY29uZCcsXG4gICAgICBkaXNwbGF5Rm9ybWF0czoge31cbiAgICB9LFxuICAgIHRpY2tzOiB7XG4gICAgICAvKipcbiAgICAgICAqIFRpY2tzIGdlbmVyYXRpb24gaW5wdXQgdmFsdWVzOlxuICAgICAgICogLSAnYXV0byc6IGdlbmVyYXRlcyBcIm9wdGltYWxcIiB0aWNrcyBiYXNlZCBvbiBzY2FsZSBzaXplIGFuZCB0aW1lIG9wdGlvbnMuXG4gICAgICAgKiAtICdkYXRhJzogZ2VuZXJhdGVzIHRpY2tzIGZyb20gZGF0YSAoaW5jbHVkaW5nIGxhYmVscyBmcm9tIGRhdGEge3R8eHx5fSBvYmplY3RzKS5cbiAgICAgICAqIC0gJ2xhYmVscyc6IGdlbmVyYXRlcyB0aWNrcyBmcm9tIHVzZXIgZ2l2ZW4gYGRhdGEubGFiZWxzYCB2YWx1ZXMgT05MWS5cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTA3XG4gICAgICAgKiBAc2luY2UgMi43LjBcbiAgICAgICAqL1xuICAgICAgc291cmNlOiAnYXV0bycsXG5cbiAgICAgIGNhbGxiYWNrOiBmYWxzZSxcblxuICAgICAgbWFqb3I6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuXHQgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAvKiogQHR5cGUge3tkYXRhOiBudW1iZXJbXSwgbGFiZWxzOiBudW1iZXJbXSwgYWxsOiBudW1iZXJbXX19ICovXG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBkYXRhOiBbXSxcbiAgICAgIGxhYmVsczogW10sXG4gICAgICBhbGw6IFtdXG4gICAgfTtcblxuICAgIC8qKiBAdHlwZSB7VW5pdH0gKi9cbiAgICB0aGlzLl91bml0ID0gJ2RheSc7XG4gICAgLyoqIEB0eXBlIHtVbml0PX0gKi9cbiAgICB0aGlzLl9tYWpvclVuaXQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fb2Zmc2V0cyA9IHt9O1xuICAgIHRoaXMuX25vcm1hbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXJzZU9wdHMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpbml0KHNjYWxlT3B0cywgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgdGltZSA9IHNjYWxlT3B0cy50aW1lIHx8IChzY2FsZU9wdHMudGltZSA9IHt9KTtcbiAgICAvKiogQHR5cGUge0RhdGVBZGFwdGVyfSAqL1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyID0gbmV3IGFkYXB0ZXJzLl9kYXRlKHNjYWxlT3B0cy5hZGFwdGVycy5kYXRlKTtcblxuICAgIGFkYXB0ZXIuaW5pdChvcHRzKTtcblxuICAgIC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IGJlZm9yZSBpbnRyb2R1Y2luZyBhZGFwdGVyLCBgZGlzcGxheUZvcm1hdHNgIHdhc1xuICAgIC8vIHN1cHBvc2VkIHRvIGNvbnRhaW4gKmFsbCogdW5pdC9zdHJpbmcgcGFpcnMgYnV0IHRoaXMgY2FuJ3QgYmUgcmVzb2x2ZWRcbiAgICAvLyB3aGVuIGxvYWRpbmcgdGhlIHNjYWxlIChhZGFwdGVycyBhcmUgbG9hZGVkIGFmdGVyd2FyZCksIHNvIGxldCdzIHBvcHVsYXRlXG4gICAgLy8gbWlzc2luZyBmb3JtYXRzIG9uIHVwZGF0ZVxuICAgIG1lcmdlSWYodGltZS5kaXNwbGF5Rm9ybWF0cywgYWRhcHRlci5mb3JtYXRzKCkpO1xuXG4gICAgdGhpcy5fcGFyc2VPcHRzID0ge1xuICAgICAgcGFyc2VyOiB0aW1lLnBhcnNlcixcbiAgICAgIHJvdW5kOiB0aW1lLnJvdW5kLFxuICAgICAgaXNvV2Vla2RheTogdGltZS5pc29XZWVrZGF5XG4gICAgfTtcblxuICAgIHN1cGVyLmluaXQoc2NhbGVPcHRzKTtcblxuICAgIHRoaXMuX25vcm1hbGl6ZWQgPSBvcHRzLm5vcm1hbGl6ZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHsqfSByYXdcblx0ICogQHBhcmFtIHtudW1iZXI/fSBbaW5kZXhdXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIHBhcnNlKHJhdywgaW5kZXgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGlmIChyYXcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZSh0aGlzLCByYXcpO1xuICB9XG5cbiAgYmVmb3JlTGF5b3V0KCkge1xuICAgIHN1cGVyLmJlZm9yZUxheW91dCgpO1xuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgZGF0YTogW10sXG4gICAgICBsYWJlbHM6IFtdLFxuICAgICAgYWxsOiBbXVxuICAgIH07XG4gIH1cblxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXI7XG4gICAgY29uc3QgdW5pdCA9IG9wdGlvbnMudGltZS51bml0IHx8ICdkYXknO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICBsZXQge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuXG4gICAgLyoqXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IGJvdW5kc1xuXHRcdCAqL1xuICAgIGZ1bmN0aW9uIF9hcHBseUJvdW5kcyhib3VuZHMpIHtcbiAgICAgIGlmICghbWluRGVmaW5lZCAmJiAhaXNOYU4oYm91bmRzLm1pbikpIHtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCBib3VuZHMubWluKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCAmJiAhaXNOYU4oYm91bmRzLm1heCkpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBib3VuZHMubWF4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBoYXZlIHVzZXIgcHJvdmlkZWQgYG1pbmAgYW5kIGBtYXhgIGxhYmVscyAvIGRhdGEgYm91bmRzIGNhbiBiZSBpZ25vcmVkXG4gICAgaWYgKCFtaW5EZWZpbmVkIHx8ICFtYXhEZWZpbmVkKSB7XG4gICAgICAvLyBMYWJlbHMgYXJlIGFsd2F5cyBjb25zaWRlcmVkLCB3aGVuIHVzZXIgZGlkIG5vdCBmb3JjZSBib3VuZHNcbiAgICAgIF9hcHBseUJvdW5kcyh0aGlzLl9nZXRMYWJlbEJvdW5kcygpKTtcblxuICAgICAgLy8gSWYgYGJvdW5kc2AgaXMgYCd0aWNrcydgIGFuZCBgdGlja3Muc291cmNlYCBpcyBgJ2xhYmVscydgLFxuICAgICAgLy8gZGF0YSBib3VuZHMgYXJlIGlnbm9yZWQgKGFuZCBkb24ndCBuZWVkIHRvIGJlIGRldGVybWluZWQpXG4gICAgICBpZiAob3B0aW9ucy5ib3VuZHMgIT09ICd0aWNrcycgfHwgb3B0aW9ucy50aWNrcy5zb3VyY2UgIT09ICdsYWJlbHMnKSB7XG4gICAgICAgIF9hcHBseUJvdW5kcyh0aGlzLmdldE1pbk1heChmYWxzZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1pbiA9IGlzRmluaXRlKG1pbikgJiYgIWlzTmFOKG1pbikgPyBtaW4gOiArYWRhcHRlci5zdGFydE9mKERhdGUubm93KCksIHVuaXQpO1xuICAgIG1heCA9IGlzRmluaXRlKG1heCkgJiYgIWlzTmFOKG1heCkgPyBtYXggOiArYWRhcHRlci5lbmRPZihEYXRlLm5vdygpLCB1bml0KSArIDE7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCBtYXggaXMgc3RyaWN0bHkgaGlnaGVyIHRoYW4gbWluIChyZXF1aXJlZCBieSB0aGUgdGltZXNlcmllcyBsb29rdXAgdGFibGUpXG4gICAgdGhpcy5taW4gPSBNYXRoLm1pbihtaW4sIG1heCAtIDEpO1xuICAgIHRoaXMubWF4ID0gTWF0aC5tYXgobWluICsgMSwgbWF4KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldExhYmVsQm91bmRzKCkge1xuICAgIGNvbnN0IGFyciA9IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCk7XG4gICAgbGV0IG1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbWF4ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuXG4gICAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICAgIG1pbiA9IGFyclswXTtcbiAgICAgIG1heCA9IGFyclthcnIubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiB7bWluLCBtYXh9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge29iamVjdFtdfVxuXHQgKi9cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpbWVPcHRzID0gb3B0aW9ucy50aW1lO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0aW9ucy50aWNrcztcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gdGlja09wdHMuc291cmNlID09PSAnbGFiZWxzJyA/IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCkgOiB0aGlzLl9nZW5lcmF0ZSgpO1xuXG4gICAgaWYgKG9wdGlvbnMuYm91bmRzID09PSAndGlja3MnICYmIHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLm1pbiA9IHRoaXMuX3VzZXJNaW4gfHwgdGltZXN0YW1wc1swXTtcbiAgICAgIHRoaXMubWF4ID0gdGhpcy5fdXNlck1heCB8fCB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG5cbiAgICBjb25zdCB0aWNrcyA9IF9maWx0ZXJCZXR3ZWVuKHRpbWVzdGFtcHMsIG1pbiwgbWF4KTtcblxuICAgIC8vIFBSSVZBVEVcbiAgICAvLyBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyByZWxpZXMgb24gdGhlIG51bWJlciBvZiB0aWNrcyBzbyB3ZSBkb24ndCB1c2UgaXQgd2hlblxuICAgIC8vIGF1dG9Ta2lwIGlzIGVuYWJsZWQgYmVjYXVzZSB3ZSBkb24ndCB5ZXQga25vdyB3aGF0IHRoZSBmaW5hbCBudW1iZXIgb2YgdGlja3Mgd2lsbCBiZVxuICAgIHRoaXMuX3VuaXQgPSB0aW1lT3B0cy51bml0IHx8ICh0aWNrT3B0cy5hdXRvU2tpcFxuICAgICAgPyBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKHRpbWVPcHRzLm1pblVuaXQsIHRoaXMubWluLCB0aGlzLm1heCwgdGhpcy5fZ2V0TGFiZWxDYXBhY2l0eShtaW4pKVxuICAgICAgOiBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyh0aGlzLCB0aWNrcy5sZW5ndGgsIHRpbWVPcHRzLm1pblVuaXQsIHRoaXMubWluLCB0aGlzLm1heCkpO1xuICAgIHRoaXMuX21ham9yVW5pdCA9ICF0aWNrT3B0cy5tYWpvci5lbmFibGVkIHx8IHRoaXMuX3VuaXQgPT09ICd5ZWFyJyA/IHVuZGVmaW5lZFxuICAgICAgOiBkZXRlcm1pbmVNYWpvclVuaXQodGhpcy5fdW5pdCk7XG4gICAgdGhpcy5pbml0T2Zmc2V0cyh0aW1lc3RhbXBzKTtcblxuICAgIGlmIChvcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIHRpY2tzLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGlja3NGcm9tVGltZXN0YW1wcyh0aGlzLCB0aWNrcywgdGhpcy5fbWFqb3JVbml0KTtcbiAgfVxuXG4gIGFmdGVyQXV0b1NraXAoKSB7XG4gICAgLy8gT2Zmc2V0cyBmb3IgYmFyIGNoYXJ0cyBuZWVkIHRvIGJlIGhhbmRsZWQgd2l0aCB0aGUgYXV0byBza2lwcGVkXG4gICAgLy8gdGlja3MuIE9uY2UgdGlja3MgaGF2ZSBiZWVuIHNraXBwZWQsIHdlIHJlLWNvbXB1dGUgdGhlIG9mZnNldHMuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXRBZnRlckF1dG9za2lwKSB7XG4gICAgICB0aGlzLmluaXRPZmZzZXRzKHRoaXMudGlja3MubWFwKHRpY2sgPT4gK3RpY2sudmFsdWUpKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgc3RhcnQgYW5kIGVuZCBvZmZzZXRzIGZyb20gZWRnZXMgaW4gdGhlIGZvcm0gb2Yge3N0YXJ0LCBlbmR9XG5cdCAqIHdoZXJlIGVhY2ggdmFsdWUgaXMgYSByZWxhdGl2ZSB3aWR0aCB0byB0aGUgc2NhbGUgYW5kIHJhbmdlcyBiZXR3ZWVuIDAgYW5kIDEuXG5cdCAqIFRoZXkgYWRkIGV4dHJhIG1hcmdpbnMgb24gdGhlIGJvdGggc2lkZXMgYnkgc2NhbGluZyBkb3duIHRoZSBvcmlnaW5hbCBzY2FsZS5cblx0ICogT2Zmc2V0cyBhcmUgYWRkZWQgd2hlbiB0aGUgYG9mZnNldGAgb3B0aW9uIGlzIHRydWUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IHRpbWVzdGFtcHNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgaW5pdE9mZnNldHModGltZXN0YW1wcyA9IFtdKSB7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgZW5kID0gMDtcbiAgICBsZXQgZmlyc3QsIGxhc3Q7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldCAmJiB0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgZmlyc3QgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzWzBdKTtcbiAgICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzdGFydCA9IDEgLSBmaXJzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gKHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbMV0pIC0gZmlyc3QpIC8gMjtcbiAgICAgIH1cbiAgICAgIGxhc3QgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV0pO1xuICAgICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGVuZCA9IGxhc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSAobGFzdCAtIHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAyXSkpIC8gMjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGltaXQgPSB0aW1lc3RhbXBzLmxlbmd0aCA8IDMgPyAwLjUgOiAwLjI1O1xuICAgIHN0YXJ0ID0gX2xpbWl0VmFsdWUoc3RhcnQsIDAsIGxpbWl0KTtcbiAgICBlbmQgPSBfbGltaXRWYWx1ZShlbmQsIDAsIGxpbWl0KTtcblxuICAgIHRoaXMuX29mZnNldHMgPSB7c3RhcnQsIGVuZCwgZmFjdG9yOiAxIC8gKHN0YXJ0ICsgMSArIGVuZCl9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEdlbmVyYXRlcyBhIG1heGltdW0gb2YgYGNhcGFjaXR5YCB0aW1lc3RhbXBzIGJldHdlZW4gbWluIGFuZCBtYXgsIHJvdW5kZWQgdG8gdGhlXG5cdCAqIGBtaW5vcmAgdW5pdCB1c2luZyB0aGUgZ2l2ZW4gc2NhbGUgdGltZSBgb3B0aW9uc2AuXG5cdCAqIEltcG9ydGFudDogdGhpcyBtZXRob2QgY2FuIHJldHVybiB0aWNrcyBvdXRzaWRlIHRoZSBtaW4gYW5kIG1heCByYW5nZSwgaXQncyB0aGVcblx0ICogcmVzcG9uc2liaWxpdHkgb2YgdGhlIGNhbGxpbmcgY29kZSB0byBjbGFtcCB2YWx1ZXMgaWYgbmVlZGVkLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBfZ2VuZXJhdGUoKSB7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXI7XG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgbWlub3IgPSB0aW1lT3B0cy51bml0IHx8IGRldGVybWluZVVuaXRGb3JBdXRvVGlja3ModGltZU9wdHMubWluVW5pdCwgbWluLCBtYXgsIHRoaXMuX2dldExhYmVsQ2FwYWNpdHkobWluKSk7XG4gICAgY29uc3Qgc3RlcFNpemUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnRpY2tzLnN0ZXBTaXplLCAxKTtcbiAgICBjb25zdCB3ZWVrZGF5ID0gbWlub3IgPT09ICd3ZWVrJyA/IHRpbWVPcHRzLmlzb1dlZWtkYXkgOiBmYWxzZTtcbiAgICBjb25zdCBoYXNXZWVrZGF5ID0gaXNOdW1iZXIod2Vla2RheSkgfHwgd2Vla2RheSA9PT0gdHJ1ZTtcbiAgICBjb25zdCB0aWNrcyA9IHt9O1xuICAgIGxldCBmaXJzdCA9IG1pbjtcbiAgICBsZXQgdGltZSwgY291bnQ7XG5cbiAgICAvLyBGb3IgJ3dlZWsnIHVuaXQsIGhhbmRsZSB0aGUgZmlyc3QgZGF5IG9mIHdlZWsgb3B0aW9uXG4gICAgaWYgKGhhc1dlZWtkYXkpIHtcbiAgICAgIGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgJ2lzb1dlZWsnLCB3ZWVrZGF5KTtcbiAgICB9XG5cbiAgICAvLyBBbGlnbiBmaXJzdCB0aWNrcyBvbiB1bml0XG4gICAgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKGZpcnN0LCBoYXNXZWVrZGF5ID8gJ2RheScgOiBtaW5vcik7XG5cbiAgICAvLyBQcmV2ZW50IGJyb3dzZXIgZnJvbSBmcmVlemluZyBpbiBjYXNlIHVzZXIgb3B0aW9ucyByZXF1ZXN0IG1pbGxpb25zIG9mIG1pbGxpc2Vjb25kc1xuICAgIGlmIChhZGFwdGVyLmRpZmYobWF4LCBtaW4sIG1pbm9yKSA+IDEwMDAwMCAqIHN0ZXBTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWluICsgJyBhbmQgJyArIG1heCArICcgYXJlIHRvbyBmYXIgYXBhcnQgd2l0aCBzdGVwU2l6ZSBvZiAnICsgc3RlcFNpemUgKyAnICcgKyBtaW5vcik7XG4gICAgfVxuXG4gICAgY29uc3QgdGltZXN0YW1wcyA9IG9wdGlvbnMudGlja3Muc291cmNlID09PSAnZGF0YScgJiYgdGhpcy5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgIGZvciAodGltZSA9IGZpcnN0LCBjb3VudCA9IDA7IHRpbWUgPCBtYXg7IHRpbWUgPSArYWRhcHRlci5hZGQodGltZSwgc3RlcFNpemUsIG1pbm9yKSwgY291bnQrKykge1xuICAgICAgYWRkVGljayh0aWNrcywgdGltZSwgdGltZXN0YW1wcyk7XG4gICAgfVxuXG4gICAgaWYgKHRpbWUgPT09IG1heCB8fCBvcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJyB8fCBjb3VudCA9PT0gMSkge1xuICAgICAgYWRkVGljayh0aWNrcywgdGltZSwgdGltZXN0YW1wcyk7XG4gICAgfVxuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aWNrcykuc29ydChzb3J0ZXIpLm1hcCh4ID0+ICt4KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IHRpbWVPcHRzID0gdGhpcy5vcHRpb25zLnRpbWU7XG5cbiAgICBpZiAodGltZU9wdHMudG9vbHRpcEZvcm1hdCkge1xuICAgICAgcmV0dXJuIGFkYXB0ZXIuZm9ybWF0KHZhbHVlLCB0aW1lT3B0cy50b29sdGlwRm9ybWF0KTtcbiAgICB9XG4gICAgcmV0dXJuIGFkYXB0ZXIuZm9ybWF0KHZhbHVlLCB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cy5kYXRldGltZSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gZm9ybWF0XG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG4gIGZvcm1hdCh2YWx1ZSwgZm9ybWF0KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBmb3JtYXRzID0gb3B0aW9ucy50aW1lLmRpc3BsYXlGb3JtYXRzO1xuICAgIGNvbnN0IHVuaXQgPSB0aGlzLl91bml0O1xuICAgIGNvbnN0IGZtdCA9IGZvcm1hdCB8fCBmb3JtYXRzW3VuaXRdO1xuICAgIHJldHVybiB0aGlzLl9hZGFwdGVyLmZvcm1hdCh2YWx1ZSwgZm10KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBGdW5jdGlvbiB0byBmb3JtYXQgYW4gaW5kaXZpZHVhbCB0aWNrIG1hcmtcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpbWVcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEBwYXJhbSB7b2JqZWN0W119IHRpY2tzXG5cdCAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gW2Zvcm1hdF1cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3RpY2tGb3JtYXRGdW5jdGlvbih0aW1lLCBpbmRleCwgdGlja3MsIGZvcm1hdCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgZm9ybWF0dGVyID0gb3B0aW9ucy50aWNrcy5jYWxsYmFjaztcblxuICAgIGlmIChmb3JtYXR0ZXIpIHtcbiAgICAgIHJldHVybiBjYWxsKGZvcm1hdHRlciwgW3RpbWUsIGluZGV4LCB0aWNrc10sIHRoaXMpO1xuICAgIH1cblxuICAgIGNvbnN0IGZvcm1hdHMgPSBvcHRpb25zLnRpbWUuZGlzcGxheUZvcm1hdHM7XG4gICAgY29uc3QgdW5pdCA9IHRoaXMuX3VuaXQ7XG4gICAgY29uc3QgbWFqb3JVbml0ID0gdGhpcy5fbWFqb3JVbml0O1xuICAgIGNvbnN0IG1pbm9yRm9ybWF0ID0gdW5pdCAmJiBmb3JtYXRzW3VuaXRdO1xuICAgIGNvbnN0IG1ham9yRm9ybWF0ID0gbWFqb3JVbml0ICYmIGZvcm1hdHNbbWFqb3JVbml0XTtcbiAgICBjb25zdCB0aWNrID0gdGlja3NbaW5kZXhdO1xuICAgIGNvbnN0IG1ham9yID0gbWFqb3JVbml0ICYmIG1ham9yRm9ybWF0ICYmIHRpY2sgJiYgdGljay5tYWpvcjtcblxuICAgIHJldHVybiB0aGlzLl9hZGFwdGVyLmZvcm1hdCh0aW1lLCBmb3JtYXQgfHwgKG1ham9yID8gbWFqb3JGb3JtYXQgOiBtaW5vckZvcm1hdCkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7b2JqZWN0W119IHRpY2tzXG5cdCAqL1xuICBnZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpIHtcbiAgICBsZXQgaSwgaWxlbiwgdGljaztcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgIHRpY2subGFiZWwgPSB0aGlzLl90aWNrRm9ybWF0RnVuY3Rpb24odGljay52YWx1ZSwgaSwgdGlja3MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBNaWxsaXNlY29uZHMgc2luY2UgZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQylcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogKHZhbHVlIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIE1pbGxpc2Vjb25kcyBzaW5jZSBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodmFsdWUpO1xuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgob2Zmc2V0cy5zdGFydCArIHBvcykgKiBvZmZzZXRzLmZhY3Rvcik7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgLyBvZmZzZXRzLmZhY3RvciAtIG9mZnNldHMuZW5kO1xuICAgIHJldHVybiB0aGlzLm1pbiArIHBvcyAqICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWxcblx0ICogQHJldHVybiB7e3c6bnVtYmVyLCBoOm51bWJlcn19XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0TGFiZWxTaXplKGxhYmVsKSB7XG4gICAgY29uc3QgdGlja3NPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IHRpY2tMYWJlbFdpZHRoID0gdGhpcy5jdHgubWVhc3VyZVRleHQobGFiZWwpLndpZHRoO1xuICAgIGNvbnN0IGFuZ2xlID0gdG9SYWRpYW5zKHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aWNrc09wdHMubWF4Um90YXRpb24gOiB0aWNrc09wdHMubWluUm90YXRpb24pO1xuICAgIGNvbnN0IGNvc1JvdGF0aW9uID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgIGNvbnN0IHNpblJvdGF0aW9uID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIGNvbnN0IHRpY2tGb250U2l6ZSA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCkuc2l6ZTtcblxuICAgIHJldHVybiB7XG4gICAgICB3OiAodGlja0xhYmVsV2lkdGggKiBjb3NSb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogc2luUm90YXRpb24pLFxuICAgICAgaDogKHRpY2tMYWJlbFdpZHRoICogc2luUm90YXRpb24pICsgKHRpY2tGb250U2l6ZSAqIGNvc1JvdGF0aW9uKVxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IGV4YW1wbGVUaW1lXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRMYWJlbENhcGFjaXR5KGV4YW1wbGVUaW1lKSB7XG4gICAgY29uc3QgdGltZU9wdHMgPSB0aGlzLm9wdGlvbnMudGltZTtcbiAgICBjb25zdCBkaXNwbGF5Rm9ybWF0cyA9IHRpbWVPcHRzLmRpc3BsYXlGb3JtYXRzO1xuXG4gICAgLy8gcGljayB0aGUgbG9uZ2VzdCBmb3JtYXQgKG1pbGxpc2Vjb25kcykgZm9yIGd1ZXNzdGltYXRpb25cbiAgICBjb25zdCBmb3JtYXQgPSBkaXNwbGF5Rm9ybWF0c1t0aW1lT3B0cy51bml0XSB8fCBkaXNwbGF5Rm9ybWF0cy5taWxsaXNlY29uZDtcbiAgICBjb25zdCBleGFtcGxlTGFiZWwgPSB0aGlzLl90aWNrRm9ybWF0RnVuY3Rpb24oZXhhbXBsZVRpbWUsIDAsIHRpY2tzRnJvbVRpbWVzdGFtcHModGhpcywgW2V4YW1wbGVUaW1lXSwgdGhpcy5fbWFqb3JVbml0KSwgZm9ybWF0KTtcbiAgICBjb25zdCBzaXplID0gdGhpcy5fZ2V0TGFiZWxTaXplKGV4YW1wbGVMYWJlbCk7XG4gICAgLy8gc3VidHJhY3QgMSAtIGlmIG9mZnNldCB0aGVuIHRoZXJlJ3Mgb25lIGxlc3MgbGFiZWwgdGhhbiB0aWNrXG4gICAgLy8gaWYgbm90IG9mZnNldCB0aGVuIG9uZSBoYWxmIGxhYmVsIHBhZGRpbmcgaXMgYWRkZWQgdG8gZWFjaCBlbmQgbGVhdmluZyByb29tIGZvciBvbmUgbGVzcyBsYWJlbFxuICAgIGNvbnN0IGNhcGFjaXR5ID0gTWF0aC5mbG9vcih0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGhpcy53aWR0aCAvIHNpemUudyA6IHRoaXMuaGVpZ2h0IC8gc2l6ZS5oKSAtIDE7XG4gICAgcmV0dXJuIGNhcGFjaXR5ID4gMCA/IGNhcGFjaXR5IDogMTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXREYXRhVGltZXN0YW1wcygpIHtcbiAgICBsZXQgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmRhdGEgfHwgW107XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cblxuICAgIGNvbnN0IG1ldGFzID0gdGhpcy5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygpO1xuXG4gICAgaWYgKHRoaXMuX25vcm1hbGl6ZWQgJiYgbWV0YXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gKHRoaXMuX2NhY2hlLmRhdGEgPSBtZXRhc1swXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyh0aGlzKSk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGltZXN0YW1wcyA9IHRpbWVzdGFtcHMuY29uY2F0KG1ldGFzW2ldLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKHRoaXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKHRoaXMuX2NhY2hlLmRhdGEgPSB0aGlzLm5vcm1hbGl6ZSh0aW1lc3RhbXBzKSk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxUaW1lc3RhbXBzKCkge1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5sYWJlbHMgfHwgW107XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cblxuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGxhYmVscy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpbWVzdGFtcHMucHVzaChwYXJzZSh0aGlzLCBsYWJlbHNbaV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKHRoaXMuX2NhY2hlLmxhYmVscyA9IHRoaXMuX25vcm1hbGl6ZWQgPyB0aW1lc3RhbXBzIDogdGhpcy5ub3JtYWxpemUodGltZXN0YW1wcykpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IHZhbHVlc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBub3JtYWxpemUodmFsdWVzKSB7XG4gICAgLy8gSXQgc2VlbXMgdG8gYmUgc29tZXdoYXQgZmFzdGVyIHRvIGRvIHNvcnRpbmcgZmlyc3RcbiAgICByZXR1cm4gX2FycmF5VW5pcXVlKHZhbHVlcy5zb3J0KHNvcnRlcikpO1xuICB9XG59XG4iLCAiaW1wb3J0IFRpbWVTY2FsZSBmcm9tICcuL3NjYWxlLnRpbWUuanMnO1xuaW1wb3J0IHtfbG9va3VwQnlLZXl9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb2xsZWN0aW9uLmpzJztcblxuLyoqXG4gKiBMaW5lYXJseSBpbnRlcnBvbGF0ZXMgdGhlIGdpdmVuIHNvdXJjZSBgdmFsYCB1c2luZyB0aGUgdGFibGUuIElmIHZhbHVlIGlzIG91dCBvZiBib3VuZHMsIHZhbHVlc1xuICogYXQgZWRnZXMgYXJlIHVzZWQgZm9yIHRoZSBpbnRlcnBvbGF0aW9uLlxuICogQHBhcmFtIHtvYmplY3R9IHRhYmxlXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXZlcnNlXSBsb29rdXAgdGltZSBiYXNlZCBvbiBwb3NpdGlvbiBpbnN0ZWFkIG9mIHZpY2UgdmVyc2FcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gaW50ZXJwb2xhdGUodGFibGUsIHZhbCwgcmV2ZXJzZSkge1xuICBsZXQgbG8gPSAwO1xuICBsZXQgaGkgPSB0YWJsZS5sZW5ndGggLSAxO1xuICBsZXQgcHJldlNvdXJjZSwgbmV4dFNvdXJjZSwgcHJldlRhcmdldCwgbmV4dFRhcmdldDtcbiAgaWYgKHJldmVyc2UpIHtcbiAgICBpZiAodmFsID49IHRhYmxlW2xvXS5wb3MgJiYgdmFsIDw9IHRhYmxlW2hpXS5wb3MpIHtcbiAgICAgICh7bG8sIGhpfSA9IF9sb29rdXBCeUtleSh0YWJsZSwgJ3BvcycsIHZhbCkpO1xuICAgIH1cbiAgICAoe3BvczogcHJldlNvdXJjZSwgdGltZTogcHJldlRhcmdldH0gPSB0YWJsZVtsb10pO1xuICAgICh7cG9zOiBuZXh0U291cmNlLCB0aW1lOiBuZXh0VGFyZ2V0fSA9IHRhYmxlW2hpXSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbCA+PSB0YWJsZVtsb10udGltZSAmJiB2YWwgPD0gdGFibGVbaGldLnRpbWUpIHtcbiAgICAgICh7bG8sIGhpfSA9IF9sb29rdXBCeUtleSh0YWJsZSwgJ3RpbWUnLCB2YWwpKTtcbiAgICB9XG4gICAgKHt0aW1lOiBwcmV2U291cmNlLCBwb3M6IHByZXZUYXJnZXR9ID0gdGFibGVbbG9dKTtcbiAgICAoe3RpbWU6IG5leHRTb3VyY2UsIHBvczogbmV4dFRhcmdldH0gPSB0YWJsZVtoaV0pO1xuICB9XG5cbiAgY29uc3Qgc3BhbiA9IG5leHRTb3VyY2UgLSBwcmV2U291cmNlO1xuICByZXR1cm4gc3BhbiA/IHByZXZUYXJnZXQgKyAobmV4dFRhcmdldCAtIHByZXZUYXJnZXQpICogKHZhbCAtIHByZXZTb3VyY2UpIC8gc3BhbiA6IHByZXZUYXJnZXQ7XG59XG5cbmNsYXNzIFRpbWVTZXJpZXNTY2FsZSBleHRlbmRzIFRpbWVTY2FsZSB7XG5cbiAgc3RhdGljIGlkID0gJ3RpbWVzZXJpZXMnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0gVGltZVNjYWxlLmRlZmF1bHRzO1xuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcblx0ICovXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgLyoqIEB0eXBlIHtvYmplY3RbXX0gKi9cbiAgICB0aGlzLl90YWJsZSA9IFtdO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX21pblBvcyA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl90YWJsZVJhbmdlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGluaXRPZmZzZXRzKCkge1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSB0aGlzLl9nZXRUaW1lc3RhbXBzRm9yVGFibGUoKTtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMuX3RhYmxlID0gdGhpcy5idWlsZExvb2t1cFRhYmxlKHRpbWVzdGFtcHMpO1xuICAgIHRoaXMuX21pblBvcyA9IGludGVycG9sYXRlKHRhYmxlLCB0aGlzLm1pbik7XG4gICAgdGhpcy5fdGFibGVSYW5nZSA9IGludGVycG9sYXRlKHRhYmxlLCB0aGlzLm1heCkgLSB0aGlzLl9taW5Qb3M7XG4gICAgc3VwZXIuaW5pdE9mZnNldHModGltZXN0YW1wcyk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhbiBhcnJheSBvZiB7dGltZSwgcG9zfSBvYmplY3RzIHVzZWQgdG8gaW50ZXJwb2xhdGUgYSBzcGVjaWZpYyBgdGltZWAgb3IgcG9zaXRpb25cblx0ICogKGBwb3NgKSBvbiB0aGUgc2NhbGUsIGJ5IHNlYXJjaGluZyBlbnRyaWVzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIHJlcXVlc3RlZCB2YWx1ZS4gYHBvc2AgaXNcblx0ICogYSBkZWNpbWFsIGJldHdlZW4gMCBhbmQgMTogMCBiZWluZyB0aGUgc3RhcnQgb2YgdGhlIHNjYWxlIChsZWZ0IG9yIHRvcCkgYW5kIDEgdGhlIG90aGVyXG5cdCAqIGV4dHJlbWl0eSAobGVmdCArIHdpZHRoIG9yIHRvcCArIGhlaWdodCkuIE5vdGUgdGhhdCBpdCB3b3VsZCBiZSBtb3JlIG9wdGltaXplZCB0byBkaXJlY3RseVxuXHQgKiBzdG9yZSBwcmUtY29tcHV0ZWQgcGl4ZWxzLCBidXQgdGhlIHNjYWxlIGRpbWVuc2lvbnMgYXJlIG5vdCBndWFyYW50ZWVkIGF0IHRoZSB0aW1lIHdlIG5lZWRcblx0ICogdG8gY3JlYXRlIHRoZSBsb29rdXAgdGFibGUuIFRoZSB0YWJsZSBBTFdBWVMgY29udGFpbnMgYXQgbGVhc3QgdHdvIGl0ZW1zOiBtaW4gYW5kIG1heC5cblx0ICogQHBhcmFtIHtudW1iZXJbXX0gdGltZXN0YW1wc1xuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgYnVpbGRMb29rdXBUYWJsZSh0aW1lc3RhbXBzKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXM7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBjb25zdCB0YWJsZSA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCBwcmV2LCBjdXJyLCBuZXh0O1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpbWVzdGFtcHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjdXJyID0gdGltZXN0YW1wc1tpXTtcbiAgICAgIGlmIChjdXJyID49IG1pbiAmJiBjdXJyIDw9IG1heCkge1xuICAgICAgICBpdGVtcy5wdXNoKGN1cnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpdGVtcy5sZW5ndGggPCAyKSB7XG4gICAgICAvLyBJbiBjYXNlIHRoZXJlIGlzIGxlc3MgdGhhdCAyIHRpbWVzdGFtcHMgYmV0d2VlbiBtaW4gYW5kIG1heCwgdGhlIHNjYWxlIGlzIGRlZmluZWQgYnkgbWluIGFuZCBtYXhcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHt0aW1lOiBtaW4sIHBvczogMH0sXG4gICAgICAgIHt0aW1lOiBtYXgsIHBvczogMX1cbiAgICAgIF07XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgbmV4dCA9IGl0ZW1zW2kgKyAxXTtcbiAgICAgIHByZXYgPSBpdGVtc1tpIC0gMV07XG4gICAgICBjdXJyID0gaXRlbXNbaV07XG5cbiAgICAgIC8vIG9ubHkgYWRkIHBvaW50cyB0aGF0IGJyZWFrcyB0aGUgc2NhbGUgbGluZWFyaXR5XG4gICAgICBpZiAoTWF0aC5yb3VuZCgobmV4dCArIHByZXYpIC8gMikgIT09IGN1cnIpIHtcbiAgICAgICAgdGFibGUucHVzaCh7dGltZTogY3VyciwgcG9zOiBpIC8gKGlsZW4gLSAxKX0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFibGU7XG4gIH1cblxuICAvKipcbiAgICAqIEdlbmVyYXRlcyBhbGwgdGltZXN0YW1wcyBkZWZpbmVkIGluIHRoZSBkYXRhLlxuICAgICogSW1wb3J0YW50OiB0aGlzIG1ldGhvZCBjYW4gcmV0dXJuIHRpY2tzIG91dHNpZGUgdGhlIG1pbiBhbmQgbWF4IHJhbmdlLCBpdCdzIHRoZVxuICAgICogcmVzcG9uc2liaWxpdHkgb2YgdGhlIGNhbGxpbmcgY29kZSB0byBjbGFtcCB2YWx1ZXMgaWYgbmVlZGVkLlxuICAgICogQHByb3RlY3RlZFxuICAgICovXG4gIF9nZW5lcmF0ZSgpIHtcbiAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcbiAgICBjb25zdCBtYXggPSB0aGlzLm1heDtcbiAgICBsZXQgdGltZXN0YW1wcyA9IHN1cGVyLmdldERhdGFUaW1lc3RhbXBzKCk7XG4gICAgaWYgKCF0aW1lc3RhbXBzLmluY2x1ZGVzKG1pbikgfHwgIXRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICB0aW1lc3RhbXBzLnNwbGljZSgwLCAwLCBtaW4pO1xuICAgIH1cbiAgICBpZiAoIXRpbWVzdGFtcHMuaW5jbHVkZXMobWF4KSB8fCB0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGltZXN0YW1wcy5wdXNoKG1heCk7XG4gICAgfVxuICAgIHJldHVybiB0aW1lc3RhbXBzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGFsbCB0aW1lc3RhbXBzXG5cdCAqIEByZXR1cm4ge251bWJlcltdfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFRpbWVzdGFtcHNGb3JUYWJsZSgpIHtcbiAgICBsZXQgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmFsbCB8fCBbXTtcblxuICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YVRpbWVzdGFtcHMoKTtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCk7XG4gICAgaWYgKGRhdGEubGVuZ3RoICYmIGxhYmVsLmxlbmd0aCkge1xuICAgICAgLy8gSWYgY29tYmluaW5nIGxhYmVscyBhbmQgZGF0YSAoZGF0YSBtaWdodCBub3QgY29udGFpbiBhbGwgbGFiZWxzKSxcbiAgICAgIC8vIHdlIG5lZWQgdG8gcmVjaGVjayB1bmlxdWVuZXNzIGFuZCBzb3J0XG4gICAgICB0aW1lc3RhbXBzID0gdGhpcy5ub3JtYWxpemUoZGF0YS5jb25jYXQobGFiZWwpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZXN0YW1wcyA9IGRhdGEubGVuZ3RoID8gZGF0YSA6IGxhYmVsO1xuICAgIH1cbiAgICB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUuYWxsID0gdGltZXN0YW1wcztcblxuICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIE1pbGxpc2Vjb25kcyBzaW5jZSBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXREZWNpbWFsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gKGludGVycG9sYXRlKHRoaXMuX3RhYmxlLCB2YWx1ZSkgLSB0aGlzLl9taW5Qb3MpIC8gdGhpcy5fdGFibGVSYW5nZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgIGNvbnN0IGRlY2ltYWwgPSB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgLyBvZmZzZXRzLmZhY3RvciAtIG9mZnNldHMuZW5kO1xuICAgIHJldHVybiBpbnRlcnBvbGF0ZSh0aGlzLl90YWJsZSwgZGVjaW1hbCAqIHRoaXMuX3RhYmxlUmFuZ2UgKyB0aGlzLl9taW5Qb3MsIHRydWUpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbWVTZXJpZXNTY2FsZTtcbiIsICJleHBvcnQgKiBmcm9tICcuL2NvbnRyb2xsZXJzL2luZGV4LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vY29yZS9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2VsZW1lbnRzL2luZGV4LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vcGxhdGZvcm0vaW5kZXguanMnO1xuZXhwb3J0ICogZnJvbSAnLi9wbHVnaW5zL2luZGV4LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vc2NhbGVzL2luZGV4LmpzJztcblxuaW1wb3J0ICogYXMgY29udHJvbGxlcnMgZnJvbSAnLi9jb250cm9sbGVycy9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyBlbGVtZW50cyBmcm9tICcuL2VsZW1lbnRzL2luZGV4LmpzJztcbmltcG9ydCAqIGFzIHBsdWdpbnMgZnJvbSAnLi9wbHVnaW5zL2luZGV4LmpzJztcbmltcG9ydCAqIGFzIHNjYWxlcyBmcm9tICcuL3NjYWxlcy9pbmRleC5qcyc7XG5cbmV4cG9ydCB7XG4gIGNvbnRyb2xsZXJzLFxuICBlbGVtZW50cyxcbiAgcGx1Z2lucyxcbiAgc2NhbGVzLFxufTtcblxuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyYWJsZXMgPSBbXG4gIGNvbnRyb2xsZXJzLFxuICBlbGVtZW50cyxcbiAgcGx1Z2lucyxcbiAgc2NhbGVzLFxuXTtcbiIsICJpbXBvcnQge0NoYXJ0LCByZWdpc3RlcmFibGVzfSBmcm9tICcuLi9kaXN0L2NoYXJ0LmpzJztcblxuQ2hhcnQucmVnaXN0ZXIoLi4ucmVnaXN0ZXJhYmxlcyk7XG5cbmV4cG9ydCAqIGZyb20gJy4uL2Rpc3QvY2hhcnQuanMnO1xuZXhwb3J0IGRlZmF1bHQgQ2hhcnQ7XG4iLCAiaW1wb3J0IENoYXJ0IGZyb20gJ2NoYXJ0LmpzL2F1dG8nXG5cbmV4cG9ydCBkZWZhdWx0IEhhbGZHYXVnZSA9IHtcbiAgICBtb3VudGVkKCkge1xuICAgICAgICBsZXQgY3R4ID0gdGhpcy5lbFxuXG4gICAgICAgIGNvbnN0IGxlYWRfbWF4X3RlbXBlcmF0dXJlID0gdGhpcy5lbC5kYXRhc2V0LmxlYWRfbWF4X3RlbXBlcmF0dXJlXG4gICAgICAgIGNvbnN0IGxlYWRfaGVhdF9jaGVjayA9IHRoaXMuZWwuZGF0YXNldC5sZWFkX2hlYXRfY2hlY2tcbiAgICAgICAgY29uc3QgX3RpdGxlID0gdGhpcy5lbC5kYXRhc2V0LmxhYmVsXG5cbiAgICAgICAgY29uc29sZS5sb2cobGVhZF9oZWF0X2NoZWNrKVxuXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZG91Z2hudXRcIixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0czogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBbbGVhZF9tYXhfdGVtcGVyYXR1cmUsIGxlYWRfaGVhdF9jaGVjayAtIGxlYWRfbWF4X3RlbXBlcmF0dXJlXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogW1wiI2ZmYTUwMFwiLCBcIiNkZGRkZGRcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogX3RpdGxlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIGNpcmN1bWZlcmVuY2U6IDE4MCxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogMjcwLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNpdmU6IGZhbHNlLCAvLyB3aGVuIHRydWUgaXQgY2F1c2UgZXJyb3IgaW4gcGhvZW5peC5cbiAgICAgICAgICAgICAgICBtYWludGFpbkFzcGVjdFJhdGlvOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjdXRvdXQ6IFwiNzAlXCIsXG4gICAgICAgICAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IDUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwbHVnaW5zOiB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogX3RpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogNCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnQ6IFwiQ29uc29sYXNcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5Q29sb3JzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBmdW5jdGlvbiAodG9vbHRpcEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvb2x0aXBJdGVtLmRhdGFJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90KFwiVmFsdWU6IFwiKSArIGxlZHRlbXBWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3QoXCJNYXg6IFwiKSArIG1heDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkaW5nIHRoZSBsYWJlbCBpbiB0aGUgY2VudGVyIG9mIHRoZSBnYXVnZVxuICAgICAgICAgICAgICAgICAgICBkYXRhbGFiZWxzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyOiAodmFsdWUsIGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5kYXRhSW5kZXggPT09IDAgPyAnZ2F1Z2VWYWx1ZScgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCIjMDAwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb250OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogMjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYXNwZWN0UmF0aW86IDMuMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH1cblxuICAgICAgICBuZXcgQ2hhcnQoY3R4LCBjb25maWcpXG4gICAgfVxufSIsICJpbXBvcnQgQ2hhcnQgZnJvbSBcImNoYXJ0LmpzL2F1dG9cIjtcblxuZXhwb3J0IGRlZmF1bHQgTGV0dGVyR2F1Z2UgPSB7XG4gICAgbW91bnRlZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVsKSByZXR1cm47IC8vIEVuc3VyZSBlbGVtZW50IGV4aXN0c1xuXG4gICAgICAgIGxldCBjdHggPSB0aGlzLmVsLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgY29uc3Qgc2NvcmUgPSB0aGlzLmVsLmRhdGFzZXQuc2NvcmVcbiAgICAgICAgY29uc3QgbWF4VmFsdWUgPSAxMFxuICAgICAgICBjb25zdCByZW1haW5pbmdWYWx1ZSA9IG1heFZhbHVlIC0gc2NvcmVcbiAgICAgICAgY29uc3QgX3RpdGxlID0gdGhpcy5lbC5kYXRhc2V0LmxhYmVsXG4gICAgICAgIGNvbnN0IGJhY2tncm91bmRDb2xvciA9IHRoaXMuZWwuZGF0YXNldC5iZ2NvbG9yXG4gICAgICAgIGNvbnN0IGxhYmVsVmFsdWUgPSBzY29yZVxuXG4gICAgICAgIC8vIEN1c3RvbSBwbHVnaW4gdG8gYWRkIHRleHQgaW4gdGhlIGNlbnRlclxuICAgICAgICBjb25zdCBjZW50ZXJUZXh0UGx1Z2luID0ge1xuICAgICAgICAgICAgaWQ6IFwiY2VudGVyVGV4dFwiLFxuICAgICAgICAgICAgYmVmb3JlRHJhdyhjaGFydCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgd2lkdGggfSA9IGNoYXJ0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdG9wLCBoZWlnaHQgfSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdHggPSBjaGFydC5jdHg7XG5cbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGN0eC5mb250ID0gXCIyOXB4IHNhbnMtc2VyaWZcIjtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjMDAwXCI7XG4gICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGxhYmVsVmFsdWUsIHdpZHRoIC8gMiwgdG9wICsgaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgdHlwZTogXCJkb3VnaG51dFwiLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGRhdGFzZXRzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IFtzY29yZSwgcmVtYWluaW5nVmFsdWVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBbYmFja2dyb3VuZENvbG9yLCBcIiNkZGRkZGRcIl0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgYXNwZWN0UmF0aW86IDEuOSxcbiAgICAgICAgICAgICAgICByZXNwb25zaXZlOiBmYWxzZSwgLy8gV2hlbiB0cnVlLCBpdCBjYXVzZXMgYW4gZXJyb3IgaW4gUGhvZW5peC5cbiAgICAgICAgICAgICAgICBtYWludGFpbkFzcGVjdFJhdGlvOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjdXRvdXQ6IFwiODAlXCIsXG4gICAgICAgICAgICAgICAgcGx1Z2luczoge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IF90aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb250OiBcInVpLW1vbm9zcGFjZVwiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IDIwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGx1Z2luczogW2NlbnRlclRleHRQbHVnaW5dLCAvLyBSZWdpc3RlciB0aGUgY3VzdG9tIHBsdWdpblxuICAgICAgICB9O1xuXG4gICAgICAgIG5ldyBDaGFydChjdHgsIGNvbmZpZyk7XG4gICAgfSxcbn07XG4iLCAiaW1wb3J0IENoYXJ0IGZyb20gXCJjaGFydC5qcy9hdXRvXCI7XG5cbmV4cG9ydCBkZWZhdWx0IFByb2dyZXNzQmFyID0ge1xuICAgIG1vdW50ZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5lbCkgcmV0dXJuOyAvLyBFbnN1cmUgdGhlIGVsZW1lbnQgZXhpc3RzXG5cbiAgICAgICAgbGV0IGN0eCA9IHRoaXMuZWxcblxuICAgICAgICBjb25zdCBwcm9ncmVzc1ZhbHVlID0gY3R4LmRhdGFzZXQucHJvZ3Jlc3N2YWx1ZVxuICAgICAgICBjb25zdCBiZ2NvbG9yID0gY3R4LmRhdGFzZXQuYmdjb2xvclxuICAgICAgICBjb25zdCBtYXhWYWx1ZSA9IDkgfHwgY3R4LmRhdGFzZXQubWF4dmFsdWU7XG5cbiAgICAgICAgLy8gQ3VzdG9tIHBsdWdpbiB0byBzaG93IHByb2dyZXNzIHRleHQgaW5zaWRlIHRoZSBiYXJcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3NUZXh0UGx1Z2luID0ge1xuICAgICAgICAgICAgaWQ6IFwicHJvZ3Jlc3NUZXh0XCIsXG4gICAgICAgICAgICBhZnRlckRhdGFzZXRzRHJhdyhjaGFydCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY3R4IH0gPSBjaGFydDtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gY2hhcnQuZGF0YS5kYXRhc2V0c1swXTtcblxuICAgICAgICAgICAgICAgIGNoYXJ0LmdldERhdGFzZXRNZXRhKDApLmRhdGEuZm9yRWFjaCgoYmFyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRhdGFzZXQuZGF0YVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5mb250ID0gXCIxMnB4IHNhbnMtc2VyaWZcIjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoYCR7dmFsdWV9YCwgYmFyLnggLSAyMCwgYmFyLnkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICAgICB0eXBlOiBcImJhclwiLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGxhYmVsczogW1wiXCJdLCAvLyBTaW5nbGUgYmFyXG4gICAgICAgICAgICAgICAgZGF0YXNldHM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogW3Byb2dyZXNzVmFsdWVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBiZ2NvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFyUGVyY2VudGFnZTogMSwgLy8gRnVsbCB3aWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnlQZXJjZW50YWdlOiAxLCAvLyBGdWxsIGhlaWdodFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIGluZGV4QXhpczogXCJ5XCIsIC8vIEhvcml6b250YWwgYmFyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2l2ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWFpbnRhaW5Bc3BlY3RSYXRpbzogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2NhbGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heDogbWF4VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBmYWxzZSwgLy8gSGlkZSBheGlzXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZhbHNlLCAvLyBIaWRlIGF4aXNcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBsdWdpbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgbGVnZW5kOiB7IGRpc3BsYXk6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6IHsgZW5hYmxlZDogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBsdWdpbnM6IFtwcm9ncmVzc1RleHRQbHVnaW5dLFxuICAgICAgICB9O1xuXG4gICAgICAgIG5ldyBDaGFydChjdHgsIGNvbmZpZyk7XG4gICAgfSxcbn07XG4iLCAiZXhwb3J0IGRlZmF1bHQgVmlkZW9QbGF5ZXIgPSB7XG4gICAgbW91bnRlZCgpIHsgXG4gICAgICAgIGNvbnN0IHZpZGVvRWxlbWVudCA9IHRoaXMuZWxcbiAgICAgICAgY29uc3QgdmlkZW9fcGF0aCA9ICB0aGlzLmVsLmRhdGFzZXQudmlkZW9cbiAgICAgICAgLy8gXCJodHRwczovL2F1ZGlvLnN5bmFpYS5pby9zdHJlYW0vdmlkZW8vNDQyMzkyODA4OTQ4ODE4LTE4NDk0NTg5OTc3LUNOWUU2RlI0QU00RC1lbmRfb2ZfdGFzay5tcDRcIlxuICAgICAgICBjb25zdCBzb3VyY2VFbGVtZW50ID0gdmlkZW9FbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJzb3VyY2VcIilcbiAgICAgICAgc291cmNlRWxlbWVudC5zcmMgPSB2aWRlb19wYXRoXG4gICAgICAgIFxuICAgICAgICBjb25zdCB0b2tlbiA9IFwieW91cl92YWxpZF90b2tlblwiO1xuXG4gICAgICAgIC8vIEZldGNoIHZpZGVvIGZpbGUgd2l0aCBhdXRob3JpemF0aW9uIGlmIG5lY2Vzc2FyeVxuICAgICAgICBmZXRjaCh2aWRlb19wYXRoLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YFxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXR3b3JrIHJlc3BvbnNlIHdhcyBub3Qgb2snKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKGJsb2IgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgICAgIHNvdXJjZUVsZW1lbnQuc3JjID0gdXJsO1xuICAgICAgICAgICAgdmlkZW9FbGVtZW50LmxvYWQoKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoZXJlIHdhcyBhIHByb2JsZW0gd2l0aCB0aGUgZmV0Y2ggb3BlcmF0aW9uOicsIGVycm9yKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gcmV0dXJuICgpID0+IHtcbiAgICAgICAgLy8gICAgIHdhdmVTdXJmZXIuZGVzdHJveSgpXG4gICAgICAgIC8vICAgICB0aGlzLnBsYXlCdXR0b24uZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGNsaWNrUGxheSlcbiAgICAgICAgLy8gfTtcblxuICAgIH1cbn0iLCAiLy8gc3BlZWNoLW5vbi1zY3JpcHRlZC1pZFxuZXhwb3J0IGRlZmF1bHQgQ29udHJvbFBsYXkgPSB7XG4gICAgbW91bnRlZCgpIHtcbiAgICAgICAgbGV0IHNwZWVjaE5vbnNjcmlwdGVkQnRuID0gdGhpcy5lbFxuICAgICAgICBzcGVlY2hOb25zY3JpcHRlZEJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3BlZWNoTm9uc2NyaXB0ZWREaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNwZWVjaC1ub24tc2NyaXB0ZWQtaWRcIilcbiAgICAgICAgICAgIGNvbnN0IHNwZWVjaHNjcmlwdGVkRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzcGVlY2gtc2NyaXB0ZWQtaWRcIilcbiAgICAgICAgICAgIGlmICh0aGlzLmVsLmlkID09IFwidGFiLW9uZVwiKSB7XG4gICAgICAgICAgICAgICAgc3BlZWNoTm9uc2NyaXB0ZWREaXYuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKVxuICAgICAgICAgICAgICAgIHNwZWVjaHNjcmlwdGVkRGl2LmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIilcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3BlZWNoc2NyaXB0ZWREaXYuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKVxuICAgICAgICAgICAgICAgIHNwZWVjaE5vbnNjcmlwdGVkRGl2LmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG59IiwgIi8vIHNjcm9sbEludG9WaWV3KHsgYmVoYXZpb3I6ICdzbW9vdGgnIH0pXG5leHBvcnQgZGVmYXVsdCBTY3JvbGxJbnRvID0ge1xuICAgIG1vdW50ZWQoKSB7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5lbFxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgICAgICAgZWwuc2Nyb2xsSW50b1ZpZXcoeyBiZWhhdmlvcjogJ3Ntb290aCcgfSlcbiAgICAgICAgfSlcbiAgICB9XG59Il0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFNQSxPQUFDLFNBQVVBLFNBQVFDLFdBQVU7QUFDM0I7QUFHQSxTQUFDLFdBQVk7QUFDWCxjQUFJLFdBQVc7QUFDZixjQUFJLFVBQVUsQ0FBQyxNQUFNLE9BQU8sVUFBVSxHQUFHO0FBQ3pDLG1CQUFTLElBQUksR0FBRyxJQUFJLFFBQVEsVUFBVSxDQUFDRCxRQUFPLHVCQUF1QixFQUFFLEdBQUc7QUFDeEUsWUFBQUEsUUFBTyx3QkFDTEEsUUFB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LElBQ04sV0FBVztBQUFBLElBQ1gsTUFBTTtBQUFBLElBQ04sT0FBTztBQUFBLElBQ1AsUUFBUTtBQUFBLElBQ1IsT0FBTztBQUFBLElBQ1AsY0FBYztBQUFBLElBQ2QsSUFBSTtBQUFBLElBQ0osU0FBUztBQUFBLElBQ1QsTUFBTTtBQUFBLElBQ04sV0FBVztBQUFBLElBQ1gsUUFBUTtBQUFBLElBQ1IsVUFBVTtBQUFBLElBQ1YsU0FBUztBQUFBLElBQ1QsS0FBSztBQUFBLElBQ0wsYUFBYTtBQUFBLElBQ2IsU0FBUztBQUFBLElBQ1QsU0FBUztBQUFBLElBQ1QsTUFBTTtBQUFBLElBQ04sS0FBSztBQUFBLElBQ0wsT0FBTztBQUFBLElBQ1AsU0FBUztBQUFBLElBQ1QsTUFBTTtBQUFBLElBQ04sTUFBTTtBQUFBLElBQ04sTUFBTTtBQUFBLElBQ04sUUFBUTtBQUFBLElBQ1IsU0FBUztBQUFBLElBQ1QsVUFBVTtBQUFBLElBQ1YsUUFBUTtBQUFBLElBQ1IsT0FBTztBQUFBLElBQ1AsS0FBSztBQUFBLElBQ0wsUUFBUTtBQUFBLElBQ1IsUUFBUTtBQUFBLElBQ1IsTUFBTTtBQUFBLElBQ04sT0FBTztBQUFBLElBQ1AsT0FBTztBQUFBLElBQ1AsS0FBSztBQUFBLElBQ0wsUUFBUTtBQUFBLElBQ1IsUUFBUTtBQUFBLElBQ1IsVUFBVTtBQUFBLElBQ1YsUUFBUTtBQUFBLElBQ1IsUUFBUTtBQUFBLElBQ1IsVUFBVTtBQUFBLElBQ1YsVUFBVTtBQUFBLElBQ1YsVUFBVTtBQUFBLElBQ1YsVUFBVTtBQUFBLElBQ1YsUUFBUTtBQUFBLElBQ1IsU0FBUztBQUFBLElBQ1QsV0FBVztBQUFBLElBQ1gsS0FBSztBQUFBLElBQ0wsUUFBUTtBQUFBLElBQ1IsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsT0FBTztBQUFBLElBQ1AsS0FBSztBQUFBLElBQ0wsU0FBUztBQUFBLElBQ1QsUUFBUTtBQUFBLElBQ1IsU0FBUztBQUFBLElBQ1QsT0FBTztBQUFBLElBQ1AsTUFBTTtBQUFBLElBQ04sT0FBTztBQUFBLElBQ1AsUUFBUTtBQUFBLElBQ1IsV0FBVztBQUFBLElBQ1gsU0FBUztBQUFBLElBQ1QsWUFBWTtBQUFBLElBQ1osS0FBSztBQUFBLElBQ0wsTUFBTTtBQUFBLElBQ04sT0FBTztBQUFBLElBQ1AsV0FBVztBQUFBLElBQ1gsTUFBTTtBQUFBLElBQ04sTUFBTTtBQUFBLElBQ04sTUFBTTtBQUFBLElBQ04sTUFBTTtBQUFBLElBQ04sUUFBUTtBQUFBLElBQ1IsUUFBUTtBQUFBLElBQ1IsUUFBUTtBQUFBLElBQ1IsT0FBTztBQUFBLElBQ1AsT0FBTztBQUFBLElBQ1AsU0FBUztBQUFBLElBQ1QsS0FBSztBQUFBLElBQ0wsTUFBTTtBQUFBLElBQ04sU0FBUztBQUFBLElBQ1QsS0FBSztBQUFBLElBQ0wsUUFBUTtBQUFBLElBQ1IsT0FBTztBQUFBLElBQ1AsWUFBWTtBQUFBLElBQ1osS0FBSztBQUFBLElBQ0wsT0FBTztBQUFBLElBQ1AsUUFBUTtBQUFBLElBQ1IsUUFBUTtBQUFBLElBQ1IsTUFBTTtBQUFBLElBQ04sV0FBVztBQUFBLElBQ1gsS0FBSztBQUFBLElBQ0wsVUFBVTtBQUFBLElBQ1YsWUFBWTtBQUFBLElBQ1osU0FBUztBQUFBLElBQ1QsVUFBVTtBQUFBLElBQ1YsU0FBUztBQUFBLElBQ1QsWUFBWTtBQUFBLElBQ1osTUFBTTtBQUFBLElBQ04sUUFBUTtBQUFBLElBQ1IsTUFBTTtBQUFBLElBQ04sU0FBUztBQUFBLElBQ1QsT0FBTztBQUFBLElBQ1AsU0FBUztBQUFBLElBQ1QsTUFBTTtBQUFBLElBQ04sV0FBVztBQUFBLElBQ1gsUUFBUTtBQUFBLElBQ1IsT0FBTztBQUFBLElBQ1AsWUFBWTtBQUFBLElBQ1osV0FBVztBQUFBLElBQ1gsU0FBUztBQUFBLElBQ1QsTUFBTTtBQUFBLElBQ04sS0FBSztBQUFBLElBQ0wsTUFBTTtBQUFBLElBQ04sU0FBUztBQUFBLElBQ1QsT0FBTztBQUFBLElBQ1AsYUFBYTtBQUFBLElBQ2IsSUFBSTtBQUFBLElBQ0osVUFBVTtBQUFBLElBQ1YsT0FBTztBQUFB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QUMzRSxTQUFPLGlCQUFpQix5QkFBeUIsV0FBUyxjQUFBQSxRQUFPLEtBQUssQ0FBQztBQUd2RSxhQUFXLFFBQVE7QUFNbkIsU0FBTyxhQUFhOyIsCiAgIm5hbWVzIjogWyJ3aW5kb3ciLCAiZG9jdW1lbnQiLCAiY2FsbGJhY2siLCAidG9wYmFyIiwgInRvIiwgIkN1c3RvbUV2ZW50IiwgInRvIiwgImUiLCAiY2xvc3VyZSIsICJjYWxsYmFjayIsICJoIiwgImkiLCAiZSIsICJjYWxsYmFjayIsICJjIiwgImkiLCAibGl2ZVNvY2tldCIsICJlIiwgImkiLCAiY2xvc3VyZSIsICJjYWxsYmFjayIsICJ0byIsICJpc0VtcHR5IiwgImRlYm91bmNlIiwgInQiLCAiZmlsZSIsICJkIiwgIm1vcnBoQXR0cnMiLCAibW9ycGhkb20iLCAiY2hpbGRyZW5Pbmx5IiwgInRhcmdldENvbnRhaW5lciIsICJmcm9tIiwgImMiLCAiY2xvbmUiLCAidmlldyIsICJlbCIsICJza2lwIiwgImRlZmF1bHRzIiwgIm5hbWVzIiwgInJlc29sdmUiLCAiaXNBcnJheSIsICJlbGVtZW50cyIsICJob29rcyIsICJsb2NrIiwgImxvYWRpbmciLCAiZW50cnkiLCAiaW5wdXQiLCAiY2xvc3VyZSIsICJjYWxsYmFjayIsICJlIiwgInRvIiwgImVsZW1lbnRzIiwgInQiLCAiZSIsICJpIiwgInMiLCAibiIsICJyIiwgIm8iLCAiaCIsICJhIiwgInQiLCAiZSIsICJpIiwgInMiLCAibiIsICJyIiwgIm8iLCAiYSIsICJoIiwgImwiLCAiZCIsICJjIiwgInUiLCAibSIsICJsIiwgImgiLCAiYSIsICJoIiwgInMiLCAibCIsICJuIiwgImkiLCAiciIsICJkIiwgIm1heCIsICJyYW5nZSIsICJjIiwgInQiLCAiY2xvbmUiLCAiY29sb3IiLCAibm9vcCIsICJ1aWQiLCAiaWQiLCAiaXNOdWxsT3JVbmRlZiIsICJ2YWx1ZSIsICJ1bmRlZmluZWQiLCAiaXNBcnJheSIsICJBcnJheSIsICJ0eXBlIiwgIk9iamVjdCIsICJwcm90b3R5cGUiLCAidG9TdHJpbmciLCAiY2FsbCIsICJzbGljZSIsICJpc09iamVjdCIsICJpc051bWJlckZpbml0ZSIsICJOdW1iZXIiLCAiaXNGaW5pdGUiLCAiZmluaXRlT3JEZWZhdWx0IiwgImRlZmF1bHRWYWx1ZSIsICJ2YWx1ZU9yRGVmYXVsdCIsICJ0b1BlcmNlbnRhZ2UiLCAiZGltZW5zaW9uIiwgImVuZHNXaXRoIiwgInBhcnNlRmxvYXQiLCAidG9EaW1lbnNpb24iLCAiY2FsbGJhY2siLCAiZm4iLCAiYXJncyIsICJ0aGlzQXJnIiwgImFwcGx5IiwgImVhY2giLCAibG9vcGFibGUiLCAicmV2ZXJzZSIsICJpIiwgImxlbiIsICJrZXlzIiwgImxlbmd0aCIsICJfZWxlbWVudHNFcXVhbCIsICJhMCIsICJhMSIsICJpbGVuIiwgInYwIiwgInYxIiwgImRhdGFzZXRJbmRleCIsICJpbmRleCIsICJjbG9uZSIsICJzb3VyY2UiLCAibWFwIiwgInRhcmdldCIsICJjcmVhdGUiLCAia2xlbiIsICJrIiwgImlzVmFsaWRLZXkiLCAia2V5IiwgImluZGV4T2YiLCAiX21lcmdlciIsICJvcHRpb25zIiwgInR2YWwiLCAic3ZhbCIsICJtZXJnZSIsICJzb3VyY2VzIiwgIm1lcmdlciIsICJjdXJyZW50IiwgIm1lcmdlSWYiLCAiX21lcmdlcklmIiwgImhhc093blByb3BlcnR5IiwgImtleVJlc29sdmVycyIsICJ2IiwgIngiLCAibyIsICJ5IiwgIl9zcGxpdEtleSIsICJrZXkiLCAicGFydHMiLCAic3BsaXQiLCAia2V5cyIsICJ0bXAiLCAicGFydCIsICJlbmRzV2l0aCIsICJzbGljZSIsICJwdXNoIiwgIl9nZXRLZXlSZXNvbHZlciIsICJvYmoiLCAiayIsICJyZXNvbHZlT2JqZWN0S2V5IiwgInJlc29sdmVyIiwgIl9jYXBpdGFsaXplIiwgInN0ciIsICJjaGFyQXQiLCAidG9VcHBlckNhc2UiLCAiZGVmaW5lZCIsICJ2YWx1ZSIsICJpc0Z1bmN0aW9uIiwgInNldHNFcXVhbCIsICJhIiwgImIiLCAic2l6ZSIsICJpdGVtIiwgImhhcyIsICJfaXNDbGlja0V2ZW50IiwgImUiLCAidHlwZSIsICJQSSIsICJNYXRoIiwgIlRBVSIsICJQSVRBVSIsICJJTkZJTklUWSIsICJOdW1iZXIiLCAiUE9TSVRJVkVfSU5GSU5JVFkiLCAiUkFEX1BFUl9ERUciLCAiSEFMRl9QSSIsICJRVUFSVEVSX1BJIiwgIlRXT19USElSRFNfUEkiLCAibG9nMTAiLCAic2lnbiIsICJhbG1vc3RFcXVhbHMiLCAiZXBzaWxvbiIsICJhYnMiLCAibmljZU51bSIsICJyYW5nZSIsICJyb3VuZGVkUmFuZ2UiLCAicm91bmQiLCAibmljZVJhbmdlIiwgInBvdyIsICJmbG9vciIsICJmcmFjdGlvbiIsICJuaWNlRnJhY3Rpb24iLCAiX2ZhY3Rvcml6ZSIsICJyZXN1bHQiLCAic3FydCIsICJpIiwgInNvcnQiLCAicG9wIiwgImlzTnVtYmVyIiwgIm4iLCAiaXNOYU4iLCAicGFyc2VGbG9hdCIsICJpc0Zpbml0ZSIsICJhbG1vc3RXaG9sZSIsICJyb3VuZGVkIiwgIl9zZXRNaW5BbmRNYXhCeUtleSIsICJhcnJheSIsICJ0YXJnZXQiLCAicHJvcGVydHkiLCAiaWxlbiIsICJsZW5ndGgiLCAibWluIiwgIm1heCIsICJ0b1JhZGlhbnMiLCAiZGVncmVlcyIsICJ0b0RlZ3JlZXMiLCAicmFkaWFucyIsICJfZGVjaW1hbFBsYWNlcyIsICJpc0Zpbml0ZU51bWJlciIsICJwIiwgImdldEFuZ2xlRnJvbVBvaW50IiwgImNlbnRyZVBvaW50IiwgImFuZ2xlUG9pbnQiLCAiZGlzdGFuY2VGcm9tWENlbnRlciIsICJkaXN0YW5jZUZyb21ZQ2VudGVyIiwgInJhZGlhbERpc3RhbmNlRnJvbUNlbnRlciIsICJhbmdsZSIsICJhdGFuMiIsICJkaXN0YW5jZSIsICJkaXN0YW5jZUJldHdlZW5Qb2ludHMiLCAicHQxIiwgInB0MiIsICJfYW5nbGVEaWZmIiwgIl9ub3JtYWxpemVBbmdsZSIsICJfYW5nbGVCZXR3ZWVuIiwgInN0YXJ0IiwgImVuZCIsICJzYW1lQW5nbGVJc0Z1bGxDaXJjbGUiLCAicyIsICJhbmdsZVRvU3RhcnQiLCAiYW5nbGVUb0VuZCIsICJzdGFydFRvQW5nbGUiLCAiZW5kVG9BbmdsZSIsICJfbGltaXRWYWx1ZSIsICJfaW50MTZSYW5nZSIsICJfaXNCZXR3ZWVuIiwgIl9sb29rdXAiLCAidGFibGUiLCAiY21wIiwgImluZGV4IiwgImhpIiwgImxvIiwgIm1pZCIsICJfbG9va3VwQnlLZXkiLCAibGFzdCIsICJ0aSIsICJfcmxvb2t1cEJ5S2V5IiwgIl9maWx0ZXJCZXR3ZWVuIiwgInZhbHVlcyIsICJhcnJheUV2ZW50cyIsICJsaXN0ZW5BcnJheUV2ZW50cyIsICJsaXN0ZW5lciIsICJfY2hhcnRqcyIsICJsaXN0ZW5lcnMiLCAiT2JqZWN0IiwgImRlZmluZVByb3BlcnR5IiwgImNvbmZpZ3VyYWJsZSIsICJlbnVtZXJhYmxlIiwgImZvckVhY2giLCAibWV0aG9kIiwgImJhc2UiLCAiYXJncyIsICJyZXMiLCAiYXBwbHkiLCAib2JqZWN0IiwgInVubGlzdGVuQXJyYXlFdmVudHMiLCAic3R1YiIsICJpbmRleE9mIiwgInNwbGljZSIsICJfYXJyYXlVbmlxdWUiLCAiaXRlbXMiLCAic2V0IiwgIlNldCIsICJBcnJheSIsICJmcm9tIiwgInJlcXVlc3RBbmltRnJhbWUiLCAid2luZG93IiwgImNhbGxiYWNrIiwgInJlcXVlc3RBbmltYXRpb25GcmFtZSIsICJ0aHJvdHRsZWQiLCAiZm4iLCAidGhpc0FyZyIsICJhcmdzVG9Vc2UiLCAidGlja2luZyIsICJhcmdzIiwgImNhbGwiLCAiYXBwbHkiLCAiZGVib3VuY2UiLCAiZGVsYXkiLCAidGltZW91dCIsICJjbGVhclRpbWVvdXQiLCAic2V0VGltZW91dCIsICJfdG9MZWZ0UmlnaHRDZW50ZXIiLCAiYWxpZ24iLCAiX2FsaWduU3RhcnRFbmQiLCAic3RhcnQiLCAiZW5kIiwgIl90ZXh0WCIsICJsZWZ0IiwgInJpZ2h0IiwgInJ0bCIsICJjaGVjayIsICJfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyIsICJtZXRhIiwgInBvaW50cyIsICJhbmltYXRpb25zRGlzYWJsZWQiLCAicG9pbnRDb3VudCIsICJsZW5ndGgiLCAiY291bnQiLCAiX3NvcnRlZCIsICJpU2NhbGUiLCAiX3BhcnNlZCIsICJheGlzIiwgIm1pbiIsICJtYXgiLCAibWluRGVmaW5lZCIsICJtYXhEZWZpbmVkIiwgImdldFVzZXJCb3VuZHMiLCAiX2xpbWl0VmFsdWUiLCAiTWF0aCIsICJfbG9va3VwQnlLZXkiLCAibG8iLCAiZ2V0UGl4ZWxGb3JWYWx1ZSIsICJoaSIsICJfc2NhbGVSYW5nZXNDaGFuZ2VkIiwgInhTY2FsZSIsICJ5U2NhbGUiLCAiX3NjYWxlUmFuZ2VzIiwgIm5ld1JhbmdlcyIsICJ4bWluIiwgInhtYXgiLCAieW1pbiIsICJ5bWF4IiwgImNoYW5nZWQiLCAiT2JqZWN0IiwgImFzc2lnbiIsICJhdEVkZ2UiLCAidCIsICJlbGFzdGljSW4iLCAicyIsICJwIiwgInBvdyIsICJzaW4iLCAiVEFVIiwgImVsYXN0aWNPdXQiLCAiZWZmZWN0cyIsICJsaW5lYXIiLCAiZWFzZUluUXVhZCIsICJlYXNlT3V0UXVhZCIsICJlYXNlSW5PdXRRdWFkIiwgImVhc2VJbkN1YmljIiwgImVhc2VPdXRDdWJpYyIsICJlYXNlSW5PdXRDdWJpYyIsICJlYXNlSW5RdWFydCIsICJlYXNlT3V0UXVhcnQiLCAiZWFzZUluT3V0UXVhcnQiLCAiZWFzZUluUXVpbnQiLCAiZWFzZU91dFF1aW50IiwgImVhc2VJbk91dFF1aW50IiwgImVhc2VJblNpbmUiLCAiY29zIiwgIkhBTEZfUEkiLCAiZWFzZU91dFNpbmUiLCAiZWFzZUluT3V0U2luZSIsICJQSSIsICJlYXNlSW5FeHBvIiwgImVhc2VPdXRFeHBvIiwgImVhc2VJbk91dEV4cG8iLCAiZWFzZUluQ2lyYyIsICJzcXJ0IiwgImVhc2VPdXRDaXJjIiwgImVhc2VJbk91dENpcmMiLCAiZWFzZUluRWxhc3RpYyIsICJlYXNlT3V0RWxhc3RpYyIsICJlYXNlSW5PdXRFbGFzdGljIiwgImVhc2VJbkJhY2siLCAiZWFzZU91dEJhY2siLCAiZWFzZUluT3V0QmFjayIsICJlYXNlSW5Cb3VuY2UiLCAiZWFzZU91dEJvdW5jZSIsICJtIiwgImQiLCAiZWFzZUluT3V0Qm91bmNlIiwgImlzUGF0dGVybk9yR3JhZGllbnQiLCAidmFsdWUiLCAidHlwZSIsICJ0b1N0cmluZyIsICJjb2xvciIsICJDb2xvciIsICJnZXRIb3ZlckNvbG9yIiwgInNhdHVyYXRlIiwgImRhcmtlbiIsICJoZXhTdHJpbmciLCAibnVtYmVycyIsICJjb2xvcnMiLCAiYXBwbHlBbmltYXRpb25zRGVmYXVsdHMiLCAiZGVmYXVsdHMiLCAic2V0IiwgInVuZGVmaW5lZCIsICJkdXJhdGlvbiIsICJlYXNpbmciLCAiZnJvbSIsICJsb29wIiwgInRvIiwgImRlc2NyaWJlIiwgIl9mYWxsYmFjayIsICJfaW5kZXhhYmxlIiwgIl9zY3JpcHRhYmxlIiwgIm5hbWUiLCAicHJvcGVydGllcyIsICJhY3RpdmUiLCAiYW5pbWF0aW9uIiwgInJlc2l6ZSIsICJzaG93IiwgImFuaW1hdGlvbnMiLCAidmlzaWJsZSIsICJoaWRlIiwgInYiLCAiYXBwbHlMYXlvdXRzRGVmYXVsdHMiLCAiYXV0b1BhZGRpbmciLCAicGFkZGluZyIsICJ0b3AiLCAiYm90dG9tIiwgImludGxDYWNoZSIsICJNYXAiLCAiZ2V0TnVtYmVyRm9ybWF0IiwgImxvY2FsZSIsICJvcHRpb25zIiwgImNhY2hlS2V5IiwgIkpTT04iLCAic3RyaW5naWZ5IiwgImZvcm1hdHRlciIsICJnZXQiLCAiSW50bCIsICJOdW1iZXJGb3JtYXQiLCAiZm9ybWF0TnVtYmVyIiwgIm51bSIsICJmb3JtYXQiLCAiZm9ybWF0dGVycyIsICJ2YWx1ZXMiLCAiaXNBcnJheSIsICJudW1lcmljIiwgInRpY2tWYWx1ZSIsICJpbmRleCIsICJ0aWNrcyIsICJjaGFydCIsICJub3RhdGlvbiIsICJkZWx0YSIsICJtYXhUaWNrIiwgImFicyIsICJjYWxjdWxhdGVEZWx0YSIsICJsb2dEZWx0YSIsICJsb2cxMCIsICJudW1EZWNpbWFsIiwgImlzTmFOIiwgImZsb29yIiwgIm1pbmltdW1GcmFjdGlvbkRpZ2l0cyIsICJtYXhpbXVtRnJhY3Rpb25EaWdpdHMiLCAibG9nYXJpdGhtaWMiLCAicmVtYWluIiwgInNpZ25pZmljYW5kIiwgImluY2x1ZGVzIiwgImFwcGx5U2NhbGVEZWZhdWx0cyIsICJkaXNwbGF5IiwgIm9mZnNldCIsICJyZXZlcnNlIiwgImJlZ2luQXRaZXJvIiwgImJvdW5kcyIsICJjbGlwIiwgImdyYWNlIiwgImdyaWQiLCAibGluZVdpZHRoIiwgImRyYXdPbkNoYXJ0QXJlYSIsICJkcmF3VGlja3MiLCAidGlja0xlbmd0aCIsICJ0aWNrV2lkdGgiLCAiX2N0eCIsICJ0aWNrQ29sb3IiLCAiYm9yZGVyIiwgImRhc2giLCAiZGFzaE9mZnNldCIsICJ3aWR0aCIsICJ0aXRsZSIsICJ0ZXh0IiwgIm1pblJvdGF0aW9uIiwgIm1heFJvdGF0aW9uIiwgIm1pcnJvciIsICJ0ZXh0U3Ryb2tlV2lkdGgiLCAidGV4dFN0cm9rZUNvbG9yIiwgImF1dG9Ta2lwIiwgImF1dG9Ta2lwUGFkZGluZyIsICJsYWJlbE9mZnNldCIsICJUaWNrcyIsICJtaW5vciIsICJtYWpvciIsICJjcm9zc0FsaWduIiwgInNob3dMYWJlbEJhY2tkcm9wIiwgImJhY2tkcm9wQ29sb3IiLCAiYmFja2Ryb3BQYWRkaW5nIiwgInJvdXRlIiwgInN0YXJ0c1dpdGgiLCAib3ZlcnJpZGVzIiwgImNyZWF0ZSIsICJkZXNjcmlwdG9ycyIsICJnZXRTY29wZSIsICJub2RlIiwgImtleSIsICJrZXlzIiwgInNwbGl0IiwgImkiLCAibiIsICJrIiwgInJvb3QiLCAic2NvcGUiLCAibWVyZ2UiLCAiRGVmYXVsdHMiLCAiY29uc3RydWN0b3IiLCAiX2Rlc2NyaXB0b3JzIiwgIl9hcHBsaWVycyIsICJiYWNrZ3JvdW5kQ29sb3IiLCAiYm9yZGVyQ29sb3IiLCAiZGF0YXNldHMiLCAiZGV2aWNlUGl4ZWxSYXRpbyIsICJjb250ZXh0IiwgInBsYXRmb3JtIiwgImdldERldmljZVBpeGVsUmF0aW8iLCAiZWxlbWVudHMiLCAiZXZlbnRzIiwgImZvbnQiLCAiZmFtaWx5IiwgInNpemUiLCAic3R5bGUiLCAibGluZUhlaWdodCIsICJ3ZWlnaHQiLCAiaG92ZXIiLCAiaG92ZXJCYWNrZ3JvdW5kQ29sb3IiLCAiY3R4IiwgImhvdmVyQm9yZGVyQ29sb3IiLCAiaG92ZXJDb2xvciIsICJpbmRleEF4aXMiLCAiaW50ZXJhY3Rpb24iLCAibW9kZSIsICJpbnRlcnNlY3QiLCAiaW5jbHVkZUludmlzaWJsZSIsICJtYWludGFpbkFzcGVjdFJhdGlvIiwgIm9uSG92ZXIiLCAib25DbGljayIsICJwYXJzaW5nIiwgInBsdWdpbnMiLCAicmVzcG9uc2l2ZSIsICJzY2FsZSIsICJzY2FsZXMiLCAic2hvd0xpbmUiLCAiZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AiLCAib3ZlcnJpZGUiLCAidGFyZ2V0U2NvcGUiLCAidGFyZ2V0TmFtZSIsICJzY29wZU9iamVjdCIsICJ0YXJnZXRTY29wZU9iamVjdCIsICJwcml2YXRlTmFtZSIsICJkZWZpbmVQcm9wZXJ0aWVzIiwgIndyaXRhYmxlIiwgImVudW1lcmFibGUiLCAibG9jYWwiLCAidGFyZ2V0IiwgImlzT2JqZWN0IiwgInZhbHVlT3JEZWZhdWx0IiwgImFwcGxpZXJzIiwgImZvckVhY2giLCAidG9Gb250U3RyaW5nIiwgImlzTnVsbE9yVW5kZWYiLCAiX21lYXN1cmVUZXh0IiwgImRhdGEiLCAiZ2MiLCAibG9uZ2VzdCIsICJzdHJpbmciLCAidGV4dFdpZHRoIiwgIm1lYXN1cmVUZXh0IiwgInB1c2giLCAiX2xvbmdlc3RUZXh0IiwgImFycmF5T2ZUaGluZ3MiLCAiY2FjaGUiLCAiZ2FyYmFnZUNvbGxlY3QiLCAic2F2ZSIsICJpbGVuIiwgImoiLCAiamxlbiIsICJ0aGluZyIsICJuZXN0ZWRUaGluZyIsICJyZXN0b3JlIiwgImdjTGVuIiwgInNwbGljZSIsICJfYWxpZ25QaXhlbCIsICJwaXhlbCIsICJjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyIsICJoYWxmV2lkdGgiLCAicm91bmQiLCAiY2xlYXJDYW52YXMiLCAiY2FudmFzIiwgImdldENvbnRleHQiLCAicmVzZXRUcmFuc2Zvcm0iLCAiY2xlYXJSZWN0IiwgImhlaWdodCIsICJkcmF3UG9pbnQiLCAieCIsICJ5IiwgImRyYXdQb2ludExlZ2VuZCIsICJ3IiwgInhPZmZzZXQiLCAieU9mZnNldCIsICJjb3JuZXJSYWRpdXMiLCAieE9mZnNldFciLCAieU9mZnNldFciLCAicG9pbnRTdHlsZSIsICJyb3RhdGlvbiIsICJyYWRpdXMiLCAicmFkIiwgIlJBRF9QRVJfREVHIiwgInRyYW5zbGF0ZSIsICJyb3RhdGUiLCAiZHJhd0ltYWdlIiwgImJlZ2luUGF0aCIsICJlbGxpcHNlIiwgImFyYyIsICJjbG9zZVBhdGgiLCAibW92ZVRvIiwgIlRXT19USElSRFNfUEkiLCAibGluZVRvIiwgIlFVQVJURVJfUEkiLCAiU1FSVDFfMiIsICJyZWN0IiwgImZpbGwiLCAiYm9yZGVyV2lkdGgiLCAic3Ryb2tlIiwgIl9pc1BvaW50SW5BcmVhIiwgInBvaW50IiwgImFyZWEiLCAibWFyZ2luIiwgImNsaXBBcmVhIiwgInVuY2xpcEFyZWEiLCAiX3N0ZXBwZWRMaW5lVG8iLCAicHJldmlvdXMiLCAiZmxpcCIsICJtaWRwb2ludCIsICJfYmV6aWVyQ3VydmVUbyIsICJiZXppZXJDdXJ2ZVRvIiwgImNwMXgiLCAiY3AyeCIsICJjcDF5IiwgImNwMnkiLCAic2V0UmVuZGVyT3B0cyIsICJvcHRzIiwgInRyYW5zbGF0aW9uIiwgImZpbGxTdHlsZSIsICJ0ZXh0QWxpZ24iLCAidGV4dEJhc2VsaW5lIiwgImRlY29yYXRlVGV4dCIsICJsaW5lIiwgInN0cmlrZXRocm91Z2giLCAidW5kZXJsaW5lIiwgIm1ldHJpY3MiLCAiYWN0dWFsQm91bmRpbmdCb3hMZWZ0IiwgImFjdHVhbEJvdW5kaW5nQm94UmlnaHQiLCAiYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQiLCAiYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50IiwgInlEZWNvcmF0aW9uIiwgInN0cm9rZVN0eWxlIiwgImRlY29yYXRpb25XaWR0aCIsICJkcmF3QmFja2Ryb3AiLCAib2xkQ29sb3IiLCAiZmlsbFJlY3QiLCAicmVuZGVyVGV4dCIsICJsaW5lcyIsICJzdHJva2VXaWR0aCIsICJzdHJva2VDb2xvciIsICJiYWNrZHJvcCIsICJzdHJva2VUZXh0IiwgIm1heFdpZHRoIiwgImZpbGxUZXh0IiwgIk51bWJlciIsICJhZGRSb3VuZGVkUmVjdFBhdGgiLCAiaCIsICJ0b3BMZWZ0IiwgImJvdHRvbUxlZnQiLCAiYm90dG9tUmlnaHQiLCAidG9wUmlnaHQiLCAiTElORV9IRUlHSFQiLCAiRk9OVF9TVFlMRSIsICJ0b0xpbmVIZWlnaHQiLCAibWF0Y2hlcyIsICJtYXRjaCIsICJudW1iZXJPclplcm8iLCAiX3JlYWRWYWx1ZVRvUHJvcHMiLCAicHJvcHMiLCAicmV0IiwgIm9ialByb3BzIiwgInJlYWQiLCAicHJvcCIsICJ0b1RSQkwiLCAidG9UUkJMQ29ybmVycyIsICJ0b1BhZGRpbmciLCAib2JqIiwgInRvRm9udCIsICJmYWxsYmFjayIsICJwYXJzZUludCIsICJjb25zb2xlIiwgIndhcm4iLCAicmVzb2x2ZSIsICJpbnB1dHMiLCAiaW5mbyIsICJjYWNoZWFibGUiLCAiX2FkZEdyYWNlIiwgIm1pbm1heCIsICJjaGFuZ2UiLCAidG9EaW1lbnNpb24iLCAia2VlcFplcm8iLCAiYWRkIiwgImNyZWF0ZUNvbnRleHQiLCAicGFyZW50Q29udGV4dCIsICJfY3JlYXRlUmVzb2x2ZXIiLCAic2NvcGVzIiwgInByZWZpeGVzIiwgInJvb3RTY29wZXMiLCAiZ2V0VGFyZ2V0IiwgImZpbmFsUm9vdFNjb3BlcyIsICJfcmVzb2x2ZSIsICJTeW1ib2wiLCAidG9TdHJpbmdUYWciLCAiX2NhY2hlYWJsZSIsICJfc2NvcGVzIiwgIl9yb290U2NvcGVzIiwgIl9nZXRUYXJnZXQiLCAiUHJveHkiLCAiZGVsZXRlUHJvcGVydHkiLCAiX2tleXMiLCAiX2NhY2hlZCIsICJfcmVzb2x2ZVdpdGhQcmVmaXhlcyIsICJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCAiUmVmbGVjdCIsICJnZXRQcm90b3R5cGVPZiIsICJoYXMiLCAiZ2V0S2V5c0Zyb21BbGxTY29wZXMiLCAib3duS2V5cyIsICJzdG9yYWdlIiwgIl9zdG9yYWdlIiwgIl9hdHRhY2hDb250ZXh0IiwgInByb3h5IiwgInN1YlByb3h5IiwgImRlc2NyaXB0b3JEZWZhdWx0cyIsICJfcHJveHkiLCAiX2NvbnRleHQiLCAiX3N1YlByb3h5IiwgIl9zdGFjayIsICJTZXQiLCAic2V0Q29udGV4dCIsICJyZWNlaXZlciIsICJfcmVzb2x2ZVdpdGhDb250ZXh0IiwgImFsbEtleXMiLCAiY29uZmlndXJhYmxlIiwgInNjcmlwdGFibGUiLCAiaW5kZXhhYmxlIiwgIl9hbGxLZXlzIiwgImlzU2NyaXB0YWJsZSIsICJpc0Z1bmN0aW9uIiwgImlzSW5kZXhhYmxlIiwgInJlYWRLZXkiLCAicHJlZml4IiwgIl9jYXBpdGFsaXplIiwgIm5lZWRzU3ViUmVzb2x2ZXIiLCAicHJvdG90eXBlIiwgImhhc093blByb3BlcnR5IiwgIl9yZXNvbHZlU2NyaXB0YWJsZSIsICJfcmVzb2x2ZUFycmF5IiwgImdldFZhbHVlIiwgIkVycm9yIiwgIkFycmF5IiwgImpvaW4iLCAiZGVsZXRlIiwgImNyZWF0ZVN1YlJlc29sdmVyIiwgImFyciIsICJmaWx0ZXIiLCAiaXRlbSIsICJyZXNvbHZlciIsICJyZXNvbHZlRmFsbGJhY2siLCAicGFyZW50IiwgInJlc29sdmVPYmplY3RLZXkiLCAiYWRkU2NvcGVzIiwgInBhcmVudFNjb3BlcyIsICJwYXJlbnRGYWxsYmFjayIsICJhbGxTY29wZXMiLCAiYWRkU2NvcGVzRnJvbUtleSIsICJzdWJHZXRUYXJnZXQiLCAicmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzIiwgIl9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZSIsICJfcGFyc2luZyIsICJwYXJzZWQiLCAiciIsICJwYXJzZSIsICJFUFNJTE9OIiwgImdldFBvaW50IiwgInNraXAiLCAiZ2V0VmFsdWVBeGlzIiwgInNwbGluZUN1cnZlIiwgImZpcnN0UG9pbnQiLCAibWlkZGxlUG9pbnQiLCAiYWZ0ZXJQb2ludCIsICJjdXJyZW50IiwgIm5leHQiLCAiZDAxIiwgImRpc3RhbmNlQmV0d2VlblBvaW50cyIsICJkMTIiLCAiczAxIiwgInMxMiIsICJmYSIsICJmYiIsICJtb25vdG9uZUFkanVzdCIsICJkZWx0YUsiLCAibUsiLCAicG9pbnRzTGVuIiwgImFscGhhSyIsICJiZXRhSyIsICJ0YXVLIiwgInNxdWFyZWRNYWduaXR1ZGUiLCAicG9pbnRDdXJyZW50IiwgInBvaW50QWZ0ZXIiLCAiYWxtb3N0RXF1YWxzIiwgIm1vbm90b25lQ29tcHV0ZSIsICJ2YWx1ZUF4aXMiLCAicG9pbnRCZWZvcmUiLCAiaVBpeGVsIiwgInZQaXhlbCIsICJzcGxpbmVDdXJ2ZU1vbm90b25lIiwgInNsb3BlRGVsdGEiLCAic2lnbiIsICJjYXBDb250cm9sUG9pbnQiLCAicHQiLCAiY2FwQmV6aWVyUG9pbnRzIiwgImluQXJlYSIsICJpbkFyZWFQcmV2IiwgImluQXJlYU5leHQiLCAiX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMiLCAiY29udHJvbFBvaW50cyIsICJzcGFuR2FwcyIsICJjdWJpY0ludGVycG9sYXRpb25Nb2RlIiwgInByZXYiLCAidGVuc2lvbiIsICJfaXNEb21TdXBwb3J0ZWQiLCAiZG9jdW1lbnQiLCAiX2dldFBhcmVudE5vZGUiLCAiZG9tTm9kZSIsICJwYXJlbnROb2RlIiwgImhvc3QiLCAicGFyc2VNYXhTdHlsZSIsICJzdHlsZVZhbHVlIiwgInBhcmVudFByb3BlcnR5IiwgInZhbHVlSW5QaXhlbHMiLCAiaW5kZXhPZiIsICJnZXRDb21wdXRlZFN0eWxlIiwgImVsZW1lbnQiLCAib3duZXJEb2N1bWVudCIsICJkZWZhdWx0VmlldyIsICJnZXRTdHlsZSIsICJlbCIsICJwcm9wZXJ0eSIsICJnZXRQcm9wZXJ0eVZhbHVlIiwgInBvc2l0aW9ucyIsICJnZXRQb3NpdGlvbmVkU3R5bGUiLCAic3R5bGVzIiwgInN1ZmZpeCIsICJyZXN1bHQiLCAicG9zIiwgInBhcnNlRmxvYXQiLCAidXNlT2Zmc2V0UG9zIiwgInNoYWRvd1Jvb3QiLCAiZ2V0Q2FudmFzUG9zaXRpb24iLCAiZSIsICJ0b3VjaGVzIiwgInNvdXJjZSIsICJvZmZzZXRYIiwgIm9mZnNldFkiLCAiYm94IiwgImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsICJjbGllbnRYIiwgImNsaWVudFkiLCAiZ2V0UmVsYXRpdmVQb3NpdGlvbiIsICJldmVudCIsICJib3JkZXJCb3giLCAiYm94U2l6aW5nIiwgInBhZGRpbmdzIiwgImJvcmRlcnMiLCAiZ2V0Q29udGFpbmVyU2l6ZSIsICJtYXhIZWlnaHQiLCAiY29udGFpbmVyIiwgImNsaWVudFdpZHRoIiwgImNsaWVudEhlaWdodCIsICJjb250YWluZXJTdHlsZSIsICJjb250YWluZXJCb3JkZXIiLCAiY29udGFpbmVyUGFkZGluZyIsICJJTkZJTklUWSIsICJyb3VuZDEiLCAiZ2V0TWF4aW11bVNpemUiLCAiYmJXaWR0aCIsICJiYkhlaWdodCIsICJhc3BlY3RSYXRpbyIsICJtYXJnaW5zIiwgImNvbnRhaW5lclNpemUiLCAibWFpbnRhaW5IZWlnaHQiLCAicmV0aW5hU2NhbGUiLCAiZm9yY2VSYXRpbyIsICJmb3JjZVN0eWxlIiwgInBpeGVsUmF0aW8iLCAiZGV2aWNlSGVpZ2h0IiwgImRldmljZVdpZHRoIiwgInNldFRyYW5zZm9ybSIsICJzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIiwgInBhc3NpdmVTdXBwb3J0ZWQiLCAicGFzc2l2ZSIsICJhZGRFdmVudExpc3RlbmVyIiwgInJlbW92ZUV2ZW50TGlzdGVuZXIiLCAicmVhZFVzZWRTaXplIiwgIl9wb2ludEluTGluZSIsICJwMSIsICJwMiIsICJfc3RlcHBlZEludGVycG9sYXRpb24iLCAiX2JlemllckludGVycG9sYXRpb24iLCAiY3AxIiwgImNwMiIsICJhIiwgImIiLCAiYyIsICJnZXRSaWdodFRvTGVmdEFkYXB0ZXIiLCAicmVjdFgiLCAic2V0V2lkdGgiLCAieFBsdXMiLCAibGVmdEZvckx0ciIsICJpdGVtV2lkdGgiLCAiZ2V0TGVmdFRvUmlnaHRBZGFwdGVyIiwgIl9pdGVtV2lkdGgiLCAiZ2V0UnRsQWRhcHRlciIsICJvdmVycmlkZVRleHREaXJlY3Rpb24iLCAiZGlyZWN0aW9uIiwgIm9yaWdpbmFsIiwgImdldFByb3BlcnR5UHJpb3JpdHkiLCAic2V0UHJvcGVydHkiLCAicHJldlRleHREaXJlY3Rpb24iLCAicmVzdG9yZVRleHREaXJlY3Rpb24iLCAicHJvcGVydHlGbiIsICJiZXR3ZWVuIiwgIl9hbmdsZUJldHdlZW4iLCAiY29tcGFyZSIsICJfYW5nbGVEaWZmIiwgIm5vcm1hbGl6ZSIsICJfbm9ybWFsaXplQW5nbGUiLCAiX2lzQmV0d2VlbiIsICJub3JtYWxpemVTZWdtZW50IiwgImdldFNlZ21lbnQiLCAic2VnbWVudCIsICJzdGFydEJvdW5kIiwgImVuZEJvdW5kIiwgIl9ib3VuZFNlZ21lbnQiLCAiaW5zaWRlIiwgInN1YlN0YXJ0IiwgInByZXZWYWx1ZSIsICJzdGFydElzQmVmb3JlIiwgImVuZElzQmVmb3JlIiwgInNob3VsZFN0YXJ0IiwgInNob3VsZFN0b3AiLCAiX2JvdW5kU2VnbWVudHMiLCAic2VnbWVudHMiLCAic3ViIiwgImZpbmRTdGFydEFuZEVuZCIsICJzb2xpZFNlZ21lbnRzIiwgImxhc3QiLCAiY3VyIiwgInN0b3AiLCAiX2NvbXB1dGVTZWdtZW50cyIsICJzZWdtZW50T3B0aW9ucyIsICJfbG9vcCIsICJzcGxpdEJ5U3R5bGVzIiwgImNvbXBsZXRlTG9vcCIsICJfZnVsbExvb3AiLCAiZG9TcGxpdEJ5U3R5bGVzIiwgImNoYXJ0Q29udGV4dCIsICJfY2hhcnQiLCAiYmFzZVN0eWxlIiwgInJlYWRTdHlsZSIsICJfZGF0YXNldEluZGV4IiwgImRhdGFzZXRJbmRleCIsICJwcmV2U3R5bGUiLCAiYWRkU3R5bGUiLCAibCIsICJzdCIsICJkaXIiLCAicDAiLCAicDBEYXRhSW5kZXgiLCAicDFEYXRhSW5kZXgiLCAic3R5bGVDaGFuZ2VkIiwgImJvcmRlckNhcFN0eWxlIiwgImJvcmRlckRhc2giLCAiYm9yZGVyRGFzaE9mZnNldCIsICJib3JkZXJKb2luU3R5bGUiLCAicmVwbGFjZXIiLCAiQW5pbWF0b3IiLCAiY29uc3RydWN0b3IiLCAiX3JlcXVlc3QiLCAiX2NoYXJ0cyIsICJNYXAiLCAiX3J1bm5pbmciLCAiX2xhc3REYXRlIiwgInVuZGVmaW5lZCIsICJfbm90aWZ5IiwgImNoYXJ0IiwgImFuaW1zIiwgImRhdGUiLCAidHlwZSIsICJjYWxsYmFja3MiLCAibGlzdGVuZXJzIiwgIm51bVN0ZXBzIiwgImR1cmF0aW9uIiwgImZvckVhY2giLCAiZm4iLCAiaW5pdGlhbCIsICJjdXJyZW50U3RlcCIsICJNYXRoIiwgIm1pbiIsICJzdGFydCIsICJfcmVmcmVzaCIsICJyZXF1ZXN0QW5pbUZyYW1lIiwgImNhbGwiLCAid2luZG93IiwgIl91cGRhdGUiLCAiRGF0ZSIsICJub3ciLCAicmVtYWluaW5nIiwgInJ1bm5pbmciLCAiaXRlbXMiLCAibGVuZ3RoIiwgImkiLCAiZHJhdyIsICJpdGVtIiwgIl9hY3RpdmUiLCAiX3RvdGFsIiwgInRpY2siLCAicG9wIiwgIl9nZXRBbmltcyIsICJjaGFydHMiLCAiZ2V0IiwgImNvbXBsZXRlIiwgInByb2dyZXNzIiwgInNldCIsICJsaXN0ZW4iLCAiZXZlbnQiLCAiY2IiLCAicHVzaCIsICJhZGQiLCAiaGFzIiwgInJlZHVjZSIsICJhY2MiLCAiY3VyIiwgIm1heCIsICJfZHVyYXRpb24iLCAic3RvcCIsICJjYW5jZWwiLCAicmVtb3ZlIiwgImRlbGV0ZSIsICJ0cmFuc3BhcmVudCIsICJpbnRlcnBvbGF0b3JzIiwgImJvb2xlYW4iLCAiZnJvbSIsICJ0byIsICJmYWN0b3IiLCAiY29sb3IiLCAiYzAiLCAiaGVscGVyc0NvbG9yIiwgImMxIiwgInZhbGlkIiwgIm1peCIsICJoZXhTdHJpbmciLCAibnVtYmVyIiwgIkFuaW1hdGlvbiIsICJjZmciLCAidGFyZ2V0IiwgInByb3AiLCAiY3VycmVudFZhbHVlIiwgInJlc29sdmUiLCAiX2ZuIiwgIl9lYXNpbmciLCAiZWZmZWN0cyIsICJlYXNpbmciLCAibGluZWFyIiwgIl9zdGFydCIsICJmbG9vciIsICJkZWxheSIsICJfbG9vcCIsICJsb29wIiwgIl90YXJnZXQiLCAiX3Byb3AiLCAiX2Zyb20iLCAiX3RvIiwgIl9wcm9taXNlcyIsICJhY3RpdmUiLCAidXBkYXRlIiwgImVsYXBzZWQiLCAicmVtYWluIiwgIndhaXQiLCAicHJvbWlzZXMiLCAiUHJvbWlzZSIsICJyZXMiLCAicmVqIiwgInJlc29sdmVkIiwgIm1ldGhvZCIsICJBbmltYXRpb25zIiwgImNvbmZpZyIsICJfY2hhcnQiLCAiX3Byb3BlcnRpZXMiLCAiY29uZmlndXJlIiwgImlzT2JqZWN0IiwgImFuaW1hdGlvbk9wdGlvbnMiLCAiT2JqZWN0IiwgImtleXMiLCAiZGVmYXVsdHMiLCAiYW5pbWF0aW9uIiwgImFuaW1hdGVkUHJvcHMiLCAiZ2V0T3duUHJvcGVydHlOYW1lcyIsICJrZXkiLCAib3B0aW9uIiwgImlzQXJyYXkiLCAicHJvcGVydGllcyIsICJfYW5pbWF0ZU9wdGlvbnMiLCAidmFsdWVzIiwgIm5ld09wdGlvbnMiLCAib3B0aW9ucyIsICJyZXNvbHZlVGFyZ2V0T3B0aW9ucyIsICJhbmltYXRpb25zIiwgIl9jcmVhdGVBbmltYXRpb25zIiwgIiRzaGFyZWQiLCAiYXdhaXRBbGwiLCAiJGFuaW1hdGlvbnMiLCAidGhlbiIsICJwcm9wcyIsICJjaGFyQXQiLCAidmFsdWUiLCAic2l6ZSIsICJhc3NpZ24iLCAiYW5pbWF0b3IiLCAiYW5pbSIsICJhbGwiLCAic2NhbGVDbGlwIiwgInNjYWxlIiwgImFsbG93ZWRPdmVyZmxvdyIsICJvcHRzIiwgInJldmVyc2UiLCAiZW5kIiwgImRlZmF1bHRDbGlwIiwgInhTY2FsZSIsICJ5U2NhbGUiLCAieCIsICJ5IiwgInRvcCIsICJyaWdodCIsICJib3R0b20iLCAibGVmdCIsICJ0b0NsaXAiLCAidCIsICJyIiwgImIiLCAibCIsICJkaXNhYmxlZCIsICJnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyIsICJmaWx0ZXJWaXNpYmxlIiwgIm1ldGFzZXRzIiwgIl9nZXRTb3J0ZWREYXRhc2V0TWV0YXMiLCAiaWxlbiIsICJpbmRleCIsICJhcHBseVN0YWNrIiwgInN0YWNrIiwgImRzSW5kZXgiLCAic2luZ2xlTW9kZSIsICJtb2RlIiwgImRhdGFzZXRJbmRleCIsICJvdGhlclZhbHVlIiwgImZvdW5kIiwgImlzRmluaXRlIiwgInNpZ24iLCAiY29udmVydE9iamVjdERhdGFUb0FycmF5IiwgImRhdGEiLCAibWV0YSIsICJpU2NhbGUiLCAidlNjYWxlIiwgImlBeGlzS2V5IiwgImF4aXMiLCAidkF4aXNLZXkiLCAiYWRhdGEiLCAiQXJyYXkiLCAiaXNTdGFja2VkIiwgInN0YWNrZWQiLCAiZ2V0U3RhY2tLZXkiLCAiaW5kZXhTY2FsZSIsICJ2YWx1ZVNjYWxlIiwgImlkIiwgImdldFVzZXJCb3VuZHMiLCAibWluRGVmaW5lZCIsICJtYXhEZWZpbmVkIiwgIk51bWJlciIsICJORUdBVElWRV9JTkZJTklUWSIsICJQT1NJVElWRV9JTkZJTklUWSIsICJnZXRPckNyZWF0ZVN0YWNrIiwgInN0YWNrcyIsICJzdGFja0tleSIsICJpbmRleFZhbHVlIiwgInN1YlN0YWNrIiwgImdldExhc3RJbmRleEluU3RhY2siLCAicG9zaXRpdmUiLCAiZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMiLCAidXBkYXRlU3RhY2tzIiwgImNvbnRyb2xsZXIiLCAicGFyc2VkIiwgIl9jYWNoZWRNZXRhIiwgIl9zdGFja3MiLCAiaUF4aXMiLCAidkF4aXMiLCAiaXRlbVN0YWNrcyIsICJfdG9wIiwgIl9ib3R0b20iLCAidmlzdWFsVmFsdWVzIiwgIl92aXN1YWxWYWx1ZXMiLCAiZ2V0Rmlyc3RTY2FsZUlkIiwgInNjYWxlcyIsICJmaWx0ZXIiLCAic2hpZnQiLCAiY3JlYXRlRGF0YXNldENvbnRleHQiLCAicGFyZW50IiwgImNyZWF0ZUNvbnRleHQiLCAiZGF0YXNldCIsICJjcmVhdGVEYXRhQ29udGV4dCIsICJlbGVtZW50IiwgImRhdGFJbmRleCIsICJyYXciLCAiY2xlYXJTdGFja3MiLCAiX3BhcnNlZCIsICJpc0RpcmVjdFVwZGF0ZU1vZGUiLCAiY2xvbmVJZk5vdFNoYXJlZCIsICJjYWNoZWQiLCAic2hhcmVkIiwgImNyZWF0ZVN0YWNrIiwgImNhblN0YWNrIiwgImhpZGRlbiIsICJfc3RhY2tlZCIsICJEYXRhc2V0Q29udHJvbGxlciIsICJfY3R4IiwgImN0eCIsICJfY2FjaGVkRGF0YU9wdHMiLCAiZ2V0TWV0YSIsICJfdHlwZSIsICJfcGFyc2luZyIsICJfZGF0YSIsICJfb2JqZWN0RGF0YSIsICJfc2hhcmVkT3B0aW9ucyIsICJfZHJhd1N0YXJ0IiwgIl9kcmF3Q291bnQiLCAiZW5hYmxlT3B0aW9uU2hhcmluZyIsICJzdXBwb3J0c0RlY2ltYXRpb24iLCAiJGNvbnRleHQiLCAiX3N5bmNMaXN0IiwgImRhdGFzZXRFbGVtZW50VHlwZSIsICJkYXRhRWxlbWVudFR5cGUiLCAiaW5pdGlhbGl6ZSIsICJsaW5rU2NhbGVzIiwgImFkZEVsZW1lbnRzIiwgImZpbGwiLCAiaXNQbHVnaW5FbmFibGVkIiwgImNvbnNvbGUiLCAid2FybiIsICJ1cGRhdGVJbmRleCIsICJnZXREYXRhc2V0IiwgImNob29zZUlkIiwgInhpZCIsICJ4QXhpc0lEIiwgInZhbHVlT3JEZWZhdWx0IiwgInlpZCIsICJ5QXhpc0lEIiwgInJpZCIsICJyQXhpc0lEIiwgImluZGV4QXhpcyIsICJpaWQiLCAiaUF4aXNJRCIsICJ2aWQiLCAidkF4aXNJRCIsICJnZXRTY2FsZUZvcklkIiwgInJTY2FsZSIsICJkYXRhc2V0cyIsICJnZXREYXRhc2V0TWV0YSIsICJzY2FsZUlEIiwgIl9nZXRPdGhlclNjYWxlIiwgInJlc2V0IiwgIl9kZXN0cm95IiwgInVubGlzdGVuQXJyYXlFdmVudHMiLCAiX2RhdGFDaGVjayIsICJpc0V4dGVuc2libGUiLCAibGlzdGVuQXJyYXlFdmVudHMiLCAiYnVpbGRPclVwZGF0ZUVsZW1lbnRzIiwgInJlc2V0TmV3RWxlbWVudHMiLCAic3RhY2tDaGFuZ2VkIiwgIm9sZFN0YWNrZWQiLCAiX3Jlc3luY0VsZW1lbnRzIiwgInNjb3BlS2V5cyIsICJkYXRhc2V0U2NvcGVLZXlzIiwgInNjb3BlcyIsICJnZXRPcHRpb25TY29wZXMiLCAiY3JlYXRlUmVzb2x2ZXIiLCAiZ2V0Q29udGV4dCIsICJwYXJzaW5nIiwgInBhcnNlIiwgImNvdW50IiwgInNvcnRlZCIsICJfc29ydGVkIiwgInByZXYiLCAicGFyc2VBcnJheURhdGEiLCAicGFyc2VPYmplY3REYXRhIiwgInBhcnNlUHJpbWl0aXZlRGF0YSIsICJpc05vdEluT3JkZXJDb21wYXJlZFRvUHJldiIsICJsYWJlbHMiLCAiZ2V0TGFiZWxzIiwgInNpbmdsZVNjYWxlIiwgInhBeGlzS2V5IiwgInlBeGlzS2V5IiwgInJlc29sdmVPYmplY3RLZXkiLCAiZ2V0UGFyc2VkIiwgImdldERhdGFFbGVtZW50IiwgInVwZGF0ZVJhbmdlRnJvbVBhcnNlZCIsICJyYW5nZSIsICJwYXJzZWRWYWx1ZSIsICJOYU4iLCAiZ2V0TWluTWF4IiwgIm90aGVyU2NhbGUiLCAib3RoZXJNaW4iLCAib3RoZXJNYXgiLCAiX3NraXAiLCAiZ2V0QWxsUGFyc2VkVmFsdWVzIiwgImdldE1heE92ZXJmbG93IiwgImdldExhYmVsQW5kVmFsdWUiLCAibGFiZWwiLCAiZ2V0TGFiZWxGb3JWYWx1ZSIsICJfY2xpcCIsICJjbGlwIiwgImVsZW1lbnRzIiwgImFyZWEiLCAiY2hhcnRBcmVhIiwgImRyYXdBY3RpdmVFbGVtZW50c09uVG9wIiwgImdldFN0eWxlIiwgInJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMiLCAicmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyIsICJjb250ZXh0IiwgIl9yZXNvbHZlRWxlbWVudE9wdGlvbnMiLCAiZWxlbWVudFR5cGUiLCAiY2FjaGUiLCAiY2FjaGVLZXkiLCAic2hhcmluZyIsICJkZWZpbmVkIiwgImRhdGFzZXRFbGVtZW50U2NvcGVLZXlzIiwgInByZWZpeGVzIiwgIm5hbWVzIiwgInJlc29sdmVOYW1lZE9wdGlvbnMiLCAiZnJlZXplIiwgIl9yZXNvbHZlQW5pbWF0aW9ucyIsICJ0cmFuc2l0aW9uIiwgImRhdGFzZXRBbmltYXRpb25TY29wZUtleXMiLCAiX2NhY2hlYWJsZSIsICJnZXRTaGFyZWRPcHRpb25zIiwgImluY2x1ZGVPcHRpb25zIiwgInNoYXJlZE9wdGlvbnMiLCAiX2FuaW1hdGlvbnNEaXNhYmxlZCIsICJfZ2V0U2hhcmVkT3B0aW9ucyIsICJmaXJzdE9wdHMiLCAicHJldmlvdXNseVNoYXJlZE9wdGlvbnMiLCAidXBkYXRlU2hhcmVkT3B0aW9ucyIsICJ1cGRhdGVFbGVtZW50IiwgIl9zZXRTdHlsZSIsICJyZW1vdmVIb3ZlclN0eWxlIiwgInNldEhvdmVyU3R5bGUiLCAiX3JlbW92ZURhdGFzZXRIb3ZlclN0eWxlIiwgIl9zZXREYXRhc2V0SG92ZXJTdHlsZSIsICJhcmcxIiwgImFyZzIiLCAibnVtTWV0YSIsICJudW1EYXRhIiwgIl9pbnNlcnRFbGVtZW50cyIsICJfcmVtb3ZlRWxlbWVudHMiLCAibW92ZSIsICJhcnIiLCAidXBkYXRlRWxlbWVudHMiLCAicmVtb3ZlZCIsICJzcGxpY2UiLCAiX3N5bmMiLCAiYXJncyIsICJfZGF0YUNoYW5nZXMiLCAiX29uRGF0YVB1c2giLCAiYXJndW1lbnRzIiwgIl9vbkRhdGFQb3AiLCAiX29uRGF0YVNoaWZ0IiwgIl9vbkRhdGFTcGxpY2UiLCAibmV3Q291bnQiLCAiX29uRGF0YVVuc2hpZnQiLCAiZ2V0QWxsU2NhbGVWYWx1ZXMiLCAiX2NhY2hlIiwgIiRiYXIiLCAidmlzaWJsZU1ldGFzIiwgImNvbmNhdCIsICJfYXJyYXlVbmlxdWUiLCAic29ydCIsICJhIiwgImNvbXB1dGVNaW5TYW1wbGVTaXplIiwgIl9sZW5ndGgiLCAiY3VyciIsICJ1cGRhdGVNaW5BbmRQcmV2IiwgImFicyIsICJnZXRQaXhlbEZvclZhbHVlIiwgInRpY2tzIiwgImdldFBpeGVsRm9yVGljayIsICJjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMiLCAicnVsZXIiLCAic3RhY2tDb3VudCIsICJ0aGlja25lc3MiLCAiYmFyVGhpY2tuZXNzIiwgInJhdGlvIiwgImlzTnVsbE9yVW5kZWYiLCAiY2F0ZWdvcnlQZXJjZW50YWdlIiwgImJhclBlcmNlbnRhZ2UiLCAiY2h1bmsiLCAicGl4ZWxzIiwgImNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMiLCAibmV4dCIsICJwZXJjZW50IiwgInBhcnNlRmxvYXRCYXIiLCAiZW50cnkiLCAic3RhcnRWYWx1ZSIsICJlbmRWYWx1ZSIsICJiYXJTdGFydCIsICJiYXJFbmQiLCAiX2N1c3RvbSIsICJwYXJzZVZhbHVlIiwgInBhcnNlQXJyYXlPclByaW1pdGl2ZSIsICJpc0Zsb2F0QmFyIiwgImN1c3RvbSIsICJiYXJTaWduIiwgImFjdHVhbEJhc2UiLCAiaXNIb3Jpem9udGFsIiwgImJvcmRlclByb3BzIiwgImhvcml6b250YWwiLCAiYmFzZSIsICJzZXRCb3JkZXJTa2lwcGVkIiwgImVkZ2UiLCAiYm9yZGVyU2tpcHBlZCIsICJlbmFibGVCb3JkZXJSYWRpdXMiLCAicGFyc2VFZGdlIiwgInN3YXAiLCAic3RhcnRFbmQiLCAib3JpZyIsICJ2MSIsICJ2MiIsICJ2IiwgInNldEluZmxhdGVBbW91bnQiLCAiaW5mbGF0ZUFtb3VudCIsICJCYXJDb250cm9sbGVyIiwgIm9iaiIsICJiYXJzIiwgImdldEJhc2VQaXhlbCIsICJfZ2V0UnVsZXIiLCAidnBpeGVscyIsICJoZWFkIiwgIl9jYWxjdWxhdGVCYXJWYWx1ZVBpeGVscyIsICJpcGl4ZWxzIiwgIl9jYWxjdWxhdGVCYXJJbmRleFBpeGVscyIsICJjZW50ZXIiLCAiaGVpZ2h0IiwgIndpZHRoIiwgIl9nZXRTdGFja3MiLCAibGFzdCIsICJncm91cGVkIiwgImN1cnJlbnRQYXJzZWQiLCAiaVNjYWxlVmFsdWUiLCAic2tpcE51bGwiLCAiZmluZCIsICJ2YWwiLCAiaXNOYU4iLCAiaW5kZXhPZiIsICJfZ2V0U3RhY2tDb3VudCIsICJfZ2V0U3RhY2tJbmRleCIsICJuYW1lIiwgIl9zdGFydFBpeGVsIiwgIl9lbmRQaXhlbCIsICJiYXNlVmFsdWUiLCAibWluQmFyTGVuZ3RoIiwgImZsb2F0aW5nIiwgImdldERhdGFWaXNpYmlsaXR5IiwgInN0YXJ0UGl4ZWwiLCAiZ2V0UGl4ZWxGb3JEZWNpbWFsIiwgImVuZFBpeGVsIiwgImdldFZhbHVlRm9yUGl4ZWwiLCAiaGFsZkdyaWQiLCAiZ2V0TGluZVdpZHRoRm9yVmFsdWUiLCAibWF4QmFyVGhpY2tuZXNzIiwgIkluZmluaXR5IiwgInN0YWNrSW5kZXgiLCAicmVjdHMiLCAibnVtYmVycyIsICJvdmVycmlkZXMiLCAiX2luZGV4XyIsICJvZmZzZXQiLCAiZ3JpZCIsICJfdmFsdWVfIiwgImJlZ2luQXRaZXJvIiwgIkJ1YmJsZUNvbnRyb2xsZXIiLCAicmFkaXVzIiwgInBvaW50cyIsICJwb2ludCIsICJpUGl4ZWwiLCAidlBpeGVsIiwgInNraXAiLCAiZ2V0UmF0aW9BbmRPZmZzZXQiLCAicm90YXRpb24iLCAiY2lyY3VtZmVyZW5jZSIsICJjdXRvdXQiLCAicmF0aW9YIiwgInJhdGlvWSIsICJvZmZzZXRYIiwgIm9mZnNldFkiLCAiVEFVIiwgInN0YXJ0QW5nbGUiLCAiZW5kQW5nbGUiLCAic3RhcnRYIiwgImNvcyIsICJzdGFydFkiLCAic2luIiwgImVuZFgiLCAiZW5kWSIsICJjYWxjTWF4IiwgImFuZ2xlIiwgIl9hbmdsZUJldHdlZW4iLCAiY2FsY01pbiIsICJtYXhYIiwgIm1heFkiLCAiSEFMRl9QSSIsICJtaW5YIiwgIlBJIiwgIm1pblkiLCAiRG91Z2hudXRDb250cm9sbGVyIiwgImlubmVyUmFkaXVzIiwgIm91dGVyUmFkaXVzIiwgImdldHRlciIsICJfZ2V0Um90YXRpb24iLCAidG9SYWRpYW5zIiwgIl9nZXRDaXJjdW1mZXJlbmNlIiwgIl9nZXRSb3RhdGlvbkV4dGVudHMiLCAiaXNEYXRhc2V0VmlzaWJsZSIsICJhcmNzIiwgInNwYWNpbmciLCAiZ2V0TWF4Qm9yZGVyV2lkdGgiLCAiZ2V0TWF4T2Zmc2V0IiwgIm1heFNpemUiLCAidG9QZXJjZW50YWdlIiwgImNoYXJ0V2VpZ2h0IiwgIl9nZXRSaW5nV2VpZ2h0IiwgIm1heFdpZHRoIiwgIm1heEhlaWdodCIsICJtYXhSYWRpdXMiLCAidG9EaW1lbnNpb24iLCAicmFkaXVzTGVuZ3RoIiwgIl9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsIiwgInRvdGFsIiwgImNhbGN1bGF0ZVRvdGFsIiwgIl9nZXRSaW5nV2VpZ2h0T2Zmc2V0IiwgIl9jaXJjdW1mZXJlbmNlIiwgImFuaW1hdGVSb3RhdGUiLCAiY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZSIsICJhbmltYXRpb25PcHRzIiwgImNlbnRlclgiLCAiY2VudGVyWSIsICJhbmltYXRlU2NhbGUiLCAiYXJjIiwgIm1ldGFEYXRhIiwgImZvcm1hdE51bWJlciIsICJsb2NhbGUiLCAiYm9yZGVyQWxpZ24iLCAiYm9yZGVyV2lkdGgiLCAiaG92ZXJCb3JkZXJXaWR0aCIsICJob3Zlck9mZnNldCIsICJyaW5nV2VpZ2h0T2Zmc2V0IiwgIndlaWdodCIsICJkZXNjcmlwdG9ycyIsICJfc2NyaXB0YWJsZSIsICJfaW5kZXhhYmxlIiwgInN0YXJ0c1dpdGgiLCAiYXNwZWN0UmF0aW8iLCAicGx1Z2lucyIsICJsZWdlbmQiLCAiZ2VuZXJhdGVMYWJlbHMiLCAicG9pbnRTdHlsZSIsICJtYXAiLCAic3R5bGUiLCAidGV4dCIsICJmaWxsU3R5bGUiLCAiYmFja2dyb3VuZENvbG9yIiwgInN0cm9rZVN0eWxlIiwgImJvcmRlckNvbG9yIiwgImZvbnRDb2xvciIsICJsaW5lV2lkdGgiLCAib25DbGljayIsICJlIiwgImxlZ2VuZEl0ZW0iLCAidG9nZ2xlRGF0YVZpc2liaWxpdHkiLCAiTGluZUNvbnRyb2xsZXIiLCAibGluZSIsICJfZGF0YXNldCIsICJhbmltYXRpb25zRGlzYWJsZWQiLCAiX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMiLCAiX3NjYWxlUmFuZ2VzQ2hhbmdlZCIsICJfZGF0YXNldEluZGV4IiwgIl9kZWNpbWF0ZWQiLCAic2hvd0xpbmUiLCAic2VnbWVudCIsICJhbmltYXRlZCIsICJzcGFuR2FwcyIsICJtYXhHYXBMZW5ndGgiLCAiaXNOdW1iZXIiLCAiZGlyZWN0VXBkYXRlIiwgInBvaW50c0NvdW50IiwgInByZXZQYXJzZWQiLCAibnVsbERhdGEiLCAiYm9yZGVyIiwgImZpcnN0UG9pbnQiLCAibGFzdFBvaW50IiwgInVwZGF0ZUNvbnRyb2xQb2ludHMiLCAiUG9sYXJBcmVhQ29udHJvbGxlciIsICJfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUiLCAiYmluZCIsICJfdXBkYXRlUmFkaXVzIiwgIm1pblNpemUiLCAiY3V0b3V0UGVyY2VudGFnZSIsICJnZXRWaXNpYmxlRGF0YXNldENvdW50IiwgInhDZW50ZXIiLCAieUNlbnRlciIsICJkYXRhc2V0U3RhcnRBbmdsZSIsICJnZXRJbmRleEFuZ2xlIiwgImRlZmF1bHRBbmdsZSIsICJjb3VudFZpc2libGVFbGVtZW50cyIsICJfY29tcHV0ZUFuZ2xlIiwgImdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlIiwgImFuZ2xlTGluZXMiLCAiZGlzcGxheSIsICJjaXJjdWxhciIsICJwb2ludExhYmVscyIsICJQaWVDb250cm9sbGVyIiwgIlJhZGFyQ29udHJvbGxlciIsICJfZnVsbExvb3AiLCAicG9pbnRQb3NpdGlvbiIsICJnZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUiLCAiU2NhdHRlckNvbnRyb2xsZXIiLCAicmVnaXN0cnkiLCAiZ2V0RWxlbWVudCIsICJpbnRlcmFjdGlvbiIsICJhYnN0cmFjdCIsICJFcnJvciIsICJEYXRlQWRhcHRlckJhc2UiLCAib3ZlcnJpZGUiLCAibWVtYmVycyIsICJwcm90b3R5cGUiLCAiaW5pdCIsICJmb3JtYXRzIiwgImZvcm1hdCIsICJkaWZmIiwgInN0YXJ0T2YiLCAiZW5kT2YiLCAiX2RhdGUiLCAiYmluYXJ5U2VhcmNoIiwgIm1ldGFzZXQiLCAiaW50ZXJzZWN0IiwgImxvb2t1cE1ldGhvZCIsICJfcmV2ZXJzZVBpeGVscyIsICJfcmxvb2t1cEJ5S2V5IiwgIl9sb29rdXBCeUtleSIsICJlbCIsICJnZXRSYW5nZSIsICJsbyIsICJoaSIsICJldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMiLCAicG9zaXRpb24iLCAiaGFuZGxlciIsICJnZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzIiwgImoiLCAiZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzIiwgInVzZVgiLCAidXNlWSIsICJwdDEiLCAicHQyIiwgImRlbHRhWCIsICJkZWx0YVkiLCAic3FydCIsICJwb3ciLCAiZ2V0SW50ZXJzZWN0SXRlbXMiLCAidXNlRmluYWxQb3NpdGlvbiIsICJpbmNsdWRlSW52aXNpYmxlIiwgImlzUG9pbnRJbkFyZWEiLCAiZXZhbHVhdGlvbkZ1bmMiLCAiX2lzUG9pbnRJbkFyZWEiLCAiaW5SYW5nZSIsICJnZXROZWFyZXN0UmFkaWFsSXRlbXMiLCAiZ2V0UHJvcHMiLCAiZ2V0QW5nbGVGcm9tUG9pbnQiLCAiZ2V0TmVhcmVzdENhcnRlc2lhbkl0ZW1zIiwgImRpc3RhbmNlTWV0cmljIiwgIm1pbkRpc3RhbmNlIiwgImdldENlbnRlclBvaW50IiwgInBvaW50SW5BcmVhIiwgImRpc3RhbmNlIiwgImdldE5lYXJlc3RJdGVtcyIsICJnZXRBeGlzSXRlbXMiLCAicmFuZ2VNZXRob2QiLCAiaW50ZXJzZWN0c0l0ZW0iLCAibW9kZXMiLCAiZ2V0UmVsYXRpdmVQb3NpdGlvbiIsICJuZWFyZXN0IiwgIlNUQVRJQ19QT1NJVElPTlMiLCAiZmlsdGVyQnlQb3NpdGlvbiIsICJhcnJheSIsICJwb3MiLCAiZmlsdGVyRHluYW1pY1Bvc2l0aW9uQnlBeGlzIiwgImJveCIsICJzb3J0QnlXZWlnaHQiLCAidjAiLCAid3JhcEJveGVzIiwgImJveGVzIiwgImxheW91dEJveGVzIiwgInN0YWNrV2VpZ2h0IiwgImJ1aWxkU3RhY2tzIiwgImxheW91dHMiLCAid3JhcCIsICJpbmNsdWRlcyIsICJfc3RhY2siLCAicGxhY2VkIiwgInNldExheW91dERpbXMiLCAicGFyYW1zIiwgInZCb3hNYXhXaWR0aCIsICJoQm94TWF4SGVpZ2h0IiwgImxheW91dCIsICJmdWxsU2l6ZSIsICJhdmFpbGFibGVXaWR0aCIsICJhdmFpbGFibGVIZWlnaHQiLCAiYnVpbGRMYXlvdXRCb3hlcyIsICJjZW50ZXJIb3Jpem9udGFsIiwgImNlbnRlclZlcnRpY2FsIiwgImxlZnRBbmRUb3AiLCAicmlnaHRBbmRCb3R0b20iLCAidmVydGljYWwiLCAiZ2V0Q29tYmluZWRNYXgiLCAibWF4UGFkZGluZyIsICJ1cGRhdGVNYXhQYWRkaW5nIiwgImJveFBhZGRpbmciLCAidXBkYXRlRGltcyIsICJnZXRQYWRkaW5nIiwgIm5ld1dpZHRoIiwgIm91dGVyV2lkdGgiLCAibmV3SGVpZ2h0IiwgIm91dGVySGVpZ2h0IiwgIndpZHRoQ2hhbmdlZCIsICJ3IiwgImhlaWdodENoYW5nZWQiLCAiaCIsICJzYW1lIiwgIm90aGVyIiwgImhhbmRsZU1heFBhZGRpbmciLCAidXBkYXRlUG9zIiwgImNoYW5nZSIsICJnZXRNYXJnaW5zIiwgIm1hcmdpbkZvclBvc2l0aW9ucyIsICJwb3NpdGlvbnMiLCAibWFyZ2luIiwgImZpdEJveGVzIiwgInJlZml0Qm94ZXMiLCAicmVmaXQiLCAiY2hhbmdlZCIsICJzZXRCb3hEaW1zIiwgInBsYWNlQm94ZXMiLCAidXNlclBhZGRpbmciLCAicGFkZGluZyIsICJhZGRCb3giLCAiX2xheWVycyIsICJ6IiwgInJlbW92ZUJveCIsICJsYXlvdXRJdGVtIiwgIm1pblBhZGRpbmciLCAidG9QYWRkaW5nIiwgInZlcnRpY2FsQm94ZXMiLCAiaG9yaXpvbnRhbEJveGVzIiwgImVhY2giLCAiYmVmb3JlTGF5b3V0IiwgInZpc2libGVWZXJ0aWNhbEJveENvdW50IiwgIkJhc2VQbGF0Zm9ybSIsICJhY3F1aXJlQ29udGV4dCIsICJjYW52YXMiLCAicmVsZWFzZUNvbnRleHQiLCAiYWRkRXZlbnRMaXN0ZW5lciIsICJsaXN0ZW5lciIsICJyZW1vdmVFdmVudExpc3RlbmVyIiwgImdldERldmljZVBpeGVsUmF0aW8iLCAiZ2V0TWF4aW11bVNpemUiLCAiaXNBdHRhY2hlZCIsICJ1cGRhdGVDb25maWciLCAiQmFzaWNQbGF0Zm9ybSIsICJFWFBBTkRPX0tFWSIsICJFVkVOVF9UWVBFUyIsICJ0b3VjaHN0YXJ0IiwgInRvdWNobW92ZSIsICJ0b3VjaGVuZCIsICJwb2ludGVyZW50ZXIiLCAicG9pbnRlcmRvd24iLCAicG9pbnRlcm1vdmUiLCAicG9pbnRlcnVwIiwgInBvaW50ZXJsZWF2ZSIsICJwb2ludGVyb3V0IiwgImlzTnVsbE9yRW1wdHkiLCAiaW5pdENhbnZhcyIsICJyZW5kZXJIZWlnaHQiLCAiZ2V0QXR0cmlidXRlIiwgInJlbmRlcldpZHRoIiwgImJveFNpemluZyIsICJkaXNwbGF5V2lkdGgiLCAicmVhZFVzZWRTaXplIiwgImRpc3BsYXlIZWlnaHQiLCAiZXZlbnRMaXN0ZW5lck9wdGlvbnMiLCAic3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyIsICJwYXNzaXZlIiwgImFkZExpc3RlbmVyIiwgIm5vZGUiLCAicmVtb3ZlTGlzdGVuZXIiLCAiZnJvbU5hdGl2ZUV2ZW50IiwgIm5hdGl2ZSIsICJub2RlTGlzdENvbnRhaW5zIiwgIm5vZGVMaXN0IiwgImNvbnRhaW5zIiwgImNyZWF0ZUF0dGFjaE9ic2VydmVyIiwgIm9ic2VydmVyIiwgIk11dGF0aW9uT2JzZXJ2ZXIiLCAiZW50cmllcyIsICJ0cmlnZ2VyIiwgImFkZGVkTm9kZXMiLCAicmVtb3ZlZE5vZGVzIiwgIm9ic2VydmUiLCAiZG9jdW1lbnQiLCAiY2hpbGRMaXN0IiwgInN1YnRyZWUiLCAiY3JlYXRlRGV0YWNoT2JzZXJ2ZXIiLCAiZHJwTGlzdGVuaW5nQ2hhcnRzIiwgIm9sZERldmljZVBpeGVsUmF0aW8iLCAib25XaW5kb3dSZXNpemUiLCAiZHByIiwgImRldmljZVBpeGVsUmF0aW8iLCAicmVzaXplIiwgImN1cnJlbnREZXZpY2VQaXhlbFJhdGlvIiwgImxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzIiwgInVubGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMiLCAiY3JlYXRlUmVzaXplT2JzZXJ2ZXIiLCAiY29udGFpbmVyIiwgIl9nZXRQYXJlbnROb2RlIiwgInRocm90dGxlZCIsICJjbGllbnRXaWR0aCIsICJSZXNpemVPYnNlcnZlciIsICJjb250ZW50UmVjdCIsICJyZWxlYXNlT2JzZXJ2ZXIiLCAiZGlzY29ubmVjdCIsICJjcmVhdGVQcm94eUFuZExpc3RlbiIsICJwcm94eSIsICJEb21QbGF0Zm9ybSIsICJyZW1vdmVBdHRyaWJ1dGUiLCAic2V0QXR0cmlidXRlIiwgInByb3hpZXMiLCAiJHByb3hpZXMiLCAiaGFuZGxlcnMiLCAiYXR0YWNoIiwgImRldGFjaCIsICJpc0Nvbm5lY3RlZCIsICJfZGV0ZWN0UGxhdGZvcm0iLCAiX2lzRG9tU3VwcG9ydGVkIiwgIk9mZnNjcmVlbkNhbnZhcyIsICJFbGVtZW50IiwgInRvb2x0aXBQb3NpdGlvbiIsICJoYXNWYWx1ZSIsICJmaW5hbCIsICJyZXQiLCAiZGVmYXVsdFJvdXRlcyIsICJhdXRvU2tpcCIsICJ0aWNrT3B0cyIsICJkZXRlcm1pbmVkTWF4VGlja3MiLCAiZGV0ZXJtaW5lTWF4VGlja3MiLCAidGlja3NMaW1pdCIsICJtYXhUaWNrc0xpbWl0IiwgIm1ham9ySW5kaWNlcyIsICJtYWpvciIsICJlbmFibGVkIiwgImdldE1ham9ySW5kaWNlcyIsICJudW1NYWpvckluZGljZXMiLCAiZmlyc3QiLCAibmV3VGlja3MiLCAic2tpcE1ham9ycyIsICJjYWxjdWxhdGVTcGFjaW5nIiwgImF2Z01ham9yU3BhY2luZyIsICJyb3VuZCIsICJ0aWNrTGVuZ3RoIiwgIl90aWNrU2l6ZSIsICJtYXhTY2FsZSIsICJtYXhDaGFydCIsICJfbWF4TGVuZ3RoIiwgImV2ZW5NYWpvclNwYWNpbmciLCAiZ2V0RXZlblNwYWNpbmciLCAiZmFjdG9ycyIsICJfZmFjdG9yaXplIiwgInJlc3VsdCIsICJjZWlsIiwgIm1ham9yU3RhcnQiLCAibWFqb3JFbmQiLCAibGVuIiwgInJldmVyc2VBbGlnbiIsICJhbGlnbiIsICJvZmZzZXRGcm9tRWRnZSIsICJnZXRUaWNrc0xpbWl0IiwgInRpY2tzTGVuZ3RoIiwgInNhbXBsZSIsICJudW1JdGVtcyIsICJpbmNyZW1lbnQiLCAiZ2V0UGl4ZWxGb3JHcmlkTGluZSIsICJvZmZzZXRHcmlkTGluZXMiLCAidmFsaWRJbmRleCIsICJlcHNpbG9uIiwgImxpbmVWYWx1ZSIsICJnYXJiYWdlQ29sbGVjdCIsICJjYWNoZXMiLCAiZ2MiLCAiZ2NMZW4iLCAiZ2V0VGlja01hcmtMZW5ndGgiLCAiZHJhd1RpY2tzIiwgImdldFRpdGxlSGVpZ2h0IiwgImZhbGxiYWNrIiwgImZvbnQiLCAidG9Gb250IiwgImxpbmVzIiwgImxpbmVIZWlnaHQiLCAiY3JlYXRlU2NhbGVDb250ZXh0IiwgImNyZWF0ZVRpY2tDb250ZXh0IiwgInRpdGxlQWxpZ24iLCAiX3RvTGVmdFJpZ2h0Q2VudGVyIiwgInRpdGxlQXJncyIsICJ0aXRsZVgiLCAidGl0bGVZIiwgIl9hbGlnblN0YXJ0RW5kIiwgInBvc2l0aW9uQXhpc0lEIiwgIlNjYWxlIiwgIl9tYXJnaW5zIiwgInBhZGRpbmdUb3AiLCAicGFkZGluZ0JvdHRvbSIsICJwYWRkaW5nTGVmdCIsICJwYWRkaW5nUmlnaHQiLCAibGFiZWxSb3RhdGlvbiIsICJfcmFuZ2UiLCAiX2dyaWRMaW5lSXRlbXMiLCAiX2xhYmVsSXRlbXMiLCAiX2xhYmVsU2l6ZXMiLCAiX2xvbmdlc3RUZXh0Q2FjaGUiLCAiX3VzZXJNYXgiLCAiX3VzZXJNaW4iLCAiX3N1Z2dlc3RlZE1heCIsICJfc3VnZ2VzdGVkTWluIiwgIl90aWNrc0xlbmd0aCIsICJfYm9yZGVyVmFsdWUiLCAiX2RhdGFMaW1pdHNDYWNoZWQiLCAic2V0Q29udGV4dCIsICJzdWdnZXN0ZWRNaW4iLCAic3VnZ2VzdGVkTWF4IiwgImZpbml0ZU9yRGVmYXVsdCIsICJtZXRhcyIsICJnZXRUaWNrcyIsICJ4TGFiZWxzIiwgInlMYWJlbHMiLCAiZ2V0TGFiZWxJdGVtcyIsICJfY29tcHV0ZUxhYmVsSXRlbXMiLCAiYmVmb3JlVXBkYXRlIiwgIm1hcmdpbnMiLCAiZ3JhY2UiLCAic2FtcGxlU2l6ZSIsICJiZWZvcmVTZXREaW1lbnNpb25zIiwgInNldERpbWVuc2lvbnMiLCAiYWZ0ZXJTZXREaW1lbnNpb25zIiwgImJlZm9yZURhdGFMaW1pdHMiLCAiZGV0ZXJtaW5lRGF0YUxpbWl0cyIsICJhZnRlckRhdGFMaW1pdHMiLCAiX2FkZEdyYWNlIiwgImJlZm9yZUJ1aWxkVGlja3MiLCAiYnVpbGRUaWNrcyIsICJhZnRlckJ1aWxkVGlja3MiLCAic2FtcGxpbmdFbmFibGVkIiwgIl9jb252ZXJ0VGlja3NUb0xhYmVscyIsICJiZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uIiwgImNhbGN1bGF0ZUxhYmVsUm90YXRpb24iLCAiYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uIiwgInNvdXJjZSIsICJhZnRlckF1dG9Ta2lwIiwgImJlZm9yZUZpdCIsICJmaXQiLCAiYWZ0ZXJGaXQiLCAiYWZ0ZXJVcGRhdGUiLCAicmV2ZXJzZVBpeGVscyIsICJfYWxpZ25Ub1BpeGVscyIsICJhbGlnblRvUGl4ZWxzIiwgIl9jYWxsSG9va3MiLCAibm90aWZ5UGx1Z2lucyIsICJiZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24iLCAiZ2VuZXJhdGVUaWNrTGFiZWxzIiwgImNhbGxiYWNrIiwgImFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uIiwgIm51bVRpY2tzIiwgIm1pblJvdGF0aW9uIiwgIm1heFJvdGF0aW9uIiwgInRpY2tXaWR0aCIsICJtYXhMYWJlbERpYWdvbmFsIiwgIl9pc1Zpc2libGUiLCAibGFiZWxTaXplcyIsICJfZ2V0TGFiZWxTaXplcyIsICJtYXhMYWJlbFdpZHRoIiwgIndpZGVzdCIsICJtYXhMYWJlbEhlaWdodCIsICJoaWdoZXN0IiwgIl9saW1pdFZhbHVlIiwgInRpdGxlIiwgInRvRGVncmVlcyIsICJhc2luIiwgInRpdGxlT3B0cyIsICJncmlkT3B0cyIsICJ0aXRsZUhlaWdodCIsICJ0aWNrUGFkZGluZyIsICJhbmdsZVJhZGlhbnMiLCAibGFiZWxIZWlnaHQiLCAibWlycm9yIiwgImxhYmVsV2lkdGgiLCAiX2NhbGN1bGF0ZVBhZGRpbmciLCAiX2hhbmRsZU1hcmdpbnMiLCAiaXNSb3RhdGVkIiwgImxhYmVsc0JlbG93VGlja3MiLCAib2Zmc2V0TGVmdCIsICJvZmZzZXRSaWdodCIsICJpc0Z1bGxTaXplIiwgIl9jb21wdXRlTGFiZWxTaXplcyIsICJ3aWR0aHMiLCAiaGVpZ2h0cyIsICJ3aWRlc3RMYWJlbFNpemUiLCAiaGlnaGVzdExhYmVsU2l6ZSIsICJqbGVuIiwgInRpY2tGb250IiwgImZvbnRTdHJpbmciLCAibmVzdGVkTGFiZWwiLCAiX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMiLCAic3RyaW5nIiwgIl9tZWFzdXJlVGV4dCIsICJ2YWx1ZUF0IiwgImlkeCIsICJwaXhlbCIsICJkZWNpbWFsIiwgIl9pbnQxNlJhbmdlIiwgIl9hbGlnblBpeGVsIiwgImdldERlY2ltYWxGb3JQaXhlbCIsICJnZXRCYXNlVmFsdWUiLCAib3B0aW9uVGlja3MiLCAicm90IiwgImF1dG9Ta2lwUGFkZGluZyIsICJfY29tcHV0ZUdyaWRMaW5lSXRlbXMiLCAidGwiLCAiYm9yZGVyT3B0cyIsICJheGlzV2lkdGgiLCAiYXhpc0hhbGZXaWR0aCIsICJhbGlnbkJvcmRlclZhbHVlIiwgImJvcmRlclZhbHVlIiwgImFsaWduZWRMaW5lVmFsdWUiLCAidHgxIiwgInR5MSIsICJ0eDIiLCAidHkyIiwgIngxIiwgInkxIiwgIngyIiwgInkyIiwgImxpbWl0IiwgInN0ZXAiLCAib3B0c0F0SW5kZXgiLCAib3B0c0F0SW5kZXhCb3JkZXIiLCAibGluZUNvbG9yIiwgImJvcmRlckRhc2giLCAiZGFzaCIsICJib3JkZXJEYXNoT2Zmc2V0IiwgImRhc2hPZmZzZXQiLCAidGlja0NvbG9yIiwgInRpY2tCb3JkZXJEYXNoIiwgInRpY2tCb3JkZXJEYXNoT2Zmc2V0IiwgImNyb3NzQWxpZ24iLCAidGlja0FuZFBhZGRpbmciLCAiaFRpY2tBbmRQYWRkaW5nIiwgInRleHRBbGlnbiIsICJsaW5lQ291bnQiLCAidGV4dE9mZnNldCIsICJ0ZXh0QmFzZWxpbmUiLCAiX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQiLCAiX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQiLCAibGFiZWxPZmZzZXQiLCAiaGFsZkNvdW50IiwgInN0cm9rZUNvbG9yIiwgInRleHRTdHJva2VDb2xvciIsICJzdHJva2VXaWR0aCIsICJ0ZXh0U3Ryb2tlV2lkdGgiLCAidGlja1RleHRBbGlnbiIsICJzaG93TGFiZWxCYWNrZHJvcCIsICJiYWNrZHJvcCIsICJsYWJlbFBhZGRpbmciLCAiYmFja2Ryb3BQYWRkaW5nIiwgImJhY2tkcm9wQ29sb3IiLCAidHJhbnNsYXRpb24iLCAiX2NvbXB1dGVMYWJlbEFyZWEiLCAiZHJhd0JhY2tncm91bmQiLCAic2F2ZSIsICJmaWxsUmVjdCIsICJyZXN0b3JlIiwgImZpbmRJbmRleCIsICJkcmF3R3JpZCIsICJkcmF3TGluZSIsICJwMSIsICJwMiIsICJzZXRMaW5lRGFzaCIsICJsaW5lRGFzaE9mZnNldCIsICJiZWdpblBhdGgiLCAibW92ZVRvIiwgImxpbmVUbyIsICJzdHJva2UiLCAiZHJhd09uQ2hhcnRBcmVhIiwgImRyYXdCb3JkZXIiLCAibGFzdExpbmVXaWR0aCIsICJkcmF3TGFiZWxzIiwgImNsaXBBcmVhIiwgInJlbmRlclRleHRPcHRpb25zIiwgInJlbmRlclRleHQiLCAidW5jbGlwQXJlYSIsICJkcmF3VGl0bGUiLCAidHoiLCAiZ3oiLCAiYnoiLCAiYXhpc0lEIiwgIl9tYXhEaWdpdHMiLCAiZm9udFNpemUiLCAiVHlwZWRSZWdpc3RyeSIsICJzY29wZSIsICJjcmVhdGUiLCAiaXNGb3JUeXBlIiwgImlzUHJvdG90eXBlT2YiLCAicmVnaXN0ZXIiLCAicHJvdG8iLCAiZ2V0UHJvdG90eXBlT2YiLCAicGFyZW50U2NvcGUiLCAiaXNJQ2hhcnRDb21wb25lbnQiLCAicmVnaXN0ZXJEZWZhdWx0cyIsICJ1bnJlZ2lzdGVyIiwgIml0ZW1EZWZhdWx0cyIsICJtZXJnZSIsICJyb3V0ZURlZmF1bHRzIiwgImRlc2NyaWJlIiwgInJvdXRlcyIsICJwcm9wZXJ0eSIsICJwcm9wZXJ0eVBhcnRzIiwgInNwbGl0IiwgInNvdXJjZU5hbWUiLCAic291cmNlU2NvcGUiLCAiam9pbiIsICJwYXJ0cyIsICJ0YXJnZXROYW1lIiwgInRhcmdldFNjb3BlIiwgInJvdXRlIiwgIlJlZ2lzdHJ5IiwgImNvbnRyb2xsZXJzIiwgIl90eXBlZFJlZ2lzdHJpZXMiLCAiX2VhY2giLCAiYWRkQ29udHJvbGxlcnMiLCAiYWRkUGx1Z2lucyIsICJhZGRTY2FsZXMiLCAiZ2V0Q29udHJvbGxlciIsICJfZ2V0IiwgImdldFBsdWdpbiIsICJnZXRTY2FsZSIsICJyZW1vdmVDb250cm9sbGVycyIsICJyZW1vdmVFbGVtZW50cyIsICJyZW1vdmVQbHVnaW5zIiwgInJlbW92ZVNjYWxlcyIsICJ0eXBlZFJlZ2lzdHJ5IiwgImFyZyIsICJyZWciLCAiX2dldFJlZ2lzdHJ5Rm9yVHlwZSIsICJfZXhlYyIsICJpdGVtUmVnIiwgImNvbXBvbmVudCIsICJjYW1lbE1ldGhvZCIsICJfY2FwaXRhbGl6ZSIsICJQbHVnaW5TZXJ2aWNlIiwgIl9pbml0IiwgIm5vdGlmeSIsICJob29rIiwgIl9jcmVhdGVEZXNjcmlwdG9ycyIsICJfZGVzY3JpcHRvcnMiLCAiZGVzY3JpcHRvciIsICJwbHVnaW4iLCAiY2FsbENhbGxiYWNrIiwgImNhbmNlbGFibGUiLCAiaW52YWxpZGF0ZSIsICJfb2xkQ2FjaGUiLCAiX25vdGlmeVN0YXRlQ2hhbmdlcyIsICJhbGxQbHVnaW5zIiwgImNyZWF0ZURlc2NyaXB0b3JzIiwgInByZXZpb3VzRGVzY3JpcHRvcnMiLCAic29tZSIsICJsb2NhbElkcyIsICJsb2NhbCIsICJnZXRPcHRzIiwgInBsdWdpbk9wdHMiLCAicGx1Z2luU2NvcGVLZXlzIiwgInNjcmlwdGFibGUiLCAiaW5kZXhhYmxlIiwgImFsbEtleXMiLCAiZ2V0SW5kZXhBeGlzIiwgImRhdGFzZXREZWZhdWx0cyIsICJkYXRhc2V0T3B0aW9ucyIsICJnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEIiwgImdldERlZmF1bHRTY2FsZUlERnJvbUF4aXMiLCAiaWRNYXRjaGVzQXhpcyIsICJheGlzRnJvbVBvc2l0aW9uIiwgImRldGVybWluZUF4aXMiLCAic2NhbGVPcHRpb25zIiwgInRvTG93ZXJDYXNlIiwgImdldEF4aXNGcm9tRGF0YXNldCIsICJyZXRyaWV2ZUF4aXNGcm9tRGF0YXNldHMiLCAiYm91bmREcyIsICJkIiwgIm1lcmdlU2NhbGVDb25maWciLCAiY2hhcnREZWZhdWx0cyIsICJjb25maWdTY2FsZXMiLCAiY2hhcnRJbmRleEF4aXMiLCAic2NhbGVDb25mIiwgImVycm9yIiwgIl9wcm94eSIsICJkZWZhdWx0SWQiLCAiZGVmYXVsdFNjYWxlT3B0aW9ucyIsICJtZXJnZUlmIiwgImRlZmF1bHRJRCIsICJpbml0T3B0aW9ucyIsICJpbml0RGF0YSIsICJpbml0Q29uZmlnIiwgImtleUNhY2hlIiwgImtleXNDYWNoZWQiLCAiU2V0IiwgImNhY2hlZEtleXMiLCAiZ2VuZXJhdGUiLCAiYWRkSWZGb3VuZCIsICJDb25maWciLCAiX2NvbmZpZyIsICJfc2NvcGVDYWNoZSIsICJfcmVzb2x2ZXJDYWNoZSIsICJwbGF0Zm9ybSIsICJjbGVhckNhY2hlIiwgImNsZWFyIiwgImRhdGFzZXRUeXBlIiwgImFkZGl0aW9uYWxPcHRpb25TY29wZXMiLCAiX2NhY2hlZFNjb3BlcyIsICJtYWluU2NvcGUiLCAicmVzZXRDYWNoZSIsICJrZXlMaXN0cyIsICJjaGFydE9wdGlvblNjb3BlcyIsICJyZXNvbHZlciIsICJzdWJQcmVmaXhlcyIsICJnZXRSZXNvbHZlciIsICJuZWVkQ29udGV4dCIsICJpc0Z1bmN0aW9uIiwgInN1YlJlc29sdmVyIiwgIl9hdHRhY2hDb250ZXh0IiwgImRlc2NyaXB0b3JEZWZhdWx0cyIsICJyZXNvbHZlckNhY2hlIiwgIl9jcmVhdGVSZXNvbHZlciIsICJwIiwgImhhc0Z1bmN0aW9uIiwgImlzU2NyaXB0YWJsZSIsICJpc0luZGV4YWJsZSIsICJLTk9XTl9QT1NJVElPTlMiLCAicG9zaXRpb25Jc0hvcml6b250YWwiLCAiY29tcGFyZTJMZXZlbCIsICJsMSIsICJsMiIsICJvbkFuaW1hdGlvbnNDb21wbGV0ZSIsICJvbkNvbXBsZXRlIiwgIm9uQW5pbWF0aW9uUHJvZ3Jlc3MiLCAib25Qcm9ncmVzcyIsICJnZXRDYW52YXMiLCAiZ2V0RWxlbWVudEJ5SWQiLCAiaW5zdGFuY2VzIiwgImdldENoYXJ0IiwgImMiLCAibW92ZU51bWVyaWNLZXlzIiwgImludEtleSIsICJkZXRlcm1pbmVMYXN0RXZlbnQiLCAibGFzdEV2ZW50IiwgImluQ2hhcnRBcmVhIiwgImlzQ2xpY2siLCAiZ2V0U2l6ZUZvckFyZWEiLCAiZmllbGQiLCAiZ2V0RGF0YXNldEFyZWEiLCAiQ2hhcnQiLCAiaW52YWxpZGF0ZVBsdWdpbnMiLCAidXNlckNvbmZpZyIsICJpbml0aWFsQ2FudmFzIiwgImV4aXN0aW5nQ2hhcnQiLCAidWlkIiwgIl9vcHRpb25zIiwgIl9hc3BlY3RSYXRpbyIsICJfbWV0YXNldHMiLCAiX2xhc3RFdmVudCIsICJfbGlzdGVuZXJzIiwgIl9yZXNwb25zaXZlTGlzdGVuZXJzIiwgIl9zb3J0ZWRNZXRhc2V0cyIsICJfcGx1Z2lucyIsICJfaGlkZGVuSW5kaWNlcyIsICJhdHRhY2hlZCIsICJfZG9SZXNpemUiLCAiZGVib3VuY2UiLCAicmVzaXplRGVsYXkiLCAiX2luaXRpYWxpemUiLCAibWFpbnRhaW5Bc3BlY3RSYXRpbyIsICJyZXNwb25zaXZlIiwgInJldGluYVNjYWxlIiwgImJpbmRFdmVudHMiLCAiY2xlYXJDYW52YXMiLCAiX3Jlc2l6ZSIsICJfcmVzaXplQmVmb3JlRHJhdyIsICJuZXdTaXplIiwgIm5ld1JhdGlvIiwgIm9uUmVzaXplIiwgInJlbmRlciIsICJlbnN1cmVTY2FsZXNIYXZlSURzIiwgInNjYWxlc09wdGlvbnMiLCAiYXhpc09wdGlvbnMiLCAiYnVpbGRPclVwZGF0ZVNjYWxlcyIsICJzY2FsZU9wdHMiLCAidXBkYXRlZCIsICJpc1JhZGlhbCIsICJkcG9zaXRpb24iLCAiZHR5cGUiLCAic2NhbGVUeXBlIiwgInNjYWxlQ2xhc3MiLCAiaGFzVXBkYXRlZCIsICJfdXBkYXRlTWV0YXNldHMiLCAiX2Rlc3Ryb3lEYXRhc2V0TWV0YSIsICJzbGljZSIsICJfcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMiLCAiYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzIiwgIm5ld0NvbnRyb2xsZXJzIiwgIm9yZGVyIiwgInZpc2libGUiLCAiQ29udHJvbGxlckNsYXNzIiwgIl9yZXNldEVsZW1lbnRzIiwgImFuaW1zRGlzYWJsZWQiLCAiX3VwZGF0ZVNjYWxlcyIsICJfY2hlY2tFdmVudEJpbmRpbmdzIiwgIl91cGRhdGVIaWRkZW5JbmRpY2VzIiwgIl9taW5QYWRkaW5nIiwgImF1dG9QYWRkaW5nIiwgIl91cGRhdGVMYXlvdXQiLCAiX3VwZGF0ZURhdGFzZXRzIiwgIl9ldmVudEhhbmRsZXIiLCAiX3VwZGF0ZUhvdmVyU3R5bGVzIiwgImV4aXN0aW5nRXZlbnRzIiwgIm5ld0V2ZW50cyIsICJldmVudHMiLCAic2V0c0VxdWFsIiwgInVuYmluZEV2ZW50cyIsICJjaGFuZ2VzIiwgIl9nZXRVbmlmb3JtRGF0YUNoYW5nZXMiLCAiZGF0YXNldENvdW50IiwgIm1ha2VTZXQiLCAiY2hhbmdlU2V0IiwgIm5vQXJlYSIsICJfaWR4IiwgIl91cGRhdGVEYXRhc2V0IiwgImxheWVycyIsICJfZHJhd0RhdGFzZXRzIiwgIl9kcmF3RGF0YXNldCIsICJ1c2VDbGlwIiwgImdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUiLCAiSW50ZXJhY3Rpb24iLCAic2V0RGF0YXNldFZpc2liaWxpdHkiLCAiX3VwZGF0ZVZpc2liaWxpdHkiLCAiaGlkZSIsICJzaG93IiwgIl9zdG9wIiwgImRlc3Ryb3kiLCAidG9CYXNlNjRJbWFnZSIsICJ0b0RhdGFVUkwiLCAiYmluZFVzZXJFdmVudHMiLCAiYmluZFJlc3BvbnNpdmVFdmVudHMiLCAiX2FkZCIsICJfcmVtb3ZlIiwgImRldGFjaGVkIiwgInVwZGF0ZUhvdmVyU3R5bGUiLCAicHJlZml4IiwgImdldEFjdGl2ZUVsZW1lbnRzIiwgInNldEFjdGl2ZUVsZW1lbnRzIiwgImFjdGl2ZUVsZW1lbnRzIiwgImxhc3RBY3RpdmUiLCAiX2VsZW1lbnRzRXF1YWwiLCAicGx1Z2luSWQiLCAicmVwbGF5IiwgImhvdmVyT3B0aW9ucyIsICJob3ZlciIsICJkZWFjdGl2YXRlZCIsICJhY3RpdmF0ZWQiLCAiZXZlbnRGaWx0ZXIiLCAiX2hhbmRsZUV2ZW50IiwgIl9nZXRBY3RpdmVFbGVtZW50cyIsICJfaXNDbGlja0V2ZW50IiwgIm9uSG92ZXIiLCAidmVyc2lvbiIsICJjbGlwQXJjIiwgInBpeGVsTWFyZ2luIiwgImFuZ2xlTWFyZ2luIiwgImNsb3NlUGF0aCIsICJ0b1JhZGl1c0Nvcm5lcnMiLCAiX3JlYWRWYWx1ZVRvUHJvcHMiLCAicGFyc2VCb3JkZXJSYWRpdXMiLCAiYW5nbGVEZWx0YSIsICJvIiwgImJvcmRlclJhZGl1cyIsICJoYWxmVGhpY2tuZXNzIiwgImlubmVyTGltaXQiLCAiY29tcHV0ZU91dGVyTGltaXQiLCAib3V0ZXJBcmNMaW1pdCIsICJvdXRlclN0YXJ0IiwgIm91dGVyRW5kIiwgImlubmVyU3RhcnQiLCAiaW5uZXJFbmQiLCAiclRoZXRhVG9YWSIsICJ0aGV0YSIsICJwYXRoQXJjIiwgImlubmVyUiIsICJzcGFjaW5nT2Zmc2V0IiwgImFscGhhIiwgIm5vU3BhY2luZ0lubmVyUmFkaXVzIiwgIm5vU3BhY2luZ091dGVyUmFkaXVzIiwgImF2Tm9nU3BhY2luZ1JhZGl1cyIsICJhZGp1c3RlZEFuZ2xlIiwgImJldGEiLCAiYW5nbGVPZmZzZXQiLCAib3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzIiwgIm91dGVyRW5kQWRqdXN0ZWRSYWRpdXMiLCAib3V0ZXJTdGFydEFkanVzdGVkQW5nbGUiLCAib3V0ZXJFbmRBZGp1c3RlZEFuZ2xlIiwgImlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cyIsICJpbm5lckVuZEFkanVzdGVkUmFkaXVzIiwgImlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlIiwgImlubmVyRW5kQWRqdXN0ZWRBbmdsZSIsICJvdXRlck1pZEFkanVzdGVkQW5nbGUiLCAicENlbnRlciIsICJwNCIsICJpbm5lck1pZEFkanVzdGVkQW5nbGUiLCAicDgiLCAib3V0ZXJTdGFydFgiLCAib3V0ZXJTdGFydFkiLCAib3V0ZXJFbmRYIiwgIm91dGVyRW5kWSIsICJkcmF3QXJjIiwgImZ1bGxDaXJjbGVzIiwgImJvcmRlckpvaW5TdHlsZSIsICJpbm5lciIsICJsaW5lSm9pbiIsICJBcmNFbGVtZW50IiwgImNoYXJ0WCIsICJjaGFydFkiLCAickFkanVzdCIsICJub25aZXJvQmV0d2VlbiIsICJiZXR3ZWVuQW5nbGVzIiwgIndpdGhpblJhZGl1cyIsICJfaXNCZXR3ZWVuIiwgImhhbGZBbmdsZSIsICJoYWxmUmFkaXVzIiwgInRyYW5zbGF0ZSIsICJmaXgiLCAicmFkaXVzT2Zmc2V0IiwgInNldFN0eWxlIiwgImxpbmVDYXAiLCAiYm9yZGVyQ2FwU3R5bGUiLCAicHJldmlvdXMiLCAiZ2V0TGluZU1ldGhvZCIsICJzdGVwcGVkIiwgIl9zdGVwcGVkTGluZVRvIiwgInRlbnNpb24iLCAiY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSIsICJfYmV6aWVyQ3VydmVUbyIsICJwYXRoVmFycyIsICJwYXJhbXNTdGFydCIsICJwYXJhbXNFbmQiLCAic2VnbWVudFN0YXJ0IiwgInNlZ21lbnRFbmQiLCAib3V0c2lkZSIsICJwYXRoU2VnbWVudCIsICJsaW5lTWV0aG9kIiwgImZhc3RQYXRoU2VnbWVudCIsICJhdmdYIiwgImNvdW50WCIsICJwcmV2WCIsICJsYXN0WSIsICJwb2ludEluZGV4IiwgImRyYXdYIiwgInRydW5jWCIsICJfZ2V0U2VnbWVudE1ldGhvZCIsICJ1c2VGYXN0UGF0aCIsICJfZ2V0SW50ZXJwb2xhdGlvbk1ldGhvZCIsICJfc3RlcHBlZEludGVycG9sYXRpb24iLCAiX2JlemllckludGVycG9sYXRpb24iLCAiX3BvaW50SW5MaW5lIiwgInN0cm9rZVBhdGhXaXRoQ2FjaGUiLCAicGF0aCIsICJfcGF0aCIsICJQYXRoMkQiLCAic3Ryb2tlUGF0aERpcmVjdCIsICJzZWdtZW50cyIsICJzZWdtZW50TWV0aG9kIiwgInVzZVBhdGgyRCIsICJMaW5lRWxlbWVudCIsICJfcG9pbnRzIiwgIl9zZWdtZW50cyIsICJfcG9pbnRzVXBkYXRlZCIsICJfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyIsICJfY29tcHV0ZVNlZ21lbnRzIiwgImludGVycG9sYXRlIiwgIl9ib3VuZFNlZ21lbnRzIiwgIl9pbnRlcnBvbGF0ZSIsICJpbnRlcnBvbGF0ZWQiLCAiY2FwQmV6aWVyUG9pbnRzIiwgImhpdFJhZGl1cyIsICJQb2ludEVsZW1lbnQiLCAibW91c2VYIiwgIm1vdXNlWSIsICJpblhSYW5nZSIsICJpbllSYW5nZSIsICJob3ZlclJhZGl1cyIsICJkcmF3UG9pbnQiLCAiZ2V0QmFyQm91bmRzIiwgImJhciIsICJoYWxmIiwgInNraXBPckxpbWl0IiwgInBhcnNlQm9yZGVyV2lkdGgiLCAibWF4VyIsICJtYXhIIiwgInRvVFJCTCIsICJ0b1RSQkxDb3JuZXJzIiwgIm1heFIiLCAiZW5hYmxlQm9yZGVyIiwgInRvcExlZnQiLCAidG9wUmlnaHQiLCAiYm90dG9tTGVmdCIsICJib3R0b21SaWdodCIsICJib3VuZGluZ1JlY3RzIiwgImJvdW5kcyIsICJvdXRlciIsICJza2lwWCIsICJza2lwWSIsICJza2lwQm90aCIsICJoYXNSYWRpdXMiLCAiYWRkTm9ybWFsUmVjdFBhdGgiLCAicmVjdCIsICJpbmZsYXRlUmVjdCIsICJhbW91bnQiLCAicmVmUmVjdCIsICJCYXJFbGVtZW50IiwgImFkZFJlY3RQYXRoIiwgImFkZFJvdW5kZWRSZWN0UGF0aCIsICJCT1JERVJfQ09MT1JTIiwgIkJBQ0tHUk9VTkRfQ09MT1JTIiwgInJlcGxhY2UiLCAiZ2V0Qm9yZGVyQ29sb3IiLCAiZ2V0QmFja2dyb3VuZENvbG9yIiwgImNvbG9yaXplRGVmYXVsdERhdGFzZXQiLCAiY29sb3JpemVEb3VnaG51dERhdGFzZXQiLCAiY29sb3JpemVQb2xhckFyZWFEYXRhc2V0IiwgImdldENvbG9yaXplciIsICJjb250YWluc0NvbG9yc0RlZmluaXRpb25zIiwgImsiLCAiY29udGFpbnNDb2xvcnNEZWZpbml0aW9uIiwgImNvbnRhaW5zRGVmYXVsdENvbG9yc0RlZmVuaXRpb25zIiwgImZvcmNlT3ZlcnJpZGUiLCAiX2FyZ3MiLCAiY2hhcnRPcHRpb25zIiwgImNvbnRhaW5zQ29sb3JEZWZlbml0aW9uIiwgImNvbG9yaXplciIsICJsdHRiRGVjaW1hdGlvbiIsICJzYW1wbGVzIiwgImRlY2ltYXRlZCIsICJidWNrZXRXaWR0aCIsICJzYW1wbGVkSW5kZXgiLCAiZW5kSW5kZXgiLCAibWF4QXJlYVBvaW50IiwgIm1heEFyZWEiLCAibmV4dEEiLCAiYXZnWSIsICJhdmdSYW5nZVN0YXJ0IiwgImF2Z1JhbmdlRW5kIiwgImF2Z1JhbmdlTGVuZ3RoIiwgInJhbmdlT2ZmcyIsICJyYW5nZVRvIiwgInBvaW50QXgiLCAicG9pbnRBeSIsICJtaW5NYXhEZWNpbWF0aW9uIiwgIm1pbkluZGV4IiwgIm1heEluZGV4IiwgInN0YXJ0SW5kZXgiLCAieE1pbiIsICJ4TWF4IiwgImR4IiwgImxhc3RJbmRleCIsICJpbnRlcm1lZGlhdGVJbmRleDEiLCAiaW50ZXJtZWRpYXRlSW5kZXgyIiwgImNsZWFuRGVjaW1hdGVkRGF0YXNldCIsICJkZWZpbmVQcm9wZXJ0eSIsICJjb25maWd1cmFibGUiLCAiZW51bWVyYWJsZSIsICJ3cml0YWJsZSIsICJjbGVhbkRlY2ltYXRlZERhdGEiLCAiZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQiLCAicG9pbnRDb3VudCIsICJhbGdvcml0aG0iLCAiYmVmb3JlRWxlbWVudHNVcGRhdGUiLCAieEF4aXMiLCAidGhyZXNob2xkIiwgInRwb2ludHMiLCAiX2ZpbmRTZWdtZW50RW5kIiwgIl9nZXRCb3VuZHMiLCAidGFyZ2V0U2VnbWVudHMiLCAidGd0IiwgInN1YkJvdW5kcyIsICJmaWxsU291cmNlcyIsICJfYm91bmRTZWdtZW50IiwgImZpbGxTb3VyY2UiLCAiX2dldEVkZ2UiLCAiX25vcm1hbGl6ZUFuZ2xlIiwgIl9wb2ludHNGcm9tU2VnbWVudHMiLCAiYm91bmRhcnkiLCAibGluZVBvaW50cyIsICJfY3JlYXRlQm91bmRhcnlMaW5lIiwgIl9zaG91bGRBcHBseUZpbGwiLCAiX3Jlc29sdmVUYXJnZXQiLCAic291cmNlcyIsICJwcm9wYWdhdGUiLCAidmlzaXRlZCIsICJfZGVjb2RlRmlsbCIsICJwYXJzZUZpbGxPcHRpb24iLCAicGFyc2VGbG9hdCIsICJkZWNvZGVUYXJnZXRJbmRleCIsICJmaXJzdENoIiwgIl9nZXRUYXJnZXRQaXhlbCIsICJfZ2V0VGFyZ2V0VmFsdWUiLCAiZmlsbE9wdGlvbiIsICJfYnVpbGRTdGFja0xpbmUiLCAic291cmNlUG9pbnRzIiwgImxpbmVzQmVsb3ciLCAiZ2V0TGluZXNCZWxvdyIsICJhZGRQb2ludHNCZWxvdyIsICJiZWxvdyIsICJ1bnNoaWZ0IiwgInNvdXJjZVBvaW50IiwgInBvc3Rwb25lZCIsICJmaW5kUG9pbnQiLCAicG9pbnRWYWx1ZSIsICJmaXJzdFZhbHVlIiwgImxhc3RWYWx1ZSIsICJzaW1wbGVBcmMiLCAiX2dldFRhcmdldCIsICJnZXRMaW5lQnlJbmRleCIsICJjb21wdXRlQm91bmRhcnkiLCAiY29tcHV0ZUNpcmN1bGFyQm91bmRhcnkiLCAiY29tcHV0ZUxpbmVhckJvdW5kYXJ5IiwgIl9kcmF3ZmlsbCIsICJsaW5lT3B0cyIsICJhYm92ZSIsICJkb0ZpbGwiLCAiY2xpcFZlcnRpY2FsIiwgImNsaXBZIiwgImxpbmVMb29wIiwgInNyYyIsICJub3RTaGFwZSIsICJjbGlwQm91bmRzIiwgImludGVycG9sYXRlZExpbmVUbyIsICJ0YXJnZXRMb29wIiwgImludGVycG9sYXRlZFBvaW50IiwgImFmdGVyRGF0YXNldHNVcGRhdGUiLCAiJGZpbGxlciIsICJiZWZvcmVEcmF3IiwgImRyYXdUaW1lIiwgImJlZm9yZURhdGFzZXRzRHJhdyIsICJiZWZvcmVEYXRhc2V0RHJhdyIsICJnZXRCb3hTaXplIiwgImxhYmVsT3B0cyIsICJib3hIZWlnaHQiLCAiYm94V2lkdGgiLCAidXNlUG9pbnRTdHlsZSIsICJwb2ludFN0eWxlV2lkdGgiLCAiaXRlbUhlaWdodCIsICJpdGVtc0VxdWFsIiwgIkxlZ2VuZCIsICJfYWRkZWQiLCAibGVnZW5kSGl0Qm94ZXMiLCAiX2hvdmVyZWRJdGVtIiwgImRvdWdobnV0TW9kZSIsICJsZWdlbmRJdGVtcyIsICJjb2x1bW5TaXplcyIsICJsaW5lV2lkdGhzIiwgImJ1aWxkTGFiZWxzIiwgImxhYmVsRm9udCIsICJfY29tcHV0ZVRpdGxlSGVpZ2h0IiwgIl9maXRSb3dzIiwgIl9maXRDb2xzIiwgImhpdGJveGVzIiwgInRvdGFsSGVpZ2h0IiwgInJvdyIsICJpdGVtV2lkdGgiLCAibWVhc3VyZVRleHQiLCAiX2l0ZW1IZWlnaHQiLCAiaGVpZ2h0TGltaXQiLCAidG90YWxXaWR0aCIsICJjdXJyZW50Q29sV2lkdGgiLCAiY3VycmVudENvbEhlaWdodCIsICJjb2wiLCAiY2FsY3VsYXRlSXRlbVNpemUiLCAiYWRqdXN0SGl0Qm94ZXMiLCAicnRsIiwgInJ0bEhlbHBlciIsICJnZXRSdGxBZGFwdGVyIiwgImhpdGJveCIsICJsZWZ0Rm9yTHRyIiwgIl9kcmF3IiwgImRlZmF1bHRDb2xvciIsICJoYWxmRm9udFNpemUiLCAiY3Vyc29yIiwgImRyYXdMZWdlbmRCb3giLCAibGluZURhc2giLCAiZHJhd09wdGlvbnMiLCAiU1FSVDIiLCAieFBsdXMiLCAiZHJhd1BvaW50TGVnZW5kIiwgInlCb3hUb3AiLCAieEJveExlZnQiLCAiZmlsbFRleHQiLCAic3RyaWtldGhyb3VnaCIsICJvdmVycmlkZVRleHREaXJlY3Rpb24iLCAidGV4dERpcmVjdGlvbiIsICJ0ZXh0V2lkdGgiLCAic2V0V2lkdGgiLCAicmVhbFgiLCAiX3RleHRYIiwgImZvbnRMaW5lSGVpZ2h0IiwgImNhbGN1bGF0ZUxlZ2VuZEl0ZW1IZWlnaHQiLCAicmVzdG9yZVRleHREaXJlY3Rpb24iLCAidGl0bGVGb250IiwgInRpdGxlUGFkZGluZyIsICJ0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZSIsICJfZ2V0TGVnZW5kSXRlbUF0IiwgImhpdEJveCIsICJsaCIsICJoYW5kbGVFdmVudCIsICJpc0xpc3RlbmVkIiwgImhvdmVyZWRJdGVtIiwgInNhbWVJdGVtIiwgIm9uTGVhdmUiLCAiY2FsY3VsYXRlSXRlbVdpZHRoIiwgImNhbGN1bGF0ZUl0ZW1IZWlnaHQiLCAibGVnZW5kSXRlbVRleHQiLCAiX2VsZW1lbnQiLCAiYWZ0ZXJFdmVudCIsICJjaSIsICJ1c2VCb3JkZXJSYWRpdXMiLCAiVGl0bGUiLCAiX3BhZGRpbmciLCAidGV4dFNpemUiLCAiX2RyYXdBcmdzIiwgImZvbnRPcHRzIiwgImNyZWF0ZVRpdGxlIiwgInRpdGxlQmxvY2siLCAiV2Vha01hcCIsICJwb3NpdGlvbmVycyIsICJhdmVyYWdlIiwgInhTZXQiLCAieEF2ZXJhZ2UiLCAiZXZlbnRQb3NpdGlvbiIsICJuZWFyZXN0RWxlbWVudCIsICJkaXN0YW5jZUJldHdlZW5Qb2ludHMiLCAidHAiLCAicHVzaE9yQ29uY2F0IiwgInRvUHVzaCIsICJhcHBseSIsICJzcGxpdE5ld2xpbmVzIiwgInN0ciIsICJTdHJpbmciLCAiY3JlYXRlVG9vbHRpcEl0ZW0iLCAiZm9ybWF0dGVkVmFsdWUiLCAiZ2V0VG9vbHRpcFNpemUiLCAidG9vbHRpcCIsICJib2R5IiwgImZvb3RlciIsICJib2R5Rm9udCIsICJmb290ZXJGb250IiwgInRpdGxlTGluZUNvdW50IiwgImZvb3RlckxpbmVDb3VudCIsICJib2R5TGluZUl0ZW1Db3VudCIsICJjb21iaW5lZEJvZHlMZW5ndGgiLCAiYm9keUl0ZW0iLCAiYmVmb3JlIiwgImFmdGVyIiwgImJlZm9yZUJvZHkiLCAiYWZ0ZXJCb2R5IiwgInRpdGxlU3BhY2luZyIsICJ0aXRsZU1hcmdpbkJvdHRvbSIsICJib2R5TGluZUhlaWdodCIsICJkaXNwbGF5Q29sb3JzIiwgImJvZHlTcGFjaW5nIiwgImZvb3Rlck1hcmdpblRvcCIsICJmb290ZXJTcGFjaW5nIiwgIndpZHRoUGFkZGluZyIsICJtYXhMaW5lV2lkdGgiLCAiZGV0ZXJtaW5lWUFsaWduIiwgImRvZXNOb3RGaXRXaXRoQWxpZ24iLCAieEFsaWduIiwgImNhcmV0IiwgImNhcmV0U2l6ZSIsICJjYXJldFBhZGRpbmciLCAiZGV0ZXJtaW5lWEFsaWduIiwgInlBbGlnbiIsICJjaGFydFdpZHRoIiwgImRldGVybWluZUFsaWdubWVudCIsICJhbGlnblgiLCAiYWxpZ25ZIiwgInBhZGRpbmdBbmRTaXplIiwgImdldEJhY2tncm91bmRQb2ludCIsICJhbGlnbm1lbnQiLCAiY29ybmVyUmFkaXVzIiwgImdldEFsaWduZWRYIiwgImdldEJlZm9yZUFmdGVyQm9keUxpbmVzIiwgImNyZWF0ZVRvb2x0aXBDb250ZXh0IiwgInRvb2x0aXBJdGVtcyIsICJvdmVycmlkZUNhbGxiYWNrcyIsICJkZWZhdWx0Q2FsbGJhY2tzIiwgImJlZm9yZVRpdGxlIiwgIm5vb3AiLCAibGFiZWxDb3VudCIsICJhZnRlclRpdGxlIiwgImJlZm9yZUxhYmVsIiwgInRvb2x0aXBJdGVtIiwgImxhYmVsQ29sb3IiLCAibGFiZWxUZXh0Q29sb3IiLCAiYm9keUNvbG9yIiwgImxhYmVsUG9pbnRTdHlsZSIsICJhZnRlckxhYmVsIiwgImJlZm9yZUZvb3RlciIsICJhZnRlckZvb3RlciIsICJpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayIsICJUb29sdGlwIiwgIm9wYWNpdHkiLCAiX2V2ZW50UG9zaXRpb24iLCAiX3NpemUiLCAiX2NhY2hlZEFuaW1hdGlvbnMiLCAiX3Rvb2x0aXBJdGVtcyIsICJkYXRhUG9pbnRzIiwgImNhcmV0WCIsICJjYXJldFkiLCAibGFiZWxDb2xvcnMiLCAibGFiZWxQb2ludFN0eWxlcyIsICJsYWJlbFRleHRDb2xvcnMiLCAiZ2V0VGl0bGUiLCAiZ2V0QmVmb3JlQm9keSIsICJnZXRCb2R5IiwgImJvZHlJdGVtcyIsICJzY29wZWQiLCAiZ2V0QWZ0ZXJCb2R5IiwgImdldEZvb3RlciIsICJfY3JlYXRlSXRlbXMiLCAiaXRlbVNvcnQiLCAicG9zaXRpb25BbmRTaXplIiwgImJhY2tncm91bmRQb2ludCIsICJleHRlcm5hbCIsICJkcmF3Q2FyZXQiLCAidG9vbHRpcFBvaW50IiwgImNhcmV0UG9zaXRpb24iLCAiZ2V0Q2FyZXRQb3NpdGlvbiIsICJ4MyIsICJ5MyIsICJwdFgiLCAicHRZIiwgInB0IiwgInRpdGxlQ29sb3IiLCAiX2RyYXdDb2xvckJveCIsICJjb2xvclgiLCAicnRsQ29sb3JYIiwgInlPZmZTZXQiLCAiY29sb3JZIiwgIm11bHRpS2V5QmFja2dyb3VuZCIsICJvdXRlclgiLCAiaW5uZXJYIiwgInN0cm9rZVJlY3QiLCAiZHJhd0JvZHkiLCAiYm9keUFsaWduIiwgInhMaW5lUGFkZGluZyIsICJmaWxsTGluZU9mVGV4dCIsICJib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiIsICJ0ZXh0Q29sb3IiLCAiZHJhd0Zvb3RlciIsICJmb290ZXJBbGlnbiIsICJmb290ZXJDb2xvciIsICJ0b29sdGlwU2l6ZSIsICJxdWFkcmF0aWNDdXJ2ZVRvIiwgIl91cGRhdGVBbmltYXRpb25UYXJnZXQiLCAiYW5pbVgiLCAiYW5pbVkiLCAiX3dpbGxSZW5kZXIiLCAiaGFzVG9vbHRpcENvbnRlbnQiLCAiZ2xvYmFsQWxwaGEiLCAicG9zaXRpb25DaGFuZ2VkIiwgIl9wb3NpdGlvbkNoYW5nZWQiLCAiX2lnbm9yZVJlcGxheUV2ZW50cyIsICJhZnRlckluaXQiLCAiYWZ0ZXJEcmF3IiwgIl9mYWxsYmFjayIsICJhZGRJZlN0cmluZyIsICJhZGRlZExhYmVscyIsICJmaW5kT3JBZGRMYWJlbCIsICJsYXN0SW5kZXhPZiIsICJfZ2V0TGFiZWxGb3JWYWx1ZSIsICJDYXRlZ29yeVNjYWxlIiwgIl9zdGFydFZhbHVlIiwgIl92YWx1ZVJhbmdlIiwgIl9hZGRlZExhYmVscyIsICJhZGRlZCIsICJnZW5lcmF0ZVRpY2tzIiwgImdlbmVyYXRpb25PcHRpb25zIiwgImRhdGFSYW5nZSIsICJNSU5fU1BBQ0lORyIsICJwcmVjaXNpb24iLCAibWF4VGlja3MiLCAibWF4RGlnaXRzIiwgImluY2x1ZGVCb3VuZHMiLCAidW5pdCIsICJtYXhTcGFjZXMiLCAicm1pbiIsICJybWF4IiwgImNvdW50RGVmaW5lZCIsICJtaW5TcGFjaW5nIiwgIm5pY2VOdW0iLCAibmljZU1pbiIsICJuaWNlTWF4IiwgIm51bVNwYWNlcyIsICJhbG1vc3RXaG9sZSIsICJhbG1vc3RFcXVhbHMiLCAiZGVjaW1hbFBsYWNlcyIsICJfZGVjaW1hbFBsYWNlcyIsICJyZWxhdGl2ZUxhYmVsU2l6ZSIsICJ0aWNrVmFsdWUiLCAicmFkIiwgIkxpbmVhclNjYWxlQmFzZSIsICJfZW5kVmFsdWUiLCAiaGFuZGxlVGlja1JhbmdlT3B0aW9ucyIsICJzZXRNaW4iLCAic2V0TWF4IiwgIm1pblNpZ24iLCAibWF4U2lnbiIsICJnZXRUaWNrTGltaXQiLCAic3RlcFNpemUiLCAiY29tcHV0ZVRpY2tMaW1pdCIsICJudW1lcmljR2VuZXJhdG9yT3B0aW9ucyIsICJfc2V0TWluQW5kTWF4QnlLZXkiLCAiTGluZWFyU2NhbGUiLCAiVGlja3MiLCAiZm9ybWF0dGVycyIsICJudW1lcmljIiwgImxvZzEwRmxvb3IiLCAibG9nMTAiLCAiY2hhbmdlRXhwb25lbnQiLCAibSIsICJpc01ham9yIiwgInRpY2tWYWwiLCAic3RlcHMiLCAicmFuZ2VFeHAiLCAicmFuZ2VTdGVwIiwgInN0YXJ0RXhwIiwgIm1pbkV4cCIsICJleHAiLCAic2lnbmlmaWNhbmQiLCAibGFzdFRpY2siLCAiTG9nYXJpdGhtaWNTY2FsZSIsICJfemVybyIsICJsb2dhcml0aG1pYyIsICJnZXRUaWNrQmFja2Ryb3BIZWlnaHQiLCAibWVhc3VyZUxhYmVsU2l6ZSIsICJfbG9uZ2VzdFRleHQiLCAiZGV0ZXJtaW5lTGltaXRzIiwgImZpdFdpdGhQb2ludExhYmVscyIsICJsaW1pdHMiLCAidmFsdWVDb3VudCIsICJfcG9pbnRMYWJlbHMiLCAicG9pbnRMYWJlbE9wdHMiLCAiYWRkaXRpb25hbEFuZ2xlIiwgImNlbnRlclBvaW50TGFiZWxzIiwgImdldFBvaW50TGFiZWxDb250ZXh0IiwgImdldFBvaW50UG9zaXRpb24iLCAiZHJhd2luZ0FyZWEiLCAicGxGb250IiwgImhMaW1pdHMiLCAidkxpbWl0cyIsICJ1cGRhdGVMaW1pdHMiLCAic2V0Q2VudGVyUG9pbnQiLCAiX3BvaW50TGFiZWxJdGVtcyIsICJidWlsZFBvaW50TGFiZWxJdGVtcyIsICJjcmVhdGVQb2ludExhYmVsSXRlbSIsICJpdGVtT3B0cyIsICJvdXRlckRpc3RhbmNlIiwgImV4dHJhIiwgInBvaW50TGFiZWxQb3NpdGlvbiIsICJ5Rm9yQW5nbGUiLCAiZ2V0VGV4dEFsaWduRm9yQW5nbGUiLCAibGVmdEZvclRleHRBbGlnbiIsICJpc05vdE92ZXJsYXBwZWQiLCAiYXBleGVzSW5BcmVhIiwgImRyYXdQb2ludExhYmVsQm94IiwgImJhY2tkcm9wTGVmdCIsICJiYWNrZHJvcFRvcCIsICJiYWNrZHJvcFdpZHRoIiwgImJhY2tkcm9wSGVpZ2h0IiwgImRyYXdQb2ludExhYmVscyIsICJwYXRoUmFkaXVzTGluZSIsICJkcmF3UmFkaXVzTGluZSIsICJncmlkTGluZU9wdHMiLCAiY3JlYXRlUG9pbnRMYWJlbENvbnRleHQiLCAiUmFkaWFsTGluZWFyU2NhbGUiLCAibGVmdE1vdmVtZW50IiwgInJpZ2h0TW92ZW1lbnQiLCAidG9wTW92ZW1lbnQiLCAiYm90dG9tTW92ZW1lbnQiLCAiYW5nbGVNdWx0aXBsaWVyIiwgInNjYWxpbmdGYWN0b3IiLCAiZ2V0VmFsdWVGb3JEaXN0YW5jZUZyb21DZW50ZXIiLCAic2NhbGVkRGlzdGFuY2UiLCAicG9pbnRMYWJlbCIsICJkaXN0YW5jZUZyb21DZW50ZXIiLCAiZ2V0QmFzZVBvc2l0aW9uIiwgImdldFBvaW50TGFiZWxQb3NpdGlvbiIsICJyb3RhdGUiLCAiYW5pbWF0ZSIsICJJTlRFUlZBTFMiLCAibWlsbGlzZWNvbmQiLCAiY29tbW9uIiwgInNlY29uZCIsICJtaW51dGUiLCAiaG91ciIsICJkYXkiLCAid2VlayIsICJtb250aCIsICJxdWFydGVyIiwgInllYXIiLCAiVU5JVFMiLCAic29ydGVyIiwgImlucHV0IiwgImFkYXB0ZXIiLCAiX2FkYXB0ZXIiLCAicGFyc2VyIiwgImlzb1dlZWtkYXkiLCAiX3BhcnNlT3B0cyIsICJkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzIiwgIm1pblVuaXQiLCAiY2FwYWNpdHkiLCAiaW50ZXJ2YWwiLCAiTUFYX1NBRkVfSU5URUdFUiIsICJkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyIsICJkZXRlcm1pbmVNYWpvclVuaXQiLCAiYWRkVGljayIsICJ0aW1lIiwgInRpbWVzdGFtcHMiLCAiX2xvb2t1cCIsICJ0aW1lc3RhbXAiLCAic2V0TWFqb3JUaWNrcyIsICJtYWpvclVuaXQiLCAidGlja3NGcm9tVGltZXN0YW1wcyIsICJUaW1lU2NhbGUiLCAiX3VuaXQiLCAiX21ham9yVW5pdCIsICJfb2Zmc2V0cyIsICJfbm9ybWFsaXplZCIsICJhZGFwdGVycyIsICJkaXNwbGF5Rm9ybWF0cyIsICJub3JtYWxpemVkIiwgIl9hcHBseUJvdW5kcyIsICJfZ2V0TGFiZWxCb3VuZHMiLCAiZ2V0TGFiZWxUaW1lc3RhbXBzIiwgInRpbWVPcHRzIiwgIl9nZW5lcmF0ZSIsICJfZmlsdGVyQmV0d2VlbiIsICJfZ2V0TGFiZWxDYXBhY2l0eSIsICJpbml0T2Zmc2V0cyIsICJvZmZzZXRBZnRlckF1dG9za2lwIiwgImdldERlY2ltYWxGb3JWYWx1ZSIsICJtaW5vciIsICJ3ZWVrZGF5IiwgImhhc1dlZWtkYXkiLCAiZ2V0RGF0YVRpbWVzdGFtcHMiLCAidG9vbHRpcEZvcm1hdCIsICJkYXRldGltZSIsICJmbXQiLCAiX3RpY2tGb3JtYXRGdW5jdGlvbiIsICJmb3JtYXR0ZXIiLCAibWlub3JGb3JtYXQiLCAibWFqb3JGb3JtYXQiLCAib2Zmc2V0cyIsICJfZ2V0TGFiZWxTaXplIiwgInRpY2tzT3B0cyIsICJ0aWNrTGFiZWxXaWR0aCIsICJjb3NSb3RhdGlvbiIsICJzaW5Sb3RhdGlvbiIsICJ0aWNrRm9udFNpemUiLCAiZXhhbXBsZVRpbWUiLCAiZXhhbXBsZUxhYmVsIiwgIm5vcm1hbGl6ZSIsICJ0YWJsZSIsICJwcmV2U291cmNlIiwgIm5leHRTb3VyY2UiLCAicHJldlRhcmdldCIsICJuZXh0VGFyZ2V0IiwgInNwYW4iLCAiVGltZVNlcmllc1NjYWxlIiwgIl90YWJsZSIsICJfbWluUG9zIiwgIl90YWJsZVJhbmdlIiwgIl9nZXRUaW1lc3RhbXBzRm9yVGFibGUiLCAiYnVpbGRMb29rdXBUYWJsZSIsICJyZWdpc3RlcmFibGVzIiwgInRvcCIsICJjdHgiLCAiY3R4IiwgImluZGV4IiwgInRvcGJhciJdCn0K
